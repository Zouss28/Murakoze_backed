
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model app_releases
 * 
 */
export type app_releases = $Result.DefaultSelection<Prisma.$app_releasesPayload>
/**
 * Model appointments
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type appointments = $Result.DefaultSelection<Prisma.$appointmentsPayload>
/**
 * Model apps
 * 
 */
export type apps = $Result.DefaultSelection<Prisma.$appsPayload>
/**
 * Model audit_trail
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type audit_trail = $Result.DefaultSelection<Prisma.$audit_trailPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model change_request
 * 
 */
export type change_request = $Result.DefaultSelection<Prisma.$change_requestPayload>
/**
 * Model device
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type device = $Result.DefaultSelection<Prisma.$devicePayload>
/**
 * Model device_heartbeat
 * 
 */
export type device_heartbeat = $Result.DefaultSelection<Prisma.$device_heartbeatPayload>
/**
 * Model institution
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type institution = $Result.DefaultSelection<Prisma.$institutionPayload>
/**
 * Model institution_invoices
 * 
 */
export type institution_invoices = $Result.DefaultSelection<Prisma.$institution_invoicesPayload>
/**
 * Model institution_service_tracking
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type institution_service_tracking = $Result.DefaultSelection<Prisma.$institution_service_trackingPayload>
/**
 * Model login_history
 * 
 */
export type login_history = $Result.DefaultSelection<Prisma.$login_historyPayload>
/**
 * Model migration
 * 
 */
export type migration = $Result.DefaultSelection<Prisma.$migrationPayload>
/**
 * Model mms_file
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type mms_file = $Result.DefaultSelection<Prisma.$mms_filePayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model notification_recipient
 * 
 */
export type notification_recipient = $Result.DefaultSelection<Prisma.$notification_recipientPayload>
/**
 * Model option
 * 
 */
export type option = $Result.DefaultSelection<Prisma.$optionPayload>
/**
 * Model popup_questions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type popup_questions = $Result.DefaultSelection<Prisma.$popup_questionsPayload>
/**
 * Model popup_questions_answers
 * 
 */
export type popup_questions_answers = $Result.DefaultSelection<Prisma.$popup_questions_answersPayload>
/**
 * Model popup_questions_possible_answers
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type popup_questions_possible_answers = $Result.DefaultSelection<Prisma.$popup_questions_possible_answersPayload>
/**
 * Model qms_branch_operator
 * 
 */
export type qms_branch_operator = $Result.DefaultSelection<Prisma.$qms_branch_operatorPayload>
/**
 * Model qms_branch_transactions
 * 
 */
export type qms_branch_transactions = $Result.DefaultSelection<Prisma.$qms_branch_transactionsPayload>
/**
 * Model qms_counter
 * 
 */
export type qms_counter = $Result.DefaultSelection<Prisma.$qms_counterPayload>
/**
 * Model qms_customer
 * 
 */
export type qms_customer = $Result.DefaultSelection<Prisma.$qms_customerPayload>
/**
 * Model qms_operator
 * 
 */
export type qms_operator = $Result.DefaultSelection<Prisma.$qms_operatorPayload>
/**
 * Model qms_operator_transactions
 * 
 */
export type qms_operator_transactions = $Result.DefaultSelection<Prisma.$qms_operator_transactionsPayload>
/**
 * Model qms_queue
 * 
 */
export type qms_queue = $Result.DefaultSelection<Prisma.$qms_queuePayload>
/**
 * Model qms_queue_operator_lnk
 * 
 */
export type qms_queue_operator_lnk = $Result.DefaultSelection<Prisma.$qms_queue_operator_lnkPayload>
/**
 * Model qms_ticket
 * 
 */
export type qms_ticket = $Result.DefaultSelection<Prisma.$qms_ticketPayload>
/**
 * Model qms_ticket_assignment
 * 
 */
export type qms_ticket_assignment = $Result.DefaultSelection<Prisma.$qms_ticket_assignmentPayload>
/**
 * Model rating
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type rating = $Result.DefaultSelection<Prisma.$ratingPayload>
/**
 * Model rating_assets
 * 
 */
export type rating_assets = $Result.DefaultSelection<Prisma.$rating_assetsPayload>
/**
 * Model rating_qr_code_sessions
 * 
 */
export type rating_qr_code_sessions = $Result.DefaultSelection<Prisma.$rating_qr_code_sessionsPayload>
/**
 * Model rating_reply
 * 
 */
export type rating_reply = $Result.DefaultSelection<Prisma.$rating_replyPayload>
/**
 * Model reports
 * 
 */
export type reports = $Result.DefaultSelection<Prisma.$reportsPayload>
/**
 * Model request_institution
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type request_institution = $Result.DefaultSelection<Prisma.$request_institutionPayload>
/**
 * Model service
 * 
 */
export type service = $Result.DefaultSelection<Prisma.$servicePayload>
/**
 * Model service_group
 * 
 */
export type service_group = $Result.DefaultSelection<Prisma.$service_groupPayload>
/**
 * Model survey
 * 
 */
export type survey = $Result.DefaultSelection<Prisma.$surveyPayload>
/**
 * Model survey_result
 * 
 */
export type survey_result = $Result.DefaultSelection<Prisma.$survey_resultPayload>
/**
 * Model tags
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type tags = $Result.DefaultSelection<Prisma.$tagsPayload>
/**
 * Model tip
 * 
 */
export type tip = $Result.DefaultSelection<Prisma.$tipPayload>
/**
 * Model user
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model wallet_accounts
 * 
 */
export type wallet_accounts = $Result.DefaultSelection<Prisma.$wallet_accountsPayload>
/**
 * Model wallet_accounts_types
 * 
 */
export type wallet_accounts_types = $Result.DefaultSelection<Prisma.$wallet_accounts_typesPayload>
/**
 * Model wallet_transfers
 * 
 */
export type wallet_transfers = $Result.DefaultSelection<Prisma.$wallet_transfersPayload>
/**
 * Model wallet_users
 * 
 */
export type wallet_users = $Result.DefaultSelection<Prisma.$wallet_usersPayload>
/**
 * Model images
 * 
 */
export type images = $Result.DefaultSelection<Prisma.$imagesPayload>
/**
 * Model sectors
 * 
 */
export type sectors = $Result.DefaultSelection<Prisma.$sectorsPayload>
/**
 * Model users_profile
 * 
 */
export type users_profile = $Result.DefaultSelection<Prisma.$users_profilePayload>
/**
 * Model reviews
 * 
 */
export type reviews = $Result.DefaultSelection<Prisma.$reviewsPayload>
/**
 * Model workingHour
 * 
 */
export type workingHour = $Result.DefaultSelection<Prisma.$workingHourPayload>
/**
 * Model amenities
 * 
 */
export type amenities = $Result.DefaultSelection<Prisma.$amenitiesPayload>
/**
 * Model business_amenities
 * 
 */
export type business_amenities = $Result.DefaultSelection<Prisma.$business_amenitiesPayload>
/**
 * Model price_ranges
 * 
 */
export type price_ranges = $Result.DefaultSelection<Prisma.$price_rangesPayload>
/**
 * Model surveyAnswers
 * 
 */
export type surveyAnswers = $Result.DefaultSelection<Prisma.$surveyAnswersPayload>
/**
 * Model surveyQuestions
 * 
 */
export type surveyQuestions = $Result.DefaultSelection<Prisma.$surveyQuestionsPayload>
/**
 * Model serviceReview
 * 
 */
export type serviceReview = $Result.DefaultSelection<Prisma.$serviceReviewPayload>
/**
 * Model category_search_terms
 * 
 */
export type category_search_terms = $Result.DefaultSelection<Prisma.$category_search_termsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const app_releases_app_name: {
  mobile_rating: 'mobile_rating',
  tablet_rating: 'tablet_rating',
  tablet_qms_o: 'tablet_qms_o'
};

export type app_releases_app_name = (typeof app_releases_app_name)[keyof typeof app_releases_app_name]


export const app_releases_platform: {
  android: 'android',
  ios: 'ios'
};

export type app_releases_platform = (typeof app_releases_platform)[keyof typeof app_releases_platform]


export const qms_queue_status: {
  open: 'open',
  paused: 'paused',
  stopped: 'stopped',
  closed: 'closed'
};

export type qms_queue_status = (typeof qms_queue_status)[keyof typeof qms_queue_status]


export const rating_qr_code_sessions_status: {
  Open: 'Open',
  Close: 'Close'
};

export type rating_qr_code_sessions_status = (typeof rating_qr_code_sessions_status)[keyof typeof rating_qr_code_sessions_status]


export const institution_invoices_payment_status: {
  FAILED: 'FAILED',
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type institution_invoices_payment_status = (typeof institution_invoices_payment_status)[keyof typeof institution_invoices_payment_status]


export const audit_trail_status: {
  CREATED: 'CREATED',
  UPDATED: 'UPDATED',
  DELETED: 'DELETED'
};

export type audit_trail_status = (typeof audit_trail_status)[keyof typeof audit_trail_status]


export const institution_invoices_status: {
  PENDING: 'PENDING',
  EXPIRED: 'EXPIRED',
  PAID: 'PAID',
  CANCELED: 'CANCELED'
};

export type institution_invoices_status = (typeof institution_invoices_status)[keyof typeof institution_invoices_status]

}

export type app_releases_app_name = $Enums.app_releases_app_name

export const app_releases_app_name: typeof $Enums.app_releases_app_name

export type app_releases_platform = $Enums.app_releases_platform

export const app_releases_platform: typeof $Enums.app_releases_platform

export type qms_queue_status = $Enums.qms_queue_status

export const qms_queue_status: typeof $Enums.qms_queue_status

export type rating_qr_code_sessions_status = $Enums.rating_qr_code_sessions_status

export const rating_qr_code_sessions_status: typeof $Enums.rating_qr_code_sessions_status

export type institution_invoices_payment_status = $Enums.institution_invoices_payment_status

export const institution_invoices_payment_status: typeof $Enums.institution_invoices_payment_status

export type audit_trail_status = $Enums.audit_trail_status

export const audit_trail_status: typeof $Enums.audit_trail_status

export type institution_invoices_status = $Enums.institution_invoices_status

export const institution_invoices_status: typeof $Enums.institution_invoices_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more App_releases
 * const app_releases = await prisma.app_releases.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more App_releases
   * const app_releases = await prisma.app_releases.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.app_releases`: Exposes CRUD operations for the **app_releases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_releases
    * const app_releases = await prisma.app_releases.findMany()
    * ```
    */
  get app_releases(): Prisma.app_releasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointments`: Exposes CRUD operations for the **appointments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointments.findMany()
    * ```
    */
  get appointments(): Prisma.appointmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apps`: Exposes CRUD operations for the **apps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apps
    * const apps = await prisma.apps.findMany()
    * ```
    */
  get apps(): Prisma.appsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_trail`: Exposes CRUD operations for the **audit_trail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_trails
    * const audit_trails = await prisma.audit_trail.findMany()
    * ```
    */
  get audit_trail(): Prisma.audit_trailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.change_request`: Exposes CRUD operations for the **change_request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Change_requests
    * const change_requests = await prisma.change_request.findMany()
    * ```
    */
  get change_request(): Prisma.change_requestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.deviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device_heartbeat`: Exposes CRUD operations for the **device_heartbeat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Device_heartbeats
    * const device_heartbeats = await prisma.device_heartbeat.findMany()
    * ```
    */
  get device_heartbeat(): Prisma.device_heartbeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution`: Exposes CRUD operations for the **institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.institutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution_invoices`: Exposes CRUD operations for the **institution_invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institution_invoices
    * const institution_invoices = await prisma.institution_invoices.findMany()
    * ```
    */
  get institution_invoices(): Prisma.institution_invoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution_service_tracking`: Exposes CRUD operations for the **institution_service_tracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institution_service_trackings
    * const institution_service_trackings = await prisma.institution_service_tracking.findMany()
    * ```
    */
  get institution_service_tracking(): Prisma.institution_service_trackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.login_history`: Exposes CRUD operations for the **login_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Login_histories
    * const login_histories = await prisma.login_history.findMany()
    * ```
    */
  get login_history(): Prisma.login_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migration`: Exposes CRUD operations for the **migration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migration.findMany()
    * ```
    */
  get migration(): Prisma.migrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mms_file`: Exposes CRUD operations for the **mms_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mms_files
    * const mms_files = await prisma.mms_file.findMany()
    * ```
    */
  get mms_file(): Prisma.mms_fileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_recipient`: Exposes CRUD operations for the **notification_recipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_recipients
    * const notification_recipients = await prisma.notification_recipient.findMany()
    * ```
    */
  get notification_recipient(): Prisma.notification_recipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.optionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.popup_questions`: Exposes CRUD operations for the **popup_questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Popup_questions
    * const popup_questions = await prisma.popup_questions.findMany()
    * ```
    */
  get popup_questions(): Prisma.popup_questionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.popup_questions_answers`: Exposes CRUD operations for the **popup_questions_answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Popup_questions_answers
    * const popup_questions_answers = await prisma.popup_questions_answers.findMany()
    * ```
    */
  get popup_questions_answers(): Prisma.popup_questions_answersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.popup_questions_possible_answers`: Exposes CRUD operations for the **popup_questions_possible_answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Popup_questions_possible_answers
    * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findMany()
    * ```
    */
  get popup_questions_possible_answers(): Prisma.popup_questions_possible_answersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_branch_operator`: Exposes CRUD operations for the **qms_branch_operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_branch_operators
    * const qms_branch_operators = await prisma.qms_branch_operator.findMany()
    * ```
    */
  get qms_branch_operator(): Prisma.qms_branch_operatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_branch_transactions`: Exposes CRUD operations for the **qms_branch_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_branch_transactions
    * const qms_branch_transactions = await prisma.qms_branch_transactions.findMany()
    * ```
    */
  get qms_branch_transactions(): Prisma.qms_branch_transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_counter`: Exposes CRUD operations for the **qms_counter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_counters
    * const qms_counters = await prisma.qms_counter.findMany()
    * ```
    */
  get qms_counter(): Prisma.qms_counterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_customer`: Exposes CRUD operations for the **qms_customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_customers
    * const qms_customers = await prisma.qms_customer.findMany()
    * ```
    */
  get qms_customer(): Prisma.qms_customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_operator`: Exposes CRUD operations for the **qms_operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_operators
    * const qms_operators = await prisma.qms_operator.findMany()
    * ```
    */
  get qms_operator(): Prisma.qms_operatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_operator_transactions`: Exposes CRUD operations for the **qms_operator_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_operator_transactions
    * const qms_operator_transactions = await prisma.qms_operator_transactions.findMany()
    * ```
    */
  get qms_operator_transactions(): Prisma.qms_operator_transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_queue`: Exposes CRUD operations for the **qms_queue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_queues
    * const qms_queues = await prisma.qms_queue.findMany()
    * ```
    */
  get qms_queue(): Prisma.qms_queueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_queue_operator_lnk`: Exposes CRUD operations for the **qms_queue_operator_lnk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_queue_operator_lnks
    * const qms_queue_operator_lnks = await prisma.qms_queue_operator_lnk.findMany()
    * ```
    */
  get qms_queue_operator_lnk(): Prisma.qms_queue_operator_lnkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_ticket`: Exposes CRUD operations for the **qms_ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_tickets
    * const qms_tickets = await prisma.qms_ticket.findMany()
    * ```
    */
  get qms_ticket(): Prisma.qms_ticketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qms_ticket_assignment`: Exposes CRUD operations for the **qms_ticket_assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qms_ticket_assignments
    * const qms_ticket_assignments = await prisma.qms_ticket_assignment.findMany()
    * ```
    */
  get qms_ticket_assignment(): Prisma.qms_ticket_assignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.ratingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating_assets`: Exposes CRUD operations for the **rating_assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rating_assets
    * const rating_assets = await prisma.rating_assets.findMany()
    * ```
    */
  get rating_assets(): Prisma.rating_assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating_qr_code_sessions`: Exposes CRUD operations for the **rating_qr_code_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rating_qr_code_sessions
    * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findMany()
    * ```
    */
  get rating_qr_code_sessions(): Prisma.rating_qr_code_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating_reply`: Exposes CRUD operations for the **rating_reply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rating_replies
    * const rating_replies = await prisma.rating_reply.findMany()
    * ```
    */
  get rating_reply(): Prisma.rating_replyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reports`: Exposes CRUD operations for the **reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.reports.findMany()
    * ```
    */
  get reports(): Prisma.reportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.request_institution`: Exposes CRUD operations for the **request_institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Request_institutions
    * const request_institutions = await prisma.request_institution.findMany()
    * ```
    */
  get request_institution(): Prisma.request_institutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.serviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service_group`: Exposes CRUD operations for the **service_group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_groups
    * const service_groups = await prisma.service_group.findMany()
    * ```
    */
  get service_group(): Prisma.service_groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.survey`: Exposes CRUD operations for the **survey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.survey.findMany()
    * ```
    */
  get survey(): Prisma.surveyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.survey_result`: Exposes CRUD operations for the **survey_result** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Survey_results
    * const survey_results = await prisma.survey_result.findMany()
    * ```
    */
  get survey_result(): Prisma.survey_resultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tip`: Exposes CRUD operations for the **tip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tips
    * const tips = await prisma.tip.findMany()
    * ```
    */
  get tip(): Prisma.tipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet_accounts`: Exposes CRUD operations for the **wallet_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_accounts
    * const wallet_accounts = await prisma.wallet_accounts.findMany()
    * ```
    */
  get wallet_accounts(): Prisma.wallet_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet_accounts_types`: Exposes CRUD operations for the **wallet_accounts_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_accounts_types
    * const wallet_accounts_types = await prisma.wallet_accounts_types.findMany()
    * ```
    */
  get wallet_accounts_types(): Prisma.wallet_accounts_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet_transfers`: Exposes CRUD operations for the **wallet_transfers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_transfers
    * const wallet_transfers = await prisma.wallet_transfers.findMany()
    * ```
    */
  get wallet_transfers(): Prisma.wallet_transfersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet_users`: Exposes CRUD operations for the **wallet_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_users
    * const wallet_users = await prisma.wallet_users.findMany()
    * ```
    */
  get wallet_users(): Prisma.wallet_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.imagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sectors`: Exposes CRUD operations for the **sectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sectors
    * const sectors = await prisma.sectors.findMany()
    * ```
    */
  get sectors(): Prisma.sectorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users_profile`: Exposes CRUD operations for the **users_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_profiles
    * const users_profiles = await prisma.users_profile.findMany()
    * ```
    */
  get users_profile(): Prisma.users_profileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.reviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workingHour`: Exposes CRUD operations for the **workingHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingHours
    * const workingHours = await prisma.workingHour.findMany()
    * ```
    */
  get workingHour(): Prisma.workingHourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenities`: Exposes CRUD operations for the **amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenities.findMany()
    * ```
    */
  get amenities(): Prisma.amenitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.business_amenities`: Exposes CRUD operations for the **business_amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Business_amenities
    * const business_amenities = await prisma.business_amenities.findMany()
    * ```
    */
  get business_amenities(): Prisma.business_amenitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.price_ranges`: Exposes CRUD operations for the **price_ranges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Price_ranges
    * const price_ranges = await prisma.price_ranges.findMany()
    * ```
    */
  get price_ranges(): Prisma.price_rangesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyAnswers`: Exposes CRUD operations for the **surveyAnswers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyAnswers
    * const surveyAnswers = await prisma.surveyAnswers.findMany()
    * ```
    */
  get surveyAnswers(): Prisma.surveyAnswersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyQuestions`: Exposes CRUD operations for the **surveyQuestions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestions
    * const surveyQuestions = await prisma.surveyQuestions.findMany()
    * ```
    */
  get surveyQuestions(): Prisma.surveyQuestionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceReview`: Exposes CRUD operations for the **serviceReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceReviews
    * const serviceReviews = await prisma.serviceReview.findMany()
    * ```
    */
  get serviceReview(): Prisma.serviceReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category_search_terms`: Exposes CRUD operations for the **category_search_terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Category_search_terms
    * const category_search_terms = await prisma.category_search_terms.findMany()
    * ```
    */
  get category_search_terms(): Prisma.category_search_termsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    app_releases: 'app_releases',
    appointments: 'appointments',
    apps: 'apps',
    audit_trail: 'audit_trail',
    categories: 'categories',
    change_request: 'change_request',
    device: 'device',
    device_heartbeat: 'device_heartbeat',
    institution: 'institution',
    institution_invoices: 'institution_invoices',
    institution_service_tracking: 'institution_service_tracking',
    login_history: 'login_history',
    migration: 'migration',
    mms_file: 'mms_file',
    notification: 'notification',
    notification_recipient: 'notification_recipient',
    option: 'option',
    popup_questions: 'popup_questions',
    popup_questions_answers: 'popup_questions_answers',
    popup_questions_possible_answers: 'popup_questions_possible_answers',
    qms_branch_operator: 'qms_branch_operator',
    qms_branch_transactions: 'qms_branch_transactions',
    qms_counter: 'qms_counter',
    qms_customer: 'qms_customer',
    qms_operator: 'qms_operator',
    qms_operator_transactions: 'qms_operator_transactions',
    qms_queue: 'qms_queue',
    qms_queue_operator_lnk: 'qms_queue_operator_lnk',
    qms_ticket: 'qms_ticket',
    qms_ticket_assignment: 'qms_ticket_assignment',
    rating: 'rating',
    rating_assets: 'rating_assets',
    rating_qr_code_sessions: 'rating_qr_code_sessions',
    rating_reply: 'rating_reply',
    reports: 'reports',
    request_institution: 'request_institution',
    service: 'service',
    service_group: 'service_group',
    survey: 'survey',
    survey_result: 'survey_result',
    tags: 'tags',
    tip: 'tip',
    user: 'user',
    wallet_accounts: 'wallet_accounts',
    wallet_accounts_types: 'wallet_accounts_types',
    wallet_transfers: 'wallet_transfers',
    wallet_users: 'wallet_users',
    images: 'images',
    sectors: 'sectors',
    users_profile: 'users_profile',
    reviews: 'reviews',
    workingHour: 'workingHour',
    amenities: 'amenities',
    business_amenities: 'business_amenities',
    price_ranges: 'price_ranges',
    surveyAnswers: 'surveyAnswers',
    surveyQuestions: 'surveyQuestions',
    serviceReview: 'serviceReview',
    category_search_terms: 'category_search_terms'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "app_releases" | "appointments" | "apps" | "audit_trail" | "categories" | "change_request" | "device" | "device_heartbeat" | "institution" | "institution_invoices" | "institution_service_tracking" | "login_history" | "migration" | "mms_file" | "notification" | "notification_recipient" | "option" | "popup_questions" | "popup_questions_answers" | "popup_questions_possible_answers" | "qms_branch_operator" | "qms_branch_transactions" | "qms_counter" | "qms_customer" | "qms_operator" | "qms_operator_transactions" | "qms_queue" | "qms_queue_operator_lnk" | "qms_ticket" | "qms_ticket_assignment" | "rating" | "rating_assets" | "rating_qr_code_sessions" | "rating_reply" | "reports" | "request_institution" | "service" | "service_group" | "survey" | "survey_result" | "tags" | "tip" | "user" | "wallet_accounts" | "wallet_accounts_types" | "wallet_transfers" | "wallet_users" | "images" | "sectors" | "users_profile" | "reviews" | "workingHour" | "amenities" | "business_amenities" | "price_ranges" | "surveyAnswers" | "surveyQuestions" | "serviceReview" | "category_search_terms"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      app_releases: {
        payload: Prisma.$app_releasesPayload<ExtArgs>
        fields: Prisma.app_releasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_releasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_releasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>
          }
          findFirst: {
            args: Prisma.app_releasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_releasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>
          }
          findMany: {
            args: Prisma.app_releasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>[]
          }
          create: {
            args: Prisma.app_releasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>
          }
          createMany: {
            args: Prisma.app_releasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.app_releasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>
          }
          update: {
            args: Prisma.app_releasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>
          }
          deleteMany: {
            args: Prisma.app_releasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_releasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_releasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_releasesPayload>
          }
          aggregate: {
            args: Prisma.App_releasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_releases>
          }
          groupBy: {
            args: Prisma.app_releasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_releasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_releasesCountArgs<ExtArgs>
            result: $Utils.Optional<App_releasesCountAggregateOutputType> | number
          }
        }
      }
      appointments: {
        payload: Prisma.$appointmentsPayload<ExtArgs>
        fields: Prisma.appointmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findFirst: {
            args: Prisma.appointmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findMany: {
            args: Prisma.appointmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          create: {
            args: Prisma.appointmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          createMany: {
            args: Prisma.appointmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.appointmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          update: {
            args: Prisma.appointmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          deleteMany: {
            args: Prisma.appointmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appointmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.appointmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          aggregate: {
            args: Prisma.AppointmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointments>
          }
          groupBy: {
            args: Prisma.appointmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsCountAggregateOutputType> | number
          }
        }
      }
      apps: {
        payload: Prisma.$appsPayload<ExtArgs>
        fields: Prisma.appsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>
          }
          findFirst: {
            args: Prisma.appsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>
          }
          findMany: {
            args: Prisma.appsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>[]
          }
          create: {
            args: Prisma.appsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>
          }
          createMany: {
            args: Prisma.appsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.appsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>
          }
          update: {
            args: Prisma.appsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>
          }
          deleteMany: {
            args: Prisma.appsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.appsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appsPayload>
          }
          aggregate: {
            args: Prisma.AppsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApps>
          }
          groupBy: {
            args: Prisma.appsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppsGroupByOutputType>[]
          }
          count: {
            args: Prisma.appsCountArgs<ExtArgs>
            result: $Utils.Optional<AppsCountAggregateOutputType> | number
          }
        }
      }
      audit_trail: {
        payload: Prisma.$audit_trailPayload<ExtArgs>
        fields: Prisma.audit_trailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_trailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_trailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>
          }
          findFirst: {
            args: Prisma.audit_trailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_trailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>
          }
          findMany: {
            args: Prisma.audit_trailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>[]
          }
          create: {
            args: Prisma.audit_trailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>
          }
          createMany: {
            args: Prisma.audit_trailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.audit_trailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>
          }
          update: {
            args: Prisma.audit_trailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>
          }
          deleteMany: {
            args: Prisma.audit_trailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_trailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.audit_trailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_trailPayload>
          }
          aggregate: {
            args: Prisma.Audit_trailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_trail>
          }
          groupBy: {
            args: Prisma.audit_trailGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_trailGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_trailCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_trailCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      change_request: {
        payload: Prisma.$change_requestPayload<ExtArgs>
        fields: Prisma.change_requestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.change_requestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.change_requestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>
          }
          findFirst: {
            args: Prisma.change_requestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.change_requestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>
          }
          findMany: {
            args: Prisma.change_requestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>[]
          }
          create: {
            args: Prisma.change_requestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>
          }
          createMany: {
            args: Prisma.change_requestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.change_requestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>
          }
          update: {
            args: Prisma.change_requestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>
          }
          deleteMany: {
            args: Prisma.change_requestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.change_requestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.change_requestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$change_requestPayload>
          }
          aggregate: {
            args: Prisma.Change_requestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChange_request>
          }
          groupBy: {
            args: Prisma.change_requestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Change_requestGroupByOutputType>[]
          }
          count: {
            args: Prisma.change_requestCountArgs<ExtArgs>
            result: $Utils.Optional<Change_requestCountAggregateOutputType> | number
          }
        }
      }
      device: {
        payload: Prisma.$devicePayload<ExtArgs>
        fields: Prisma.deviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          findFirst: {
            args: Prisma.deviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          findMany: {
            args: Prisma.deviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>[]
          }
          create: {
            args: Prisma.deviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          createMany: {
            args: Prisma.deviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.deviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          update: {
            args: Prisma.deviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          deleteMany: {
            args: Prisma.deviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.deviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$devicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.deviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.deviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      device_heartbeat: {
        payload: Prisma.$device_heartbeatPayload<ExtArgs>
        fields: Prisma.device_heartbeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.device_heartbeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.device_heartbeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>
          }
          findFirst: {
            args: Prisma.device_heartbeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.device_heartbeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>
          }
          findMany: {
            args: Prisma.device_heartbeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>[]
          }
          create: {
            args: Prisma.device_heartbeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>
          }
          createMany: {
            args: Prisma.device_heartbeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.device_heartbeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>
          }
          update: {
            args: Prisma.device_heartbeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>
          }
          deleteMany: {
            args: Prisma.device_heartbeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.device_heartbeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.device_heartbeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_heartbeatPayload>
          }
          aggregate: {
            args: Prisma.Device_heartbeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice_heartbeat>
          }
          groupBy: {
            args: Prisma.device_heartbeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<Device_heartbeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.device_heartbeatCountArgs<ExtArgs>
            result: $Utils.Optional<Device_heartbeatCountAggregateOutputType> | number
          }
        }
      }
      institution: {
        payload: Prisma.$institutionPayload<ExtArgs>
        fields: Prisma.institutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.institutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.institutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>
          }
          findFirst: {
            args: Prisma.institutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.institutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>
          }
          findMany: {
            args: Prisma.institutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>[]
          }
          create: {
            args: Prisma.institutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>
          }
          createMany: {
            args: Prisma.institutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.institutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>
          }
          update: {
            args: Prisma.institutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>
          }
          deleteMany: {
            args: Prisma.institutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.institutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.institutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.institutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.institutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      institution_invoices: {
        payload: Prisma.$institution_invoicesPayload<ExtArgs>
        fields: Prisma.institution_invoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.institution_invoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.institution_invoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>
          }
          findFirst: {
            args: Prisma.institution_invoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.institution_invoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>
          }
          findMany: {
            args: Prisma.institution_invoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>[]
          }
          create: {
            args: Prisma.institution_invoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>
          }
          createMany: {
            args: Prisma.institution_invoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.institution_invoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>
          }
          update: {
            args: Prisma.institution_invoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>
          }
          deleteMany: {
            args: Prisma.institution_invoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.institution_invoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.institution_invoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_invoicesPayload>
          }
          aggregate: {
            args: Prisma.Institution_invoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution_invoices>
          }
          groupBy: {
            args: Prisma.institution_invoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Institution_invoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.institution_invoicesCountArgs<ExtArgs>
            result: $Utils.Optional<Institution_invoicesCountAggregateOutputType> | number
          }
        }
      }
      institution_service_tracking: {
        payload: Prisma.$institution_service_trackingPayload<ExtArgs>
        fields: Prisma.institution_service_trackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.institution_service_trackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.institution_service_trackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>
          }
          findFirst: {
            args: Prisma.institution_service_trackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.institution_service_trackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>
          }
          findMany: {
            args: Prisma.institution_service_trackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>[]
          }
          create: {
            args: Prisma.institution_service_trackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>
          }
          createMany: {
            args: Prisma.institution_service_trackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.institution_service_trackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>
          }
          update: {
            args: Prisma.institution_service_trackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>
          }
          deleteMany: {
            args: Prisma.institution_service_trackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.institution_service_trackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.institution_service_trackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institution_service_trackingPayload>
          }
          aggregate: {
            args: Prisma.Institution_service_trackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution_service_tracking>
          }
          groupBy: {
            args: Prisma.institution_service_trackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Institution_service_trackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.institution_service_trackingCountArgs<ExtArgs>
            result: $Utils.Optional<Institution_service_trackingCountAggregateOutputType> | number
          }
        }
      }
      login_history: {
        payload: Prisma.$login_historyPayload<ExtArgs>
        fields: Prisma.login_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.login_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.login_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          findFirst: {
            args: Prisma.login_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.login_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          findMany: {
            args: Prisma.login_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>[]
          }
          create: {
            args: Prisma.login_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          createMany: {
            args: Prisma.login_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.login_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          update: {
            args: Prisma.login_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          deleteMany: {
            args: Prisma.login_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.login_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.login_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$login_historyPayload>
          }
          aggregate: {
            args: Prisma.Login_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogin_history>
          }
          groupBy: {
            args: Prisma.login_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Login_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.login_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Login_historyCountAggregateOutputType> | number
          }
        }
      }
      migration: {
        payload: Prisma.$migrationPayload<ExtArgs>
        fields: Prisma.migrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          findFirst: {
            args: Prisma.migrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          findMany: {
            args: Prisma.migrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>[]
          }
          create: {
            args: Prisma.migrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          createMany: {
            args: Prisma.migrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.migrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          update: {
            args: Prisma.migrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          deleteMany: {
            args: Prisma.migrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.migrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          aggregate: {
            args: Prisma.MigrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigration>
          }
          groupBy: {
            args: Prisma.migrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationCountAggregateOutputType> | number
          }
        }
      }
      mms_file: {
        payload: Prisma.$mms_filePayload<ExtArgs>
        fields: Prisma.mms_fileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mms_fileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mms_fileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>
          }
          findFirst: {
            args: Prisma.mms_fileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mms_fileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>
          }
          findMany: {
            args: Prisma.mms_fileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>[]
          }
          create: {
            args: Prisma.mms_fileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>
          }
          createMany: {
            args: Prisma.mms_fileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.mms_fileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>
          }
          update: {
            args: Prisma.mms_fileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>
          }
          deleteMany: {
            args: Prisma.mms_fileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mms_fileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mms_fileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mms_filePayload>
          }
          aggregate: {
            args: Prisma.Mms_fileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMms_file>
          }
          groupBy: {
            args: Prisma.mms_fileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mms_fileGroupByOutputType>[]
          }
          count: {
            args: Prisma.mms_fileCountArgs<ExtArgs>
            result: $Utils.Optional<Mms_fileCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      notification_recipient: {
        payload: Prisma.$notification_recipientPayload<ExtArgs>
        fields: Prisma.notification_recipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_recipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_recipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>
          }
          findFirst: {
            args: Prisma.notification_recipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_recipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>
          }
          findMany: {
            args: Prisma.notification_recipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>[]
          }
          create: {
            args: Prisma.notification_recipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>
          }
          createMany: {
            args: Prisma.notification_recipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notification_recipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>
          }
          update: {
            args: Prisma.notification_recipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>
          }
          deleteMany: {
            args: Prisma.notification_recipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_recipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notification_recipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_recipientPayload>
          }
          aggregate: {
            args: Prisma.Notification_recipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_recipient>
          }
          groupBy: {
            args: Prisma.notification_recipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_recipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_recipientCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_recipientCountAggregateOutputType> | number
          }
        }
      }
      option: {
        payload: Prisma.$optionPayload<ExtArgs>
        fields: Prisma.optionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.optionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.optionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          findFirst: {
            args: Prisma.optionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.optionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          findMany: {
            args: Prisma.optionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>[]
          }
          create: {
            args: Prisma.optionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          createMany: {
            args: Prisma.optionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.optionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          update: {
            args: Prisma.optionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          deleteMany: {
            args: Prisma.optionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.optionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.optionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optionPayload>
          }
          aggregate: {
            args: Prisma.OptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption>
          }
          groupBy: {
            args: Prisma.optionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.optionCountArgs<ExtArgs>
            result: $Utils.Optional<OptionCountAggregateOutputType> | number
          }
        }
      }
      popup_questions: {
        payload: Prisma.$popup_questionsPayload<ExtArgs>
        fields: Prisma.popup_questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.popup_questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.popup_questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>
          }
          findFirst: {
            args: Prisma.popup_questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.popup_questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>
          }
          findMany: {
            args: Prisma.popup_questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>[]
          }
          create: {
            args: Prisma.popup_questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>
          }
          createMany: {
            args: Prisma.popup_questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.popup_questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>
          }
          update: {
            args: Prisma.popup_questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>
          }
          deleteMany: {
            args: Prisma.popup_questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.popup_questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.popup_questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questionsPayload>
          }
          aggregate: {
            args: Prisma.Popup_questionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePopup_questions>
          }
          groupBy: {
            args: Prisma.popup_questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Popup_questionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.popup_questionsCountArgs<ExtArgs>
            result: $Utils.Optional<Popup_questionsCountAggregateOutputType> | number
          }
        }
      }
      popup_questions_answers: {
        payload: Prisma.$popup_questions_answersPayload<ExtArgs>
        fields: Prisma.popup_questions_answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.popup_questions_answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.popup_questions_answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>
          }
          findFirst: {
            args: Prisma.popup_questions_answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.popup_questions_answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>
          }
          findMany: {
            args: Prisma.popup_questions_answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>[]
          }
          create: {
            args: Prisma.popup_questions_answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>
          }
          createMany: {
            args: Prisma.popup_questions_answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.popup_questions_answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>
          }
          update: {
            args: Prisma.popup_questions_answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>
          }
          deleteMany: {
            args: Prisma.popup_questions_answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.popup_questions_answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.popup_questions_answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_answersPayload>
          }
          aggregate: {
            args: Prisma.Popup_questions_answersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePopup_questions_answers>
          }
          groupBy: {
            args: Prisma.popup_questions_answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Popup_questions_answersGroupByOutputType>[]
          }
          count: {
            args: Prisma.popup_questions_answersCountArgs<ExtArgs>
            result: $Utils.Optional<Popup_questions_answersCountAggregateOutputType> | number
          }
        }
      }
      popup_questions_possible_answers: {
        payload: Prisma.$popup_questions_possible_answersPayload<ExtArgs>
        fields: Prisma.popup_questions_possible_answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.popup_questions_possible_answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.popup_questions_possible_answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>
          }
          findFirst: {
            args: Prisma.popup_questions_possible_answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.popup_questions_possible_answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>
          }
          findMany: {
            args: Prisma.popup_questions_possible_answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>[]
          }
          create: {
            args: Prisma.popup_questions_possible_answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>
          }
          createMany: {
            args: Prisma.popup_questions_possible_answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.popup_questions_possible_answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>
          }
          update: {
            args: Prisma.popup_questions_possible_answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>
          }
          deleteMany: {
            args: Prisma.popup_questions_possible_answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.popup_questions_possible_answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.popup_questions_possible_answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$popup_questions_possible_answersPayload>
          }
          aggregate: {
            args: Prisma.Popup_questions_possible_answersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePopup_questions_possible_answers>
          }
          groupBy: {
            args: Prisma.popup_questions_possible_answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Popup_questions_possible_answersGroupByOutputType>[]
          }
          count: {
            args: Prisma.popup_questions_possible_answersCountArgs<ExtArgs>
            result: $Utils.Optional<Popup_questions_possible_answersCountAggregateOutputType> | number
          }
        }
      }
      qms_branch_operator: {
        payload: Prisma.$qms_branch_operatorPayload<ExtArgs>
        fields: Prisma.qms_branch_operatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_branch_operatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_branch_operatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>
          }
          findFirst: {
            args: Prisma.qms_branch_operatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_branch_operatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>
          }
          findMany: {
            args: Prisma.qms_branch_operatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>[]
          }
          create: {
            args: Prisma.qms_branch_operatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>
          }
          createMany: {
            args: Prisma.qms_branch_operatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_branch_operatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>
          }
          update: {
            args: Prisma.qms_branch_operatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>
          }
          deleteMany: {
            args: Prisma.qms_branch_operatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_branch_operatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_branch_operatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_operatorPayload>
          }
          aggregate: {
            args: Prisma.Qms_branch_operatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_branch_operator>
          }
          groupBy: {
            args: Prisma.qms_branch_operatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_branch_operatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_branch_operatorCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_branch_operatorCountAggregateOutputType> | number
          }
        }
      }
      qms_branch_transactions: {
        payload: Prisma.$qms_branch_transactionsPayload<ExtArgs>
        fields: Prisma.qms_branch_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_branch_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_branch_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>
          }
          findFirst: {
            args: Prisma.qms_branch_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_branch_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>
          }
          findMany: {
            args: Prisma.qms_branch_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>[]
          }
          create: {
            args: Prisma.qms_branch_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>
          }
          createMany: {
            args: Prisma.qms_branch_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_branch_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>
          }
          update: {
            args: Prisma.qms_branch_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.qms_branch_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_branch_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_branch_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_branch_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Qms_branch_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_branch_transactions>
          }
          groupBy: {
            args: Prisma.qms_branch_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_branch_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_branch_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_branch_transactionsCountAggregateOutputType> | number
          }
        }
      }
      qms_counter: {
        payload: Prisma.$qms_counterPayload<ExtArgs>
        fields: Prisma.qms_counterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_counterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_counterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>
          }
          findFirst: {
            args: Prisma.qms_counterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_counterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>
          }
          findMany: {
            args: Prisma.qms_counterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>[]
          }
          create: {
            args: Prisma.qms_counterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>
          }
          createMany: {
            args: Prisma.qms_counterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_counterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>
          }
          update: {
            args: Prisma.qms_counterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>
          }
          deleteMany: {
            args: Prisma.qms_counterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_counterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_counterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_counterPayload>
          }
          aggregate: {
            args: Prisma.Qms_counterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_counter>
          }
          groupBy: {
            args: Prisma.qms_counterGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_counterGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_counterCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_counterCountAggregateOutputType> | number
          }
        }
      }
      qms_customer: {
        payload: Prisma.$qms_customerPayload<ExtArgs>
        fields: Prisma.qms_customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>
          }
          findFirst: {
            args: Prisma.qms_customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>
          }
          findMany: {
            args: Prisma.qms_customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>[]
          }
          create: {
            args: Prisma.qms_customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>
          }
          createMany: {
            args: Prisma.qms_customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>
          }
          update: {
            args: Prisma.qms_customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>
          }
          deleteMany: {
            args: Prisma.qms_customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_customerPayload>
          }
          aggregate: {
            args: Prisma.Qms_customerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_customer>
          }
          groupBy: {
            args: Prisma.qms_customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_customerGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_customerCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_customerCountAggregateOutputType> | number
          }
        }
      }
      qms_operator: {
        payload: Prisma.$qms_operatorPayload<ExtArgs>
        fields: Prisma.qms_operatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_operatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_operatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>
          }
          findFirst: {
            args: Prisma.qms_operatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_operatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>
          }
          findMany: {
            args: Prisma.qms_operatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>[]
          }
          create: {
            args: Prisma.qms_operatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>
          }
          createMany: {
            args: Prisma.qms_operatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_operatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>
          }
          update: {
            args: Prisma.qms_operatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>
          }
          deleteMany: {
            args: Prisma.qms_operatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_operatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_operatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operatorPayload>
          }
          aggregate: {
            args: Prisma.Qms_operatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_operator>
          }
          groupBy: {
            args: Prisma.qms_operatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_operatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_operatorCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_operatorCountAggregateOutputType> | number
          }
        }
      }
      qms_operator_transactions: {
        payload: Prisma.$qms_operator_transactionsPayload<ExtArgs>
        fields: Prisma.qms_operator_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_operator_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_operator_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>
          }
          findFirst: {
            args: Prisma.qms_operator_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_operator_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>
          }
          findMany: {
            args: Prisma.qms_operator_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>[]
          }
          create: {
            args: Prisma.qms_operator_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>
          }
          createMany: {
            args: Prisma.qms_operator_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_operator_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>
          }
          update: {
            args: Prisma.qms_operator_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.qms_operator_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_operator_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_operator_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_operator_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Qms_operator_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_operator_transactions>
          }
          groupBy: {
            args: Prisma.qms_operator_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_operator_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_operator_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_operator_transactionsCountAggregateOutputType> | number
          }
        }
      }
      qms_queue: {
        payload: Prisma.$qms_queuePayload<ExtArgs>
        fields: Prisma.qms_queueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_queueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_queueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>
          }
          findFirst: {
            args: Prisma.qms_queueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_queueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>
          }
          findMany: {
            args: Prisma.qms_queueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>[]
          }
          create: {
            args: Prisma.qms_queueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>
          }
          createMany: {
            args: Prisma.qms_queueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_queueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>
          }
          update: {
            args: Prisma.qms_queueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>
          }
          deleteMany: {
            args: Prisma.qms_queueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_queueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_queueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queuePayload>
          }
          aggregate: {
            args: Prisma.Qms_queueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_queue>
          }
          groupBy: {
            args: Prisma.qms_queueGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_queueGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_queueCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_queueCountAggregateOutputType> | number
          }
        }
      }
      qms_queue_operator_lnk: {
        payload: Prisma.$qms_queue_operator_lnkPayload<ExtArgs>
        fields: Prisma.qms_queue_operator_lnkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_queue_operator_lnkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_queue_operator_lnkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>
          }
          findFirst: {
            args: Prisma.qms_queue_operator_lnkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_queue_operator_lnkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>
          }
          findMany: {
            args: Prisma.qms_queue_operator_lnkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>[]
          }
          create: {
            args: Prisma.qms_queue_operator_lnkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>
          }
          createMany: {
            args: Prisma.qms_queue_operator_lnkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_queue_operator_lnkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>
          }
          update: {
            args: Prisma.qms_queue_operator_lnkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>
          }
          deleteMany: {
            args: Prisma.qms_queue_operator_lnkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_queue_operator_lnkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_queue_operator_lnkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_queue_operator_lnkPayload>
          }
          aggregate: {
            args: Prisma.Qms_queue_operator_lnkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_queue_operator_lnk>
          }
          groupBy: {
            args: Prisma.qms_queue_operator_lnkGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_queue_operator_lnkGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_queue_operator_lnkCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_queue_operator_lnkCountAggregateOutputType> | number
          }
        }
      }
      qms_ticket: {
        payload: Prisma.$qms_ticketPayload<ExtArgs>
        fields: Prisma.qms_ticketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_ticketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_ticketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>
          }
          findFirst: {
            args: Prisma.qms_ticketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_ticketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>
          }
          findMany: {
            args: Prisma.qms_ticketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>[]
          }
          create: {
            args: Prisma.qms_ticketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>
          }
          createMany: {
            args: Prisma.qms_ticketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_ticketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>
          }
          update: {
            args: Prisma.qms_ticketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>
          }
          deleteMany: {
            args: Prisma.qms_ticketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_ticketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_ticketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticketPayload>
          }
          aggregate: {
            args: Prisma.Qms_ticketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_ticket>
          }
          groupBy: {
            args: Prisma.qms_ticketGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_ticketGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_ticketCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_ticketCountAggregateOutputType> | number
          }
        }
      }
      qms_ticket_assignment: {
        payload: Prisma.$qms_ticket_assignmentPayload<ExtArgs>
        fields: Prisma.qms_ticket_assignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qms_ticket_assignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qms_ticket_assignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>
          }
          findFirst: {
            args: Prisma.qms_ticket_assignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qms_ticket_assignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>
          }
          findMany: {
            args: Prisma.qms_ticket_assignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>[]
          }
          create: {
            args: Prisma.qms_ticket_assignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>
          }
          createMany: {
            args: Prisma.qms_ticket_assignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qms_ticket_assignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>
          }
          update: {
            args: Prisma.qms_ticket_assignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>
          }
          deleteMany: {
            args: Prisma.qms_ticket_assignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qms_ticket_assignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qms_ticket_assignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qms_ticket_assignmentPayload>
          }
          aggregate: {
            args: Prisma.Qms_ticket_assignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQms_ticket_assignment>
          }
          groupBy: {
            args: Prisma.qms_ticket_assignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qms_ticket_assignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.qms_ticket_assignmentCountArgs<ExtArgs>
            result: $Utils.Optional<Qms_ticket_assignmentCountAggregateOutputType> | number
          }
        }
      }
      rating: {
        payload: Prisma.$ratingPayload<ExtArgs>
        fields: Prisma.ratingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ratingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ratingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          findFirst: {
            args: Prisma.ratingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ratingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          findMany: {
            args: Prisma.ratingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>[]
          }
          create: {
            args: Prisma.ratingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          createMany: {
            args: Prisma.ratingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ratingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          update: {
            args: Prisma.ratingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          deleteMany: {
            args: Prisma.ratingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ratingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ratingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.ratingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ratingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      rating_assets: {
        payload: Prisma.$rating_assetsPayload<ExtArgs>
        fields: Prisma.rating_assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rating_assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rating_assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>
          }
          findFirst: {
            args: Prisma.rating_assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rating_assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>
          }
          findMany: {
            args: Prisma.rating_assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>[]
          }
          create: {
            args: Prisma.rating_assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>
          }
          createMany: {
            args: Prisma.rating_assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rating_assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>
          }
          update: {
            args: Prisma.rating_assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>
          }
          deleteMany: {
            args: Prisma.rating_assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rating_assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rating_assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_assetsPayload>
          }
          aggregate: {
            args: Prisma.Rating_assetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating_assets>
          }
          groupBy: {
            args: Prisma.rating_assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rating_assetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rating_assetsCountArgs<ExtArgs>
            result: $Utils.Optional<Rating_assetsCountAggregateOutputType> | number
          }
        }
      }
      rating_qr_code_sessions: {
        payload: Prisma.$rating_qr_code_sessionsPayload<ExtArgs>
        fields: Prisma.rating_qr_code_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rating_qr_code_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rating_qr_code_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>
          }
          findFirst: {
            args: Prisma.rating_qr_code_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rating_qr_code_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>
          }
          findMany: {
            args: Prisma.rating_qr_code_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>[]
          }
          create: {
            args: Prisma.rating_qr_code_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>
          }
          createMany: {
            args: Prisma.rating_qr_code_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rating_qr_code_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>
          }
          update: {
            args: Prisma.rating_qr_code_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.rating_qr_code_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rating_qr_code_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rating_qr_code_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_qr_code_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Rating_qr_code_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating_qr_code_sessions>
          }
          groupBy: {
            args: Prisma.rating_qr_code_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rating_qr_code_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rating_qr_code_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Rating_qr_code_sessionsCountAggregateOutputType> | number
          }
        }
      }
      rating_reply: {
        payload: Prisma.$rating_replyPayload<ExtArgs>
        fields: Prisma.rating_replyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rating_replyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rating_replyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>
          }
          findFirst: {
            args: Prisma.rating_replyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rating_replyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>
          }
          findMany: {
            args: Prisma.rating_replyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>[]
          }
          create: {
            args: Prisma.rating_replyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>
          }
          createMany: {
            args: Prisma.rating_replyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rating_replyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>
          }
          update: {
            args: Prisma.rating_replyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>
          }
          deleteMany: {
            args: Prisma.rating_replyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rating_replyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rating_replyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rating_replyPayload>
          }
          aggregate: {
            args: Prisma.Rating_replyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating_reply>
          }
          groupBy: {
            args: Prisma.rating_replyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rating_replyGroupByOutputType>[]
          }
          count: {
            args: Prisma.rating_replyCountArgs<ExtArgs>
            result: $Utils.Optional<Rating_replyCountAggregateOutputType> | number
          }
        }
      }
      reports: {
        payload: Prisma.$reportsPayload<ExtArgs>
        fields: Prisma.reportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          findFirst: {
            args: Prisma.reportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          findMany: {
            args: Prisma.reportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>[]
          }
          create: {
            args: Prisma.reportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          createMany: {
            args: Prisma.reportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          update: {
            args: Prisma.reportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          deleteMany: {
            args: Prisma.reportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          aggregate: {
            args: Prisma.ReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReports>
          }
          groupBy: {
            args: Prisma.reportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportsCountArgs<ExtArgs>
            result: $Utils.Optional<ReportsCountAggregateOutputType> | number
          }
        }
      }
      request_institution: {
        payload: Prisma.$request_institutionPayload<ExtArgs>
        fields: Prisma.request_institutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.request_institutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.request_institutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>
          }
          findFirst: {
            args: Prisma.request_institutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.request_institutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>
          }
          findMany: {
            args: Prisma.request_institutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>[]
          }
          create: {
            args: Prisma.request_institutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>
          }
          createMany: {
            args: Prisma.request_institutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.request_institutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>
          }
          update: {
            args: Prisma.request_institutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>
          }
          deleteMany: {
            args: Prisma.request_institutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.request_institutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.request_institutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$request_institutionPayload>
          }
          aggregate: {
            args: Prisma.Request_institutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequest_institution>
          }
          groupBy: {
            args: Prisma.request_institutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Request_institutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.request_institutionCountArgs<ExtArgs>
            result: $Utils.Optional<Request_institutionCountAggregateOutputType> | number
          }
        }
      }
      service: {
        payload: Prisma.$servicePayload<ExtArgs>
        fields: Prisma.serviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          findFirst: {
            args: Prisma.serviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          findMany: {
            args: Prisma.serviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>[]
          }
          create: {
            args: Prisma.serviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          createMany: {
            args: Prisma.serviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          update: {
            args: Prisma.serviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          deleteMany: {
            args: Prisma.serviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.serviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      service_group: {
        payload: Prisma.$service_groupPayload<ExtArgs>
        fields: Prisma.service_groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>
          }
          findFirst: {
            args: Prisma.service_groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>
          }
          findMany: {
            args: Prisma.service_groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>[]
          }
          create: {
            args: Prisma.service_groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>
          }
          createMany: {
            args: Prisma.service_groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.service_groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>
          }
          update: {
            args: Prisma.service_groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>
          }
          deleteMany: {
            args: Prisma.service_groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.service_groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_groupPayload>
          }
          aggregate: {
            args: Prisma.Service_groupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_group>
          }
          groupBy: {
            args: Prisma.service_groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_groupGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_groupCountArgs<ExtArgs>
            result: $Utils.Optional<Service_groupCountAggregateOutputType> | number
          }
        }
      }
      survey: {
        payload: Prisma.$surveyPayload<ExtArgs>
        fields: Prisma.surveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>
          }
          findFirst: {
            args: Prisma.surveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>
          }
          findMany: {
            args: Prisma.surveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>[]
          }
          create: {
            args: Prisma.surveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>
          }
          createMany: {
            args: Prisma.surveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.surveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>
          }
          update: {
            args: Prisma.surveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>
          }
          deleteMany: {
            args: Prisma.surveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.surveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyPayload>
          }
          aggregate: {
            args: Prisma.SurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurvey>
          }
          groupBy: {
            args: Prisma.surveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.surveyCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyCountAggregateOutputType> | number
          }
        }
      }
      survey_result: {
        payload: Prisma.$survey_resultPayload<ExtArgs>
        fields: Prisma.survey_resultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.survey_resultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.survey_resultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>
          }
          findFirst: {
            args: Prisma.survey_resultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.survey_resultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>
          }
          findMany: {
            args: Prisma.survey_resultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>[]
          }
          create: {
            args: Prisma.survey_resultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>
          }
          createMany: {
            args: Prisma.survey_resultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.survey_resultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>
          }
          update: {
            args: Prisma.survey_resultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>
          }
          deleteMany: {
            args: Prisma.survey_resultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.survey_resultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.survey_resultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$survey_resultPayload>
          }
          aggregate: {
            args: Prisma.Survey_resultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurvey_result>
          }
          groupBy: {
            args: Prisma.survey_resultGroupByArgs<ExtArgs>
            result: $Utils.Optional<Survey_resultGroupByOutputType>[]
          }
          count: {
            args: Prisma.survey_resultCountArgs<ExtArgs>
            result: $Utils.Optional<Survey_resultCountAggregateOutputType> | number
          }
        }
      }
      tags: {
        payload: Prisma.$tagsPayload<ExtArgs>
        fields: Prisma.tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findFirst: {
            args: Prisma.tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findMany: {
            args: Prisma.tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          create: {
            args: Prisma.tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          createMany: {
            args: Prisma.tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          update: {
            args: Prisma.tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          deleteMany: {
            args: Prisma.tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      tip: {
        payload: Prisma.$tipPayload<ExtArgs>
        fields: Prisma.tipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>
          }
          findFirst: {
            args: Prisma.tipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>
          }
          findMany: {
            args: Prisma.tipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>[]
          }
          create: {
            args: Prisma.tipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>
          }
          createMany: {
            args: Prisma.tipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>
          }
          update: {
            args: Prisma.tipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>
          }
          deleteMany: {
            args: Prisma.tipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipPayload>
          }
          aggregate: {
            args: Prisma.TipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTip>
          }
          groupBy: {
            args: Prisma.tipGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipCountArgs<ExtArgs>
            result: $Utils.Optional<TipCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      wallet_accounts: {
        payload: Prisma.$wallet_accountsPayload<ExtArgs>
        fields: Prisma.wallet_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>
          }
          findFirst: {
            args: Prisma.wallet_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>
          }
          findMany: {
            args: Prisma.wallet_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>[]
          }
          create: {
            args: Prisma.wallet_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>
          }
          createMany: {
            args: Prisma.wallet_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallet_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>
          }
          update: {
            args: Prisma.wallet_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>
          }
          deleteMany: {
            args: Prisma.wallet_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallet_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accountsPayload>
          }
          aggregate: {
            args: Prisma.Wallet_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_accounts>
          }
          groupBy: {
            args: Prisma.wallet_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_accountsCountAggregateOutputType> | number
          }
        }
      }
      wallet_accounts_types: {
        payload: Prisma.$wallet_accounts_typesPayload<ExtArgs>
        fields: Prisma.wallet_accounts_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_accounts_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_accounts_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>
          }
          findFirst: {
            args: Prisma.wallet_accounts_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_accounts_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>
          }
          findMany: {
            args: Prisma.wallet_accounts_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>[]
          }
          create: {
            args: Prisma.wallet_accounts_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>
          }
          createMany: {
            args: Prisma.wallet_accounts_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallet_accounts_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>
          }
          update: {
            args: Prisma.wallet_accounts_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>
          }
          deleteMany: {
            args: Prisma.wallet_accounts_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_accounts_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallet_accounts_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_accounts_typesPayload>
          }
          aggregate: {
            args: Prisma.Wallet_accounts_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_accounts_types>
          }
          groupBy: {
            args: Prisma.wallet_accounts_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_accounts_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_accounts_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_accounts_typesCountAggregateOutputType> | number
          }
        }
      }
      wallet_transfers: {
        payload: Prisma.$wallet_transfersPayload<ExtArgs>
        fields: Prisma.wallet_transfersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_transfersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_transfersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>
          }
          findFirst: {
            args: Prisma.wallet_transfersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_transfersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>
          }
          findMany: {
            args: Prisma.wallet_transfersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>[]
          }
          create: {
            args: Prisma.wallet_transfersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>
          }
          createMany: {
            args: Prisma.wallet_transfersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallet_transfersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>
          }
          update: {
            args: Prisma.wallet_transfersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>
          }
          deleteMany: {
            args: Prisma.wallet_transfersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_transfersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallet_transfersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_transfersPayload>
          }
          aggregate: {
            args: Prisma.Wallet_transfersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_transfers>
          }
          groupBy: {
            args: Prisma.wallet_transfersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_transfersGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_transfersCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_transfersCountAggregateOutputType> | number
          }
        }
      }
      wallet_users: {
        payload: Prisma.$wallet_usersPayload<ExtArgs>
        fields: Prisma.wallet_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>
          }
          findFirst: {
            args: Prisma.wallet_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>
          }
          findMany: {
            args: Prisma.wallet_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>[]
          }
          create: {
            args: Prisma.wallet_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>
          }
          createMany: {
            args: Prisma.wallet_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallet_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>
          }
          update: {
            args: Prisma.wallet_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>
          }
          deleteMany: {
            args: Prisma.wallet_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallet_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_usersPayload>
          }
          aggregate: {
            args: Prisma.Wallet_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_users>
          }
          groupBy: {
            args: Prisma.wallet_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_usersCountAggregateOutputType> | number
          }
        }
      }
      images: {
        payload: Prisma.$imagesPayload<ExtArgs>
        fields: Prisma.imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findFirst: {
            args: Prisma.imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          findMany: {
            args: Prisma.imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>[]
          }
          create: {
            args: Prisma.imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          createMany: {
            args: Prisma.imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          update: {
            args: Prisma.imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          deleteMany: {
            args: Prisma.imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$imagesPayload>
          }
          aggregate: {
            args: Prisma.ImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImages>
          }
          groupBy: {
            args: Prisma.imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.imagesCountArgs<ExtArgs>
            result: $Utils.Optional<ImagesCountAggregateOutputType> | number
          }
        }
      }
      sectors: {
        payload: Prisma.$sectorsPayload<ExtArgs>
        fields: Prisma.sectorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sectorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sectorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>
          }
          findFirst: {
            args: Prisma.sectorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sectorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>
          }
          findMany: {
            args: Prisma.sectorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>[]
          }
          create: {
            args: Prisma.sectorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>
          }
          createMany: {
            args: Prisma.sectorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sectorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>
          }
          update: {
            args: Prisma.sectorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>
          }
          deleteMany: {
            args: Prisma.sectorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sectorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sectorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectorsPayload>
          }
          aggregate: {
            args: Prisma.SectorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectors>
          }
          groupBy: {
            args: Prisma.sectorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sectorsCountArgs<ExtArgs>
            result: $Utils.Optional<SectorsCountAggregateOutputType> | number
          }
        }
      }
      users_profile: {
        payload: Prisma.$users_profilePayload<ExtArgs>
        fields: Prisma.users_profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_profileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_profileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>
          }
          findFirst: {
            args: Prisma.users_profileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_profileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>
          }
          findMany: {
            args: Prisma.users_profileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>[]
          }
          create: {
            args: Prisma.users_profileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>
          }
          createMany: {
            args: Prisma.users_profileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users_profileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>
          }
          update: {
            args: Prisma.users_profileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>
          }
          deleteMany: {
            args: Prisma.users_profileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users_profileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users_profileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_profilePayload>
          }
          aggregate: {
            args: Prisma.Users_profileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_profile>
          }
          groupBy: {
            args: Prisma.users_profileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_profileGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_profileCountArgs<ExtArgs>
            result: $Utils.Optional<Users_profileCountAggregateOutputType> | number
          }
        }
      }
      reviews: {
        payload: Prisma.$reviewsPayload<ExtArgs>
        fields: Prisma.reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findFirst: {
            args: Prisma.reviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findMany: {
            args: Prisma.reviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          create: {
            args: Prisma.reviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          createMany: {
            args: Prisma.reviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          update: {
            args: Prisma.reviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          deleteMany: {
            args: Prisma.reviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.reviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      workingHour: {
        payload: Prisma.$workingHourPayload<ExtArgs>
        fields: Prisma.workingHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.workingHourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.workingHourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>
          }
          findFirst: {
            args: Prisma.workingHourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.workingHourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>
          }
          findMany: {
            args: Prisma.workingHourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>[]
          }
          create: {
            args: Prisma.workingHourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>
          }
          createMany: {
            args: Prisma.workingHourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.workingHourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>
          }
          update: {
            args: Prisma.workingHourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>
          }
          deleteMany: {
            args: Prisma.workingHourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.workingHourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.workingHourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workingHourPayload>
          }
          aggregate: {
            args: Prisma.WorkingHourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkingHour>
          }
          groupBy: {
            args: Prisma.workingHourGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkingHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.workingHourCountArgs<ExtArgs>
            result: $Utils.Optional<WorkingHourCountAggregateOutputType> | number
          }
        }
      }
      amenities: {
        payload: Prisma.$amenitiesPayload<ExtArgs>
        fields: Prisma.amenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.amenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.amenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>
          }
          findFirst: {
            args: Prisma.amenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.amenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>
          }
          findMany: {
            args: Prisma.amenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>[]
          }
          create: {
            args: Prisma.amenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>
          }
          createMany: {
            args: Prisma.amenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.amenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>
          }
          update: {
            args: Prisma.amenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>
          }
          deleteMany: {
            args: Prisma.amenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.amenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.amenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$amenitiesPayload>
          }
          aggregate: {
            args: Prisma.AmenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenities>
          }
          groupBy: {
            args: Prisma.amenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.amenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesCountAggregateOutputType> | number
          }
        }
      }
      business_amenities: {
        payload: Prisma.$business_amenitiesPayload<ExtArgs>
        fields: Prisma.business_amenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.business_amenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.business_amenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>
          }
          findFirst: {
            args: Prisma.business_amenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.business_amenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>
          }
          findMany: {
            args: Prisma.business_amenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>[]
          }
          create: {
            args: Prisma.business_amenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>
          }
          createMany: {
            args: Prisma.business_amenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.business_amenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>
          }
          update: {
            args: Prisma.business_amenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>
          }
          deleteMany: {
            args: Prisma.business_amenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.business_amenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.business_amenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_amenitiesPayload>
          }
          aggregate: {
            args: Prisma.Business_amenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness_amenities>
          }
          groupBy: {
            args: Prisma.business_amenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Business_amenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.business_amenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Business_amenitiesCountAggregateOutputType> | number
          }
        }
      }
      price_ranges: {
        payload: Prisma.$price_rangesPayload<ExtArgs>
        fields: Prisma.price_rangesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.price_rangesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.price_rangesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>
          }
          findFirst: {
            args: Prisma.price_rangesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.price_rangesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>
          }
          findMany: {
            args: Prisma.price_rangesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>[]
          }
          create: {
            args: Prisma.price_rangesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>
          }
          createMany: {
            args: Prisma.price_rangesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.price_rangesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>
          }
          update: {
            args: Prisma.price_rangesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>
          }
          deleteMany: {
            args: Prisma.price_rangesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.price_rangesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.price_rangesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$price_rangesPayload>
          }
          aggregate: {
            args: Prisma.Price_rangesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrice_ranges>
          }
          groupBy: {
            args: Prisma.price_rangesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Price_rangesGroupByOutputType>[]
          }
          count: {
            args: Prisma.price_rangesCountArgs<ExtArgs>
            result: $Utils.Optional<Price_rangesCountAggregateOutputType> | number
          }
        }
      }
      surveyAnswers: {
        payload: Prisma.$surveyAnswersPayload<ExtArgs>
        fields: Prisma.surveyAnswersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surveyAnswersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surveyAnswersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>
          }
          findFirst: {
            args: Prisma.surveyAnswersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surveyAnswersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>
          }
          findMany: {
            args: Prisma.surveyAnswersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>[]
          }
          create: {
            args: Prisma.surveyAnswersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>
          }
          createMany: {
            args: Prisma.surveyAnswersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.surveyAnswersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>
          }
          update: {
            args: Prisma.surveyAnswersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>
          }
          deleteMany: {
            args: Prisma.surveyAnswersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surveyAnswersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.surveyAnswersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyAnswersPayload>
          }
          aggregate: {
            args: Prisma.SurveyAnswersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyAnswers>
          }
          groupBy: {
            args: Prisma.surveyAnswersGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyAnswersGroupByOutputType>[]
          }
          count: {
            args: Prisma.surveyAnswersCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyAnswersCountAggregateOutputType> | number
          }
        }
      }
      surveyQuestions: {
        payload: Prisma.$surveyQuestionsPayload<ExtArgs>
        fields: Prisma.surveyQuestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surveyQuestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surveyQuestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>
          }
          findFirst: {
            args: Prisma.surveyQuestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surveyQuestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>
          }
          findMany: {
            args: Prisma.surveyQuestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>[]
          }
          create: {
            args: Prisma.surveyQuestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>
          }
          createMany: {
            args: Prisma.surveyQuestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.surveyQuestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>
          }
          update: {
            args: Prisma.surveyQuestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>
          }
          deleteMany: {
            args: Prisma.surveyQuestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surveyQuestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.surveyQuestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveyQuestionsPayload>
          }
          aggregate: {
            args: Prisma.SurveyQuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyQuestions>
          }
          groupBy: {
            args: Prisma.surveyQuestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.surveyQuestionsCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionsCountAggregateOutputType> | number
          }
        }
      }
      serviceReview: {
        payload: Prisma.$serviceReviewPayload<ExtArgs>
        fields: Prisma.serviceReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>
          }
          findFirst: {
            args: Prisma.serviceReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>
          }
          findMany: {
            args: Prisma.serviceReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>[]
          }
          create: {
            args: Prisma.serviceReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>
          }
          createMany: {
            args: Prisma.serviceReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serviceReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>
          }
          update: {
            args: Prisma.serviceReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>
          }
          deleteMany: {
            args: Prisma.serviceReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviceReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceReviewPayload>
          }
          aggregate: {
            args: Prisma.ServiceReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceReview>
          }
          groupBy: {
            args: Prisma.serviceReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceReviewCountAggregateOutputType> | number
          }
        }
      }
      category_search_terms: {
        payload: Prisma.$category_search_termsPayload<ExtArgs>
        fields: Prisma.category_search_termsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.category_search_termsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.category_search_termsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>
          }
          findFirst: {
            args: Prisma.category_search_termsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.category_search_termsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>
          }
          findMany: {
            args: Prisma.category_search_termsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>[]
          }
          create: {
            args: Prisma.category_search_termsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>
          }
          createMany: {
            args: Prisma.category_search_termsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.category_search_termsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>
          }
          update: {
            args: Prisma.category_search_termsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>
          }
          deleteMany: {
            args: Prisma.category_search_termsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.category_search_termsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.category_search_termsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_search_termsPayload>
          }
          aggregate: {
            args: Prisma.Category_search_termsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory_search_terms>
          }
          groupBy: {
            args: Prisma.category_search_termsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Category_search_termsGroupByOutputType>[]
          }
          count: {
            args: Prisma.category_search_termsCountArgs<ExtArgs>
            result: $Utils.Optional<Category_search_termsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    app_releases?: app_releasesOmit
    appointments?: appointmentsOmit
    apps?: appsOmit
    audit_trail?: audit_trailOmit
    categories?: categoriesOmit
    change_request?: change_requestOmit
    device?: deviceOmit
    device_heartbeat?: device_heartbeatOmit
    institution?: institutionOmit
    institution_invoices?: institution_invoicesOmit
    institution_service_tracking?: institution_service_trackingOmit
    login_history?: login_historyOmit
    migration?: migrationOmit
    mms_file?: mms_fileOmit
    notification?: notificationOmit
    notification_recipient?: notification_recipientOmit
    option?: optionOmit
    popup_questions?: popup_questionsOmit
    popup_questions_answers?: popup_questions_answersOmit
    popup_questions_possible_answers?: popup_questions_possible_answersOmit
    qms_branch_operator?: qms_branch_operatorOmit
    qms_branch_transactions?: qms_branch_transactionsOmit
    qms_counter?: qms_counterOmit
    qms_customer?: qms_customerOmit
    qms_operator?: qms_operatorOmit
    qms_operator_transactions?: qms_operator_transactionsOmit
    qms_queue?: qms_queueOmit
    qms_queue_operator_lnk?: qms_queue_operator_lnkOmit
    qms_ticket?: qms_ticketOmit
    qms_ticket_assignment?: qms_ticket_assignmentOmit
    rating?: ratingOmit
    rating_assets?: rating_assetsOmit
    rating_qr_code_sessions?: rating_qr_code_sessionsOmit
    rating_reply?: rating_replyOmit
    reports?: reportsOmit
    request_institution?: request_institutionOmit
    service?: serviceOmit
    service_group?: service_groupOmit
    survey?: surveyOmit
    survey_result?: survey_resultOmit
    tags?: tagsOmit
    tip?: tipOmit
    user?: userOmit
    wallet_accounts?: wallet_accountsOmit
    wallet_accounts_types?: wallet_accounts_typesOmit
    wallet_transfers?: wallet_transfersOmit
    wallet_users?: wallet_usersOmit
    images?: imagesOmit
    sectors?: sectorsOmit
    users_profile?: users_profileOmit
    reviews?: reviewsOmit
    workingHour?: workingHourOmit
    amenities?: amenitiesOmit
    business_amenities?: business_amenitiesOmit
    price_ranges?: price_rangesOmit
    surveyAnswers?: surveyAnswersOmit
    surveyQuestions?: surveyQuestionsOmit
    serviceReview?: serviceReviewOmit
    category_search_terms?: category_search_termsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    category_search_terms: number
    institution: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category_search_terms?: boolean | CategoriesCountOutputTypeCountCategory_search_termsArgs
    institution?: boolean | CategoriesCountOutputTypeCountInstitutionArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountCategory_search_termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_search_termsWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountInstitutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institutionWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    qms_customer: number
    rating: number
    tip: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_customer?: boolean | DeviceCountOutputTypeCountQms_customerArgs
    rating?: boolean | DeviceCountOutputTypeCountRatingArgs
    tip?: boolean | DeviceCountOutputTypeCountTipArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountQms_customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_customerWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipWhereInput
  }


  /**
   * Count Type InstitutionCountOutputType
   */

  export type InstitutionCountOutputType = {
    appointments: number
    apps: number
    business_amenities: number
    device: number
    images: number
    popup_questions: number
    price_ranges: number
    qms_branch_operator: number
    qms_branch_transactions: number
    qms_operator: number
    reviews: number
    service: number
    service_group: number
    workingHour: number
  }

  export type InstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | InstitutionCountOutputTypeCountAppointmentsArgs
    apps?: boolean | InstitutionCountOutputTypeCountAppsArgs
    business_amenities?: boolean | InstitutionCountOutputTypeCountBusiness_amenitiesArgs
    device?: boolean | InstitutionCountOutputTypeCountDeviceArgs
    images?: boolean | InstitutionCountOutputTypeCountImagesArgs
    popup_questions?: boolean | InstitutionCountOutputTypeCountPopup_questionsArgs
    price_ranges?: boolean | InstitutionCountOutputTypeCountPrice_rangesArgs
    qms_branch_operator?: boolean | InstitutionCountOutputTypeCountQms_branch_operatorArgs
    qms_branch_transactions?: boolean | InstitutionCountOutputTypeCountQms_branch_transactionsArgs
    qms_operator?: boolean | InstitutionCountOutputTypeCountQms_operatorArgs
    reviews?: boolean | InstitutionCountOutputTypeCountReviewsArgs
    service?: boolean | InstitutionCountOutputTypeCountServiceArgs
    service_group?: boolean | InstitutionCountOutputTypeCountService_groupArgs
    workingHour?: boolean | InstitutionCountOutputTypeCountWorkingHourArgs
  }

  // Custom InputTypes
  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionCountOutputType
     */
    select?: InstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appsWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountBusiness_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: business_amenitiesWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deviceWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountPopup_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: popup_questionsWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountPrice_rangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: price_rangesWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountQms_branch_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_branch_operatorWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountQms_branch_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_branch_transactionsWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountQms_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_operatorWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountService_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_groupWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountWorkingHourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workingHourWhereInput
  }


  /**
   * Count Type OptionCountOutputType
   */

  export type OptionCountOutputType = {
    qms_ticket: number
  }

  export type OptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_ticket?: boolean | OptionCountOutputTypeCountQms_ticketArgs
  }

  // Custom InputTypes
  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionCountOutputType
     */
    select?: OptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeCountQms_ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticketWhereInput
  }


  /**
   * Count Type Popup_questionsCountOutputType
   */

  export type Popup_questionsCountOutputType = {
    popup_questions_possible_answers: number
  }

  export type Popup_questionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    popup_questions_possible_answers?: boolean | Popup_questionsCountOutputTypeCountPopup_questions_possible_answersArgs
  }

  // Custom InputTypes
  /**
   * Popup_questionsCountOutputType without action
   */
  export type Popup_questionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Popup_questionsCountOutputType
     */
    select?: Popup_questionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Popup_questionsCountOutputType without action
   */
  export type Popup_questionsCountOutputTypeCountPopup_questions_possible_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: popup_questions_possible_answersWhereInput
  }


  /**
   * Count Type Popup_questions_possible_answersCountOutputType
   */

  export type Popup_questions_possible_answersCountOutputType = {
    popup_questions_answers: number
  }

  export type Popup_questions_possible_answersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    popup_questions_answers?: boolean | Popup_questions_possible_answersCountOutputTypeCountPopup_questions_answersArgs
  }

  // Custom InputTypes
  /**
   * Popup_questions_possible_answersCountOutputType without action
   */
  export type Popup_questions_possible_answersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Popup_questions_possible_answersCountOutputType
     */
    select?: Popup_questions_possible_answersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Popup_questions_possible_answersCountOutputType without action
   */
  export type Popup_questions_possible_answersCountOutputTypeCountPopup_questions_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: popup_questions_answersWhereInput
  }


  /**
   * Count Type Qms_branch_transactionsCountOutputType
   */

  export type Qms_branch_transactionsCountOutputType = {
    qms_operator_transactions: number
  }

  export type Qms_branch_transactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_operator_transactions?: boolean | Qms_branch_transactionsCountOutputTypeCountQms_operator_transactionsArgs
  }

  // Custom InputTypes
  /**
   * Qms_branch_transactionsCountOutputType without action
   */
  export type Qms_branch_transactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qms_branch_transactionsCountOutputType
     */
    select?: Qms_branch_transactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Qms_branch_transactionsCountOutputType without action
   */
  export type Qms_branch_transactionsCountOutputTypeCountQms_operator_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_operator_transactionsWhereInput
  }


  /**
   * Count Type Qms_customerCountOutputType
   */

  export type Qms_customerCountOutputType = {
    qms_ticket: number
  }

  export type Qms_customerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_ticket?: boolean | Qms_customerCountOutputTypeCountQms_ticketArgs
  }

  // Custom InputTypes
  /**
   * Qms_customerCountOutputType without action
   */
  export type Qms_customerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qms_customerCountOutputType
     */
    select?: Qms_customerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Qms_customerCountOutputType without action
   */
  export type Qms_customerCountOutputTypeCountQms_ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticketWhereInput
  }


  /**
   * Count Type Qms_operatorCountOutputType
   */

  export type Qms_operatorCountOutputType = {
    appointments: number
    qms_branch_operator: number
    qms_operator_transactions: number
    qms_queue_operator_lnk: number
    qms_ticket_assignment: number
  }

  export type Qms_operatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Qms_operatorCountOutputTypeCountAppointmentsArgs
    qms_branch_operator?: boolean | Qms_operatorCountOutputTypeCountQms_branch_operatorArgs
    qms_operator_transactions?: boolean | Qms_operatorCountOutputTypeCountQms_operator_transactionsArgs
    qms_queue_operator_lnk?: boolean | Qms_operatorCountOutputTypeCountQms_queue_operator_lnkArgs
    qms_ticket_assignment?: boolean | Qms_operatorCountOutputTypeCountQms_ticket_assignmentArgs
  }

  // Custom InputTypes
  /**
   * Qms_operatorCountOutputType without action
   */
  export type Qms_operatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qms_operatorCountOutputType
     */
    select?: Qms_operatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Qms_operatorCountOutputType without action
   */
  export type Qms_operatorCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * Qms_operatorCountOutputType without action
   */
  export type Qms_operatorCountOutputTypeCountQms_branch_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_branch_operatorWhereInput
  }

  /**
   * Qms_operatorCountOutputType without action
   */
  export type Qms_operatorCountOutputTypeCountQms_operator_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_operator_transactionsWhereInput
  }

  /**
   * Qms_operatorCountOutputType without action
   */
  export type Qms_operatorCountOutputTypeCountQms_queue_operator_lnkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_queue_operator_lnkWhereInput
  }

  /**
   * Qms_operatorCountOutputType without action
   */
  export type Qms_operatorCountOutputTypeCountQms_ticket_assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticket_assignmentWhereInput
  }


  /**
   * Count Type Qms_queueCountOutputType
   */

  export type Qms_queueCountOutputType = {
    qms_queue_operator_lnk: number
    qms_ticket: number
  }

  export type Qms_queueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_queue_operator_lnk?: boolean | Qms_queueCountOutputTypeCountQms_queue_operator_lnkArgs
    qms_ticket?: boolean | Qms_queueCountOutputTypeCountQms_ticketArgs
  }

  // Custom InputTypes
  /**
   * Qms_queueCountOutputType without action
   */
  export type Qms_queueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qms_queueCountOutputType
     */
    select?: Qms_queueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Qms_queueCountOutputType without action
   */
  export type Qms_queueCountOutputTypeCountQms_queue_operator_lnkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_queue_operator_lnkWhereInput
  }

  /**
   * Qms_queueCountOutputType without action
   */
  export type Qms_queueCountOutputTypeCountQms_ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticketWhereInput
  }


  /**
   * Count Type Qms_ticketCountOutputType
   */

  export type Qms_ticketCountOutputType = {
    qms_ticket_assignment: number
  }

  export type Qms_ticketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_ticket_assignment?: boolean | Qms_ticketCountOutputTypeCountQms_ticket_assignmentArgs
  }

  // Custom InputTypes
  /**
   * Qms_ticketCountOutputType without action
   */
  export type Qms_ticketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qms_ticketCountOutputType
     */
    select?: Qms_ticketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Qms_ticketCountOutputType without action
   */
  export type Qms_ticketCountOutputTypeCountQms_ticket_assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticket_assignmentWhereInput
  }


  /**
   * Count Type RatingCountOutputType
   */

  export type RatingCountOutputType = {
    rating_assets: number
    tip: number
  }

  export type RatingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rating_assets?: boolean | RatingCountOutputTypeCountRating_assetsArgs
    tip?: boolean | RatingCountOutputTypeCountTipArgs
  }

  // Custom InputTypes
  /**
   * RatingCountOutputType without action
   */
  export type RatingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatingCountOutputType
     */
    select?: RatingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RatingCountOutputType without action
   */
  export type RatingCountOutputTypeCountRating_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rating_assetsWhereInput
  }

  /**
   * RatingCountOutputType without action
   */
  export type RatingCountOutputTypeCountTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    appointments: number
    qms_counter: number
    qms_queue: number
    rating: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ServiceCountOutputTypeCountAppointmentsArgs
    qms_counter?: boolean | ServiceCountOutputTypeCountQms_counterArgs
    qms_queue?: boolean | ServiceCountOutputTypeCountQms_queueArgs
    rating?: boolean | ServiceCountOutputTypeCountRatingArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountQms_counterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_counterWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountQms_queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_queueWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
  }


  /**
   * Count Type Service_groupCountOutputType
   */

  export type Service_groupCountOutputType = {
    service: number
    serviceReview: number
    surveyQuestions: number
  }

  export type Service_groupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Service_groupCountOutputTypeCountServiceArgs
    serviceReview?: boolean | Service_groupCountOutputTypeCountServiceReviewArgs
    surveyQuestions?: boolean | Service_groupCountOutputTypeCountSurveyQuestionsArgs
  }

  // Custom InputTypes
  /**
   * Service_groupCountOutputType without action
   */
  export type Service_groupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service_groupCountOutputType
     */
    select?: Service_groupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Service_groupCountOutputType without action
   */
  export type Service_groupCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
  }

  /**
   * Service_groupCountOutputType without action
   */
  export type Service_groupCountOutputTypeCountServiceReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceReviewWhereInput
  }

  /**
   * Service_groupCountOutputType without action
   */
  export type Service_groupCountOutputTypeCountSurveyQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyQuestionsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    appointments_appointments_creator_idTouser: number
    appointments_appointments_user_idTouser: number
    tags_tags_created_byTouser: number
    tags_tags_updated_byTouser: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments_appointments_creator_idTouser?: boolean | UserCountOutputTypeCountAppointments_appointments_creator_idTouserArgs
    appointments_appointments_user_idTouser?: boolean | UserCountOutputTypeCountAppointments_appointments_user_idTouserArgs
    tags_tags_created_byTouser?: boolean | UserCountOutputTypeCountTags_tags_created_byTouserArgs
    tags_tags_updated_byTouser?: boolean | UserCountOutputTypeCountTags_tags_updated_byTouserArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointments_appointments_creator_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointments_appointments_user_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTags_tags_created_byTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTags_tags_updated_byTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
  }


  /**
   * Count Type SectorsCountOutputType
   */

  export type SectorsCountOutputType = {
    categories: number
  }

  export type SectorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | SectorsCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * SectorsCountOutputType without action
   */
  export type SectorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectorsCountOutputType
     */
    select?: SectorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectorsCountOutputType without action
   */
  export type SectorsCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }


  /**
   * Count Type Users_profileCountOutputType
   */

  export type Users_profileCountOutputType = {
    images: number
    reviews: number
    serviceReview: number
  }

  export type Users_profileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Users_profileCountOutputTypeCountImagesArgs
    reviews?: boolean | Users_profileCountOutputTypeCountReviewsArgs
    serviceReview?: boolean | Users_profileCountOutputTypeCountServiceReviewArgs
  }

  // Custom InputTypes
  /**
   * Users_profileCountOutputType without action
   */
  export type Users_profileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users_profileCountOutputType
     */
    select?: Users_profileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Users_profileCountOutputType without action
   */
  export type Users_profileCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }

  /**
   * Users_profileCountOutputType without action
   */
  export type Users_profileCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }

  /**
   * Users_profileCountOutputType without action
   */
  export type Users_profileCountOutputTypeCountServiceReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceReviewWhereInput
  }


  /**
   * Count Type ReviewsCountOutputType
   */

  export type ReviewsCountOutputType = {
    images: number
  }

  export type ReviewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ReviewsCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewsCountOutputType
     */
    select?: ReviewsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
  }


  /**
   * Count Type AmenitiesCountOutputType
   */

  export type AmenitiesCountOutputType = {
    business_amenities: number
  }

  export type AmenitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business_amenities?: boolean | AmenitiesCountOutputTypeCountBusiness_amenitiesArgs
  }

  // Custom InputTypes
  /**
   * AmenitiesCountOutputType without action
   */
  export type AmenitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenitiesCountOutputType
     */
    select?: AmenitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenitiesCountOutputType without action
   */
  export type AmenitiesCountOutputTypeCountBusiness_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: business_amenitiesWhereInput
  }


  /**
   * Count Type SurveyQuestionsCountOutputType
   */

  export type SurveyQuestionsCountOutputType = {
    surveyAnswers: number
  }

  export type SurveyQuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyAnswers?: boolean | SurveyQuestionsCountOutputTypeCountSurveyAnswersArgs
  }

  // Custom InputTypes
  /**
   * SurveyQuestionsCountOutputType without action
   */
  export type SurveyQuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionsCountOutputType
     */
    select?: SurveyQuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyQuestionsCountOutputType without action
   */
  export type SurveyQuestionsCountOutputTypeCountSurveyAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyAnswersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model app_releases
   */

  export type AggregateApp_releases = {
    _count: App_releasesCountAggregateOutputType | null
    _avg: App_releasesAvgAggregateOutputType | null
    _sum: App_releasesSumAggregateOutputType | null
    _min: App_releasesMinAggregateOutputType | null
    _max: App_releasesMaxAggregateOutputType | null
  }

  export type App_releasesAvgAggregateOutputType = {
    id: number | null
  }

  export type App_releasesSumAggregateOutputType = {
    id: number | null
  }

  export type App_releasesMinAggregateOutputType = {
    id: number | null
    release_version: string | null
    app_name: $Enums.app_releases_app_name | null
    platform: $Enums.app_releases_platform | null
    release_note: string | null
    release_url: string | null
    minimum_version: string | null
    added_at: Date | null
  }

  export type App_releasesMaxAggregateOutputType = {
    id: number | null
    release_version: string | null
    app_name: $Enums.app_releases_app_name | null
    platform: $Enums.app_releases_platform | null
    release_note: string | null
    release_url: string | null
    minimum_version: string | null
    added_at: Date | null
  }

  export type App_releasesCountAggregateOutputType = {
    id: number
    release_version: number
    app_name: number
    platform: number
    release_note: number
    release_url: number
    minimum_version: number
    added_at: number
    _all: number
  }


  export type App_releasesAvgAggregateInputType = {
    id?: true
  }

  export type App_releasesSumAggregateInputType = {
    id?: true
  }

  export type App_releasesMinAggregateInputType = {
    id?: true
    release_version?: true
    app_name?: true
    platform?: true
    release_note?: true
    release_url?: true
    minimum_version?: true
    added_at?: true
  }

  export type App_releasesMaxAggregateInputType = {
    id?: true
    release_version?: true
    app_name?: true
    platform?: true
    release_note?: true
    release_url?: true
    minimum_version?: true
    added_at?: true
  }

  export type App_releasesCountAggregateInputType = {
    id?: true
    release_version?: true
    app_name?: true
    platform?: true
    release_note?: true
    release_url?: true
    minimum_version?: true
    added_at?: true
    _all?: true
  }

  export type App_releasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_releases to aggregate.
     */
    where?: app_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_releases to fetch.
     */
    orderBy?: app_releasesOrderByWithRelationInput | app_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_releases
    **/
    _count?: true | App_releasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_releasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_releasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_releasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_releasesMaxAggregateInputType
  }

  export type GetApp_releasesAggregateType<T extends App_releasesAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_releases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_releases[P]>
      : GetScalarType<T[P], AggregateApp_releases[P]>
  }




  export type app_releasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_releasesWhereInput
    orderBy?: app_releasesOrderByWithAggregationInput | app_releasesOrderByWithAggregationInput[]
    by: App_releasesScalarFieldEnum[] | App_releasesScalarFieldEnum
    having?: app_releasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_releasesCountAggregateInputType | true
    _avg?: App_releasesAvgAggregateInputType
    _sum?: App_releasesSumAggregateInputType
    _min?: App_releasesMinAggregateInputType
    _max?: App_releasesMaxAggregateInputType
  }

  export type App_releasesGroupByOutputType = {
    id: number
    release_version: string
    app_name: $Enums.app_releases_app_name
    platform: $Enums.app_releases_platform
    release_note: string | null
    release_url: string
    minimum_version: string
    added_at: Date
    _count: App_releasesCountAggregateOutputType | null
    _avg: App_releasesAvgAggregateOutputType | null
    _sum: App_releasesSumAggregateOutputType | null
    _min: App_releasesMinAggregateOutputType | null
    _max: App_releasesMaxAggregateOutputType | null
  }

  type GetApp_releasesGroupByPayload<T extends app_releasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_releasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_releasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_releasesGroupByOutputType[P]>
            : GetScalarType<T[P], App_releasesGroupByOutputType[P]>
        }
      >
    >


  export type app_releasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    release_version?: boolean
    app_name?: boolean
    platform?: boolean
    release_note?: boolean
    release_url?: boolean
    minimum_version?: boolean
    added_at?: boolean
  }, ExtArgs["result"]["app_releases"]>



  export type app_releasesSelectScalar = {
    id?: boolean
    release_version?: boolean
    app_name?: boolean
    platform?: boolean
    release_note?: boolean
    release_url?: boolean
    minimum_version?: boolean
    added_at?: boolean
  }

  export type app_releasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "release_version" | "app_name" | "platform" | "release_note" | "release_url" | "minimum_version" | "added_at", ExtArgs["result"]["app_releases"]>

  export type $app_releasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_releases"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      release_version: string
      app_name: $Enums.app_releases_app_name
      platform: $Enums.app_releases_platform
      release_note: string | null
      release_url: string
      minimum_version: string
      added_at: Date
    }, ExtArgs["result"]["app_releases"]>
    composites: {}
  }

  type app_releasesGetPayload<S extends boolean | null | undefined | app_releasesDefaultArgs> = $Result.GetResult<Prisma.$app_releasesPayload, S>

  type app_releasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<app_releasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: App_releasesCountAggregateInputType | true
    }

  export interface app_releasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_releases'], meta: { name: 'app_releases' } }
    /**
     * Find zero or one App_releases that matches the filter.
     * @param {app_releasesFindUniqueArgs} args - Arguments to find a App_releases
     * @example
     * // Get one App_releases
     * const app_releases = await prisma.app_releases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_releasesFindUniqueArgs>(args: SelectSubset<T, app_releasesFindUniqueArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one App_releases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {app_releasesFindUniqueOrThrowArgs} args - Arguments to find a App_releases
     * @example
     * // Get one App_releases
     * const app_releases = await prisma.app_releases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_releasesFindUniqueOrThrowArgs>(args: SelectSubset<T, app_releasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App_releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_releasesFindFirstArgs} args - Arguments to find a App_releases
     * @example
     * // Get one App_releases
     * const app_releases = await prisma.app_releases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_releasesFindFirstArgs>(args?: SelectSubset<T, app_releasesFindFirstArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App_releases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_releasesFindFirstOrThrowArgs} args - Arguments to find a App_releases
     * @example
     * // Get one App_releases
     * const app_releases = await prisma.app_releases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_releasesFindFirstOrThrowArgs>(args?: SelectSubset<T, app_releasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more App_releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_releasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_releases
     * const app_releases = await prisma.app_releases.findMany()
     * 
     * // Get first 10 App_releases
     * const app_releases = await prisma.app_releases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_releasesWithIdOnly = await prisma.app_releases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_releasesFindManyArgs>(args?: SelectSubset<T, app_releasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a App_releases.
     * @param {app_releasesCreateArgs} args - Arguments to create a App_releases.
     * @example
     * // Create one App_releases
     * const App_releases = await prisma.app_releases.create({
     *   data: {
     *     // ... data to create a App_releases
     *   }
     * })
     * 
     */
    create<T extends app_releasesCreateArgs>(args: SelectSubset<T, app_releasesCreateArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many App_releases.
     * @param {app_releasesCreateManyArgs} args - Arguments to create many App_releases.
     * @example
     * // Create many App_releases
     * const app_releases = await prisma.app_releases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_releasesCreateManyArgs>(args?: SelectSubset<T, app_releasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a App_releases.
     * @param {app_releasesDeleteArgs} args - Arguments to delete one App_releases.
     * @example
     * // Delete one App_releases
     * const App_releases = await prisma.app_releases.delete({
     *   where: {
     *     // ... filter to delete one App_releases
     *   }
     * })
     * 
     */
    delete<T extends app_releasesDeleteArgs>(args: SelectSubset<T, app_releasesDeleteArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one App_releases.
     * @param {app_releasesUpdateArgs} args - Arguments to update one App_releases.
     * @example
     * // Update one App_releases
     * const app_releases = await prisma.app_releases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_releasesUpdateArgs>(args: SelectSubset<T, app_releasesUpdateArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more App_releases.
     * @param {app_releasesDeleteManyArgs} args - Arguments to filter App_releases to delete.
     * @example
     * // Delete a few App_releases
     * const { count } = await prisma.app_releases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_releasesDeleteManyArgs>(args?: SelectSubset<T, app_releasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_releasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_releases
     * const app_releases = await prisma.app_releases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_releasesUpdateManyArgs>(args: SelectSubset<T, app_releasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_releases.
     * @param {app_releasesUpsertArgs} args - Arguments to update or create a App_releases.
     * @example
     * // Update or create a App_releases
     * const app_releases = await prisma.app_releases.upsert({
     *   create: {
     *     // ... data to create a App_releases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_releases we want to update
     *   }
     * })
     */
    upsert<T extends app_releasesUpsertArgs>(args: SelectSubset<T, app_releasesUpsertArgs<ExtArgs>>): Prisma__app_releasesClient<$Result.GetResult<Prisma.$app_releasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of App_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_releasesCountArgs} args - Arguments to filter App_releases to count.
     * @example
     * // Count the number of App_releases
     * const count = await prisma.app_releases.count({
     *   where: {
     *     // ... the filter for the App_releases we want to count
     *   }
     * })
    **/
    count<T extends app_releasesCountArgs>(
      args?: Subset<T, app_releasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_releasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_releasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_releasesAggregateArgs>(args: Subset<T, App_releasesAggregateArgs>): Prisma.PrismaPromise<GetApp_releasesAggregateType<T>>

    /**
     * Group by App_releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_releasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_releasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_releasesGroupByArgs['orderBy'] }
        : { orderBy?: app_releasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_releasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_releasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_releases model
   */
  readonly fields: app_releasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_releases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_releasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_releases model
   */
  interface app_releasesFieldRefs {
    readonly id: FieldRef<"app_releases", 'Int'>
    readonly release_version: FieldRef<"app_releases", 'String'>
    readonly app_name: FieldRef<"app_releases", 'app_releases_app_name'>
    readonly platform: FieldRef<"app_releases", 'app_releases_platform'>
    readonly release_note: FieldRef<"app_releases", 'String'>
    readonly release_url: FieldRef<"app_releases", 'String'>
    readonly minimum_version: FieldRef<"app_releases", 'String'>
    readonly added_at: FieldRef<"app_releases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_releases findUnique
   */
  export type app_releasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * Filter, which app_releases to fetch.
     */
    where: app_releasesWhereUniqueInput
  }

  /**
   * app_releases findUniqueOrThrow
   */
  export type app_releasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * Filter, which app_releases to fetch.
     */
    where: app_releasesWhereUniqueInput
  }

  /**
   * app_releases findFirst
   */
  export type app_releasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * Filter, which app_releases to fetch.
     */
    where?: app_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_releases to fetch.
     */
    orderBy?: app_releasesOrderByWithRelationInput | app_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_releases.
     */
    cursor?: app_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_releases.
     */
    distinct?: App_releasesScalarFieldEnum | App_releasesScalarFieldEnum[]
  }

  /**
   * app_releases findFirstOrThrow
   */
  export type app_releasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * Filter, which app_releases to fetch.
     */
    where?: app_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_releases to fetch.
     */
    orderBy?: app_releasesOrderByWithRelationInput | app_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_releases.
     */
    cursor?: app_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_releases.
     */
    distinct?: App_releasesScalarFieldEnum | App_releasesScalarFieldEnum[]
  }

  /**
   * app_releases findMany
   */
  export type app_releasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * Filter, which app_releases to fetch.
     */
    where?: app_releasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_releases to fetch.
     */
    orderBy?: app_releasesOrderByWithRelationInput | app_releasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_releases.
     */
    cursor?: app_releasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_releases.
     */
    skip?: number
    distinct?: App_releasesScalarFieldEnum | App_releasesScalarFieldEnum[]
  }

  /**
   * app_releases create
   */
  export type app_releasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * The data needed to create a app_releases.
     */
    data: XOR<app_releasesCreateInput, app_releasesUncheckedCreateInput>
  }

  /**
   * app_releases createMany
   */
  export type app_releasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_releases.
     */
    data: app_releasesCreateManyInput | app_releasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_releases update
   */
  export type app_releasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * The data needed to update a app_releases.
     */
    data: XOR<app_releasesUpdateInput, app_releasesUncheckedUpdateInput>
    /**
     * Choose, which app_releases to update.
     */
    where: app_releasesWhereUniqueInput
  }

  /**
   * app_releases updateMany
   */
  export type app_releasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_releases.
     */
    data: XOR<app_releasesUpdateManyMutationInput, app_releasesUncheckedUpdateManyInput>
    /**
     * Filter which app_releases to update
     */
    where?: app_releasesWhereInput
    /**
     * Limit how many app_releases to update.
     */
    limit?: number
  }

  /**
   * app_releases upsert
   */
  export type app_releasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * The filter to search for the app_releases to update in case it exists.
     */
    where: app_releasesWhereUniqueInput
    /**
     * In case the app_releases found by the `where` argument doesn't exist, create a new app_releases with this data.
     */
    create: XOR<app_releasesCreateInput, app_releasesUncheckedCreateInput>
    /**
     * In case the app_releases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_releasesUpdateInput, app_releasesUncheckedUpdateInput>
  }

  /**
   * app_releases delete
   */
  export type app_releasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
    /**
     * Filter which app_releases to delete.
     */
    where: app_releasesWhereUniqueInput
  }

  /**
   * app_releases deleteMany
   */
  export type app_releasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_releases to delete
     */
    where?: app_releasesWhereInput
    /**
     * Limit how many app_releases to delete.
     */
    limit?: number
  }

  /**
   * app_releases without action
   */
  export type app_releasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_releases
     */
    select?: app_releasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_releases
     */
    omit?: app_releasesOmit<ExtArgs> | null
  }


  /**
   * Model appointments
   */

  export type AggregateAppointments = {
    _count: AppointmentsCountAggregateOutputType | null
    _avg: AppointmentsAvgAggregateOutputType | null
    _sum: AppointmentsSumAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  export type AppointmentsAvgAggregateOutputType = {
    id: number | null
    registry_type: number | null
    institution_id: number | null
    service_id: number | null
    operator_id: number | null
    user_id: number | null
    creator_id: number | null
    recurring: number | null
    notification_status: number | null
    ticket_created: number | null
    appointment_cancelled: number | null
  }

  export type AppointmentsSumAggregateOutputType = {
    id: number | null
    registry_type: number | null
    institution_id: number | null
    service_id: number | null
    operator_id: number | null
    user_id: number | null
    creator_id: number | null
    recurring: number | null
    notification_status: number | null
    ticket_created: number | null
    appointment_cancelled: number | null
  }

  export type AppointmentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    registry_type: number | null
    institution_id: number | null
    service_id: number | null
    operator_id: number | null
    user_id: number | null
    reason: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    location: string | null
    additional_note: string | null
    creator_id: number | null
    recurring: number | null
    notification_status: number | null
    ticket_created: number | null
    appointment_cancelled: number | null
    created_at: Date | null
    cancellation_reason: string | null
  }

  export type AppointmentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    registry_type: number | null
    institution_id: number | null
    service_id: number | null
    operator_id: number | null
    user_id: number | null
    reason: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    location: string | null
    additional_note: string | null
    creator_id: number | null
    recurring: number | null
    notification_status: number | null
    ticket_created: number | null
    appointment_cancelled: number | null
    created_at: Date | null
    cancellation_reason: string | null
  }

  export type AppointmentsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    registry_type: number
    institution_id: number
    service_id: number
    operator_id: number
    user_id: number
    reason: number
    date: number
    start_time: number
    end_time: number
    location: number
    additional_note: number
    creator_id: number
    recurring: number
    notification_status: number
    ticket_created: number
    appointment_cancelled: number
    created_at: number
    cancellation_reason: number
    _all: number
  }


  export type AppointmentsAvgAggregateInputType = {
    id?: true
    registry_type?: true
    institution_id?: true
    service_id?: true
    operator_id?: true
    user_id?: true
    creator_id?: true
    recurring?: true
    notification_status?: true
    ticket_created?: true
    appointment_cancelled?: true
  }

  export type AppointmentsSumAggregateInputType = {
    id?: true
    registry_type?: true
    institution_id?: true
    service_id?: true
    operator_id?: true
    user_id?: true
    creator_id?: true
    recurring?: true
    notification_status?: true
    ticket_created?: true
    appointment_cancelled?: true
  }

  export type AppointmentsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    registry_type?: true
    institution_id?: true
    service_id?: true
    operator_id?: true
    user_id?: true
    reason?: true
    date?: true
    start_time?: true
    end_time?: true
    location?: true
    additional_note?: true
    creator_id?: true
    recurring?: true
    notification_status?: true
    ticket_created?: true
    appointment_cancelled?: true
    created_at?: true
    cancellation_reason?: true
  }

  export type AppointmentsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    registry_type?: true
    institution_id?: true
    service_id?: true
    operator_id?: true
    user_id?: true
    reason?: true
    date?: true
    start_time?: true
    end_time?: true
    location?: true
    additional_note?: true
    creator_id?: true
    recurring?: true
    notification_status?: true
    ticket_created?: true
    appointment_cancelled?: true
    created_at?: true
    cancellation_reason?: true
  }

  export type AppointmentsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    registry_type?: true
    institution_id?: true
    service_id?: true
    operator_id?: true
    user_id?: true
    reason?: true
    date?: true
    start_time?: true
    end_time?: true
    location?: true
    additional_note?: true
    creator_id?: true
    recurring?: true
    notification_status?: true
    ticket_created?: true
    appointment_cancelled?: true
    created_at?: true
    cancellation_reason?: true
    _all?: true
  }

  export type AppointmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to aggregate.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointments
    **/
    _count?: true | AppointmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentsMaxAggregateInputType
  }

  export type GetAppointmentsAggregateType<T extends AppointmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointments[P]>
      : GetScalarType<T[P], AggregateAppointments[P]>
  }




  export type appointmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithAggregationInput | appointmentsOrderByWithAggregationInput[]
    by: AppointmentsScalarFieldEnum[] | AppointmentsScalarFieldEnum
    having?: appointmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentsCountAggregateInputType | true
    _avg?: AppointmentsAvgAggregateInputType
    _sum?: AppointmentsSumAggregateInputType
    _min?: AppointmentsMinAggregateInputType
    _max?: AppointmentsMaxAggregateInputType
  }

  export type AppointmentsGroupByOutputType = {
    id: number
    name: string | null
    email: string | null
    phone: string
    registry_type: number
    institution_id: number | null
    service_id: number | null
    operator_id: number | null
    user_id: number | null
    reason: string
    date: Date
    start_time: Date
    end_time: Date
    location: string
    additional_note: string
    creator_id: number
    recurring: number | null
    notification_status: number | null
    ticket_created: number | null
    appointment_cancelled: number | null
    created_at: Date | null
    cancellation_reason: string | null
    _count: AppointmentsCountAggregateOutputType | null
    _avg: AppointmentsAvgAggregateOutputType | null
    _sum: AppointmentsSumAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  type GetAppointmentsGroupByPayload<T extends appointmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
        }
      >
    >


  export type appointmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    registry_type?: boolean
    institution_id?: boolean
    service_id?: boolean
    operator_id?: boolean
    user_id?: boolean
    reason?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    location?: boolean
    additional_note?: boolean
    creator_id?: boolean
    recurring?: boolean
    notification_status?: boolean
    ticket_created?: boolean
    appointment_cancelled?: boolean
    created_at?: boolean
    cancellation_reason?: boolean
    user_appointments_creator_idTouser?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | appointments$institutionArgs<ExtArgs>
    qms_operator?: boolean | appointments$qms_operatorArgs<ExtArgs>
    service?: boolean | appointments$serviceArgs<ExtArgs>
    user_appointments_user_idTouser?: boolean | appointments$user_appointments_user_idTouserArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>



  export type appointmentsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    registry_type?: boolean
    institution_id?: boolean
    service_id?: boolean
    operator_id?: boolean
    user_id?: boolean
    reason?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    location?: boolean
    additional_note?: boolean
    creator_id?: boolean
    recurring?: boolean
    notification_status?: boolean
    ticket_created?: boolean
    appointment_cancelled?: boolean
    created_at?: boolean
    cancellation_reason?: boolean
  }

  export type appointmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "registry_type" | "institution_id" | "service_id" | "operator_id" | "user_id" | "reason" | "date" | "start_time" | "end_time" | "location" | "additional_note" | "creator_id" | "recurring" | "notification_status" | "ticket_created" | "appointment_cancelled" | "created_at" | "cancellation_reason", ExtArgs["result"]["appointments"]>
  export type appointmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_appointments_creator_idTouser?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | appointments$institutionArgs<ExtArgs>
    qms_operator?: boolean | appointments$qms_operatorArgs<ExtArgs>
    service?: boolean | appointments$serviceArgs<ExtArgs>
    user_appointments_user_idTouser?: boolean | appointments$user_appointments_user_idTouserArgs<ExtArgs>
  }

  export type $appointmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointments"
    objects: {
      user_appointments_creator_idTouser: Prisma.$userPayload<ExtArgs>
      institution: Prisma.$institutionPayload<ExtArgs> | null
      qms_operator: Prisma.$qms_operatorPayload<ExtArgs> | null
      service: Prisma.$servicePayload<ExtArgs> | null
      user_appointments_user_idTouser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      email: string | null
      phone: string
      registry_type: number
      institution_id: number | null
      service_id: number | null
      operator_id: number | null
      user_id: number | null
      reason: string
      date: Date
      start_time: Date
      end_time: Date
      location: string
      additional_note: string
      creator_id: number
      recurring: number | null
      notification_status: number | null
      ticket_created: number | null
      appointment_cancelled: number | null
      created_at: Date | null
      cancellation_reason: string | null
    }, ExtArgs["result"]["appointments"]>
    composites: {}
  }

  type appointmentsGetPayload<S extends boolean | null | undefined | appointmentsDefaultArgs> = $Result.GetResult<Prisma.$appointmentsPayload, S>

  type appointmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<appointmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentsCountAggregateInputType | true
    }

  export interface appointmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointments'], meta: { name: 'appointments' } }
    /**
     * Find zero or one Appointments that matches the filter.
     * @param {appointmentsFindUniqueArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appointmentsFindUniqueArgs>(args: SelectSubset<T, appointmentsFindUniqueArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {appointmentsFindUniqueOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appointmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, appointmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appointmentsFindFirstArgs>(args?: SelectSubset<T, appointmentsFindFirstArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appointmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, appointmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointments.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends appointmentsFindManyArgs>(args?: SelectSubset<T, appointmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointments.
     * @param {appointmentsCreateArgs} args - Arguments to create a Appointments.
     * @example
     * // Create one Appointments
     * const Appointments = await prisma.appointments.create({
     *   data: {
     *     // ... data to create a Appointments
     *   }
     * })
     * 
     */
    create<T extends appointmentsCreateArgs>(args: SelectSubset<T, appointmentsCreateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {appointmentsCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appointmentsCreateManyArgs>(args?: SelectSubset<T, appointmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointments.
     * @param {appointmentsDeleteArgs} args - Arguments to delete one Appointments.
     * @example
     * // Delete one Appointments
     * const Appointments = await prisma.appointments.delete({
     *   where: {
     *     // ... filter to delete one Appointments
     *   }
     * })
     * 
     */
    delete<T extends appointmentsDeleteArgs>(args: SelectSubset<T, appointmentsDeleteArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointments.
     * @param {appointmentsUpdateArgs} args - Arguments to update one Appointments.
     * @example
     * // Update one Appointments
     * const appointments = await prisma.appointments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appointmentsUpdateArgs>(args: SelectSubset<T, appointmentsUpdateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {appointmentsDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appointmentsDeleteManyArgs>(args?: SelectSubset<T, appointmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appointmentsUpdateManyArgs>(args: SelectSubset<T, appointmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointments.
     * @param {appointmentsUpsertArgs} args - Arguments to update or create a Appointments.
     * @example
     * // Update or create a Appointments
     * const appointments = await prisma.appointments.upsert({
     *   create: {
     *     // ... data to create a Appointments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointments we want to update
     *   }
     * })
     */
    upsert<T extends appointmentsUpsertArgs>(args: SelectSubset<T, appointmentsUpsertArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointments.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends appointmentsCountArgs>(
      args?: Subset<T, appointmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentsAggregateArgs>(args: Subset<T, AppointmentsAggregateArgs>): Prisma.PrismaPromise<GetAppointmentsAggregateType<T>>

    /**
     * Group by Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointmentsGroupByArgs['orderBy'] }
        : { orderBy?: appointmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointments model
   */
  readonly fields: appointmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_appointments_creator_idTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends appointments$institutionArgs<ExtArgs> = {}>(args?: Subset<T, appointments$institutionArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qms_operator<T extends appointments$qms_operatorArgs<ExtArgs> = {}>(args?: Subset<T, appointments$qms_operatorArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends appointments$serviceArgs<ExtArgs> = {}>(args?: Subset<T, appointments$serviceArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_appointments_user_idTouser<T extends appointments$user_appointments_user_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, appointments$user_appointments_user_idTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the appointments model
   */
  interface appointmentsFieldRefs {
    readonly id: FieldRef<"appointments", 'Int'>
    readonly name: FieldRef<"appointments", 'String'>
    readonly email: FieldRef<"appointments", 'String'>
    readonly phone: FieldRef<"appointments", 'String'>
    readonly registry_type: FieldRef<"appointments", 'Int'>
    readonly institution_id: FieldRef<"appointments", 'Int'>
    readonly service_id: FieldRef<"appointments", 'Int'>
    readonly operator_id: FieldRef<"appointments", 'Int'>
    readonly user_id: FieldRef<"appointments", 'Int'>
    readonly reason: FieldRef<"appointments", 'String'>
    readonly date: FieldRef<"appointments", 'DateTime'>
    readonly start_time: FieldRef<"appointments", 'DateTime'>
    readonly end_time: FieldRef<"appointments", 'DateTime'>
    readonly location: FieldRef<"appointments", 'String'>
    readonly additional_note: FieldRef<"appointments", 'String'>
    readonly creator_id: FieldRef<"appointments", 'Int'>
    readonly recurring: FieldRef<"appointments", 'Int'>
    readonly notification_status: FieldRef<"appointments", 'Int'>
    readonly ticket_created: FieldRef<"appointments", 'Int'>
    readonly appointment_cancelled: FieldRef<"appointments", 'Int'>
    readonly created_at: FieldRef<"appointments", 'DateTime'>
    readonly cancellation_reason: FieldRef<"appointments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * appointments findUnique
   */
  export type appointmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findUniqueOrThrow
   */
  export type appointmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findFirst
   */
  export type appointmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findFirstOrThrow
   */
  export type appointmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findMany
   */
  export type appointmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments create
   */
  export type appointmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a appointments.
     */
    data: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
  }

  /**
   * appointments createMany
   */
  export type appointmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointments update
   */
  export type appointmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a appointments.
     */
    data: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
    /**
     * Choose, which appointments to update.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments updateMany
   */
  export type appointmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
  }

  /**
   * appointments upsert
   */
  export type appointmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the appointments to update in case it exists.
     */
    where: appointmentsWhereUniqueInput
    /**
     * In case the appointments found by the `where` argument doesn't exist, create a new appointments with this data.
     */
    create: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
    /**
     * In case the appointments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
  }

  /**
   * appointments delete
   */
  export type appointmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter which appointments to delete.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments deleteMany
   */
  export type appointmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to delete
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to delete.
     */
    limit?: number
  }

  /**
   * appointments.institution
   */
  export type appointments$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
  }

  /**
   * appointments.qms_operator
   */
  export type appointments$qms_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    where?: qms_operatorWhereInput
  }

  /**
   * appointments.service
   */
  export type appointments$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
  }

  /**
   * appointments.user_appointments_user_idTouser
   */
  export type appointments$user_appointments_user_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * appointments without action
   */
  export type appointmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
  }


  /**
   * Model apps
   */

  export type AggregateApps = {
    _count: AppsCountAggregateOutputType | null
    _avg: AppsAvgAggregateOutputType | null
    _sum: AppsSumAggregateOutputType | null
    _min: AppsMinAggregateOutputType | null
    _max: AppsMaxAggregateOutputType | null
  }

  export type AppsAvgAggregateOutputType = {
    id: number | null
    status: number | null
    institution_id: number | null
  }

  export type AppsSumAggregateOutputType = {
    id: number | null
    status: number | null
    institution_id: number | null
  }

  export type AppsMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: number | null
    institution_id: number | null
    secret_key: string | null
    access_key: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AppsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: number | null
    institution_id: number | null
    secret_key: string | null
    access_key: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AppsCountAggregateOutputType = {
    id: number
    name: number
    status: number
    institution_id: number
    secret_key: number
    access_key: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AppsAvgAggregateInputType = {
    id?: true
    status?: true
    institution_id?: true
  }

  export type AppsSumAggregateInputType = {
    id?: true
    status?: true
    institution_id?: true
  }

  export type AppsMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    institution_id?: true
    secret_key?: true
    access_key?: true
    created_at?: true
    updated_at?: true
  }

  export type AppsMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    institution_id?: true
    secret_key?: true
    access_key?: true
    created_at?: true
    updated_at?: true
  }

  export type AppsCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    institution_id?: true
    secret_key?: true
    access_key?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AppsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apps to aggregate.
     */
    where?: appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apps to fetch.
     */
    orderBy?: appsOrderByWithRelationInput | appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apps
    **/
    _count?: true | AppsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppsMaxAggregateInputType
  }

  export type GetAppsAggregateType<T extends AppsAggregateArgs> = {
        [P in keyof T & keyof AggregateApps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApps[P]>
      : GetScalarType<T[P], AggregateApps[P]>
  }




  export type appsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appsWhereInput
    orderBy?: appsOrderByWithAggregationInput | appsOrderByWithAggregationInput[]
    by: AppsScalarFieldEnum[] | AppsScalarFieldEnum
    having?: appsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppsCountAggregateInputType | true
    _avg?: AppsAvgAggregateInputType
    _sum?: AppsSumAggregateInputType
    _min?: AppsMinAggregateInputType
    _max?: AppsMaxAggregateInputType
  }

  export type AppsGroupByOutputType = {
    id: number
    name: string
    status: number
    institution_id: number
    secret_key: string | null
    access_key: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: AppsCountAggregateOutputType | null
    _avg: AppsAvgAggregateOutputType | null
    _sum: AppsSumAggregateOutputType | null
    _min: AppsMinAggregateOutputType | null
    _max: AppsMaxAggregateOutputType | null
  }

  type GetAppsGroupByPayload<T extends appsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppsGroupByOutputType[P]>
            : GetScalarType<T[P], AppsGroupByOutputType[P]>
        }
      >
    >


  export type appsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    institution_id?: boolean
    secret_key?: boolean
    access_key?: boolean
    created_at?: boolean
    updated_at?: boolean
    institution?: boolean | institutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apps"]>



  export type appsSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    institution_id?: boolean
    secret_key?: boolean
    access_key?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type appsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "institution_id" | "secret_key" | "access_key" | "created_at" | "updated_at", ExtArgs["result"]["apps"]>
  export type appsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionDefaultArgs<ExtArgs>
  }

  export type $appsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apps"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      status: number
      institution_id: number
      secret_key: string | null
      access_key: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["apps"]>
    composites: {}
  }

  type appsGetPayload<S extends boolean | null | undefined | appsDefaultArgs> = $Result.GetResult<Prisma.$appsPayload, S>

  type appsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<appsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppsCountAggregateInputType | true
    }

  export interface appsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apps'], meta: { name: 'apps' } }
    /**
     * Find zero or one Apps that matches the filter.
     * @param {appsFindUniqueArgs} args - Arguments to find a Apps
     * @example
     * // Get one Apps
     * const apps = await prisma.apps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appsFindUniqueArgs>(args: SelectSubset<T, appsFindUniqueArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apps that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {appsFindUniqueOrThrowArgs} args - Arguments to find a Apps
     * @example
     * // Get one Apps
     * const apps = await prisma.apps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appsFindUniqueOrThrowArgs>(args: SelectSubset<T, appsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appsFindFirstArgs} args - Arguments to find a Apps
     * @example
     * // Get one Apps
     * const apps = await prisma.apps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appsFindFirstArgs>(args?: SelectSubset<T, appsFindFirstArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appsFindFirstOrThrowArgs} args - Arguments to find a Apps
     * @example
     * // Get one Apps
     * const apps = await prisma.apps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appsFindFirstOrThrowArgs>(args?: SelectSubset<T, appsFindFirstOrThrowArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apps
     * const apps = await prisma.apps.findMany()
     * 
     * // Get first 10 Apps
     * const apps = await prisma.apps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appsWithIdOnly = await prisma.apps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends appsFindManyArgs>(args?: SelectSubset<T, appsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apps.
     * @param {appsCreateArgs} args - Arguments to create a Apps.
     * @example
     * // Create one Apps
     * const Apps = await prisma.apps.create({
     *   data: {
     *     // ... data to create a Apps
     *   }
     * })
     * 
     */
    create<T extends appsCreateArgs>(args: SelectSubset<T, appsCreateArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apps.
     * @param {appsCreateManyArgs} args - Arguments to create many Apps.
     * @example
     * // Create many Apps
     * const apps = await prisma.apps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appsCreateManyArgs>(args?: SelectSubset<T, appsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apps.
     * @param {appsDeleteArgs} args - Arguments to delete one Apps.
     * @example
     * // Delete one Apps
     * const Apps = await prisma.apps.delete({
     *   where: {
     *     // ... filter to delete one Apps
     *   }
     * })
     * 
     */
    delete<T extends appsDeleteArgs>(args: SelectSubset<T, appsDeleteArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apps.
     * @param {appsUpdateArgs} args - Arguments to update one Apps.
     * @example
     * // Update one Apps
     * const apps = await prisma.apps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appsUpdateArgs>(args: SelectSubset<T, appsUpdateArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apps.
     * @param {appsDeleteManyArgs} args - Arguments to filter Apps to delete.
     * @example
     * // Delete a few Apps
     * const { count } = await prisma.apps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appsDeleteManyArgs>(args?: SelectSubset<T, appsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apps
     * const apps = await prisma.apps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appsUpdateManyArgs>(args: SelectSubset<T, appsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apps.
     * @param {appsUpsertArgs} args - Arguments to update or create a Apps.
     * @example
     * // Update or create a Apps
     * const apps = await prisma.apps.upsert({
     *   create: {
     *     // ... data to create a Apps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apps we want to update
     *   }
     * })
     */
    upsert<T extends appsUpsertArgs>(args: SelectSubset<T, appsUpsertArgs<ExtArgs>>): Prisma__appsClient<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appsCountArgs} args - Arguments to filter Apps to count.
     * @example
     * // Count the number of Apps
     * const count = await prisma.apps.count({
     *   where: {
     *     // ... the filter for the Apps we want to count
     *   }
     * })
    **/
    count<T extends appsCountArgs>(
      args?: Subset<T, appsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppsAggregateArgs>(args: Subset<T, AppsAggregateArgs>): Prisma.PrismaPromise<GetAppsAggregateType<T>>

    /**
     * Group by Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appsGroupByArgs['orderBy'] }
        : { orderBy?: appsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apps model
   */
  readonly fields: appsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apps model
   */
  interface appsFieldRefs {
    readonly id: FieldRef<"apps", 'Int'>
    readonly name: FieldRef<"apps", 'String'>
    readonly status: FieldRef<"apps", 'Int'>
    readonly institution_id: FieldRef<"apps", 'Int'>
    readonly secret_key: FieldRef<"apps", 'String'>
    readonly access_key: FieldRef<"apps", 'String'>
    readonly created_at: FieldRef<"apps", 'DateTime'>
    readonly updated_at: FieldRef<"apps", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * apps findUnique
   */
  export type appsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * Filter, which apps to fetch.
     */
    where: appsWhereUniqueInput
  }

  /**
   * apps findUniqueOrThrow
   */
  export type appsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * Filter, which apps to fetch.
     */
    where: appsWhereUniqueInput
  }

  /**
   * apps findFirst
   */
  export type appsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * Filter, which apps to fetch.
     */
    where?: appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apps to fetch.
     */
    orderBy?: appsOrderByWithRelationInput | appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apps.
     */
    cursor?: appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apps.
     */
    distinct?: AppsScalarFieldEnum | AppsScalarFieldEnum[]
  }

  /**
   * apps findFirstOrThrow
   */
  export type appsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * Filter, which apps to fetch.
     */
    where?: appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apps to fetch.
     */
    orderBy?: appsOrderByWithRelationInput | appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apps.
     */
    cursor?: appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apps.
     */
    distinct?: AppsScalarFieldEnum | AppsScalarFieldEnum[]
  }

  /**
   * apps findMany
   */
  export type appsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * Filter, which apps to fetch.
     */
    where?: appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apps to fetch.
     */
    orderBy?: appsOrderByWithRelationInput | appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apps.
     */
    cursor?: appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apps.
     */
    skip?: number
    distinct?: AppsScalarFieldEnum | AppsScalarFieldEnum[]
  }

  /**
   * apps create
   */
  export type appsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * The data needed to create a apps.
     */
    data: XOR<appsCreateInput, appsUncheckedCreateInput>
  }

  /**
   * apps createMany
   */
  export type appsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apps.
     */
    data: appsCreateManyInput | appsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apps update
   */
  export type appsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * The data needed to update a apps.
     */
    data: XOR<appsUpdateInput, appsUncheckedUpdateInput>
    /**
     * Choose, which apps to update.
     */
    where: appsWhereUniqueInput
  }

  /**
   * apps updateMany
   */
  export type appsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apps.
     */
    data: XOR<appsUpdateManyMutationInput, appsUncheckedUpdateManyInput>
    /**
     * Filter which apps to update
     */
    where?: appsWhereInput
    /**
     * Limit how many apps to update.
     */
    limit?: number
  }

  /**
   * apps upsert
   */
  export type appsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * The filter to search for the apps to update in case it exists.
     */
    where: appsWhereUniqueInput
    /**
     * In case the apps found by the `where` argument doesn't exist, create a new apps with this data.
     */
    create: XOR<appsCreateInput, appsUncheckedCreateInput>
    /**
     * In case the apps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appsUpdateInput, appsUncheckedUpdateInput>
  }

  /**
   * apps delete
   */
  export type appsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    /**
     * Filter which apps to delete.
     */
    where: appsWhereUniqueInput
  }

  /**
   * apps deleteMany
   */
  export type appsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apps to delete
     */
    where?: appsWhereInput
    /**
     * Limit how many apps to delete.
     */
    limit?: number
  }

  /**
   * apps without action
   */
  export type appsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
  }


  /**
   * Model audit_trail
   */

  export type AggregateAudit_trail = {
    _count: Audit_trailCountAggregateOutputType | null
    _avg: Audit_trailAvgAggregateOutputType | null
    _sum: Audit_trailSumAggregateOutputType | null
    _min: Audit_trailMinAggregateOutputType | null
    _max: Audit_trailMaxAggregateOutputType | null
  }

  export type Audit_trailAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    reviewed_by: number | null
  }

  export type Audit_trailSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    reviewed_by: number | null
  }

  export type Audit_trailMinAggregateOutputType = {
    id: number | null
    old_value: string | null
    new_value: string | null
    action: string | null
    model: string | null
    field: string | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    model_id: string | null
    display_name: string | null
    time: Date | null
    status: $Enums.audit_trail_status | null
    reviewed_by: number | null
  }

  export type Audit_trailMaxAggregateOutputType = {
    id: number | null
    old_value: string | null
    new_value: string | null
    action: string | null
    model: string | null
    field: string | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    model_id: string | null
    display_name: string | null
    time: Date | null
    status: $Enums.audit_trail_status | null
    reviewed_by: number | null
  }

  export type Audit_trailCountAggregateOutputType = {
    id: number
    old_value: number
    new_value: number
    action: number
    model: number
    field: number
    user_id: number
    ip: number
    user_agent: number
    model_id: number
    display_name: number
    time: number
    status: number
    reviewed_by: number
    _all: number
  }


  export type Audit_trailAvgAggregateInputType = {
    id?: true
    user_id?: true
    reviewed_by?: true
  }

  export type Audit_trailSumAggregateInputType = {
    id?: true
    user_id?: true
    reviewed_by?: true
  }

  export type Audit_trailMinAggregateInputType = {
    id?: true
    old_value?: true
    new_value?: true
    action?: true
    model?: true
    field?: true
    user_id?: true
    ip?: true
    user_agent?: true
    model_id?: true
    display_name?: true
    time?: true
    status?: true
    reviewed_by?: true
  }

  export type Audit_trailMaxAggregateInputType = {
    id?: true
    old_value?: true
    new_value?: true
    action?: true
    model?: true
    field?: true
    user_id?: true
    ip?: true
    user_agent?: true
    model_id?: true
    display_name?: true
    time?: true
    status?: true
    reviewed_by?: true
  }

  export type Audit_trailCountAggregateInputType = {
    id?: true
    old_value?: true
    new_value?: true
    action?: true
    model?: true
    field?: true
    user_id?: true
    ip?: true
    user_agent?: true
    model_id?: true
    display_name?: true
    time?: true
    status?: true
    reviewed_by?: true
    _all?: true
  }

  export type Audit_trailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_trail to aggregate.
     */
    where?: audit_trailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_trails to fetch.
     */
    orderBy?: audit_trailOrderByWithRelationInput | audit_trailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_trailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_trails
    **/
    _count?: true | Audit_trailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audit_trailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audit_trailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_trailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_trailMaxAggregateInputType
  }

  export type GetAudit_trailAggregateType<T extends Audit_trailAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_trail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_trail[P]>
      : GetScalarType<T[P], AggregateAudit_trail[P]>
  }




  export type audit_trailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_trailWhereInput
    orderBy?: audit_trailOrderByWithAggregationInput | audit_trailOrderByWithAggregationInput[]
    by: Audit_trailScalarFieldEnum[] | Audit_trailScalarFieldEnum
    having?: audit_trailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_trailCountAggregateInputType | true
    _avg?: Audit_trailAvgAggregateInputType
    _sum?: Audit_trailSumAggregateInputType
    _min?: Audit_trailMinAggregateInputType
    _max?: Audit_trailMaxAggregateInputType
  }

  export type Audit_trailGroupByOutputType = {
    id: number
    old_value: string | null
    new_value: string | null
    action: string
    model: string
    field: string | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    model_id: string
    display_name: string | null
    time: Date
    status: $Enums.audit_trail_status | null
    reviewed_by: number | null
    _count: Audit_trailCountAggregateOutputType | null
    _avg: Audit_trailAvgAggregateOutputType | null
    _sum: Audit_trailSumAggregateOutputType | null
    _min: Audit_trailMinAggregateOutputType | null
    _max: Audit_trailMaxAggregateOutputType | null
  }

  type GetAudit_trailGroupByPayload<T extends audit_trailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_trailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_trailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_trailGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_trailGroupByOutputType[P]>
        }
      >
    >


  export type audit_trailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    old_value?: boolean
    new_value?: boolean
    action?: boolean
    model?: boolean
    field?: boolean
    user_id?: boolean
    ip?: boolean
    user_agent?: boolean
    model_id?: boolean
    display_name?: boolean
    time?: boolean
    status?: boolean
    reviewed_by?: boolean
  }, ExtArgs["result"]["audit_trail"]>



  export type audit_trailSelectScalar = {
    id?: boolean
    old_value?: boolean
    new_value?: boolean
    action?: boolean
    model?: boolean
    field?: boolean
    user_id?: boolean
    ip?: boolean
    user_agent?: boolean
    model_id?: boolean
    display_name?: boolean
    time?: boolean
    status?: boolean
    reviewed_by?: boolean
  }

  export type audit_trailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "old_value" | "new_value" | "action" | "model" | "field" | "user_id" | "ip" | "user_agent" | "model_id" | "display_name" | "time" | "status" | "reviewed_by", ExtArgs["result"]["audit_trail"]>

  export type $audit_trailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_trail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      old_value: string | null
      new_value: string | null
      action: string
      model: string
      field: string | null
      user_id: number | null
      ip: string | null
      user_agent: string | null
      model_id: string
      display_name: string | null
      time: Date
      status: $Enums.audit_trail_status | null
      reviewed_by: number | null
    }, ExtArgs["result"]["audit_trail"]>
    composites: {}
  }

  type audit_trailGetPayload<S extends boolean | null | undefined | audit_trailDefaultArgs> = $Result.GetResult<Prisma.$audit_trailPayload, S>

  type audit_trailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_trailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_trailCountAggregateInputType | true
    }

  export interface audit_trailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_trail'], meta: { name: 'audit_trail' } }
    /**
     * Find zero or one Audit_trail that matches the filter.
     * @param {audit_trailFindUniqueArgs} args - Arguments to find a Audit_trail
     * @example
     * // Get one Audit_trail
     * const audit_trail = await prisma.audit_trail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_trailFindUniqueArgs>(args: SelectSubset<T, audit_trailFindUniqueArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_trail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_trailFindUniqueOrThrowArgs} args - Arguments to find a Audit_trail
     * @example
     * // Get one Audit_trail
     * const audit_trail = await prisma.audit_trail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_trailFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_trailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_trail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_trailFindFirstArgs} args - Arguments to find a Audit_trail
     * @example
     * // Get one Audit_trail
     * const audit_trail = await prisma.audit_trail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_trailFindFirstArgs>(args?: SelectSubset<T, audit_trailFindFirstArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_trail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_trailFindFirstOrThrowArgs} args - Arguments to find a Audit_trail
     * @example
     * // Get one Audit_trail
     * const audit_trail = await prisma.audit_trail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_trailFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_trailFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_trails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_trailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_trails
     * const audit_trails = await prisma.audit_trail.findMany()
     * 
     * // Get first 10 Audit_trails
     * const audit_trails = await prisma.audit_trail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_trailWithIdOnly = await prisma.audit_trail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_trailFindManyArgs>(args?: SelectSubset<T, audit_trailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_trail.
     * @param {audit_trailCreateArgs} args - Arguments to create a Audit_trail.
     * @example
     * // Create one Audit_trail
     * const Audit_trail = await prisma.audit_trail.create({
     *   data: {
     *     // ... data to create a Audit_trail
     *   }
     * })
     * 
     */
    create<T extends audit_trailCreateArgs>(args: SelectSubset<T, audit_trailCreateArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_trails.
     * @param {audit_trailCreateManyArgs} args - Arguments to create many Audit_trails.
     * @example
     * // Create many Audit_trails
     * const audit_trail = await prisma.audit_trail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_trailCreateManyArgs>(args?: SelectSubset<T, audit_trailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audit_trail.
     * @param {audit_trailDeleteArgs} args - Arguments to delete one Audit_trail.
     * @example
     * // Delete one Audit_trail
     * const Audit_trail = await prisma.audit_trail.delete({
     *   where: {
     *     // ... filter to delete one Audit_trail
     *   }
     * })
     * 
     */
    delete<T extends audit_trailDeleteArgs>(args: SelectSubset<T, audit_trailDeleteArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_trail.
     * @param {audit_trailUpdateArgs} args - Arguments to update one Audit_trail.
     * @example
     * // Update one Audit_trail
     * const audit_trail = await prisma.audit_trail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_trailUpdateArgs>(args: SelectSubset<T, audit_trailUpdateArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_trails.
     * @param {audit_trailDeleteManyArgs} args - Arguments to filter Audit_trails to delete.
     * @example
     * // Delete a few Audit_trails
     * const { count } = await prisma.audit_trail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_trailDeleteManyArgs>(args?: SelectSubset<T, audit_trailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_trails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_trailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_trails
     * const audit_trail = await prisma.audit_trail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_trailUpdateManyArgs>(args: SelectSubset<T, audit_trailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audit_trail.
     * @param {audit_trailUpsertArgs} args - Arguments to update or create a Audit_trail.
     * @example
     * // Update or create a Audit_trail
     * const audit_trail = await prisma.audit_trail.upsert({
     *   create: {
     *     // ... data to create a Audit_trail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_trail we want to update
     *   }
     * })
     */
    upsert<T extends audit_trailUpsertArgs>(args: SelectSubset<T, audit_trailUpsertArgs<ExtArgs>>): Prisma__audit_trailClient<$Result.GetResult<Prisma.$audit_trailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_trails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_trailCountArgs} args - Arguments to filter Audit_trails to count.
     * @example
     * // Count the number of Audit_trails
     * const count = await prisma.audit_trail.count({
     *   where: {
     *     // ... the filter for the Audit_trails we want to count
     *   }
     * })
    **/
    count<T extends audit_trailCountArgs>(
      args?: Subset<T, audit_trailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_trailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_trail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_trailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_trailAggregateArgs>(args: Subset<T, Audit_trailAggregateArgs>): Prisma.PrismaPromise<GetAudit_trailAggregateType<T>>

    /**
     * Group by Audit_trail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_trailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_trailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_trailGroupByArgs['orderBy'] }
        : { orderBy?: audit_trailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_trailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_trailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_trail model
   */
  readonly fields: audit_trailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_trail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_trailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_trail model
   */
  interface audit_trailFieldRefs {
    readonly id: FieldRef<"audit_trail", 'Int'>
    readonly old_value: FieldRef<"audit_trail", 'String'>
    readonly new_value: FieldRef<"audit_trail", 'String'>
    readonly action: FieldRef<"audit_trail", 'String'>
    readonly model: FieldRef<"audit_trail", 'String'>
    readonly field: FieldRef<"audit_trail", 'String'>
    readonly user_id: FieldRef<"audit_trail", 'Int'>
    readonly ip: FieldRef<"audit_trail", 'String'>
    readonly user_agent: FieldRef<"audit_trail", 'String'>
    readonly model_id: FieldRef<"audit_trail", 'String'>
    readonly display_name: FieldRef<"audit_trail", 'String'>
    readonly time: FieldRef<"audit_trail", 'DateTime'>
    readonly status: FieldRef<"audit_trail", 'audit_trail_status'>
    readonly reviewed_by: FieldRef<"audit_trail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * audit_trail findUnique
   */
  export type audit_trailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * Filter, which audit_trail to fetch.
     */
    where: audit_trailWhereUniqueInput
  }

  /**
   * audit_trail findUniqueOrThrow
   */
  export type audit_trailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * Filter, which audit_trail to fetch.
     */
    where: audit_trailWhereUniqueInput
  }

  /**
   * audit_trail findFirst
   */
  export type audit_trailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * Filter, which audit_trail to fetch.
     */
    where?: audit_trailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_trails to fetch.
     */
    orderBy?: audit_trailOrderByWithRelationInput | audit_trailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_trails.
     */
    cursor?: audit_trailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_trails.
     */
    distinct?: Audit_trailScalarFieldEnum | Audit_trailScalarFieldEnum[]
  }

  /**
   * audit_trail findFirstOrThrow
   */
  export type audit_trailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * Filter, which audit_trail to fetch.
     */
    where?: audit_trailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_trails to fetch.
     */
    orderBy?: audit_trailOrderByWithRelationInput | audit_trailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_trails.
     */
    cursor?: audit_trailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_trails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_trails.
     */
    distinct?: Audit_trailScalarFieldEnum | Audit_trailScalarFieldEnum[]
  }

  /**
   * audit_trail findMany
   */
  export type audit_trailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * Filter, which audit_trails to fetch.
     */
    where?: audit_trailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_trails to fetch.
     */
    orderBy?: audit_trailOrderByWithRelationInput | audit_trailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_trails.
     */
    cursor?: audit_trailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_trails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_trails.
     */
    skip?: number
    distinct?: Audit_trailScalarFieldEnum | Audit_trailScalarFieldEnum[]
  }

  /**
   * audit_trail create
   */
  export type audit_trailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * The data needed to create a audit_trail.
     */
    data: XOR<audit_trailCreateInput, audit_trailUncheckedCreateInput>
  }

  /**
   * audit_trail createMany
   */
  export type audit_trailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_trails.
     */
    data: audit_trailCreateManyInput | audit_trailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_trail update
   */
  export type audit_trailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * The data needed to update a audit_trail.
     */
    data: XOR<audit_trailUpdateInput, audit_trailUncheckedUpdateInput>
    /**
     * Choose, which audit_trail to update.
     */
    where: audit_trailWhereUniqueInput
  }

  /**
   * audit_trail updateMany
   */
  export type audit_trailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_trails.
     */
    data: XOR<audit_trailUpdateManyMutationInput, audit_trailUncheckedUpdateManyInput>
    /**
     * Filter which audit_trails to update
     */
    where?: audit_trailWhereInput
    /**
     * Limit how many audit_trails to update.
     */
    limit?: number
  }

  /**
   * audit_trail upsert
   */
  export type audit_trailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * The filter to search for the audit_trail to update in case it exists.
     */
    where: audit_trailWhereUniqueInput
    /**
     * In case the audit_trail found by the `where` argument doesn't exist, create a new audit_trail with this data.
     */
    create: XOR<audit_trailCreateInput, audit_trailUncheckedCreateInput>
    /**
     * In case the audit_trail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_trailUpdateInput, audit_trailUncheckedUpdateInput>
  }

  /**
   * audit_trail delete
   */
  export type audit_trailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
    /**
     * Filter which audit_trail to delete.
     */
    where: audit_trailWhereUniqueInput
  }

  /**
   * audit_trail deleteMany
   */
  export type audit_trailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_trails to delete
     */
    where?: audit_trailWhereInput
    /**
     * Limit how many audit_trails to delete.
     */
    limit?: number
  }

  /**
   * audit_trail without action
   */
  export type audit_trailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_trail
     */
    select?: audit_trailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_trail
     */
    omit?: audit_trailOmit<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
    sector_id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
    sector_id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    sector_id: number | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    sector_id: number | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    sector_id: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
    sector_id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
    sector_id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    sector_id?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    sector_id?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    sector_id?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: number
    name: string
    sector_id: number | null
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sector_id?: boolean
    sectors?: boolean | categories$sectorsArgs<ExtArgs>
    category_search_terms?: boolean | categories$category_search_termsArgs<ExtArgs>
    institution?: boolean | categories$institutionArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>



  export type categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    sector_id?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sector_id", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sectors?: boolean | categories$sectorsArgs<ExtArgs>
    category_search_terms?: boolean | categories$category_search_termsArgs<ExtArgs>
    institution?: boolean | categories$institutionArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      sectors: Prisma.$sectorsPayload<ExtArgs> | null
      category_search_terms: Prisma.$category_search_termsPayload<ExtArgs>[]
      institution: Prisma.$institutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      sector_id: number | null
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sectors<T extends categories$sectorsArgs<ExtArgs> = {}>(args?: Subset<T, categories$sectorsArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category_search_terms<T extends categories$category_search_termsArgs<ExtArgs> = {}>(args?: Subset<T, categories$category_search_termsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institution<T extends categories$institutionArgs<ExtArgs> = {}>(args?: Subset<T, categories$institutionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'Int'>
    readonly name: FieldRef<"categories", 'String'>
    readonly sector_id: FieldRef<"categories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.sectors
   */
  export type categories$sectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    where?: sectorsWhereInput
  }

  /**
   * categories.category_search_terms
   */
  export type categories$category_search_termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    where?: category_search_termsWhereInput
    orderBy?: category_search_termsOrderByWithRelationInput | category_search_termsOrderByWithRelationInput[]
    cursor?: category_search_termsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Category_search_termsScalarFieldEnum | Category_search_termsScalarFieldEnum[]
  }

  /**
   * categories.institution
   */
  export type categories$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
    orderBy?: institutionOrderByWithRelationInput | institutionOrderByWithRelationInput[]
    cursor?: institutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model change_request
   */

  export type AggregateChange_request = {
    _count: Change_requestCountAggregateOutputType | null
    _avg: Change_requestAvgAggregateOutputType | null
    _sum: Change_requestSumAggregateOutputType | null
    _min: Change_requestMinAggregateOutputType | null
    _max: Change_requestMaxAggregateOutputType | null
  }

  export type Change_requestAvgAggregateOutputType = {
    id: number | null
    model_id: number | null
    user_id: number | null
    reviewed_by: number | null
    institution_id: number | null
  }

  export type Change_requestSumAggregateOutputType = {
    id: number | null
    model_id: number | null
    user_id: number | null
    reviewed_by: number | null
    institution_id: number | null
  }

  export type Change_requestMinAggregateOutputType = {
    id: number | null
    old_value: string | null
    new_value: string | null
    action: string | null
    model: string | null
    model_id: number | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    display_name: string | null
    status: boolean | null
    reviewed_by: number | null
    time: Date | null
    institution_id: number | null
  }

  export type Change_requestMaxAggregateOutputType = {
    id: number | null
    old_value: string | null
    new_value: string | null
    action: string | null
    model: string | null
    model_id: number | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    display_name: string | null
    status: boolean | null
    reviewed_by: number | null
    time: Date | null
    institution_id: number | null
  }

  export type Change_requestCountAggregateOutputType = {
    id: number
    old_value: number
    new_value: number
    action: number
    model: number
    model_id: number
    user_id: number
    ip: number
    user_agent: number
    display_name: number
    status: number
    reviewed_by: number
    time: number
    institution_id: number
    _all: number
  }


  export type Change_requestAvgAggregateInputType = {
    id?: true
    model_id?: true
    user_id?: true
    reviewed_by?: true
    institution_id?: true
  }

  export type Change_requestSumAggregateInputType = {
    id?: true
    model_id?: true
    user_id?: true
    reviewed_by?: true
    institution_id?: true
  }

  export type Change_requestMinAggregateInputType = {
    id?: true
    old_value?: true
    new_value?: true
    action?: true
    model?: true
    model_id?: true
    user_id?: true
    ip?: true
    user_agent?: true
    display_name?: true
    status?: true
    reviewed_by?: true
    time?: true
    institution_id?: true
  }

  export type Change_requestMaxAggregateInputType = {
    id?: true
    old_value?: true
    new_value?: true
    action?: true
    model?: true
    model_id?: true
    user_id?: true
    ip?: true
    user_agent?: true
    display_name?: true
    status?: true
    reviewed_by?: true
    time?: true
    institution_id?: true
  }

  export type Change_requestCountAggregateInputType = {
    id?: true
    old_value?: true
    new_value?: true
    action?: true
    model?: true
    model_id?: true
    user_id?: true
    ip?: true
    user_agent?: true
    display_name?: true
    status?: true
    reviewed_by?: true
    time?: true
    institution_id?: true
    _all?: true
  }

  export type Change_requestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which change_request to aggregate.
     */
    where?: change_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of change_requests to fetch.
     */
    orderBy?: change_requestOrderByWithRelationInput | change_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: change_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` change_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` change_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned change_requests
    **/
    _count?: true | Change_requestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Change_requestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Change_requestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Change_requestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Change_requestMaxAggregateInputType
  }

  export type GetChange_requestAggregateType<T extends Change_requestAggregateArgs> = {
        [P in keyof T & keyof AggregateChange_request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChange_request[P]>
      : GetScalarType<T[P], AggregateChange_request[P]>
  }




  export type change_requestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: change_requestWhereInput
    orderBy?: change_requestOrderByWithAggregationInput | change_requestOrderByWithAggregationInput[]
    by: Change_requestScalarFieldEnum[] | Change_requestScalarFieldEnum
    having?: change_requestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Change_requestCountAggregateInputType | true
    _avg?: Change_requestAvgAggregateInputType
    _sum?: Change_requestSumAggregateInputType
    _min?: Change_requestMinAggregateInputType
    _max?: Change_requestMaxAggregateInputType
  }

  export type Change_requestGroupByOutputType = {
    id: number
    old_value: string | null
    new_value: string | null
    action: string
    model: string
    model_id: number | null
    user_id: number
    ip: string | null
    user_agent: string | null
    display_name: string | null
    status: boolean | null
    reviewed_by: number | null
    time: Date
    institution_id: number | null
    _count: Change_requestCountAggregateOutputType | null
    _avg: Change_requestAvgAggregateOutputType | null
    _sum: Change_requestSumAggregateOutputType | null
    _min: Change_requestMinAggregateOutputType | null
    _max: Change_requestMaxAggregateOutputType | null
  }

  type GetChange_requestGroupByPayload<T extends change_requestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Change_requestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Change_requestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Change_requestGroupByOutputType[P]>
            : GetScalarType<T[P], Change_requestGroupByOutputType[P]>
        }
      >
    >


  export type change_requestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    old_value?: boolean
    new_value?: boolean
    action?: boolean
    model?: boolean
    model_id?: boolean
    user_id?: boolean
    ip?: boolean
    user_agent?: boolean
    display_name?: boolean
    status?: boolean
    reviewed_by?: boolean
    time?: boolean
    institution_id?: boolean
  }, ExtArgs["result"]["change_request"]>



  export type change_requestSelectScalar = {
    id?: boolean
    old_value?: boolean
    new_value?: boolean
    action?: boolean
    model?: boolean
    model_id?: boolean
    user_id?: boolean
    ip?: boolean
    user_agent?: boolean
    display_name?: boolean
    status?: boolean
    reviewed_by?: boolean
    time?: boolean
    institution_id?: boolean
  }

  export type change_requestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "old_value" | "new_value" | "action" | "model" | "model_id" | "user_id" | "ip" | "user_agent" | "display_name" | "status" | "reviewed_by" | "time" | "institution_id", ExtArgs["result"]["change_request"]>

  export type $change_requestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "change_request"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      old_value: string | null
      new_value: string | null
      action: string
      model: string
      model_id: number | null
      user_id: number
      ip: string | null
      user_agent: string | null
      display_name: string | null
      status: boolean | null
      reviewed_by: number | null
      time: Date
      institution_id: number | null
    }, ExtArgs["result"]["change_request"]>
    composites: {}
  }

  type change_requestGetPayload<S extends boolean | null | undefined | change_requestDefaultArgs> = $Result.GetResult<Prisma.$change_requestPayload, S>

  type change_requestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<change_requestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Change_requestCountAggregateInputType | true
    }

  export interface change_requestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['change_request'], meta: { name: 'change_request' } }
    /**
     * Find zero or one Change_request that matches the filter.
     * @param {change_requestFindUniqueArgs} args - Arguments to find a Change_request
     * @example
     * // Get one Change_request
     * const change_request = await prisma.change_request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends change_requestFindUniqueArgs>(args: SelectSubset<T, change_requestFindUniqueArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Change_request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {change_requestFindUniqueOrThrowArgs} args - Arguments to find a Change_request
     * @example
     * // Get one Change_request
     * const change_request = await prisma.change_request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends change_requestFindUniqueOrThrowArgs>(args: SelectSubset<T, change_requestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Change_request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {change_requestFindFirstArgs} args - Arguments to find a Change_request
     * @example
     * // Get one Change_request
     * const change_request = await prisma.change_request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends change_requestFindFirstArgs>(args?: SelectSubset<T, change_requestFindFirstArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Change_request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {change_requestFindFirstOrThrowArgs} args - Arguments to find a Change_request
     * @example
     * // Get one Change_request
     * const change_request = await prisma.change_request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends change_requestFindFirstOrThrowArgs>(args?: SelectSubset<T, change_requestFindFirstOrThrowArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Change_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {change_requestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Change_requests
     * const change_requests = await prisma.change_request.findMany()
     * 
     * // Get first 10 Change_requests
     * const change_requests = await prisma.change_request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const change_requestWithIdOnly = await prisma.change_request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends change_requestFindManyArgs>(args?: SelectSubset<T, change_requestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Change_request.
     * @param {change_requestCreateArgs} args - Arguments to create a Change_request.
     * @example
     * // Create one Change_request
     * const Change_request = await prisma.change_request.create({
     *   data: {
     *     // ... data to create a Change_request
     *   }
     * })
     * 
     */
    create<T extends change_requestCreateArgs>(args: SelectSubset<T, change_requestCreateArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Change_requests.
     * @param {change_requestCreateManyArgs} args - Arguments to create many Change_requests.
     * @example
     * // Create many Change_requests
     * const change_request = await prisma.change_request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends change_requestCreateManyArgs>(args?: SelectSubset<T, change_requestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Change_request.
     * @param {change_requestDeleteArgs} args - Arguments to delete one Change_request.
     * @example
     * // Delete one Change_request
     * const Change_request = await prisma.change_request.delete({
     *   where: {
     *     // ... filter to delete one Change_request
     *   }
     * })
     * 
     */
    delete<T extends change_requestDeleteArgs>(args: SelectSubset<T, change_requestDeleteArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Change_request.
     * @param {change_requestUpdateArgs} args - Arguments to update one Change_request.
     * @example
     * // Update one Change_request
     * const change_request = await prisma.change_request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends change_requestUpdateArgs>(args: SelectSubset<T, change_requestUpdateArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Change_requests.
     * @param {change_requestDeleteManyArgs} args - Arguments to filter Change_requests to delete.
     * @example
     * // Delete a few Change_requests
     * const { count } = await prisma.change_request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends change_requestDeleteManyArgs>(args?: SelectSubset<T, change_requestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Change_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {change_requestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Change_requests
     * const change_request = await prisma.change_request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends change_requestUpdateManyArgs>(args: SelectSubset<T, change_requestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Change_request.
     * @param {change_requestUpsertArgs} args - Arguments to update or create a Change_request.
     * @example
     * // Update or create a Change_request
     * const change_request = await prisma.change_request.upsert({
     *   create: {
     *     // ... data to create a Change_request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Change_request we want to update
     *   }
     * })
     */
    upsert<T extends change_requestUpsertArgs>(args: SelectSubset<T, change_requestUpsertArgs<ExtArgs>>): Prisma__change_requestClient<$Result.GetResult<Prisma.$change_requestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Change_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {change_requestCountArgs} args - Arguments to filter Change_requests to count.
     * @example
     * // Count the number of Change_requests
     * const count = await prisma.change_request.count({
     *   where: {
     *     // ... the filter for the Change_requests we want to count
     *   }
     * })
    **/
    count<T extends change_requestCountArgs>(
      args?: Subset<T, change_requestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Change_requestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Change_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Change_requestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Change_requestAggregateArgs>(args: Subset<T, Change_requestAggregateArgs>): Prisma.PrismaPromise<GetChange_requestAggregateType<T>>

    /**
     * Group by Change_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {change_requestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends change_requestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: change_requestGroupByArgs['orderBy'] }
        : { orderBy?: change_requestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, change_requestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChange_requestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the change_request model
   */
  readonly fields: change_requestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for change_request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__change_requestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the change_request model
   */
  interface change_requestFieldRefs {
    readonly id: FieldRef<"change_request", 'Int'>
    readonly old_value: FieldRef<"change_request", 'String'>
    readonly new_value: FieldRef<"change_request", 'String'>
    readonly action: FieldRef<"change_request", 'String'>
    readonly model: FieldRef<"change_request", 'String'>
    readonly model_id: FieldRef<"change_request", 'Int'>
    readonly user_id: FieldRef<"change_request", 'Int'>
    readonly ip: FieldRef<"change_request", 'String'>
    readonly user_agent: FieldRef<"change_request", 'String'>
    readonly display_name: FieldRef<"change_request", 'String'>
    readonly status: FieldRef<"change_request", 'Boolean'>
    readonly reviewed_by: FieldRef<"change_request", 'Int'>
    readonly time: FieldRef<"change_request", 'DateTime'>
    readonly institution_id: FieldRef<"change_request", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * change_request findUnique
   */
  export type change_requestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * Filter, which change_request to fetch.
     */
    where: change_requestWhereUniqueInput
  }

  /**
   * change_request findUniqueOrThrow
   */
  export type change_requestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * Filter, which change_request to fetch.
     */
    where: change_requestWhereUniqueInput
  }

  /**
   * change_request findFirst
   */
  export type change_requestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * Filter, which change_request to fetch.
     */
    where?: change_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of change_requests to fetch.
     */
    orderBy?: change_requestOrderByWithRelationInput | change_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for change_requests.
     */
    cursor?: change_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` change_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` change_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of change_requests.
     */
    distinct?: Change_requestScalarFieldEnum | Change_requestScalarFieldEnum[]
  }

  /**
   * change_request findFirstOrThrow
   */
  export type change_requestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * Filter, which change_request to fetch.
     */
    where?: change_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of change_requests to fetch.
     */
    orderBy?: change_requestOrderByWithRelationInput | change_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for change_requests.
     */
    cursor?: change_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` change_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` change_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of change_requests.
     */
    distinct?: Change_requestScalarFieldEnum | Change_requestScalarFieldEnum[]
  }

  /**
   * change_request findMany
   */
  export type change_requestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * Filter, which change_requests to fetch.
     */
    where?: change_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of change_requests to fetch.
     */
    orderBy?: change_requestOrderByWithRelationInput | change_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing change_requests.
     */
    cursor?: change_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` change_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` change_requests.
     */
    skip?: number
    distinct?: Change_requestScalarFieldEnum | Change_requestScalarFieldEnum[]
  }

  /**
   * change_request create
   */
  export type change_requestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * The data needed to create a change_request.
     */
    data: XOR<change_requestCreateInput, change_requestUncheckedCreateInput>
  }

  /**
   * change_request createMany
   */
  export type change_requestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many change_requests.
     */
    data: change_requestCreateManyInput | change_requestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * change_request update
   */
  export type change_requestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * The data needed to update a change_request.
     */
    data: XOR<change_requestUpdateInput, change_requestUncheckedUpdateInput>
    /**
     * Choose, which change_request to update.
     */
    where: change_requestWhereUniqueInput
  }

  /**
   * change_request updateMany
   */
  export type change_requestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update change_requests.
     */
    data: XOR<change_requestUpdateManyMutationInput, change_requestUncheckedUpdateManyInput>
    /**
     * Filter which change_requests to update
     */
    where?: change_requestWhereInput
    /**
     * Limit how many change_requests to update.
     */
    limit?: number
  }

  /**
   * change_request upsert
   */
  export type change_requestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * The filter to search for the change_request to update in case it exists.
     */
    where: change_requestWhereUniqueInput
    /**
     * In case the change_request found by the `where` argument doesn't exist, create a new change_request with this data.
     */
    create: XOR<change_requestCreateInput, change_requestUncheckedCreateInput>
    /**
     * In case the change_request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<change_requestUpdateInput, change_requestUncheckedUpdateInput>
  }

  /**
   * change_request delete
   */
  export type change_requestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
    /**
     * Filter which change_request to delete.
     */
    where: change_requestWhereUniqueInput
  }

  /**
   * change_request deleteMany
   */
  export type change_requestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which change_requests to delete
     */
    where?: change_requestWhereInput
    /**
     * Limit how many change_requests to delete.
     */
    limit?: number
  }

  /**
   * change_request without action
   */
  export type change_requestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the change_request
     */
    select?: change_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the change_request
     */
    omit?: change_requestOmit<ExtArgs> | null
  }


  /**
   * Model device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
    affiliate_id: number | null
    status: number | null
    device_type: number | null
    gender: number | null
    age_range: number | null
    language: number | null
    nonce: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
    affiliate_id: number | null
    status: number | null
    device_type: number | null
    gender: number | null
    age_range: number | null
    language: number | null
    nonce: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    notification_token: string | null
    affiliate_id: number | null
    service_id: string | null
    serial_number: string | null
    status: number | null
    created_at: Date | null
    device_type: number | null
    gender: number | null
    age_range: number | null
    language: number | null
    notification_enabled: boolean | null
    apiKey: string | null
    nonce: number | null
    linkShortCode: string | null
    linkShortCodeExp: Date | null
    phone_number: string | null
    latest_hb: Date | null
    latest_hb_version: string | null
    updated_at: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    notification_token: string | null
    affiliate_id: number | null
    service_id: string | null
    serial_number: string | null
    status: number | null
    created_at: Date | null
    device_type: number | null
    gender: number | null
    age_range: number | null
    language: number | null
    notification_enabled: boolean | null
    apiKey: string | null
    nonce: number | null
    linkShortCode: string | null
    linkShortCodeExp: Date | null
    phone_number: string | null
    latest_hb: Date | null
    latest_hb_version: string | null
    updated_at: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    uuid: number
    notification_token: number
    affiliate_id: number
    service_id: number
    serial_number: number
    status: number
    created_at: number
    device_type: number
    gender: number
    age_range: number
    language: number
    notification_enabled: number
    apiKey: number
    nonce: number
    linkShortCode: number
    linkShortCodeExp: number
    phone_number: number
    latest_hb: number
    latest_hb_version: number
    updated_at: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
    affiliate_id?: true
    status?: true
    device_type?: true
    gender?: true
    age_range?: true
    language?: true
    nonce?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
    affiliate_id?: true
    status?: true
    device_type?: true
    gender?: true
    age_range?: true
    language?: true
    nonce?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    uuid?: true
    notification_token?: true
    affiliate_id?: true
    service_id?: true
    serial_number?: true
    status?: true
    created_at?: true
    device_type?: true
    gender?: true
    age_range?: true
    language?: true
    notification_enabled?: true
    apiKey?: true
    nonce?: true
    linkShortCode?: true
    linkShortCodeExp?: true
    phone_number?: true
    latest_hb?: true
    latest_hb_version?: true
    updated_at?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    uuid?: true
    notification_token?: true
    affiliate_id?: true
    service_id?: true
    serial_number?: true
    status?: true
    created_at?: true
    device_type?: true
    gender?: true
    age_range?: true
    language?: true
    notification_enabled?: true
    apiKey?: true
    nonce?: true
    linkShortCode?: true
    linkShortCodeExp?: true
    phone_number?: true
    latest_hb?: true
    latest_hb_version?: true
    updated_at?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    uuid?: true
    notification_token?: true
    affiliate_id?: true
    service_id?: true
    serial_number?: true
    status?: true
    created_at?: true
    device_type?: true
    gender?: true
    age_range?: true
    language?: true
    notification_enabled?: true
    apiKey?: true
    nonce?: true
    linkShortCode?: true
    linkShortCodeExp?: true
    phone_number?: true
    latest_hb?: true
    latest_hb_version?: true
    updated_at?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device to aggregate.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type deviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deviceWhereInput
    orderBy?: deviceOrderByWithAggregationInput | deviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: deviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    uuid: string | null
    notification_token: string | null
    affiliate_id: number | null
    service_id: string | null
    serial_number: string | null
    status: number
    created_at: Date
    device_type: number
    gender: number | null
    age_range: number | null
    language: number | null
    notification_enabled: boolean | null
    apiKey: string | null
    nonce: number | null
    linkShortCode: string | null
    linkShortCodeExp: Date | null
    phone_number: string | null
    latest_hb: Date | null
    latest_hb_version: string | null
    updated_at: Date
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends deviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type deviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    notification_token?: boolean
    affiliate_id?: boolean
    service_id?: boolean
    serial_number?: boolean
    status?: boolean
    created_at?: boolean
    device_type?: boolean
    gender?: boolean
    age_range?: boolean
    language?: boolean
    notification_enabled?: boolean
    apiKey?: boolean
    nonce?: boolean
    linkShortCode?: boolean
    linkShortCodeExp?: boolean
    phone_number?: boolean
    latest_hb?: boolean
    latest_hb_version?: boolean
    updated_at?: boolean
    institution?: boolean | device$institutionArgs<ExtArgs>
    qms_customer?: boolean | device$qms_customerArgs<ExtArgs>
    rating?: boolean | device$ratingArgs<ExtArgs>
    tip?: boolean | device$tipArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>



  export type deviceSelectScalar = {
    id?: boolean
    uuid?: boolean
    notification_token?: boolean
    affiliate_id?: boolean
    service_id?: boolean
    serial_number?: boolean
    status?: boolean
    created_at?: boolean
    device_type?: boolean
    gender?: boolean
    age_range?: boolean
    language?: boolean
    notification_enabled?: boolean
    apiKey?: boolean
    nonce?: boolean
    linkShortCode?: boolean
    linkShortCodeExp?: boolean
    phone_number?: boolean
    latest_hb?: boolean
    latest_hb_version?: boolean
    updated_at?: boolean
  }

  export type deviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "notification_token" | "affiliate_id" | "service_id" | "serial_number" | "status" | "created_at" | "device_type" | "gender" | "age_range" | "language" | "notification_enabled" | "apiKey" | "nonce" | "linkShortCode" | "linkShortCodeExp" | "phone_number" | "latest_hb" | "latest_hb_version" | "updated_at", ExtArgs["result"]["device"]>
  export type deviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | device$institutionArgs<ExtArgs>
    qms_customer?: boolean | device$qms_customerArgs<ExtArgs>
    rating?: boolean | device$ratingArgs<ExtArgs>
    tip?: boolean | device$tipArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $devicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "device"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs> | null
      qms_customer: Prisma.$qms_customerPayload<ExtArgs>[]
      rating: Prisma.$ratingPayload<ExtArgs>[]
      tip: Prisma.$tipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      notification_token: string | null
      affiliate_id: number | null
      service_id: string | null
      serial_number: string | null
      status: number
      created_at: Date
      device_type: number
      gender: number | null
      age_range: number | null
      language: number | null
      notification_enabled: boolean | null
      apiKey: string | null
      nonce: number | null
      linkShortCode: string | null
      linkShortCodeExp: Date | null
      phone_number: string | null
      latest_hb: Date | null
      latest_hb_version: string | null
      updated_at: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type deviceGetPayload<S extends boolean | null | undefined | deviceDefaultArgs> = $Result.GetResult<Prisma.$devicePayload, S>

  type deviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface deviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['device'], meta: { name: 'device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {deviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deviceFindUniqueArgs>(args: SelectSubset<T, deviceFindUniqueArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deviceFindUniqueOrThrowArgs>(args: SelectSubset<T, deviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deviceFindFirstArgs>(args?: SelectSubset<T, deviceFindFirstArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deviceFindFirstOrThrowArgs>(args?: SelectSubset<T, deviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deviceFindManyArgs>(args?: SelectSubset<T, deviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {deviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends deviceCreateArgs>(args: SelectSubset<T, deviceCreateArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {deviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deviceCreateManyArgs>(args?: SelectSubset<T, deviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Device.
     * @param {deviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends deviceDeleteArgs>(args: SelectSubset<T, deviceDeleteArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {deviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deviceUpdateArgs>(args: SelectSubset<T, deviceUpdateArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {deviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deviceDeleteManyArgs>(args?: SelectSubset<T, deviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deviceUpdateManyArgs>(args: SelectSubset<T, deviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {deviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends deviceUpsertArgs>(args: SelectSubset<T, deviceUpsertArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends deviceCountArgs>(
      args?: Subset<T, deviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deviceGroupByArgs['orderBy'] }
        : { orderBy?: deviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the device model
   */
  readonly fields: deviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends device$institutionArgs<ExtArgs> = {}>(args?: Subset<T, device$institutionArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qms_customer<T extends device$qms_customerArgs<ExtArgs> = {}>(args?: Subset<T, device$qms_customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rating<T extends device$ratingArgs<ExtArgs> = {}>(args?: Subset<T, device$ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tip<T extends device$tipArgs<ExtArgs> = {}>(args?: Subset<T, device$tipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the device model
   */
  interface deviceFieldRefs {
    readonly id: FieldRef<"device", 'Int'>
    readonly uuid: FieldRef<"device", 'String'>
    readonly notification_token: FieldRef<"device", 'String'>
    readonly affiliate_id: FieldRef<"device", 'Int'>
    readonly service_id: FieldRef<"device", 'String'>
    readonly serial_number: FieldRef<"device", 'String'>
    readonly status: FieldRef<"device", 'Int'>
    readonly created_at: FieldRef<"device", 'DateTime'>
    readonly device_type: FieldRef<"device", 'Int'>
    readonly gender: FieldRef<"device", 'Int'>
    readonly age_range: FieldRef<"device", 'Int'>
    readonly language: FieldRef<"device", 'Int'>
    readonly notification_enabled: FieldRef<"device", 'Boolean'>
    readonly apiKey: FieldRef<"device", 'String'>
    readonly nonce: FieldRef<"device", 'Int'>
    readonly linkShortCode: FieldRef<"device", 'String'>
    readonly linkShortCodeExp: FieldRef<"device", 'DateTime'>
    readonly phone_number: FieldRef<"device", 'String'>
    readonly latest_hb: FieldRef<"device", 'DateTime'>
    readonly latest_hb_version: FieldRef<"device", 'String'>
    readonly updated_at: FieldRef<"device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * device findUnique
   */
  export type deviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device findUniqueOrThrow
   */
  export type deviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device findFirst
   */
  export type deviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for devices.
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device findFirstOrThrow
   */
  export type deviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which device to fetch.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for devices.
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device findMany
   */
  export type deviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter, which devices to fetch.
     */
    where?: deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of devices to fetch.
     */
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing devices.
     */
    cursor?: deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * device create
   */
  export type deviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * The data needed to create a device.
     */
    data?: XOR<deviceCreateInput, deviceUncheckedCreateInput>
  }

  /**
   * device createMany
   */
  export type deviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many devices.
     */
    data: deviceCreateManyInput | deviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device update
   */
  export type deviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * The data needed to update a device.
     */
    data: XOR<deviceUpdateInput, deviceUncheckedUpdateInput>
    /**
     * Choose, which device to update.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device updateMany
   */
  export type deviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update devices.
     */
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyInput>
    /**
     * Filter which devices to update
     */
    where?: deviceWhereInput
    /**
     * Limit how many devices to update.
     */
    limit?: number
  }

  /**
   * device upsert
   */
  export type deviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * The filter to search for the device to update in case it exists.
     */
    where: deviceWhereUniqueInput
    /**
     * In case the device found by the `where` argument doesn't exist, create a new device with this data.
     */
    create: XOR<deviceCreateInput, deviceUncheckedCreateInput>
    /**
     * In case the device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deviceUpdateInput, deviceUncheckedUpdateInput>
  }

  /**
   * device delete
   */
  export type deviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    /**
     * Filter which device to delete.
     */
    where: deviceWhereUniqueInput
  }

  /**
   * device deleteMany
   */
  export type deviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which devices to delete
     */
    where?: deviceWhereInput
    /**
     * Limit how many devices to delete.
     */
    limit?: number
  }

  /**
   * device.institution
   */
  export type device$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
  }

  /**
   * device.qms_customer
   */
  export type device$qms_customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    where?: qms_customerWhereInput
    orderBy?: qms_customerOrderByWithRelationInput | qms_customerOrderByWithRelationInput[]
    cursor?: qms_customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_customerScalarFieldEnum | Qms_customerScalarFieldEnum[]
  }

  /**
   * device.rating
   */
  export type device$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    cursor?: ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * device.tip
   */
  export type device$tipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    where?: tipWhereInput
    orderBy?: tipOrderByWithRelationInput | tipOrderByWithRelationInput[]
    cursor?: tipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TipScalarFieldEnum | TipScalarFieldEnum[]
  }

  /**
   * device without action
   */
  export type deviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
  }


  /**
   * Model device_heartbeat
   */

  export type AggregateDevice_heartbeat = {
    _count: Device_heartbeatCountAggregateOutputType | null
    _avg: Device_heartbeatAvgAggregateOutputType | null
    _sum: Device_heartbeatSumAggregateOutputType | null
    _min: Device_heartbeatMinAggregateOutputType | null
    _max: Device_heartbeatMaxAggregateOutputType | null
  }

  export type Device_heartbeatAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    operator_id: number | null
  }

  export type Device_heartbeatSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    operator_id: number | null
  }

  export type Device_heartbeatMinAggregateOutputType = {
    id: number | null
    time: Date | null
    device_id: number | null
    operator_id: number | null
    version: string | null
  }

  export type Device_heartbeatMaxAggregateOutputType = {
    id: number | null
    time: Date | null
    device_id: number | null
    operator_id: number | null
    version: string | null
  }

  export type Device_heartbeatCountAggregateOutputType = {
    id: number
    time: number
    device_id: number
    operator_id: number
    version: number
    _all: number
  }


  export type Device_heartbeatAvgAggregateInputType = {
    id?: true
    device_id?: true
    operator_id?: true
  }

  export type Device_heartbeatSumAggregateInputType = {
    id?: true
    device_id?: true
    operator_id?: true
  }

  export type Device_heartbeatMinAggregateInputType = {
    id?: true
    time?: true
    device_id?: true
    operator_id?: true
    version?: true
  }

  export type Device_heartbeatMaxAggregateInputType = {
    id?: true
    time?: true
    device_id?: true
    operator_id?: true
    version?: true
  }

  export type Device_heartbeatCountAggregateInputType = {
    id?: true
    time?: true
    device_id?: true
    operator_id?: true
    version?: true
    _all?: true
  }

  export type Device_heartbeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_heartbeat to aggregate.
     */
    where?: device_heartbeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_heartbeats to fetch.
     */
    orderBy?: device_heartbeatOrderByWithRelationInput | device_heartbeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: device_heartbeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_heartbeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_heartbeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned device_heartbeats
    **/
    _count?: true | Device_heartbeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Device_heartbeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Device_heartbeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Device_heartbeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Device_heartbeatMaxAggregateInputType
  }

  export type GetDevice_heartbeatAggregateType<T extends Device_heartbeatAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice_heartbeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice_heartbeat[P]>
      : GetScalarType<T[P], AggregateDevice_heartbeat[P]>
  }




  export type device_heartbeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: device_heartbeatWhereInput
    orderBy?: device_heartbeatOrderByWithAggregationInput | device_heartbeatOrderByWithAggregationInput[]
    by: Device_heartbeatScalarFieldEnum[] | Device_heartbeatScalarFieldEnum
    having?: device_heartbeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Device_heartbeatCountAggregateInputType | true
    _avg?: Device_heartbeatAvgAggregateInputType
    _sum?: Device_heartbeatSumAggregateInputType
    _min?: Device_heartbeatMinAggregateInputType
    _max?: Device_heartbeatMaxAggregateInputType
  }

  export type Device_heartbeatGroupByOutputType = {
    id: number
    time: Date
    device_id: number | null
    operator_id: number | null
    version: string | null
    _count: Device_heartbeatCountAggregateOutputType | null
    _avg: Device_heartbeatAvgAggregateOutputType | null
    _sum: Device_heartbeatSumAggregateOutputType | null
    _min: Device_heartbeatMinAggregateOutputType | null
    _max: Device_heartbeatMaxAggregateOutputType | null
  }

  type GetDevice_heartbeatGroupByPayload<T extends device_heartbeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Device_heartbeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Device_heartbeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Device_heartbeatGroupByOutputType[P]>
            : GetScalarType<T[P], Device_heartbeatGroupByOutputType[P]>
        }
      >
    >


  export type device_heartbeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    device_id?: boolean
    operator_id?: boolean
    version?: boolean
  }, ExtArgs["result"]["device_heartbeat"]>



  export type device_heartbeatSelectScalar = {
    id?: boolean
    time?: boolean
    device_id?: boolean
    operator_id?: boolean
    version?: boolean
  }

  export type device_heartbeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "time" | "device_id" | "operator_id" | "version", ExtArgs["result"]["device_heartbeat"]>

  export type $device_heartbeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "device_heartbeat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      time: Date
      device_id: number | null
      operator_id: number | null
      version: string | null
    }, ExtArgs["result"]["device_heartbeat"]>
    composites: {}
  }

  type device_heartbeatGetPayload<S extends boolean | null | undefined | device_heartbeatDefaultArgs> = $Result.GetResult<Prisma.$device_heartbeatPayload, S>

  type device_heartbeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<device_heartbeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Device_heartbeatCountAggregateInputType | true
    }

  export interface device_heartbeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['device_heartbeat'], meta: { name: 'device_heartbeat' } }
    /**
     * Find zero or one Device_heartbeat that matches the filter.
     * @param {device_heartbeatFindUniqueArgs} args - Arguments to find a Device_heartbeat
     * @example
     * // Get one Device_heartbeat
     * const device_heartbeat = await prisma.device_heartbeat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends device_heartbeatFindUniqueArgs>(args: SelectSubset<T, device_heartbeatFindUniqueArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device_heartbeat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {device_heartbeatFindUniqueOrThrowArgs} args - Arguments to find a Device_heartbeat
     * @example
     * // Get one Device_heartbeat
     * const device_heartbeat = await prisma.device_heartbeat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends device_heartbeatFindUniqueOrThrowArgs>(args: SelectSubset<T, device_heartbeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device_heartbeat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_heartbeatFindFirstArgs} args - Arguments to find a Device_heartbeat
     * @example
     * // Get one Device_heartbeat
     * const device_heartbeat = await prisma.device_heartbeat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends device_heartbeatFindFirstArgs>(args?: SelectSubset<T, device_heartbeatFindFirstArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device_heartbeat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_heartbeatFindFirstOrThrowArgs} args - Arguments to find a Device_heartbeat
     * @example
     * // Get one Device_heartbeat
     * const device_heartbeat = await prisma.device_heartbeat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends device_heartbeatFindFirstOrThrowArgs>(args?: SelectSubset<T, device_heartbeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Device_heartbeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_heartbeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Device_heartbeats
     * const device_heartbeats = await prisma.device_heartbeat.findMany()
     * 
     * // Get first 10 Device_heartbeats
     * const device_heartbeats = await prisma.device_heartbeat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const device_heartbeatWithIdOnly = await prisma.device_heartbeat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends device_heartbeatFindManyArgs>(args?: SelectSubset<T, device_heartbeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device_heartbeat.
     * @param {device_heartbeatCreateArgs} args - Arguments to create a Device_heartbeat.
     * @example
     * // Create one Device_heartbeat
     * const Device_heartbeat = await prisma.device_heartbeat.create({
     *   data: {
     *     // ... data to create a Device_heartbeat
     *   }
     * })
     * 
     */
    create<T extends device_heartbeatCreateArgs>(args: SelectSubset<T, device_heartbeatCreateArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Device_heartbeats.
     * @param {device_heartbeatCreateManyArgs} args - Arguments to create many Device_heartbeats.
     * @example
     * // Create many Device_heartbeats
     * const device_heartbeat = await prisma.device_heartbeat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends device_heartbeatCreateManyArgs>(args?: SelectSubset<T, device_heartbeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Device_heartbeat.
     * @param {device_heartbeatDeleteArgs} args - Arguments to delete one Device_heartbeat.
     * @example
     * // Delete one Device_heartbeat
     * const Device_heartbeat = await prisma.device_heartbeat.delete({
     *   where: {
     *     // ... filter to delete one Device_heartbeat
     *   }
     * })
     * 
     */
    delete<T extends device_heartbeatDeleteArgs>(args: SelectSubset<T, device_heartbeatDeleteArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device_heartbeat.
     * @param {device_heartbeatUpdateArgs} args - Arguments to update one Device_heartbeat.
     * @example
     * // Update one Device_heartbeat
     * const device_heartbeat = await prisma.device_heartbeat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends device_heartbeatUpdateArgs>(args: SelectSubset<T, device_heartbeatUpdateArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Device_heartbeats.
     * @param {device_heartbeatDeleteManyArgs} args - Arguments to filter Device_heartbeats to delete.
     * @example
     * // Delete a few Device_heartbeats
     * const { count } = await prisma.device_heartbeat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends device_heartbeatDeleteManyArgs>(args?: SelectSubset<T, device_heartbeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Device_heartbeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_heartbeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Device_heartbeats
     * const device_heartbeat = await prisma.device_heartbeat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends device_heartbeatUpdateManyArgs>(args: SelectSubset<T, device_heartbeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device_heartbeat.
     * @param {device_heartbeatUpsertArgs} args - Arguments to update or create a Device_heartbeat.
     * @example
     * // Update or create a Device_heartbeat
     * const device_heartbeat = await prisma.device_heartbeat.upsert({
     *   create: {
     *     // ... data to create a Device_heartbeat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device_heartbeat we want to update
     *   }
     * })
     */
    upsert<T extends device_heartbeatUpsertArgs>(args: SelectSubset<T, device_heartbeatUpsertArgs<ExtArgs>>): Prisma__device_heartbeatClient<$Result.GetResult<Prisma.$device_heartbeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Device_heartbeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_heartbeatCountArgs} args - Arguments to filter Device_heartbeats to count.
     * @example
     * // Count the number of Device_heartbeats
     * const count = await prisma.device_heartbeat.count({
     *   where: {
     *     // ... the filter for the Device_heartbeats we want to count
     *   }
     * })
    **/
    count<T extends device_heartbeatCountArgs>(
      args?: Subset<T, device_heartbeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Device_heartbeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device_heartbeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Device_heartbeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Device_heartbeatAggregateArgs>(args: Subset<T, Device_heartbeatAggregateArgs>): Prisma.PrismaPromise<GetDevice_heartbeatAggregateType<T>>

    /**
     * Group by Device_heartbeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_heartbeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends device_heartbeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: device_heartbeatGroupByArgs['orderBy'] }
        : { orderBy?: device_heartbeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, device_heartbeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevice_heartbeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the device_heartbeat model
   */
  readonly fields: device_heartbeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for device_heartbeat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__device_heartbeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the device_heartbeat model
   */
  interface device_heartbeatFieldRefs {
    readonly id: FieldRef<"device_heartbeat", 'Int'>
    readonly time: FieldRef<"device_heartbeat", 'DateTime'>
    readonly device_id: FieldRef<"device_heartbeat", 'Int'>
    readonly operator_id: FieldRef<"device_heartbeat", 'Int'>
    readonly version: FieldRef<"device_heartbeat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * device_heartbeat findUnique
   */
  export type device_heartbeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * Filter, which device_heartbeat to fetch.
     */
    where: device_heartbeatWhereUniqueInput
  }

  /**
   * device_heartbeat findUniqueOrThrow
   */
  export type device_heartbeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * Filter, which device_heartbeat to fetch.
     */
    where: device_heartbeatWhereUniqueInput
  }

  /**
   * device_heartbeat findFirst
   */
  export type device_heartbeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * Filter, which device_heartbeat to fetch.
     */
    where?: device_heartbeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_heartbeats to fetch.
     */
    orderBy?: device_heartbeatOrderByWithRelationInput | device_heartbeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_heartbeats.
     */
    cursor?: device_heartbeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_heartbeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_heartbeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_heartbeats.
     */
    distinct?: Device_heartbeatScalarFieldEnum | Device_heartbeatScalarFieldEnum[]
  }

  /**
   * device_heartbeat findFirstOrThrow
   */
  export type device_heartbeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * Filter, which device_heartbeat to fetch.
     */
    where?: device_heartbeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_heartbeats to fetch.
     */
    orderBy?: device_heartbeatOrderByWithRelationInput | device_heartbeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_heartbeats.
     */
    cursor?: device_heartbeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_heartbeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_heartbeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_heartbeats.
     */
    distinct?: Device_heartbeatScalarFieldEnum | Device_heartbeatScalarFieldEnum[]
  }

  /**
   * device_heartbeat findMany
   */
  export type device_heartbeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * Filter, which device_heartbeats to fetch.
     */
    where?: device_heartbeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_heartbeats to fetch.
     */
    orderBy?: device_heartbeatOrderByWithRelationInput | device_heartbeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing device_heartbeats.
     */
    cursor?: device_heartbeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_heartbeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_heartbeats.
     */
    skip?: number
    distinct?: Device_heartbeatScalarFieldEnum | Device_heartbeatScalarFieldEnum[]
  }

  /**
   * device_heartbeat create
   */
  export type device_heartbeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * The data needed to create a device_heartbeat.
     */
    data?: XOR<device_heartbeatCreateInput, device_heartbeatUncheckedCreateInput>
  }

  /**
   * device_heartbeat createMany
   */
  export type device_heartbeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many device_heartbeats.
     */
    data: device_heartbeatCreateManyInput | device_heartbeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device_heartbeat update
   */
  export type device_heartbeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * The data needed to update a device_heartbeat.
     */
    data: XOR<device_heartbeatUpdateInput, device_heartbeatUncheckedUpdateInput>
    /**
     * Choose, which device_heartbeat to update.
     */
    where: device_heartbeatWhereUniqueInput
  }

  /**
   * device_heartbeat updateMany
   */
  export type device_heartbeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update device_heartbeats.
     */
    data: XOR<device_heartbeatUpdateManyMutationInput, device_heartbeatUncheckedUpdateManyInput>
    /**
     * Filter which device_heartbeats to update
     */
    where?: device_heartbeatWhereInput
    /**
     * Limit how many device_heartbeats to update.
     */
    limit?: number
  }

  /**
   * device_heartbeat upsert
   */
  export type device_heartbeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * The filter to search for the device_heartbeat to update in case it exists.
     */
    where: device_heartbeatWhereUniqueInput
    /**
     * In case the device_heartbeat found by the `where` argument doesn't exist, create a new device_heartbeat with this data.
     */
    create: XOR<device_heartbeatCreateInput, device_heartbeatUncheckedCreateInput>
    /**
     * In case the device_heartbeat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<device_heartbeatUpdateInput, device_heartbeatUncheckedUpdateInput>
  }

  /**
   * device_heartbeat delete
   */
  export type device_heartbeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
    /**
     * Filter which device_heartbeat to delete.
     */
    where: device_heartbeatWhereUniqueInput
  }

  /**
   * device_heartbeat deleteMany
   */
  export type device_heartbeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_heartbeats to delete
     */
    where?: device_heartbeatWhereInput
    /**
     * Limit how many device_heartbeats to delete.
     */
    limit?: number
  }

  /**
   * device_heartbeat without action
   */
  export type device_heartbeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_heartbeat
     */
    select?: device_heartbeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device_heartbeat
     */
    omit?: device_heartbeatOmit<ExtArgs> | null
  }


  /**
   * Model institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _avg: InstitutionAvgAggregateOutputType | null
    _sum: InstitutionSumAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionAvgAggregateOutputType = {
    id: number | null
    status: number | null
    plan: number | null
    type: number | null
    level: number | null
    parent_id: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    queue_autocreation: number | null
    queue_manual_creation: number | null
    allowed_context: number | null
    membership_type: number | null
    category_id: number | null
  }

  export type InstitutionSumAggregateOutputType = {
    id: number | null
    status: number | null
    plan: number | null
    type: number | null
    level: number | null
    parent_id: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    queue_autocreation: number | null
    queue_manual_creation: number | null
    allowed_context: number | null
    membership_type: number | null
    category_id: number | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    search_term: string | null
    email: string | null
    address: string | null
    phone_number: string | null
    url: string | null
    status: number | null
    created_at: Date | null
    plan: number | null
    type: number | null
    level: number | null
    parent_id: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    queue_autocreation: number | null
    queue_manual_creation: number | null
    working_hours: string | null
    qms_message: string | null
    priority_list: string | null
    logo: string | null
    app_name: string | null
    allowed_context: number | null
    host_name: string | null
    membership_type: number | null
    category_id: number | null
    latest_membership_renew_time: Date | null
    description: string | null
    latitude: string | null
    longitude: string | null
    button_one: string | null
    button_two: string | null
    amenities: string | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    search_term: string | null
    email: string | null
    address: string | null
    phone_number: string | null
    url: string | null
    status: number | null
    created_at: Date | null
    plan: number | null
    type: number | null
    level: number | null
    parent_id: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    queue_autocreation: number | null
    queue_manual_creation: number | null
    working_hours: string | null
    qms_message: string | null
    priority_list: string | null
    logo: string | null
    app_name: string | null
    allowed_context: number | null
    host_name: string | null
    membership_type: number | null
    category_id: number | null
    latest_membership_renew_time: Date | null
    description: string | null
    latitude: string | null
    longitude: string | null
    button_one: string | null
    button_two: string | null
    amenities: string | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    search_term: number
    email: number
    address: number
    phone_number: number
    url: number
    status: number
    created_at: number
    plan: number
    type: number
    level: number
    parent_id: number
    good_ratings: number
    bad_ratings: number
    excellent_ratings: number
    nps: number
    csat: number
    queue_autocreation: number
    queue_manual_creation: number
    working_hours: number
    qms_message: number
    priority_list: number
    logo: number
    app_name: number
    allowed_context: number
    host_name: number
    membership_type: number
    category_id: number
    latest_membership_renew_time: number
    description: number
    latitude: number
    longitude: number
    button_one: number
    button_two: number
    amenities: number
    _all: number
  }


  export type InstitutionAvgAggregateInputType = {
    id?: true
    status?: true
    plan?: true
    type?: true
    level?: true
    parent_id?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    queue_autocreation?: true
    queue_manual_creation?: true
    allowed_context?: true
    membership_type?: true
    category_id?: true
  }

  export type InstitutionSumAggregateInputType = {
    id?: true
    status?: true
    plan?: true
    type?: true
    level?: true
    parent_id?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    queue_autocreation?: true
    queue_manual_creation?: true
    allowed_context?: true
    membership_type?: true
    category_id?: true
  }

  export type InstitutionMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    search_term?: true
    email?: true
    address?: true
    phone_number?: true
    url?: true
    status?: true
    created_at?: true
    plan?: true
    type?: true
    level?: true
    parent_id?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    queue_autocreation?: true
    queue_manual_creation?: true
    working_hours?: true
    qms_message?: true
    priority_list?: true
    logo?: true
    app_name?: true
    allowed_context?: true
    host_name?: true
    membership_type?: true
    category_id?: true
    latest_membership_renew_time?: true
    description?: true
    latitude?: true
    longitude?: true
    button_one?: true
    button_two?: true
    amenities?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    search_term?: true
    email?: true
    address?: true
    phone_number?: true
    url?: true
    status?: true
    created_at?: true
    plan?: true
    type?: true
    level?: true
    parent_id?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    queue_autocreation?: true
    queue_manual_creation?: true
    working_hours?: true
    qms_message?: true
    priority_list?: true
    logo?: true
    app_name?: true
    allowed_context?: true
    host_name?: true
    membership_type?: true
    category_id?: true
    latest_membership_renew_time?: true
    description?: true
    latitude?: true
    longitude?: true
    button_one?: true
    button_two?: true
    amenities?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    search_term?: true
    email?: true
    address?: true
    phone_number?: true
    url?: true
    status?: true
    created_at?: true
    plan?: true
    type?: true
    level?: true
    parent_id?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    queue_autocreation?: true
    queue_manual_creation?: true
    working_hours?: true
    qms_message?: true
    priority_list?: true
    logo?: true
    app_name?: true
    allowed_context?: true
    host_name?: true
    membership_type?: true
    category_id?: true
    latest_membership_renew_time?: true
    description?: true
    latitude?: true
    longitude?: true
    button_one?: true
    button_two?: true
    amenities?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institution to aggregate.
     */
    where?: institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionOrderByWithRelationInput | institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type institutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institutionWhereInput
    orderBy?: institutionOrderByWithAggregationInput | institutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: institutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _avg?: InstitutionAvgAggregateInputType
    _sum?: InstitutionSumAggregateInputType
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: number
    uuid: string | null
    name: string
    search_term: string | null
    email: string | null
    address: string | null
    phone_number: string | null
    url: string | null
    status: number | null
    created_at: Date
    plan: number | null
    type: number | null
    level: number | null
    parent_id: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    queue_autocreation: number | null
    queue_manual_creation: number | null
    working_hours: string | null
    qms_message: string | null
    priority_list: string | null
    logo: string | null
    app_name: string | null
    allowed_context: number | null
    host_name: string | null
    membership_type: number
    category_id: number | null
    latest_membership_renew_time: Date | null
    description: string | null
    latitude: string | null
    longitude: string | null
    button_one: string | null
    button_two: string | null
    amenities: string | null
    _count: InstitutionCountAggregateOutputType | null
    _avg: InstitutionAvgAggregateOutputType | null
    _sum: InstitutionSumAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends institutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type institutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    search_term?: boolean
    email?: boolean
    address?: boolean
    phone_number?: boolean
    url?: boolean
    status?: boolean
    created_at?: boolean
    plan?: boolean
    type?: boolean
    level?: boolean
    parent_id?: boolean
    good_ratings?: boolean
    bad_ratings?: boolean
    excellent_ratings?: boolean
    nps?: boolean
    csat?: boolean
    queue_autocreation?: boolean
    queue_manual_creation?: boolean
    working_hours?: boolean
    qms_message?: boolean
    priority_list?: boolean
    logo?: boolean
    app_name?: boolean
    allowed_context?: boolean
    host_name?: boolean
    membership_type?: boolean
    category_id?: boolean
    latest_membership_renew_time?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    button_one?: boolean
    button_two?: boolean
    amenities?: boolean
    appointments?: boolean | institution$appointmentsArgs<ExtArgs>
    apps?: boolean | institution$appsArgs<ExtArgs>
    business_amenities?: boolean | institution$business_amenitiesArgs<ExtArgs>
    device?: boolean | institution$deviceArgs<ExtArgs>
    images?: boolean | institution$imagesArgs<ExtArgs>
    categories?: boolean | institution$categoriesArgs<ExtArgs>
    popup_questions?: boolean | institution$popup_questionsArgs<ExtArgs>
    price_ranges?: boolean | institution$price_rangesArgs<ExtArgs>
    qms_branch_operator?: boolean | institution$qms_branch_operatorArgs<ExtArgs>
    qms_branch_transactions?: boolean | institution$qms_branch_transactionsArgs<ExtArgs>
    qms_operator?: boolean | institution$qms_operatorArgs<ExtArgs>
    reviews?: boolean | institution$reviewsArgs<ExtArgs>
    service?: boolean | institution$serviceArgs<ExtArgs>
    service_group?: boolean | institution$service_groupArgs<ExtArgs>
    workingHour?: boolean | institution$workingHourArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>



  export type institutionSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    search_term?: boolean
    email?: boolean
    address?: boolean
    phone_number?: boolean
    url?: boolean
    status?: boolean
    created_at?: boolean
    plan?: boolean
    type?: boolean
    level?: boolean
    parent_id?: boolean
    good_ratings?: boolean
    bad_ratings?: boolean
    excellent_ratings?: boolean
    nps?: boolean
    csat?: boolean
    queue_autocreation?: boolean
    queue_manual_creation?: boolean
    working_hours?: boolean
    qms_message?: boolean
    priority_list?: boolean
    logo?: boolean
    app_name?: boolean
    allowed_context?: boolean
    host_name?: boolean
    membership_type?: boolean
    category_id?: boolean
    latest_membership_renew_time?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    button_one?: boolean
    button_two?: boolean
    amenities?: boolean
  }

  export type institutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "name" | "search_term" | "email" | "address" | "phone_number" | "url" | "status" | "created_at" | "plan" | "type" | "level" | "parent_id" | "good_ratings" | "bad_ratings" | "excellent_ratings" | "nps" | "csat" | "queue_autocreation" | "queue_manual_creation" | "working_hours" | "qms_message" | "priority_list" | "logo" | "app_name" | "allowed_context" | "host_name" | "membership_type" | "category_id" | "latest_membership_renew_time" | "description" | "latitude" | "longitude" | "button_one" | "button_two" | "amenities", ExtArgs["result"]["institution"]>
  export type institutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | institution$appointmentsArgs<ExtArgs>
    apps?: boolean | institution$appsArgs<ExtArgs>
    business_amenities?: boolean | institution$business_amenitiesArgs<ExtArgs>
    device?: boolean | institution$deviceArgs<ExtArgs>
    images?: boolean | institution$imagesArgs<ExtArgs>
    categories?: boolean | institution$categoriesArgs<ExtArgs>
    popup_questions?: boolean | institution$popup_questionsArgs<ExtArgs>
    price_ranges?: boolean | institution$price_rangesArgs<ExtArgs>
    qms_branch_operator?: boolean | institution$qms_branch_operatorArgs<ExtArgs>
    qms_branch_transactions?: boolean | institution$qms_branch_transactionsArgs<ExtArgs>
    qms_operator?: boolean | institution$qms_operatorArgs<ExtArgs>
    reviews?: boolean | institution$reviewsArgs<ExtArgs>
    service?: boolean | institution$serviceArgs<ExtArgs>
    service_group?: boolean | institution$service_groupArgs<ExtArgs>
    workingHour?: boolean | institution$workingHourArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $institutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "institution"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      apps: Prisma.$appsPayload<ExtArgs>[]
      business_amenities: Prisma.$business_amenitiesPayload<ExtArgs>[]
      device: Prisma.$devicePayload<ExtArgs>[]
      images: Prisma.$imagesPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      popup_questions: Prisma.$popup_questionsPayload<ExtArgs>[]
      price_ranges: Prisma.$price_rangesPayload<ExtArgs>[]
      qms_branch_operator: Prisma.$qms_branch_operatorPayload<ExtArgs>[]
      qms_branch_transactions: Prisma.$qms_branch_transactionsPayload<ExtArgs>[]
      qms_operator: Prisma.$qms_operatorPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
      service: Prisma.$servicePayload<ExtArgs>[]
      service_group: Prisma.$service_groupPayload<ExtArgs>[]
      workingHour: Prisma.$workingHourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      name: string
      search_term: string | null
      email: string | null
      address: string | null
      phone_number: string | null
      url: string | null
      status: number | null
      created_at: Date
      plan: number | null
      type: number | null
      level: number | null
      parent_id: number | null
      good_ratings: number | null
      bad_ratings: number | null
      excellent_ratings: number | null
      nps: number | null
      csat: number | null
      queue_autocreation: number | null
      queue_manual_creation: number | null
      working_hours: string | null
      qms_message: string | null
      priority_list: string | null
      logo: string | null
      app_name: string | null
      allowed_context: number | null
      host_name: string | null
      membership_type: number
      category_id: number | null
      latest_membership_renew_time: Date | null
      description: string | null
      latitude: string | null
      longitude: string | null
      button_one: string | null
      button_two: string | null
      amenities: string | null
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type institutionGetPayload<S extends boolean | null | undefined | institutionDefaultArgs> = $Result.GetResult<Prisma.$institutionPayload, S>

  type institutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<institutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface institutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['institution'], meta: { name: 'institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {institutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends institutionFindUniqueArgs>(args: SelectSubset<T, institutionFindUniqueArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {institutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends institutionFindUniqueOrThrowArgs>(args: SelectSubset<T, institutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends institutionFindFirstArgs>(args?: SelectSubset<T, institutionFindFirstArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends institutionFindFirstOrThrowArgs>(args?: SelectSubset<T, institutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends institutionFindManyArgs>(args?: SelectSubset<T, institutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {institutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends institutionCreateArgs>(args: SelectSubset<T, institutionCreateArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {institutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends institutionCreateManyArgs>(args?: SelectSubset<T, institutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institution.
     * @param {institutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends institutionDeleteArgs>(args: SelectSubset<T, institutionDeleteArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {institutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends institutionUpdateArgs>(args: SelectSubset<T, institutionUpdateArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {institutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends institutionDeleteManyArgs>(args?: SelectSubset<T, institutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends institutionUpdateManyArgs>(args: SelectSubset<T, institutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institution.
     * @param {institutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends institutionUpsertArgs>(args: SelectSubset<T, institutionUpsertArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends institutionCountArgs>(
      args?: Subset<T, institutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends institutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: institutionGroupByArgs['orderBy'] }
        : { orderBy?: institutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, institutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the institution model
   */
  readonly fields: institutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__institutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends institution$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, institution$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apps<T extends institution$appsArgs<ExtArgs> = {}>(args?: Subset<T, institution$appsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    business_amenities<T extends institution$business_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, institution$business_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    device<T extends institution$deviceArgs<ExtArgs> = {}>(args?: Subset<T, institution$deviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends institution$imagesArgs<ExtArgs> = {}>(args?: Subset<T, institution$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends institution$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, institution$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    popup_questions<T extends institution$popup_questionsArgs<ExtArgs> = {}>(args?: Subset<T, institution$popup_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    price_ranges<T extends institution$price_rangesArgs<ExtArgs> = {}>(args?: Subset<T, institution$price_rangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_branch_operator<T extends institution$qms_branch_operatorArgs<ExtArgs> = {}>(args?: Subset<T, institution$qms_branch_operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_branch_transactions<T extends institution$qms_branch_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, institution$qms_branch_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_operator<T extends institution$qms_operatorArgs<ExtArgs> = {}>(args?: Subset<T, institution$qms_operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends institution$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, institution$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service<T extends institution$serviceArgs<ExtArgs> = {}>(args?: Subset<T, institution$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_group<T extends institution$service_groupArgs<ExtArgs> = {}>(args?: Subset<T, institution$service_groupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workingHour<T extends institution$workingHourArgs<ExtArgs> = {}>(args?: Subset<T, institution$workingHourArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the institution model
   */
  interface institutionFieldRefs {
    readonly id: FieldRef<"institution", 'Int'>
    readonly uuid: FieldRef<"institution", 'String'>
    readonly name: FieldRef<"institution", 'String'>
    readonly search_term: FieldRef<"institution", 'String'>
    readonly email: FieldRef<"institution", 'String'>
    readonly address: FieldRef<"institution", 'String'>
    readonly phone_number: FieldRef<"institution", 'String'>
    readonly url: FieldRef<"institution", 'String'>
    readonly status: FieldRef<"institution", 'Int'>
    readonly created_at: FieldRef<"institution", 'DateTime'>
    readonly plan: FieldRef<"institution", 'Int'>
    readonly type: FieldRef<"institution", 'Int'>
    readonly level: FieldRef<"institution", 'Int'>
    readonly parent_id: FieldRef<"institution", 'Int'>
    readonly good_ratings: FieldRef<"institution", 'Int'>
    readonly bad_ratings: FieldRef<"institution", 'Int'>
    readonly excellent_ratings: FieldRef<"institution", 'Int'>
    readonly nps: FieldRef<"institution", 'Int'>
    readonly csat: FieldRef<"institution", 'Int'>
    readonly queue_autocreation: FieldRef<"institution", 'Int'>
    readonly queue_manual_creation: FieldRef<"institution", 'Int'>
    readonly working_hours: FieldRef<"institution", 'String'>
    readonly qms_message: FieldRef<"institution", 'String'>
    readonly priority_list: FieldRef<"institution", 'String'>
    readonly logo: FieldRef<"institution", 'String'>
    readonly app_name: FieldRef<"institution", 'String'>
    readonly allowed_context: FieldRef<"institution", 'Int'>
    readonly host_name: FieldRef<"institution", 'String'>
    readonly membership_type: FieldRef<"institution", 'Int'>
    readonly category_id: FieldRef<"institution", 'Int'>
    readonly latest_membership_renew_time: FieldRef<"institution", 'DateTime'>
    readonly description: FieldRef<"institution", 'String'>
    readonly latitude: FieldRef<"institution", 'String'>
    readonly longitude: FieldRef<"institution", 'String'>
    readonly button_one: FieldRef<"institution", 'String'>
    readonly button_two: FieldRef<"institution", 'String'>
    readonly amenities: FieldRef<"institution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * institution findUnique
   */
  export type institutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * Filter, which institution to fetch.
     */
    where: institutionWhereUniqueInput
  }

  /**
   * institution findUniqueOrThrow
   */
  export type institutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * Filter, which institution to fetch.
     */
    where: institutionWhereUniqueInput
  }

  /**
   * institution findFirst
   */
  export type institutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * Filter, which institution to fetch.
     */
    where?: institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionOrderByWithRelationInput | institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutions.
     */
    cursor?: institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * institution findFirstOrThrow
   */
  export type institutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * Filter, which institution to fetch.
     */
    where?: institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionOrderByWithRelationInput | institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutions.
     */
    cursor?: institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * institution findMany
   */
  export type institutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionOrderByWithRelationInput | institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing institutions.
     */
    cursor?: institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * institution create
   */
  export type institutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * The data needed to create a institution.
     */
    data: XOR<institutionCreateInput, institutionUncheckedCreateInput>
  }

  /**
   * institution createMany
   */
  export type institutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many institutions.
     */
    data: institutionCreateManyInput | institutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * institution update
   */
  export type institutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * The data needed to update a institution.
     */
    data: XOR<institutionUpdateInput, institutionUncheckedUpdateInput>
    /**
     * Choose, which institution to update.
     */
    where: institutionWhereUniqueInput
  }

  /**
   * institution updateMany
   */
  export type institutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update institutions.
     */
    data: XOR<institutionUpdateManyMutationInput, institutionUncheckedUpdateManyInput>
    /**
     * Filter which institutions to update
     */
    where?: institutionWhereInput
    /**
     * Limit how many institutions to update.
     */
    limit?: number
  }

  /**
   * institution upsert
   */
  export type institutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * The filter to search for the institution to update in case it exists.
     */
    where: institutionWhereUniqueInput
    /**
     * In case the institution found by the `where` argument doesn't exist, create a new institution with this data.
     */
    create: XOR<institutionCreateInput, institutionUncheckedCreateInput>
    /**
     * In case the institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<institutionUpdateInput, institutionUncheckedUpdateInput>
  }

  /**
   * institution delete
   */
  export type institutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    /**
     * Filter which institution to delete.
     */
    where: institutionWhereUniqueInput
  }

  /**
   * institution deleteMany
   */
  export type institutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institutions to delete
     */
    where?: institutionWhereInput
    /**
     * Limit how many institutions to delete.
     */
    limit?: number
  }

  /**
   * institution.appointments
   */
  export type institution$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * institution.apps
   */
  export type institution$appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apps
     */
    select?: appsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apps
     */
    omit?: appsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appsInclude<ExtArgs> | null
    where?: appsWhereInput
    orderBy?: appsOrderByWithRelationInput | appsOrderByWithRelationInput[]
    cursor?: appsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppsScalarFieldEnum | AppsScalarFieldEnum[]
  }

  /**
   * institution.business_amenities
   */
  export type institution$business_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    where?: business_amenitiesWhereInput
    orderBy?: business_amenitiesOrderByWithRelationInput | business_amenitiesOrderByWithRelationInput[]
    cursor?: business_amenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Business_amenitiesScalarFieldEnum | Business_amenitiesScalarFieldEnum[]
  }

  /**
   * institution.device
   */
  export type institution$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
    orderBy?: deviceOrderByWithRelationInput | deviceOrderByWithRelationInput[]
    cursor?: deviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * institution.images
   */
  export type institution$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * institution.categories
   */
  export type institution$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * institution.popup_questions
   */
  export type institution$popup_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    where?: popup_questionsWhereInput
    orderBy?: popup_questionsOrderByWithRelationInput | popup_questionsOrderByWithRelationInput[]
    cursor?: popup_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Popup_questionsScalarFieldEnum | Popup_questionsScalarFieldEnum[]
  }

  /**
   * institution.price_ranges
   */
  export type institution$price_rangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    where?: price_rangesWhereInput
    orderBy?: price_rangesOrderByWithRelationInput | price_rangesOrderByWithRelationInput[]
    cursor?: price_rangesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Price_rangesScalarFieldEnum | Price_rangesScalarFieldEnum[]
  }

  /**
   * institution.qms_branch_operator
   */
  export type institution$qms_branch_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    where?: qms_branch_operatorWhereInput
    orderBy?: qms_branch_operatorOrderByWithRelationInput | qms_branch_operatorOrderByWithRelationInput[]
    cursor?: qms_branch_operatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_branch_operatorScalarFieldEnum | Qms_branch_operatorScalarFieldEnum[]
  }

  /**
   * institution.qms_branch_transactions
   */
  export type institution$qms_branch_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    where?: qms_branch_transactionsWhereInput
    orderBy?: qms_branch_transactionsOrderByWithRelationInput | qms_branch_transactionsOrderByWithRelationInput[]
    cursor?: qms_branch_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_branch_transactionsScalarFieldEnum | Qms_branch_transactionsScalarFieldEnum[]
  }

  /**
   * institution.qms_operator
   */
  export type institution$qms_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    where?: qms_operatorWhereInput
    orderBy?: qms_operatorOrderByWithRelationInput | qms_operatorOrderByWithRelationInput[]
    cursor?: qms_operatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_operatorScalarFieldEnum | Qms_operatorScalarFieldEnum[]
  }

  /**
   * institution.reviews
   */
  export type institution$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * institution.service
   */
  export type institution$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    cursor?: serviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * institution.service_group
   */
  export type institution$service_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    where?: service_groupWhereInput
    orderBy?: service_groupOrderByWithRelationInput | service_groupOrderByWithRelationInput[]
    cursor?: service_groupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_groupScalarFieldEnum | Service_groupScalarFieldEnum[]
  }

  /**
   * institution.workingHour
   */
  export type institution$workingHourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    where?: workingHourWhereInput
    orderBy?: workingHourOrderByWithRelationInput | workingHourOrderByWithRelationInput[]
    cursor?: workingHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkingHourScalarFieldEnum | WorkingHourScalarFieldEnum[]
  }

  /**
   * institution without action
   */
  export type institutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
  }


  /**
   * Model institution_invoices
   */

  export type AggregateInstitution_invoices = {
    _count: Institution_invoicesCountAggregateOutputType | null
    _avg: Institution_invoicesAvgAggregateOutputType | null
    _sum: Institution_invoicesSumAggregateOutputType | null
    _min: Institution_invoicesMinAggregateOutputType | null
    _max: Institution_invoicesMaxAggregateOutputType | null
  }

  export type Institution_invoicesAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    payment_retries: number | null
    total_amount: number | null
  }

  export type Institution_invoicesSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    payment_retries: number | null
    total_amount: number | null
  }

  export type Institution_invoicesMinAggregateOutputType = {
    id: number | null
    invoice_number: string | null
    institution_id: number | null
    institution_name: string | null
    period_start: Date | null
    period_end: Date | null
    generated_at: Date | null
    expiry: Date | null
    payment_reference_number: string | null
    ext_payment_reference_number: string | null
    payment_status: $Enums.institution_invoices_payment_status | null
    payment_status_desc: string | null
    payment_method: string | null
    payment_retries: number | null
    status: $Enums.institution_invoices_status | null
    total_amount: number | null
  }

  export type Institution_invoicesMaxAggregateOutputType = {
    id: number | null
    invoice_number: string | null
    institution_id: number | null
    institution_name: string | null
    period_start: Date | null
    period_end: Date | null
    generated_at: Date | null
    expiry: Date | null
    payment_reference_number: string | null
    ext_payment_reference_number: string | null
    payment_status: $Enums.institution_invoices_payment_status | null
    payment_status_desc: string | null
    payment_method: string | null
    payment_retries: number | null
    status: $Enums.institution_invoices_status | null
    total_amount: number | null
  }

  export type Institution_invoicesCountAggregateOutputType = {
    id: number
    invoice_number: number
    institution_id: number
    institution_name: number
    period_start: number
    period_end: number
    generated_at: number
    expiry: number
    payment_reference_number: number
    ext_payment_reference_number: number
    payment_status: number
    payment_status_desc: number
    payment_method: number
    payment_retries: number
    status: number
    total_amount: number
    _all: number
  }


  export type Institution_invoicesAvgAggregateInputType = {
    id?: true
    institution_id?: true
    payment_retries?: true
    total_amount?: true
  }

  export type Institution_invoicesSumAggregateInputType = {
    id?: true
    institution_id?: true
    payment_retries?: true
    total_amount?: true
  }

  export type Institution_invoicesMinAggregateInputType = {
    id?: true
    invoice_number?: true
    institution_id?: true
    institution_name?: true
    period_start?: true
    period_end?: true
    generated_at?: true
    expiry?: true
    payment_reference_number?: true
    ext_payment_reference_number?: true
    payment_status?: true
    payment_status_desc?: true
    payment_method?: true
    payment_retries?: true
    status?: true
    total_amount?: true
  }

  export type Institution_invoicesMaxAggregateInputType = {
    id?: true
    invoice_number?: true
    institution_id?: true
    institution_name?: true
    period_start?: true
    period_end?: true
    generated_at?: true
    expiry?: true
    payment_reference_number?: true
    ext_payment_reference_number?: true
    payment_status?: true
    payment_status_desc?: true
    payment_method?: true
    payment_retries?: true
    status?: true
    total_amount?: true
  }

  export type Institution_invoicesCountAggregateInputType = {
    id?: true
    invoice_number?: true
    institution_id?: true
    institution_name?: true
    period_start?: true
    period_end?: true
    generated_at?: true
    expiry?: true
    payment_reference_number?: true
    ext_payment_reference_number?: true
    payment_status?: true
    payment_status_desc?: true
    payment_method?: true
    payment_retries?: true
    status?: true
    total_amount?: true
    _all?: true
  }

  export type Institution_invoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institution_invoices to aggregate.
     */
    where?: institution_invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_invoices to fetch.
     */
    orderBy?: institution_invoicesOrderByWithRelationInput | institution_invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: institution_invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned institution_invoices
    **/
    _count?: true | Institution_invoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Institution_invoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Institution_invoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Institution_invoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Institution_invoicesMaxAggregateInputType
  }

  export type GetInstitution_invoicesAggregateType<T extends Institution_invoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution_invoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution_invoices[P]>
      : GetScalarType<T[P], AggregateInstitution_invoices[P]>
  }




  export type institution_invoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institution_invoicesWhereInput
    orderBy?: institution_invoicesOrderByWithAggregationInput | institution_invoicesOrderByWithAggregationInput[]
    by: Institution_invoicesScalarFieldEnum[] | Institution_invoicesScalarFieldEnum
    having?: institution_invoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Institution_invoicesCountAggregateInputType | true
    _avg?: Institution_invoicesAvgAggregateInputType
    _sum?: Institution_invoicesSumAggregateInputType
    _min?: Institution_invoicesMinAggregateInputType
    _max?: Institution_invoicesMaxAggregateInputType
  }

  export type Institution_invoicesGroupByOutputType = {
    id: number
    invoice_number: string
    institution_id: number
    institution_name: string
    period_start: Date
    period_end: Date
    generated_at: Date
    expiry: Date
    payment_reference_number: string
    ext_payment_reference_number: string | null
    payment_status: $Enums.institution_invoices_payment_status
    payment_status_desc: string | null
    payment_method: string | null
    payment_retries: number | null
    status: $Enums.institution_invoices_status
    total_amount: number | null
    _count: Institution_invoicesCountAggregateOutputType | null
    _avg: Institution_invoicesAvgAggregateOutputType | null
    _sum: Institution_invoicesSumAggregateOutputType | null
    _min: Institution_invoicesMinAggregateOutputType | null
    _max: Institution_invoicesMaxAggregateOutputType | null
  }

  type GetInstitution_invoicesGroupByPayload<T extends institution_invoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Institution_invoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Institution_invoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Institution_invoicesGroupByOutputType[P]>
            : GetScalarType<T[P], Institution_invoicesGroupByOutputType[P]>
        }
      >
    >


  export type institution_invoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    institution_id?: boolean
    institution_name?: boolean
    period_start?: boolean
    period_end?: boolean
    generated_at?: boolean
    expiry?: boolean
    payment_reference_number?: boolean
    ext_payment_reference_number?: boolean
    payment_status?: boolean
    payment_status_desc?: boolean
    payment_method?: boolean
    payment_retries?: boolean
    status?: boolean
    total_amount?: boolean
  }, ExtArgs["result"]["institution_invoices"]>



  export type institution_invoicesSelectScalar = {
    id?: boolean
    invoice_number?: boolean
    institution_id?: boolean
    institution_name?: boolean
    period_start?: boolean
    period_end?: boolean
    generated_at?: boolean
    expiry?: boolean
    payment_reference_number?: boolean
    ext_payment_reference_number?: boolean
    payment_status?: boolean
    payment_status_desc?: boolean
    payment_method?: boolean
    payment_retries?: boolean
    status?: boolean
    total_amount?: boolean
  }

  export type institution_invoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_number" | "institution_id" | "institution_name" | "period_start" | "period_end" | "generated_at" | "expiry" | "payment_reference_number" | "ext_payment_reference_number" | "payment_status" | "payment_status_desc" | "payment_method" | "payment_retries" | "status" | "total_amount", ExtArgs["result"]["institution_invoices"]>

  export type $institution_invoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "institution_invoices"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoice_number: string
      institution_id: number
      institution_name: string
      period_start: Date
      period_end: Date
      generated_at: Date
      expiry: Date
      payment_reference_number: string
      ext_payment_reference_number: string | null
      payment_status: $Enums.institution_invoices_payment_status
      payment_status_desc: string | null
      payment_method: string | null
      payment_retries: number | null
      status: $Enums.institution_invoices_status
      total_amount: number | null
    }, ExtArgs["result"]["institution_invoices"]>
    composites: {}
  }

  type institution_invoicesGetPayload<S extends boolean | null | undefined | institution_invoicesDefaultArgs> = $Result.GetResult<Prisma.$institution_invoicesPayload, S>

  type institution_invoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<institution_invoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Institution_invoicesCountAggregateInputType | true
    }

  export interface institution_invoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['institution_invoices'], meta: { name: 'institution_invoices' } }
    /**
     * Find zero or one Institution_invoices that matches the filter.
     * @param {institution_invoicesFindUniqueArgs} args - Arguments to find a Institution_invoices
     * @example
     * // Get one Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends institution_invoicesFindUniqueArgs>(args: SelectSubset<T, institution_invoicesFindUniqueArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution_invoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {institution_invoicesFindUniqueOrThrowArgs} args - Arguments to find a Institution_invoices
     * @example
     * // Get one Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends institution_invoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, institution_invoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution_invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_invoicesFindFirstArgs} args - Arguments to find a Institution_invoices
     * @example
     * // Get one Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends institution_invoicesFindFirstArgs>(args?: SelectSubset<T, institution_invoicesFindFirstArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution_invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_invoicesFindFirstOrThrowArgs} args - Arguments to find a Institution_invoices
     * @example
     * // Get one Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends institution_invoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, institution_invoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institution_invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_invoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.findMany()
     * 
     * // Get first 10 Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institution_invoicesWithIdOnly = await prisma.institution_invoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends institution_invoicesFindManyArgs>(args?: SelectSubset<T, institution_invoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution_invoices.
     * @param {institution_invoicesCreateArgs} args - Arguments to create a Institution_invoices.
     * @example
     * // Create one Institution_invoices
     * const Institution_invoices = await prisma.institution_invoices.create({
     *   data: {
     *     // ... data to create a Institution_invoices
     *   }
     * })
     * 
     */
    create<T extends institution_invoicesCreateArgs>(args: SelectSubset<T, institution_invoicesCreateArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institution_invoices.
     * @param {institution_invoicesCreateManyArgs} args - Arguments to create many Institution_invoices.
     * @example
     * // Create many Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends institution_invoicesCreateManyArgs>(args?: SelectSubset<T, institution_invoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institution_invoices.
     * @param {institution_invoicesDeleteArgs} args - Arguments to delete one Institution_invoices.
     * @example
     * // Delete one Institution_invoices
     * const Institution_invoices = await prisma.institution_invoices.delete({
     *   where: {
     *     // ... filter to delete one Institution_invoices
     *   }
     * })
     * 
     */
    delete<T extends institution_invoicesDeleteArgs>(args: SelectSubset<T, institution_invoicesDeleteArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution_invoices.
     * @param {institution_invoicesUpdateArgs} args - Arguments to update one Institution_invoices.
     * @example
     * // Update one Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends institution_invoicesUpdateArgs>(args: SelectSubset<T, institution_invoicesUpdateArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institution_invoices.
     * @param {institution_invoicesDeleteManyArgs} args - Arguments to filter Institution_invoices to delete.
     * @example
     * // Delete a few Institution_invoices
     * const { count } = await prisma.institution_invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends institution_invoicesDeleteManyArgs>(args?: SelectSubset<T, institution_invoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institution_invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_invoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends institution_invoicesUpdateManyArgs>(args: SelectSubset<T, institution_invoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institution_invoices.
     * @param {institution_invoicesUpsertArgs} args - Arguments to update or create a Institution_invoices.
     * @example
     * // Update or create a Institution_invoices
     * const institution_invoices = await prisma.institution_invoices.upsert({
     *   create: {
     *     // ... data to create a Institution_invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution_invoices we want to update
     *   }
     * })
     */
    upsert<T extends institution_invoicesUpsertArgs>(args: SelectSubset<T, institution_invoicesUpsertArgs<ExtArgs>>): Prisma__institution_invoicesClient<$Result.GetResult<Prisma.$institution_invoicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institution_invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_invoicesCountArgs} args - Arguments to filter Institution_invoices to count.
     * @example
     * // Count the number of Institution_invoices
     * const count = await prisma.institution_invoices.count({
     *   where: {
     *     // ... the filter for the Institution_invoices we want to count
     *   }
     * })
    **/
    count<T extends institution_invoicesCountArgs>(
      args?: Subset<T, institution_invoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Institution_invoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution_invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Institution_invoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Institution_invoicesAggregateArgs>(args: Subset<T, Institution_invoicesAggregateArgs>): Prisma.PrismaPromise<GetInstitution_invoicesAggregateType<T>>

    /**
     * Group by Institution_invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_invoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends institution_invoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: institution_invoicesGroupByArgs['orderBy'] }
        : { orderBy?: institution_invoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, institution_invoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitution_invoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the institution_invoices model
   */
  readonly fields: institution_invoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for institution_invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__institution_invoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the institution_invoices model
   */
  interface institution_invoicesFieldRefs {
    readonly id: FieldRef<"institution_invoices", 'Int'>
    readonly invoice_number: FieldRef<"institution_invoices", 'String'>
    readonly institution_id: FieldRef<"institution_invoices", 'Int'>
    readonly institution_name: FieldRef<"institution_invoices", 'String'>
    readonly period_start: FieldRef<"institution_invoices", 'DateTime'>
    readonly period_end: FieldRef<"institution_invoices", 'DateTime'>
    readonly generated_at: FieldRef<"institution_invoices", 'DateTime'>
    readonly expiry: FieldRef<"institution_invoices", 'DateTime'>
    readonly payment_reference_number: FieldRef<"institution_invoices", 'String'>
    readonly ext_payment_reference_number: FieldRef<"institution_invoices", 'String'>
    readonly payment_status: FieldRef<"institution_invoices", 'institution_invoices_payment_status'>
    readonly payment_status_desc: FieldRef<"institution_invoices", 'String'>
    readonly payment_method: FieldRef<"institution_invoices", 'String'>
    readonly payment_retries: FieldRef<"institution_invoices", 'Int'>
    readonly status: FieldRef<"institution_invoices", 'institution_invoices_status'>
    readonly total_amount: FieldRef<"institution_invoices", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * institution_invoices findUnique
   */
  export type institution_invoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * Filter, which institution_invoices to fetch.
     */
    where: institution_invoicesWhereUniqueInput
  }

  /**
   * institution_invoices findUniqueOrThrow
   */
  export type institution_invoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * Filter, which institution_invoices to fetch.
     */
    where: institution_invoicesWhereUniqueInput
  }

  /**
   * institution_invoices findFirst
   */
  export type institution_invoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * Filter, which institution_invoices to fetch.
     */
    where?: institution_invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_invoices to fetch.
     */
    orderBy?: institution_invoicesOrderByWithRelationInput | institution_invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institution_invoices.
     */
    cursor?: institution_invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institution_invoices.
     */
    distinct?: Institution_invoicesScalarFieldEnum | Institution_invoicesScalarFieldEnum[]
  }

  /**
   * institution_invoices findFirstOrThrow
   */
  export type institution_invoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * Filter, which institution_invoices to fetch.
     */
    where?: institution_invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_invoices to fetch.
     */
    orderBy?: institution_invoicesOrderByWithRelationInput | institution_invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institution_invoices.
     */
    cursor?: institution_invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institution_invoices.
     */
    distinct?: Institution_invoicesScalarFieldEnum | Institution_invoicesScalarFieldEnum[]
  }

  /**
   * institution_invoices findMany
   */
  export type institution_invoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * Filter, which institution_invoices to fetch.
     */
    where?: institution_invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_invoices to fetch.
     */
    orderBy?: institution_invoicesOrderByWithRelationInput | institution_invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing institution_invoices.
     */
    cursor?: institution_invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_invoices.
     */
    skip?: number
    distinct?: Institution_invoicesScalarFieldEnum | Institution_invoicesScalarFieldEnum[]
  }

  /**
   * institution_invoices create
   */
  export type institution_invoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * The data needed to create a institution_invoices.
     */
    data: XOR<institution_invoicesCreateInput, institution_invoicesUncheckedCreateInput>
  }

  /**
   * institution_invoices createMany
   */
  export type institution_invoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many institution_invoices.
     */
    data: institution_invoicesCreateManyInput | institution_invoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * institution_invoices update
   */
  export type institution_invoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * The data needed to update a institution_invoices.
     */
    data: XOR<institution_invoicesUpdateInput, institution_invoicesUncheckedUpdateInput>
    /**
     * Choose, which institution_invoices to update.
     */
    where: institution_invoicesWhereUniqueInput
  }

  /**
   * institution_invoices updateMany
   */
  export type institution_invoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update institution_invoices.
     */
    data: XOR<institution_invoicesUpdateManyMutationInput, institution_invoicesUncheckedUpdateManyInput>
    /**
     * Filter which institution_invoices to update
     */
    where?: institution_invoicesWhereInput
    /**
     * Limit how many institution_invoices to update.
     */
    limit?: number
  }

  /**
   * institution_invoices upsert
   */
  export type institution_invoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * The filter to search for the institution_invoices to update in case it exists.
     */
    where: institution_invoicesWhereUniqueInput
    /**
     * In case the institution_invoices found by the `where` argument doesn't exist, create a new institution_invoices with this data.
     */
    create: XOR<institution_invoicesCreateInput, institution_invoicesUncheckedCreateInput>
    /**
     * In case the institution_invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<institution_invoicesUpdateInput, institution_invoicesUncheckedUpdateInput>
  }

  /**
   * institution_invoices delete
   */
  export type institution_invoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
    /**
     * Filter which institution_invoices to delete.
     */
    where: institution_invoicesWhereUniqueInput
  }

  /**
   * institution_invoices deleteMany
   */
  export type institution_invoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institution_invoices to delete
     */
    where?: institution_invoicesWhereInput
    /**
     * Limit how many institution_invoices to delete.
     */
    limit?: number
  }

  /**
   * institution_invoices without action
   */
  export type institution_invoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_invoices
     */
    select?: institution_invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_invoices
     */
    omit?: institution_invoicesOmit<ExtArgs> | null
  }


  /**
   * Model institution_service_tracking
   */

  export type AggregateInstitution_service_tracking = {
    _count: Institution_service_trackingCountAggregateOutputType | null
    _avg: Institution_service_trackingAvgAggregateOutputType | null
    _sum: Institution_service_trackingSumAggregateOutputType | null
    _min: Institution_service_trackingMinAggregateOutputType | null
    _max: Institution_service_trackingMaxAggregateOutputType | null
  }

  export type Institution_service_trackingAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    branch_id: number | null
    service_id: number | null
  }

  export type Institution_service_trackingSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    branch_id: number | null
    service_id: number | null
  }

  export type Institution_service_trackingMinAggregateOutputType = {
    id: number | null
    institution_id: number | null
    branch_id: number | null
    service_id: number | null
    branch_name: string | null
    service_group_name: string | null
    time: Date | null
    action: boolean | null
    status: boolean | null
    invoice_number: string | null
  }

  export type Institution_service_trackingMaxAggregateOutputType = {
    id: number | null
    institution_id: number | null
    branch_id: number | null
    service_id: number | null
    branch_name: string | null
    service_group_name: string | null
    time: Date | null
    action: boolean | null
    status: boolean | null
    invoice_number: string | null
  }

  export type Institution_service_trackingCountAggregateOutputType = {
    id: number
    institution_id: number
    branch_id: number
    service_id: number
    branch_name: number
    service_group_name: number
    time: number
    action: number
    status: number
    invoice_number: number
    _all: number
  }


  export type Institution_service_trackingAvgAggregateInputType = {
    id?: true
    institution_id?: true
    branch_id?: true
    service_id?: true
  }

  export type Institution_service_trackingSumAggregateInputType = {
    id?: true
    institution_id?: true
    branch_id?: true
    service_id?: true
  }

  export type Institution_service_trackingMinAggregateInputType = {
    id?: true
    institution_id?: true
    branch_id?: true
    service_id?: true
    branch_name?: true
    service_group_name?: true
    time?: true
    action?: true
    status?: true
    invoice_number?: true
  }

  export type Institution_service_trackingMaxAggregateInputType = {
    id?: true
    institution_id?: true
    branch_id?: true
    service_id?: true
    branch_name?: true
    service_group_name?: true
    time?: true
    action?: true
    status?: true
    invoice_number?: true
  }

  export type Institution_service_trackingCountAggregateInputType = {
    id?: true
    institution_id?: true
    branch_id?: true
    service_id?: true
    branch_name?: true
    service_group_name?: true
    time?: true
    action?: true
    status?: true
    invoice_number?: true
    _all?: true
  }

  export type Institution_service_trackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institution_service_tracking to aggregate.
     */
    where?: institution_service_trackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_service_trackings to fetch.
     */
    orderBy?: institution_service_trackingOrderByWithRelationInput | institution_service_trackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: institution_service_trackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_service_trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_service_trackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned institution_service_trackings
    **/
    _count?: true | Institution_service_trackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Institution_service_trackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Institution_service_trackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Institution_service_trackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Institution_service_trackingMaxAggregateInputType
  }

  export type GetInstitution_service_trackingAggregateType<T extends Institution_service_trackingAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution_service_tracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution_service_tracking[P]>
      : GetScalarType<T[P], AggregateInstitution_service_tracking[P]>
  }




  export type institution_service_trackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institution_service_trackingWhereInput
    orderBy?: institution_service_trackingOrderByWithAggregationInput | institution_service_trackingOrderByWithAggregationInput[]
    by: Institution_service_trackingScalarFieldEnum[] | Institution_service_trackingScalarFieldEnum
    having?: institution_service_trackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Institution_service_trackingCountAggregateInputType | true
    _avg?: Institution_service_trackingAvgAggregateInputType
    _sum?: Institution_service_trackingSumAggregateInputType
    _min?: Institution_service_trackingMinAggregateInputType
    _max?: Institution_service_trackingMaxAggregateInputType
  }

  export type Institution_service_trackingGroupByOutputType = {
    id: number
    institution_id: number | null
    branch_id: number | null
    service_id: number | null
    branch_name: string | null
    service_group_name: string | null
    time: Date
    action: boolean | null
    status: boolean | null
    invoice_number: string | null
    _count: Institution_service_trackingCountAggregateOutputType | null
    _avg: Institution_service_trackingAvgAggregateOutputType | null
    _sum: Institution_service_trackingSumAggregateOutputType | null
    _min: Institution_service_trackingMinAggregateOutputType | null
    _max: Institution_service_trackingMaxAggregateOutputType | null
  }

  type GetInstitution_service_trackingGroupByPayload<T extends institution_service_trackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Institution_service_trackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Institution_service_trackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Institution_service_trackingGroupByOutputType[P]>
            : GetScalarType<T[P], Institution_service_trackingGroupByOutputType[P]>
        }
      >
    >


  export type institution_service_trackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution_id?: boolean
    branch_id?: boolean
    service_id?: boolean
    branch_name?: boolean
    service_group_name?: boolean
    time?: boolean
    action?: boolean
    status?: boolean
    invoice_number?: boolean
  }, ExtArgs["result"]["institution_service_tracking"]>



  export type institution_service_trackingSelectScalar = {
    id?: boolean
    institution_id?: boolean
    branch_id?: boolean
    service_id?: boolean
    branch_name?: boolean
    service_group_name?: boolean
    time?: boolean
    action?: boolean
    status?: boolean
    invoice_number?: boolean
  }

  export type institution_service_trackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution_id" | "branch_id" | "service_id" | "branch_name" | "service_group_name" | "time" | "action" | "status" | "invoice_number", ExtArgs["result"]["institution_service_tracking"]>

  export type $institution_service_trackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "institution_service_tracking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institution_id: number | null
      branch_id: number | null
      service_id: number | null
      branch_name: string | null
      service_group_name: string | null
      time: Date
      action: boolean | null
      status: boolean | null
      invoice_number: string | null
    }, ExtArgs["result"]["institution_service_tracking"]>
    composites: {}
  }

  type institution_service_trackingGetPayload<S extends boolean | null | undefined | institution_service_trackingDefaultArgs> = $Result.GetResult<Prisma.$institution_service_trackingPayload, S>

  type institution_service_trackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<institution_service_trackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Institution_service_trackingCountAggregateInputType | true
    }

  export interface institution_service_trackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['institution_service_tracking'], meta: { name: 'institution_service_tracking' } }
    /**
     * Find zero or one Institution_service_tracking that matches the filter.
     * @param {institution_service_trackingFindUniqueArgs} args - Arguments to find a Institution_service_tracking
     * @example
     * // Get one Institution_service_tracking
     * const institution_service_tracking = await prisma.institution_service_tracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends institution_service_trackingFindUniqueArgs>(args: SelectSubset<T, institution_service_trackingFindUniqueArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution_service_tracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {institution_service_trackingFindUniqueOrThrowArgs} args - Arguments to find a Institution_service_tracking
     * @example
     * // Get one Institution_service_tracking
     * const institution_service_tracking = await prisma.institution_service_tracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends institution_service_trackingFindUniqueOrThrowArgs>(args: SelectSubset<T, institution_service_trackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution_service_tracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_service_trackingFindFirstArgs} args - Arguments to find a Institution_service_tracking
     * @example
     * // Get one Institution_service_tracking
     * const institution_service_tracking = await prisma.institution_service_tracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends institution_service_trackingFindFirstArgs>(args?: SelectSubset<T, institution_service_trackingFindFirstArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution_service_tracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_service_trackingFindFirstOrThrowArgs} args - Arguments to find a Institution_service_tracking
     * @example
     * // Get one Institution_service_tracking
     * const institution_service_tracking = await prisma.institution_service_tracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends institution_service_trackingFindFirstOrThrowArgs>(args?: SelectSubset<T, institution_service_trackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institution_service_trackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_service_trackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institution_service_trackings
     * const institution_service_trackings = await prisma.institution_service_tracking.findMany()
     * 
     * // Get first 10 Institution_service_trackings
     * const institution_service_trackings = await prisma.institution_service_tracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institution_service_trackingWithIdOnly = await prisma.institution_service_tracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends institution_service_trackingFindManyArgs>(args?: SelectSubset<T, institution_service_trackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution_service_tracking.
     * @param {institution_service_trackingCreateArgs} args - Arguments to create a Institution_service_tracking.
     * @example
     * // Create one Institution_service_tracking
     * const Institution_service_tracking = await prisma.institution_service_tracking.create({
     *   data: {
     *     // ... data to create a Institution_service_tracking
     *   }
     * })
     * 
     */
    create<T extends institution_service_trackingCreateArgs>(args: SelectSubset<T, institution_service_trackingCreateArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institution_service_trackings.
     * @param {institution_service_trackingCreateManyArgs} args - Arguments to create many Institution_service_trackings.
     * @example
     * // Create many Institution_service_trackings
     * const institution_service_tracking = await prisma.institution_service_tracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends institution_service_trackingCreateManyArgs>(args?: SelectSubset<T, institution_service_trackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institution_service_tracking.
     * @param {institution_service_trackingDeleteArgs} args - Arguments to delete one Institution_service_tracking.
     * @example
     * // Delete one Institution_service_tracking
     * const Institution_service_tracking = await prisma.institution_service_tracking.delete({
     *   where: {
     *     // ... filter to delete one Institution_service_tracking
     *   }
     * })
     * 
     */
    delete<T extends institution_service_trackingDeleteArgs>(args: SelectSubset<T, institution_service_trackingDeleteArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution_service_tracking.
     * @param {institution_service_trackingUpdateArgs} args - Arguments to update one Institution_service_tracking.
     * @example
     * // Update one Institution_service_tracking
     * const institution_service_tracking = await prisma.institution_service_tracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends institution_service_trackingUpdateArgs>(args: SelectSubset<T, institution_service_trackingUpdateArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institution_service_trackings.
     * @param {institution_service_trackingDeleteManyArgs} args - Arguments to filter Institution_service_trackings to delete.
     * @example
     * // Delete a few Institution_service_trackings
     * const { count } = await prisma.institution_service_tracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends institution_service_trackingDeleteManyArgs>(args?: SelectSubset<T, institution_service_trackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institution_service_trackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_service_trackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institution_service_trackings
     * const institution_service_tracking = await prisma.institution_service_tracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends institution_service_trackingUpdateManyArgs>(args: SelectSubset<T, institution_service_trackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institution_service_tracking.
     * @param {institution_service_trackingUpsertArgs} args - Arguments to update or create a Institution_service_tracking.
     * @example
     * // Update or create a Institution_service_tracking
     * const institution_service_tracking = await prisma.institution_service_tracking.upsert({
     *   create: {
     *     // ... data to create a Institution_service_tracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution_service_tracking we want to update
     *   }
     * })
     */
    upsert<T extends institution_service_trackingUpsertArgs>(args: SelectSubset<T, institution_service_trackingUpsertArgs<ExtArgs>>): Prisma__institution_service_trackingClient<$Result.GetResult<Prisma.$institution_service_trackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institution_service_trackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_service_trackingCountArgs} args - Arguments to filter Institution_service_trackings to count.
     * @example
     * // Count the number of Institution_service_trackings
     * const count = await prisma.institution_service_tracking.count({
     *   where: {
     *     // ... the filter for the Institution_service_trackings we want to count
     *   }
     * })
    **/
    count<T extends institution_service_trackingCountArgs>(
      args?: Subset<T, institution_service_trackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Institution_service_trackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution_service_tracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Institution_service_trackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Institution_service_trackingAggregateArgs>(args: Subset<T, Institution_service_trackingAggregateArgs>): Prisma.PrismaPromise<GetInstitution_service_trackingAggregateType<T>>

    /**
     * Group by Institution_service_tracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institution_service_trackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends institution_service_trackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: institution_service_trackingGroupByArgs['orderBy'] }
        : { orderBy?: institution_service_trackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, institution_service_trackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitution_service_trackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the institution_service_tracking model
   */
  readonly fields: institution_service_trackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for institution_service_tracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__institution_service_trackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the institution_service_tracking model
   */
  interface institution_service_trackingFieldRefs {
    readonly id: FieldRef<"institution_service_tracking", 'Int'>
    readonly institution_id: FieldRef<"institution_service_tracking", 'Int'>
    readonly branch_id: FieldRef<"institution_service_tracking", 'Int'>
    readonly service_id: FieldRef<"institution_service_tracking", 'Int'>
    readonly branch_name: FieldRef<"institution_service_tracking", 'String'>
    readonly service_group_name: FieldRef<"institution_service_tracking", 'String'>
    readonly time: FieldRef<"institution_service_tracking", 'DateTime'>
    readonly action: FieldRef<"institution_service_tracking", 'Boolean'>
    readonly status: FieldRef<"institution_service_tracking", 'Boolean'>
    readonly invoice_number: FieldRef<"institution_service_tracking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * institution_service_tracking findUnique
   */
  export type institution_service_trackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * Filter, which institution_service_tracking to fetch.
     */
    where: institution_service_trackingWhereUniqueInput
  }

  /**
   * institution_service_tracking findUniqueOrThrow
   */
  export type institution_service_trackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * Filter, which institution_service_tracking to fetch.
     */
    where: institution_service_trackingWhereUniqueInput
  }

  /**
   * institution_service_tracking findFirst
   */
  export type institution_service_trackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * Filter, which institution_service_tracking to fetch.
     */
    where?: institution_service_trackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_service_trackings to fetch.
     */
    orderBy?: institution_service_trackingOrderByWithRelationInput | institution_service_trackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institution_service_trackings.
     */
    cursor?: institution_service_trackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_service_trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_service_trackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institution_service_trackings.
     */
    distinct?: Institution_service_trackingScalarFieldEnum | Institution_service_trackingScalarFieldEnum[]
  }

  /**
   * institution_service_tracking findFirstOrThrow
   */
  export type institution_service_trackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * Filter, which institution_service_tracking to fetch.
     */
    where?: institution_service_trackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_service_trackings to fetch.
     */
    orderBy?: institution_service_trackingOrderByWithRelationInput | institution_service_trackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institution_service_trackings.
     */
    cursor?: institution_service_trackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_service_trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_service_trackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institution_service_trackings.
     */
    distinct?: Institution_service_trackingScalarFieldEnum | Institution_service_trackingScalarFieldEnum[]
  }

  /**
   * institution_service_tracking findMany
   */
  export type institution_service_trackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * Filter, which institution_service_trackings to fetch.
     */
    where?: institution_service_trackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institution_service_trackings to fetch.
     */
    orderBy?: institution_service_trackingOrderByWithRelationInput | institution_service_trackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing institution_service_trackings.
     */
    cursor?: institution_service_trackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institution_service_trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institution_service_trackings.
     */
    skip?: number
    distinct?: Institution_service_trackingScalarFieldEnum | Institution_service_trackingScalarFieldEnum[]
  }

  /**
   * institution_service_tracking create
   */
  export type institution_service_trackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * The data needed to create a institution_service_tracking.
     */
    data?: XOR<institution_service_trackingCreateInput, institution_service_trackingUncheckedCreateInput>
  }

  /**
   * institution_service_tracking createMany
   */
  export type institution_service_trackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many institution_service_trackings.
     */
    data: institution_service_trackingCreateManyInput | institution_service_trackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * institution_service_tracking update
   */
  export type institution_service_trackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * The data needed to update a institution_service_tracking.
     */
    data: XOR<institution_service_trackingUpdateInput, institution_service_trackingUncheckedUpdateInput>
    /**
     * Choose, which institution_service_tracking to update.
     */
    where: institution_service_trackingWhereUniqueInput
  }

  /**
   * institution_service_tracking updateMany
   */
  export type institution_service_trackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update institution_service_trackings.
     */
    data: XOR<institution_service_trackingUpdateManyMutationInput, institution_service_trackingUncheckedUpdateManyInput>
    /**
     * Filter which institution_service_trackings to update
     */
    where?: institution_service_trackingWhereInput
    /**
     * Limit how many institution_service_trackings to update.
     */
    limit?: number
  }

  /**
   * institution_service_tracking upsert
   */
  export type institution_service_trackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * The filter to search for the institution_service_tracking to update in case it exists.
     */
    where: institution_service_trackingWhereUniqueInput
    /**
     * In case the institution_service_tracking found by the `where` argument doesn't exist, create a new institution_service_tracking with this data.
     */
    create: XOR<institution_service_trackingCreateInput, institution_service_trackingUncheckedCreateInput>
    /**
     * In case the institution_service_tracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<institution_service_trackingUpdateInput, institution_service_trackingUncheckedUpdateInput>
  }

  /**
   * institution_service_tracking delete
   */
  export type institution_service_trackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
    /**
     * Filter which institution_service_tracking to delete.
     */
    where: institution_service_trackingWhereUniqueInput
  }

  /**
   * institution_service_tracking deleteMany
   */
  export type institution_service_trackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institution_service_trackings to delete
     */
    where?: institution_service_trackingWhereInput
    /**
     * Limit how many institution_service_trackings to delete.
     */
    limit?: number
  }

  /**
   * institution_service_tracking without action
   */
  export type institution_service_trackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution_service_tracking
     */
    select?: institution_service_trackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution_service_tracking
     */
    omit?: institution_service_trackingOmit<ExtArgs> | null
  }


  /**
   * Model login_history
   */

  export type AggregateLogin_history = {
    _count: Login_historyCountAggregateOutputType | null
    _avg: Login_historyAvgAggregateOutputType | null
    _sum: Login_historySumAggregateOutputType | null
    _min: Login_historyMinAggregateOutputType | null
    _max: Login_historyMaxAggregateOutputType | null
  }

  export type Login_historyAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Login_historySumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Login_historyMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    time: Date | null
  }

  export type Login_historyMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    ip: string | null
    user_agent: string | null
    time: Date | null
  }

  export type Login_historyCountAggregateOutputType = {
    id: number
    user_id: number
    ip: number
    user_agent: number
    time: number
    _all: number
  }


  export type Login_historyAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Login_historySumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Login_historyMinAggregateInputType = {
    id?: true
    user_id?: true
    ip?: true
    user_agent?: true
    time?: true
  }

  export type Login_historyMaxAggregateInputType = {
    id?: true
    user_id?: true
    ip?: true
    user_agent?: true
    time?: true
  }

  export type Login_historyCountAggregateInputType = {
    id?: true
    user_id?: true
    ip?: true
    user_agent?: true
    time?: true
    _all?: true
  }

  export type Login_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login_history to aggregate.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned login_histories
    **/
    _count?: true | Login_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Login_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Login_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Login_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Login_historyMaxAggregateInputType
  }

  export type GetLogin_historyAggregateType<T extends Login_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin_history[P]>
      : GetScalarType<T[P], AggregateLogin_history[P]>
  }




  export type login_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: login_historyWhereInput
    orderBy?: login_historyOrderByWithAggregationInput | login_historyOrderByWithAggregationInput[]
    by: Login_historyScalarFieldEnum[] | Login_historyScalarFieldEnum
    having?: login_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Login_historyCountAggregateInputType | true
    _avg?: Login_historyAvgAggregateInputType
    _sum?: Login_historySumAggregateInputType
    _min?: Login_historyMinAggregateInputType
    _max?: Login_historyMaxAggregateInputType
  }

  export type Login_historyGroupByOutputType = {
    id: number
    user_id: number | null
    ip: string | null
    user_agent: string | null
    time: Date
    _count: Login_historyCountAggregateOutputType | null
    _avg: Login_historyAvgAggregateOutputType | null
    _sum: Login_historySumAggregateOutputType | null
    _min: Login_historyMinAggregateOutputType | null
    _max: Login_historyMaxAggregateOutputType | null
  }

  type GetLogin_historyGroupByPayload<T extends login_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Login_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Login_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Login_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Login_historyGroupByOutputType[P]>
        }
      >
    >


  export type login_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    ip?: boolean
    user_agent?: boolean
    time?: boolean
  }, ExtArgs["result"]["login_history"]>



  export type login_historySelectScalar = {
    id?: boolean
    user_id?: boolean
    ip?: boolean
    user_agent?: boolean
    time?: boolean
  }

  export type login_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "ip" | "user_agent" | "time", ExtArgs["result"]["login_history"]>

  export type $login_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "login_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      ip: string | null
      user_agent: string | null
      time: Date
    }, ExtArgs["result"]["login_history"]>
    composites: {}
  }

  type login_historyGetPayload<S extends boolean | null | undefined | login_historyDefaultArgs> = $Result.GetResult<Prisma.$login_historyPayload, S>

  type login_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<login_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Login_historyCountAggregateInputType | true
    }

  export interface login_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['login_history'], meta: { name: 'login_history' } }
    /**
     * Find zero or one Login_history that matches the filter.
     * @param {login_historyFindUniqueArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends login_historyFindUniqueArgs>(args: SelectSubset<T, login_historyFindUniqueArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Login_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {login_historyFindUniqueOrThrowArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends login_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, login_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Login_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyFindFirstArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends login_historyFindFirstArgs>(args?: SelectSubset<T, login_historyFindFirstArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Login_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyFindFirstOrThrowArgs} args - Arguments to find a Login_history
     * @example
     * // Get one Login_history
     * const login_history = await prisma.login_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends login_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, login_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Login_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Login_histories
     * const login_histories = await prisma.login_history.findMany()
     * 
     * // Get first 10 Login_histories
     * const login_histories = await prisma.login_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const login_historyWithIdOnly = await prisma.login_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends login_historyFindManyArgs>(args?: SelectSubset<T, login_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Login_history.
     * @param {login_historyCreateArgs} args - Arguments to create a Login_history.
     * @example
     * // Create one Login_history
     * const Login_history = await prisma.login_history.create({
     *   data: {
     *     // ... data to create a Login_history
     *   }
     * })
     * 
     */
    create<T extends login_historyCreateArgs>(args: SelectSubset<T, login_historyCreateArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Login_histories.
     * @param {login_historyCreateManyArgs} args - Arguments to create many Login_histories.
     * @example
     * // Create many Login_histories
     * const login_history = await prisma.login_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends login_historyCreateManyArgs>(args?: SelectSubset<T, login_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Login_history.
     * @param {login_historyDeleteArgs} args - Arguments to delete one Login_history.
     * @example
     * // Delete one Login_history
     * const Login_history = await prisma.login_history.delete({
     *   where: {
     *     // ... filter to delete one Login_history
     *   }
     * })
     * 
     */
    delete<T extends login_historyDeleteArgs>(args: SelectSubset<T, login_historyDeleteArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Login_history.
     * @param {login_historyUpdateArgs} args - Arguments to update one Login_history.
     * @example
     * // Update one Login_history
     * const login_history = await prisma.login_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends login_historyUpdateArgs>(args: SelectSubset<T, login_historyUpdateArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Login_histories.
     * @param {login_historyDeleteManyArgs} args - Arguments to filter Login_histories to delete.
     * @example
     * // Delete a few Login_histories
     * const { count } = await prisma.login_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends login_historyDeleteManyArgs>(args?: SelectSubset<T, login_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Login_histories
     * const login_history = await prisma.login_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends login_historyUpdateManyArgs>(args: SelectSubset<T, login_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login_history.
     * @param {login_historyUpsertArgs} args - Arguments to update or create a Login_history.
     * @example
     * // Update or create a Login_history
     * const login_history = await prisma.login_history.upsert({
     *   create: {
     *     // ... data to create a Login_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login_history we want to update
     *   }
     * })
     */
    upsert<T extends login_historyUpsertArgs>(args: SelectSubset<T, login_historyUpsertArgs<ExtArgs>>): Prisma__login_historyClient<$Result.GetResult<Prisma.$login_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Login_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyCountArgs} args - Arguments to filter Login_histories to count.
     * @example
     * // Count the number of Login_histories
     * const count = await prisma.login_history.count({
     *   where: {
     *     // ... the filter for the Login_histories we want to count
     *   }
     * })
    **/
    count<T extends login_historyCountArgs>(
      args?: Subset<T, login_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Login_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Login_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Login_historyAggregateArgs>(args: Subset<T, Login_historyAggregateArgs>): Prisma.PrismaPromise<GetLogin_historyAggregateType<T>>

    /**
     * Group by Login_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {login_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends login_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: login_historyGroupByArgs['orderBy'] }
        : { orderBy?: login_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, login_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogin_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the login_history model
   */
  readonly fields: login_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for login_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__login_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the login_history model
   */
  interface login_historyFieldRefs {
    readonly id: FieldRef<"login_history", 'Int'>
    readonly user_id: FieldRef<"login_history", 'Int'>
    readonly ip: FieldRef<"login_history", 'String'>
    readonly user_agent: FieldRef<"login_history", 'String'>
    readonly time: FieldRef<"login_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * login_history findUnique
   */
  export type login_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history findUniqueOrThrow
   */
  export type login_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history findFirst
   */
  export type login_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for login_histories.
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of login_histories.
     */
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * login_history findFirstOrThrow
   */
  export type login_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * Filter, which login_history to fetch.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for login_histories.
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of login_histories.
     */
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * login_history findMany
   */
  export type login_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * Filter, which login_histories to fetch.
     */
    where?: login_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of login_histories to fetch.
     */
    orderBy?: login_historyOrderByWithRelationInput | login_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing login_histories.
     */
    cursor?: login_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` login_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` login_histories.
     */
    skip?: number
    distinct?: Login_historyScalarFieldEnum | Login_historyScalarFieldEnum[]
  }

  /**
   * login_history create
   */
  export type login_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a login_history.
     */
    data: XOR<login_historyCreateInput, login_historyUncheckedCreateInput>
  }

  /**
   * login_history createMany
   */
  export type login_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many login_histories.
     */
    data: login_historyCreateManyInput | login_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * login_history update
   */
  export type login_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a login_history.
     */
    data: XOR<login_historyUpdateInput, login_historyUncheckedUpdateInput>
    /**
     * Choose, which login_history to update.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history updateMany
   */
  export type login_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update login_histories.
     */
    data: XOR<login_historyUpdateManyMutationInput, login_historyUncheckedUpdateManyInput>
    /**
     * Filter which login_histories to update
     */
    where?: login_historyWhereInput
    /**
     * Limit how many login_histories to update.
     */
    limit?: number
  }

  /**
   * login_history upsert
   */
  export type login_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the login_history to update in case it exists.
     */
    where: login_historyWhereUniqueInput
    /**
     * In case the login_history found by the `where` argument doesn't exist, create a new login_history with this data.
     */
    create: XOR<login_historyCreateInput, login_historyUncheckedCreateInput>
    /**
     * In case the login_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<login_historyUpdateInput, login_historyUncheckedUpdateInput>
  }

  /**
   * login_history delete
   */
  export type login_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
    /**
     * Filter which login_history to delete.
     */
    where: login_historyWhereUniqueInput
  }

  /**
   * login_history deleteMany
   */
  export type login_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login_histories to delete
     */
    where?: login_historyWhereInput
    /**
     * Limit how many login_histories to delete.
     */
    limit?: number
  }

  /**
   * login_history without action
   */
  export type login_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login_history
     */
    select?: login_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the login_history
     */
    omit?: login_historyOmit<ExtArgs> | null
  }


  /**
   * Model migration
   */

  export type AggregateMigration = {
    _count: MigrationCountAggregateOutputType | null
    _avg: MigrationAvgAggregateOutputType | null
    _sum: MigrationSumAggregateOutputType | null
    _min: MigrationMinAggregateOutputType | null
    _max: MigrationMaxAggregateOutputType | null
  }

  export type MigrationAvgAggregateOutputType = {
    apply_time: number | null
  }

  export type MigrationSumAggregateOutputType = {
    apply_time: number | null
  }

  export type MigrationMinAggregateOutputType = {
    version: string | null
    apply_time: number | null
  }

  export type MigrationMaxAggregateOutputType = {
    version: string | null
    apply_time: number | null
  }

  export type MigrationCountAggregateOutputType = {
    version: number
    apply_time: number
    _all: number
  }


  export type MigrationAvgAggregateInputType = {
    apply_time?: true
  }

  export type MigrationSumAggregateInputType = {
    apply_time?: true
  }

  export type MigrationMinAggregateInputType = {
    version?: true
    apply_time?: true
  }

  export type MigrationMaxAggregateInputType = {
    version?: true
    apply_time?: true
  }

  export type MigrationCountAggregateInputType = {
    version?: true
    apply_time?: true
    _all?: true
  }

  export type MigrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migration to aggregate.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationMaxAggregateInputType
  }

  export type GetMigrationAggregateType<T extends MigrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMigration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigration[P]>
      : GetScalarType<T[P], AggregateMigration[P]>
  }




  export type migrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationWhereInput
    orderBy?: migrationOrderByWithAggregationInput | migrationOrderByWithAggregationInput[]
    by: MigrationScalarFieldEnum[] | MigrationScalarFieldEnum
    having?: migrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationCountAggregateInputType | true
    _avg?: MigrationAvgAggregateInputType
    _sum?: MigrationSumAggregateInputType
    _min?: MigrationMinAggregateInputType
    _max?: MigrationMaxAggregateInputType
  }

  export type MigrationGroupByOutputType = {
    version: string
    apply_time: number | null
    _count: MigrationCountAggregateOutputType | null
    _avg: MigrationAvgAggregateOutputType | null
    _sum: MigrationSumAggregateOutputType | null
    _min: MigrationMinAggregateOutputType | null
    _max: MigrationMaxAggregateOutputType | null
  }

  type GetMigrationGroupByPayload<T extends migrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationGroupByOutputType[P]>
        }
      >
    >


  export type migrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    apply_time?: boolean
  }, ExtArgs["result"]["migration"]>



  export type migrationSelectScalar = {
    version?: boolean
    apply_time?: boolean
  }

  export type migrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"version" | "apply_time", ExtArgs["result"]["migration"]>

  export type $migrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: string
      apply_time: number | null
    }, ExtArgs["result"]["migration"]>
    composites: {}
  }

  type migrationGetPayload<S extends boolean | null | undefined | migrationDefaultArgs> = $Result.GetResult<Prisma.$migrationPayload, S>

  type migrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationCountAggregateInputType | true
    }

  export interface migrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migration'], meta: { name: 'migration' } }
    /**
     * Find zero or one Migration that matches the filter.
     * @param {migrationFindUniqueArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationFindUniqueArgs>(args: SelectSubset<T, migrationFindUniqueArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationFindUniqueOrThrowArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationFindFirstArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationFindFirstArgs>(args?: SelectSubset<T, migrationFindFirstArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationFindFirstOrThrowArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migration.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migration.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const migrationWithVersionOnly = await prisma.migration.findMany({ select: { version: true } })
     * 
     */
    findMany<T extends migrationFindManyArgs>(args?: SelectSubset<T, migrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migration.
     * @param {migrationCreateArgs} args - Arguments to create a Migration.
     * @example
     * // Create one Migration
     * const Migration = await prisma.migration.create({
     *   data: {
     *     // ... data to create a Migration
     *   }
     * })
     * 
     */
    create<T extends migrationCreateArgs>(args: SelectSubset<T, migrationCreateArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migration = await prisma.migration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationCreateManyArgs>(args?: SelectSubset<T, migrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migration.
     * @param {migrationDeleteArgs} args - Arguments to delete one Migration.
     * @example
     * // Delete one Migration
     * const Migration = await prisma.migration.delete({
     *   where: {
     *     // ... filter to delete one Migration
     *   }
     * })
     * 
     */
    delete<T extends migrationDeleteArgs>(args: SelectSubset<T, migrationDeleteArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migration.
     * @param {migrationUpdateArgs} args - Arguments to update one Migration.
     * @example
     * // Update one Migration
     * const migration = await prisma.migration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationUpdateArgs>(args: SelectSubset<T, migrationUpdateArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationDeleteManyArgs>(args?: SelectSubset<T, migrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migration = await prisma.migration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationUpdateManyArgs>(args: SelectSubset<T, migrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migration.
     * @param {migrationUpsertArgs} args - Arguments to update or create a Migration.
     * @example
     * // Update or create a Migration
     * const migration = await prisma.migration.upsert({
     *   create: {
     *     // ... data to create a Migration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migration we want to update
     *   }
     * })
     */
    upsert<T extends migrationUpsertArgs>(args: SelectSubset<T, migrationUpsertArgs<ExtArgs>>): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migration.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationCountArgs>(
      args?: Subset<T, migrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationAggregateArgs>(args: Subset<T, MigrationAggregateArgs>): Prisma.PrismaPromise<GetMigrationAggregateType<T>>

    /**
     * Group by Migration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationGroupByArgs['orderBy'] }
        : { orderBy?: migrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migration model
   */
  readonly fields: migrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migration model
   */
  interface migrationFieldRefs {
    readonly version: FieldRef<"migration", 'String'>
    readonly apply_time: FieldRef<"migration", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * migration findUnique
   */
  export type migrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where: migrationWhereUniqueInput
  }

  /**
   * migration findUniqueOrThrow
   */
  export type migrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where: migrationWhereUniqueInput
  }

  /**
   * migration findFirst
   */
  export type migrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationScalarFieldEnum | MigrationScalarFieldEnum[]
  }

  /**
   * migration findFirstOrThrow
   */
  export type migrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationScalarFieldEnum | MigrationScalarFieldEnum[]
  }

  /**
   * migration findMany
   */
  export type migrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationScalarFieldEnum | MigrationScalarFieldEnum[]
  }

  /**
   * migration create
   */
  export type migrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * The data needed to create a migration.
     */
    data: XOR<migrationCreateInput, migrationUncheckedCreateInput>
  }

  /**
   * migration createMany
   */
  export type migrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationCreateManyInput | migrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migration update
   */
  export type migrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * The data needed to update a migration.
     */
    data: XOR<migrationUpdateInput, migrationUncheckedUpdateInput>
    /**
     * Choose, which migration to update.
     */
    where: migrationWhereUniqueInput
  }

  /**
   * migration updateMany
   */
  export type migrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationUpdateManyMutationInput, migrationUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migration upsert
   */
  export type migrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * The filter to search for the migration to update in case it exists.
     */
    where: migrationWhereUniqueInput
    /**
     * In case the migration found by the `where` argument doesn't exist, create a new migration with this data.
     */
    create: XOR<migrationCreateInput, migrationUncheckedCreateInput>
    /**
     * In case the migration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationUpdateInput, migrationUncheckedUpdateInput>
  }

  /**
   * migration delete
   */
  export type migrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
    /**
     * Filter which migration to delete.
     */
    where: migrationWhereUniqueInput
  }

  /**
   * migration deleteMany
   */
  export type migrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migration without action
   */
  export type migrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migration
     */
    omit?: migrationOmit<ExtArgs> | null
  }


  /**
   * Model mms_file
   */

  export type AggregateMms_file = {
    _count: Mms_fileCountAggregateOutputType | null
    _avg: Mms_fileAvgAggregateOutputType | null
    _sum: Mms_fileSumAggregateOutputType | null
    _min: Mms_fileMinAggregateOutputType | null
    _max: Mms_fileMaxAggregateOutputType | null
  }

  export type Mms_fileAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    type: number | null
    longitude: number | null
    latitude: number | null
    height: number | null
    width: number | null
  }

  export type Mms_fileSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    type: number | null
    longitude: number | null
    latitude: number | null
    height: number | null
    width: number | null
  }

  export type Mms_fileMinAggregateOutputType = {
    id: number | null
    device_uuid: string | null
    institution_id: number | null
    path: string | null
    comment: string | null
    type: number | null
    longitude: number | null
    latitude: number | null
    height: number | null
    width: number | null
    first_view_time: Date | null
    last_view_time: Date | null
    created_at: Date | null
  }

  export type Mms_fileMaxAggregateOutputType = {
    id: number | null
    device_uuid: string | null
    institution_id: number | null
    path: string | null
    comment: string | null
    type: number | null
    longitude: number | null
    latitude: number | null
    height: number | null
    width: number | null
    first_view_time: Date | null
    last_view_time: Date | null
    created_at: Date | null
  }

  export type Mms_fileCountAggregateOutputType = {
    id: number
    device_uuid: number
    institution_id: number
    path: number
    comment: number
    type: number
    longitude: number
    latitude: number
    height: number
    width: number
    first_view_time: number
    last_view_time: number
    created_at: number
    _all: number
  }


  export type Mms_fileAvgAggregateInputType = {
    id?: true
    institution_id?: true
    type?: true
    longitude?: true
    latitude?: true
    height?: true
    width?: true
  }

  export type Mms_fileSumAggregateInputType = {
    id?: true
    institution_id?: true
    type?: true
    longitude?: true
    latitude?: true
    height?: true
    width?: true
  }

  export type Mms_fileMinAggregateInputType = {
    id?: true
    device_uuid?: true
    institution_id?: true
    path?: true
    comment?: true
    type?: true
    longitude?: true
    latitude?: true
    height?: true
    width?: true
    first_view_time?: true
    last_view_time?: true
    created_at?: true
  }

  export type Mms_fileMaxAggregateInputType = {
    id?: true
    device_uuid?: true
    institution_id?: true
    path?: true
    comment?: true
    type?: true
    longitude?: true
    latitude?: true
    height?: true
    width?: true
    first_view_time?: true
    last_view_time?: true
    created_at?: true
  }

  export type Mms_fileCountAggregateInputType = {
    id?: true
    device_uuid?: true
    institution_id?: true
    path?: true
    comment?: true
    type?: true
    longitude?: true
    latitude?: true
    height?: true
    width?: true
    first_view_time?: true
    last_view_time?: true
    created_at?: true
    _all?: true
  }

  export type Mms_fileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mms_file to aggregate.
     */
    where?: mms_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mms_files to fetch.
     */
    orderBy?: mms_fileOrderByWithRelationInput | mms_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mms_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mms_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mms_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mms_files
    **/
    _count?: true | Mms_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mms_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mms_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mms_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mms_fileMaxAggregateInputType
  }

  export type GetMms_fileAggregateType<T extends Mms_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateMms_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMms_file[P]>
      : GetScalarType<T[P], AggregateMms_file[P]>
  }




  export type mms_fileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mms_fileWhereInput
    orderBy?: mms_fileOrderByWithAggregationInput | mms_fileOrderByWithAggregationInput[]
    by: Mms_fileScalarFieldEnum[] | Mms_fileScalarFieldEnum
    having?: mms_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mms_fileCountAggregateInputType | true
    _avg?: Mms_fileAvgAggregateInputType
    _sum?: Mms_fileSumAggregateInputType
    _min?: Mms_fileMinAggregateInputType
    _max?: Mms_fileMaxAggregateInputType
  }

  export type Mms_fileGroupByOutputType = {
    id: number
    device_uuid: string
    institution_id: number
    path: string
    comment: string | null
    type: number
    longitude: number | null
    latitude: number | null
    height: number | null
    width: number | null
    first_view_time: Date | null
    last_view_time: Date | null
    created_at: Date | null
    _count: Mms_fileCountAggregateOutputType | null
    _avg: Mms_fileAvgAggregateOutputType | null
    _sum: Mms_fileSumAggregateOutputType | null
    _min: Mms_fileMinAggregateOutputType | null
    _max: Mms_fileMaxAggregateOutputType | null
  }

  type GetMms_fileGroupByPayload<T extends mms_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mms_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mms_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mms_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Mms_fileGroupByOutputType[P]>
        }
      >
    >


  export type mms_fileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_uuid?: boolean
    institution_id?: boolean
    path?: boolean
    comment?: boolean
    type?: boolean
    longitude?: boolean
    latitude?: boolean
    height?: boolean
    width?: boolean
    first_view_time?: boolean
    last_view_time?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["mms_file"]>



  export type mms_fileSelectScalar = {
    id?: boolean
    device_uuid?: boolean
    institution_id?: boolean
    path?: boolean
    comment?: boolean
    type?: boolean
    longitude?: boolean
    latitude?: boolean
    height?: boolean
    width?: boolean
    first_view_time?: boolean
    last_view_time?: boolean
    created_at?: boolean
  }

  export type mms_fileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_uuid" | "institution_id" | "path" | "comment" | "type" | "longitude" | "latitude" | "height" | "width" | "first_view_time" | "last_view_time" | "created_at", ExtArgs["result"]["mms_file"]>

  export type $mms_filePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mms_file"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_uuid: string
      institution_id: number
      path: string
      comment: string | null
      type: number
      longitude: number | null
      latitude: number | null
      height: number | null
      width: number | null
      first_view_time: Date | null
      last_view_time: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["mms_file"]>
    composites: {}
  }

  type mms_fileGetPayload<S extends boolean | null | undefined | mms_fileDefaultArgs> = $Result.GetResult<Prisma.$mms_filePayload, S>

  type mms_fileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mms_fileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mms_fileCountAggregateInputType | true
    }

  export interface mms_fileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mms_file'], meta: { name: 'mms_file' } }
    /**
     * Find zero or one Mms_file that matches the filter.
     * @param {mms_fileFindUniqueArgs} args - Arguments to find a Mms_file
     * @example
     * // Get one Mms_file
     * const mms_file = await prisma.mms_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mms_fileFindUniqueArgs>(args: SelectSubset<T, mms_fileFindUniqueArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mms_file that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mms_fileFindUniqueOrThrowArgs} args - Arguments to find a Mms_file
     * @example
     * // Get one Mms_file
     * const mms_file = await prisma.mms_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mms_fileFindUniqueOrThrowArgs>(args: SelectSubset<T, mms_fileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mms_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mms_fileFindFirstArgs} args - Arguments to find a Mms_file
     * @example
     * // Get one Mms_file
     * const mms_file = await prisma.mms_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mms_fileFindFirstArgs>(args?: SelectSubset<T, mms_fileFindFirstArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mms_file that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mms_fileFindFirstOrThrowArgs} args - Arguments to find a Mms_file
     * @example
     * // Get one Mms_file
     * const mms_file = await prisma.mms_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mms_fileFindFirstOrThrowArgs>(args?: SelectSubset<T, mms_fileFindFirstOrThrowArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mms_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mms_fileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mms_files
     * const mms_files = await prisma.mms_file.findMany()
     * 
     * // Get first 10 Mms_files
     * const mms_files = await prisma.mms_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mms_fileWithIdOnly = await prisma.mms_file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mms_fileFindManyArgs>(args?: SelectSubset<T, mms_fileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mms_file.
     * @param {mms_fileCreateArgs} args - Arguments to create a Mms_file.
     * @example
     * // Create one Mms_file
     * const Mms_file = await prisma.mms_file.create({
     *   data: {
     *     // ... data to create a Mms_file
     *   }
     * })
     * 
     */
    create<T extends mms_fileCreateArgs>(args: SelectSubset<T, mms_fileCreateArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mms_files.
     * @param {mms_fileCreateManyArgs} args - Arguments to create many Mms_files.
     * @example
     * // Create many Mms_files
     * const mms_file = await prisma.mms_file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mms_fileCreateManyArgs>(args?: SelectSubset<T, mms_fileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mms_file.
     * @param {mms_fileDeleteArgs} args - Arguments to delete one Mms_file.
     * @example
     * // Delete one Mms_file
     * const Mms_file = await prisma.mms_file.delete({
     *   where: {
     *     // ... filter to delete one Mms_file
     *   }
     * })
     * 
     */
    delete<T extends mms_fileDeleteArgs>(args: SelectSubset<T, mms_fileDeleteArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mms_file.
     * @param {mms_fileUpdateArgs} args - Arguments to update one Mms_file.
     * @example
     * // Update one Mms_file
     * const mms_file = await prisma.mms_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mms_fileUpdateArgs>(args: SelectSubset<T, mms_fileUpdateArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mms_files.
     * @param {mms_fileDeleteManyArgs} args - Arguments to filter Mms_files to delete.
     * @example
     * // Delete a few Mms_files
     * const { count } = await prisma.mms_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mms_fileDeleteManyArgs>(args?: SelectSubset<T, mms_fileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mms_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mms_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mms_files
     * const mms_file = await prisma.mms_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mms_fileUpdateManyArgs>(args: SelectSubset<T, mms_fileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mms_file.
     * @param {mms_fileUpsertArgs} args - Arguments to update or create a Mms_file.
     * @example
     * // Update or create a Mms_file
     * const mms_file = await prisma.mms_file.upsert({
     *   create: {
     *     // ... data to create a Mms_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mms_file we want to update
     *   }
     * })
     */
    upsert<T extends mms_fileUpsertArgs>(args: SelectSubset<T, mms_fileUpsertArgs<ExtArgs>>): Prisma__mms_fileClient<$Result.GetResult<Prisma.$mms_filePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mms_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mms_fileCountArgs} args - Arguments to filter Mms_files to count.
     * @example
     * // Count the number of Mms_files
     * const count = await prisma.mms_file.count({
     *   where: {
     *     // ... the filter for the Mms_files we want to count
     *   }
     * })
    **/
    count<T extends mms_fileCountArgs>(
      args?: Subset<T, mms_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mms_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mms_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mms_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mms_fileAggregateArgs>(args: Subset<T, Mms_fileAggregateArgs>): Prisma.PrismaPromise<GetMms_fileAggregateType<T>>

    /**
     * Group by Mms_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mms_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mms_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mms_fileGroupByArgs['orderBy'] }
        : { orderBy?: mms_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mms_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMms_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mms_file model
   */
  readonly fields: mms_fileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mms_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mms_fileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mms_file model
   */
  interface mms_fileFieldRefs {
    readonly id: FieldRef<"mms_file", 'Int'>
    readonly device_uuid: FieldRef<"mms_file", 'String'>
    readonly institution_id: FieldRef<"mms_file", 'Int'>
    readonly path: FieldRef<"mms_file", 'String'>
    readonly comment: FieldRef<"mms_file", 'String'>
    readonly type: FieldRef<"mms_file", 'Int'>
    readonly longitude: FieldRef<"mms_file", 'Float'>
    readonly latitude: FieldRef<"mms_file", 'Float'>
    readonly height: FieldRef<"mms_file", 'Int'>
    readonly width: FieldRef<"mms_file", 'Int'>
    readonly first_view_time: FieldRef<"mms_file", 'DateTime'>
    readonly last_view_time: FieldRef<"mms_file", 'DateTime'>
    readonly created_at: FieldRef<"mms_file", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mms_file findUnique
   */
  export type mms_fileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * Filter, which mms_file to fetch.
     */
    where: mms_fileWhereUniqueInput
  }

  /**
   * mms_file findUniqueOrThrow
   */
  export type mms_fileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * Filter, which mms_file to fetch.
     */
    where: mms_fileWhereUniqueInput
  }

  /**
   * mms_file findFirst
   */
  export type mms_fileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * Filter, which mms_file to fetch.
     */
    where?: mms_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mms_files to fetch.
     */
    orderBy?: mms_fileOrderByWithRelationInput | mms_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mms_files.
     */
    cursor?: mms_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mms_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mms_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mms_files.
     */
    distinct?: Mms_fileScalarFieldEnum | Mms_fileScalarFieldEnum[]
  }

  /**
   * mms_file findFirstOrThrow
   */
  export type mms_fileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * Filter, which mms_file to fetch.
     */
    where?: mms_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mms_files to fetch.
     */
    orderBy?: mms_fileOrderByWithRelationInput | mms_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mms_files.
     */
    cursor?: mms_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mms_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mms_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mms_files.
     */
    distinct?: Mms_fileScalarFieldEnum | Mms_fileScalarFieldEnum[]
  }

  /**
   * mms_file findMany
   */
  export type mms_fileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * Filter, which mms_files to fetch.
     */
    where?: mms_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mms_files to fetch.
     */
    orderBy?: mms_fileOrderByWithRelationInput | mms_fileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mms_files.
     */
    cursor?: mms_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mms_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mms_files.
     */
    skip?: number
    distinct?: Mms_fileScalarFieldEnum | Mms_fileScalarFieldEnum[]
  }

  /**
   * mms_file create
   */
  export type mms_fileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * The data needed to create a mms_file.
     */
    data: XOR<mms_fileCreateInput, mms_fileUncheckedCreateInput>
  }

  /**
   * mms_file createMany
   */
  export type mms_fileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mms_files.
     */
    data: mms_fileCreateManyInput | mms_fileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mms_file update
   */
  export type mms_fileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * The data needed to update a mms_file.
     */
    data: XOR<mms_fileUpdateInput, mms_fileUncheckedUpdateInput>
    /**
     * Choose, which mms_file to update.
     */
    where: mms_fileWhereUniqueInput
  }

  /**
   * mms_file updateMany
   */
  export type mms_fileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mms_files.
     */
    data: XOR<mms_fileUpdateManyMutationInput, mms_fileUncheckedUpdateManyInput>
    /**
     * Filter which mms_files to update
     */
    where?: mms_fileWhereInput
    /**
     * Limit how many mms_files to update.
     */
    limit?: number
  }

  /**
   * mms_file upsert
   */
  export type mms_fileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * The filter to search for the mms_file to update in case it exists.
     */
    where: mms_fileWhereUniqueInput
    /**
     * In case the mms_file found by the `where` argument doesn't exist, create a new mms_file with this data.
     */
    create: XOR<mms_fileCreateInput, mms_fileUncheckedCreateInput>
    /**
     * In case the mms_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mms_fileUpdateInput, mms_fileUncheckedUpdateInput>
  }

  /**
   * mms_file delete
   */
  export type mms_fileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
    /**
     * Filter which mms_file to delete.
     */
    where: mms_fileWhereUniqueInput
  }

  /**
   * mms_file deleteMany
   */
  export type mms_fileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mms_files to delete
     */
    where?: mms_fileWhereInput
    /**
     * Limit how many mms_files to delete.
     */
    limit?: number
  }

  /**
   * mms_file without action
   */
  export type mms_fileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mms_file
     */
    select?: mms_fileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mms_file
     */
    omit?: mms_fileOmit<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    link: string | null
    seen: boolean | null
    time_sent: Date | null
    time_seen: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    link: string | null
    seen: boolean | null
    time_sent: Date | null
    time_seen: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    content: number
    link: number
    seen: number
    time_sent: number
    time_seen: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    link?: true
    seen?: true
    time_sent?: true
    time_seen?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    link?: true
    seen?: true
    time_sent?: true
    time_seen?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    link?: true
    seen?: true
    time_sent?: true
    time_seen?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    title: string | null
    content: string
    link: string | null
    seen: boolean | null
    time_sent: Date | null
    time_seen: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    seen?: boolean
    time_sent?: boolean
    time_seen?: boolean
  }, ExtArgs["result"]["notification"]>



  export type notificationSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    link?: boolean
    seen?: boolean
    time_sent?: boolean
    time_seen?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "link" | "seen" | "time_sent" | "time_seen", ExtArgs["result"]["notification"]>

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      content: string
      link: string | null
      seen: boolean | null
      time_sent: Date | null
      time_seen: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'Int'>
    readonly title: FieldRef<"notification", 'String'>
    readonly content: FieldRef<"notification", 'String'>
    readonly link: FieldRef<"notification", 'String'>
    readonly seen: FieldRef<"notification", 'Boolean'>
    readonly time_sent: FieldRef<"notification", 'DateTime'>
    readonly time_seen: FieldRef<"notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
  }


  /**
   * Model notification_recipient
   */

  export type AggregateNotification_recipient = {
    _count: Notification_recipientCountAggregateOutputType | null
    _avg: Notification_recipientAvgAggregateOutputType | null
    _sum: Notification_recipientSumAggregateOutputType | null
    _min: Notification_recipientMinAggregateOutputType | null
    _max: Notification_recipientMaxAggregateOutputType | null
  }

  export type Notification_recipientAvgAggregateOutputType = {
    id: number | null
    id_notification: number | null
    id_user: number | null
    seen: number | null
    ticket: number | null
    reference_id: number | null
  }

  export type Notification_recipientSumAggregateOutputType = {
    id: number | null
    id_notification: number | null
    id_user: number | null
    seen: number | null
    ticket: number | null
    reference_id: number | null
  }

  export type Notification_recipientMinAggregateOutputType = {
    id: number | null
    id_notification: number | null
    id_user: number | null
    seen: number | null
    ticket: number | null
    reference_id: number | null
  }

  export type Notification_recipientMaxAggregateOutputType = {
    id: number | null
    id_notification: number | null
    id_user: number | null
    seen: number | null
    ticket: number | null
    reference_id: number | null
  }

  export type Notification_recipientCountAggregateOutputType = {
    id: number
    id_notification: number
    id_user: number
    seen: number
    ticket: number
    reference_id: number
    _all: number
  }


  export type Notification_recipientAvgAggregateInputType = {
    id?: true
    id_notification?: true
    id_user?: true
    seen?: true
    ticket?: true
    reference_id?: true
  }

  export type Notification_recipientSumAggregateInputType = {
    id?: true
    id_notification?: true
    id_user?: true
    seen?: true
    ticket?: true
    reference_id?: true
  }

  export type Notification_recipientMinAggregateInputType = {
    id?: true
    id_notification?: true
    id_user?: true
    seen?: true
    ticket?: true
    reference_id?: true
  }

  export type Notification_recipientMaxAggregateInputType = {
    id?: true
    id_notification?: true
    id_user?: true
    seen?: true
    ticket?: true
    reference_id?: true
  }

  export type Notification_recipientCountAggregateInputType = {
    id?: true
    id_notification?: true
    id_user?: true
    seen?: true
    ticket?: true
    reference_id?: true
    _all?: true
  }

  export type Notification_recipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_recipient to aggregate.
     */
    where?: notification_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_recipients to fetch.
     */
    orderBy?: notification_recipientOrderByWithRelationInput | notification_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_recipients
    **/
    _count?: true | Notification_recipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Notification_recipientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Notification_recipientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_recipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_recipientMaxAggregateInputType
  }

  export type GetNotification_recipientAggregateType<T extends Notification_recipientAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_recipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_recipient[P]>
      : GetScalarType<T[P], AggregateNotification_recipient[P]>
  }




  export type notification_recipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_recipientWhereInput
    orderBy?: notification_recipientOrderByWithAggregationInput | notification_recipientOrderByWithAggregationInput[]
    by: Notification_recipientScalarFieldEnum[] | Notification_recipientScalarFieldEnum
    having?: notification_recipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_recipientCountAggregateInputType | true
    _avg?: Notification_recipientAvgAggregateInputType
    _sum?: Notification_recipientSumAggregateInputType
    _min?: Notification_recipientMinAggregateInputType
    _max?: Notification_recipientMaxAggregateInputType
  }

  export type Notification_recipientGroupByOutputType = {
    id: number
    id_notification: number
    id_user: number | null
    seen: number | null
    ticket: number | null
    reference_id: number | null
    _count: Notification_recipientCountAggregateOutputType | null
    _avg: Notification_recipientAvgAggregateOutputType | null
    _sum: Notification_recipientSumAggregateOutputType | null
    _min: Notification_recipientMinAggregateOutputType | null
    _max: Notification_recipientMaxAggregateOutputType | null
  }

  type GetNotification_recipientGroupByPayload<T extends notification_recipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_recipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_recipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_recipientGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_recipientGroupByOutputType[P]>
        }
      >
    >


  export type notification_recipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_notification?: boolean
    id_user?: boolean
    seen?: boolean
    ticket?: boolean
    reference_id?: boolean
  }, ExtArgs["result"]["notification_recipient"]>



  export type notification_recipientSelectScalar = {
    id?: boolean
    id_notification?: boolean
    id_user?: boolean
    seen?: boolean
    ticket?: boolean
    reference_id?: boolean
  }

  export type notification_recipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_notification" | "id_user" | "seen" | "ticket" | "reference_id", ExtArgs["result"]["notification_recipient"]>

  export type $notification_recipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_recipient"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_notification: number
      id_user: number | null
      seen: number | null
      ticket: number | null
      reference_id: number | null
    }, ExtArgs["result"]["notification_recipient"]>
    composites: {}
  }

  type notification_recipientGetPayload<S extends boolean | null | undefined | notification_recipientDefaultArgs> = $Result.GetResult<Prisma.$notification_recipientPayload, S>

  type notification_recipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notification_recipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_recipientCountAggregateInputType | true
    }

  export interface notification_recipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_recipient'], meta: { name: 'notification_recipient' } }
    /**
     * Find zero or one Notification_recipient that matches the filter.
     * @param {notification_recipientFindUniqueArgs} args - Arguments to find a Notification_recipient
     * @example
     * // Get one Notification_recipient
     * const notification_recipient = await prisma.notification_recipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_recipientFindUniqueArgs>(args: SelectSubset<T, notification_recipientFindUniqueArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_recipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notification_recipientFindUniqueOrThrowArgs} args - Arguments to find a Notification_recipient
     * @example
     * // Get one Notification_recipient
     * const notification_recipient = await prisma.notification_recipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_recipientFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_recipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_recipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_recipientFindFirstArgs} args - Arguments to find a Notification_recipient
     * @example
     * // Get one Notification_recipient
     * const notification_recipient = await prisma.notification_recipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_recipientFindFirstArgs>(args?: SelectSubset<T, notification_recipientFindFirstArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_recipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_recipientFindFirstOrThrowArgs} args - Arguments to find a Notification_recipient
     * @example
     * // Get one Notification_recipient
     * const notification_recipient = await prisma.notification_recipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_recipientFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_recipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_recipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_recipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_recipients
     * const notification_recipients = await prisma.notification_recipient.findMany()
     * 
     * // Get first 10 Notification_recipients
     * const notification_recipients = await prisma.notification_recipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_recipientWithIdOnly = await prisma.notification_recipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_recipientFindManyArgs>(args?: SelectSubset<T, notification_recipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_recipient.
     * @param {notification_recipientCreateArgs} args - Arguments to create a Notification_recipient.
     * @example
     * // Create one Notification_recipient
     * const Notification_recipient = await prisma.notification_recipient.create({
     *   data: {
     *     // ... data to create a Notification_recipient
     *   }
     * })
     * 
     */
    create<T extends notification_recipientCreateArgs>(args: SelectSubset<T, notification_recipientCreateArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_recipients.
     * @param {notification_recipientCreateManyArgs} args - Arguments to create many Notification_recipients.
     * @example
     * // Create many Notification_recipients
     * const notification_recipient = await prisma.notification_recipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_recipientCreateManyArgs>(args?: SelectSubset<T, notification_recipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification_recipient.
     * @param {notification_recipientDeleteArgs} args - Arguments to delete one Notification_recipient.
     * @example
     * // Delete one Notification_recipient
     * const Notification_recipient = await prisma.notification_recipient.delete({
     *   where: {
     *     // ... filter to delete one Notification_recipient
     *   }
     * })
     * 
     */
    delete<T extends notification_recipientDeleteArgs>(args: SelectSubset<T, notification_recipientDeleteArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_recipient.
     * @param {notification_recipientUpdateArgs} args - Arguments to update one Notification_recipient.
     * @example
     * // Update one Notification_recipient
     * const notification_recipient = await prisma.notification_recipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_recipientUpdateArgs>(args: SelectSubset<T, notification_recipientUpdateArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_recipients.
     * @param {notification_recipientDeleteManyArgs} args - Arguments to filter Notification_recipients to delete.
     * @example
     * // Delete a few Notification_recipients
     * const { count } = await prisma.notification_recipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_recipientDeleteManyArgs>(args?: SelectSubset<T, notification_recipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_recipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_recipients
     * const notification_recipient = await prisma.notification_recipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_recipientUpdateManyArgs>(args: SelectSubset<T, notification_recipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification_recipient.
     * @param {notification_recipientUpsertArgs} args - Arguments to update or create a Notification_recipient.
     * @example
     * // Update or create a Notification_recipient
     * const notification_recipient = await prisma.notification_recipient.upsert({
     *   create: {
     *     // ... data to create a Notification_recipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_recipient we want to update
     *   }
     * })
     */
    upsert<T extends notification_recipientUpsertArgs>(args: SelectSubset<T, notification_recipientUpsertArgs<ExtArgs>>): Prisma__notification_recipientClient<$Result.GetResult<Prisma.$notification_recipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_recipientCountArgs} args - Arguments to filter Notification_recipients to count.
     * @example
     * // Count the number of Notification_recipients
     * const count = await prisma.notification_recipient.count({
     *   where: {
     *     // ... the filter for the Notification_recipients we want to count
     *   }
     * })
    **/
    count<T extends notification_recipientCountArgs>(
      args?: Subset<T, notification_recipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_recipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_recipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_recipientAggregateArgs>(args: Subset<T, Notification_recipientAggregateArgs>): Prisma.PrismaPromise<GetNotification_recipientAggregateType<T>>

    /**
     * Group by Notification_recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_recipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_recipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_recipientGroupByArgs['orderBy'] }
        : { orderBy?: notification_recipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_recipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_recipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_recipient model
   */
  readonly fields: notification_recipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_recipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_recipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_recipient model
   */
  interface notification_recipientFieldRefs {
    readonly id: FieldRef<"notification_recipient", 'Int'>
    readonly id_notification: FieldRef<"notification_recipient", 'Int'>
    readonly id_user: FieldRef<"notification_recipient", 'Int'>
    readonly seen: FieldRef<"notification_recipient", 'Int'>
    readonly ticket: FieldRef<"notification_recipient", 'Int'>
    readonly reference_id: FieldRef<"notification_recipient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * notification_recipient findUnique
   */
  export type notification_recipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * Filter, which notification_recipient to fetch.
     */
    where: notification_recipientWhereUniqueInput
  }

  /**
   * notification_recipient findUniqueOrThrow
   */
  export type notification_recipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * Filter, which notification_recipient to fetch.
     */
    where: notification_recipientWhereUniqueInput
  }

  /**
   * notification_recipient findFirst
   */
  export type notification_recipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * Filter, which notification_recipient to fetch.
     */
    where?: notification_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_recipients to fetch.
     */
    orderBy?: notification_recipientOrderByWithRelationInput | notification_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_recipients.
     */
    cursor?: notification_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_recipients.
     */
    distinct?: Notification_recipientScalarFieldEnum | Notification_recipientScalarFieldEnum[]
  }

  /**
   * notification_recipient findFirstOrThrow
   */
  export type notification_recipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * Filter, which notification_recipient to fetch.
     */
    where?: notification_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_recipients to fetch.
     */
    orderBy?: notification_recipientOrderByWithRelationInput | notification_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_recipients.
     */
    cursor?: notification_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_recipients.
     */
    distinct?: Notification_recipientScalarFieldEnum | Notification_recipientScalarFieldEnum[]
  }

  /**
   * notification_recipient findMany
   */
  export type notification_recipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * Filter, which notification_recipients to fetch.
     */
    where?: notification_recipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_recipients to fetch.
     */
    orderBy?: notification_recipientOrderByWithRelationInput | notification_recipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_recipients.
     */
    cursor?: notification_recipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_recipients.
     */
    skip?: number
    distinct?: Notification_recipientScalarFieldEnum | Notification_recipientScalarFieldEnum[]
  }

  /**
   * notification_recipient create
   */
  export type notification_recipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * The data needed to create a notification_recipient.
     */
    data: XOR<notification_recipientCreateInput, notification_recipientUncheckedCreateInput>
  }

  /**
   * notification_recipient createMany
   */
  export type notification_recipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_recipients.
     */
    data: notification_recipientCreateManyInput | notification_recipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_recipient update
   */
  export type notification_recipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * The data needed to update a notification_recipient.
     */
    data: XOR<notification_recipientUpdateInput, notification_recipientUncheckedUpdateInput>
    /**
     * Choose, which notification_recipient to update.
     */
    where: notification_recipientWhereUniqueInput
  }

  /**
   * notification_recipient updateMany
   */
  export type notification_recipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_recipients.
     */
    data: XOR<notification_recipientUpdateManyMutationInput, notification_recipientUncheckedUpdateManyInput>
    /**
     * Filter which notification_recipients to update
     */
    where?: notification_recipientWhereInput
    /**
     * Limit how many notification_recipients to update.
     */
    limit?: number
  }

  /**
   * notification_recipient upsert
   */
  export type notification_recipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * The filter to search for the notification_recipient to update in case it exists.
     */
    where: notification_recipientWhereUniqueInput
    /**
     * In case the notification_recipient found by the `where` argument doesn't exist, create a new notification_recipient with this data.
     */
    create: XOR<notification_recipientCreateInput, notification_recipientUncheckedCreateInput>
    /**
     * In case the notification_recipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_recipientUpdateInput, notification_recipientUncheckedUpdateInput>
  }

  /**
   * notification_recipient delete
   */
  export type notification_recipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
    /**
     * Filter which notification_recipient to delete.
     */
    where: notification_recipientWhereUniqueInput
  }

  /**
   * notification_recipient deleteMany
   */
  export type notification_recipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_recipients to delete
     */
    where?: notification_recipientWhereInput
    /**
     * Limit how many notification_recipients to delete.
     */
    limit?: number
  }

  /**
   * notification_recipient without action
   */
  export type notification_recipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_recipient
     */
    select?: notification_recipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_recipient
     */
    omit?: notification_recipientOmit<ExtArgs> | null
  }


  /**
   * Model option
   */

  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionAvgAggregateOutputType = {
    id: number | null
    type: number | null
    parent_id: number | null
  }

  export type OptionSumAggregateOutputType = {
    id: number | null
    type: number | null
    parent_id: number | null
  }

  export type OptionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: number | null
    parent_id: number | null
    created_at: Date | null
  }

  export type OptionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: number | null
    parent_id: number | null
    created_at: Date | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    parent_id: number
    created_at: number
    _all: number
  }


  export type OptionAvgAggregateInputType = {
    id?: true
    type?: true
    parent_id?: true
  }

  export type OptionSumAggregateInputType = {
    id?: true
    type?: true
    parent_id?: true
  }

  export type OptionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    parent_id?: true
    created_at?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    parent_id?: true
    created_at?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    parent_id?: true
    created_at?: true
    _all?: true
  }

  export type OptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which option to aggregate.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type optionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optionWhereInput
    orderBy?: optionOrderByWithAggregationInput | optionOrderByWithAggregationInput[]
    by: OptionScalarFieldEnum[] | OptionScalarFieldEnum
    having?: optionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _avg?: OptionAvgAggregateInputType
    _sum?: OptionSumAggregateInputType
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }

  export type OptionGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    type: number | null
    parent_id: number | null
    created_at: Date
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends optionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type optionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    parent_id?: boolean
    created_at?: boolean
    qms_ticket?: boolean | option$qms_ticketArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>



  export type optionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    parent_id?: boolean
    created_at?: boolean
  }

  export type optionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "parent_id" | "created_at", ExtArgs["result"]["option"]>
  export type optionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_ticket?: boolean | option$qms_ticketArgs<ExtArgs>
    _count?: boolean | OptionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $optionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "option"
    objects: {
      qms_ticket: Prisma.$qms_ticketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      description: string | null
      type: number | null
      parent_id: number | null
      created_at: Date
    }, ExtArgs["result"]["option"]>
    composites: {}
  }

  type optionGetPayload<S extends boolean | null | undefined | optionDefaultArgs> = $Result.GetResult<Prisma.$optionPayload, S>

  type optionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<optionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface optionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['option'], meta: { name: 'option' } }
    /**
     * Find zero or one Option that matches the filter.
     * @param {optionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends optionFindUniqueArgs>(args: SelectSubset<T, optionFindUniqueArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {optionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends optionFindUniqueOrThrowArgs>(args: SelectSubset<T, optionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends optionFindFirstArgs>(args?: SelectSubset<T, optionFindFirstArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends optionFindFirstOrThrowArgs>(args?: SelectSubset<T, optionFindFirstOrThrowArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends optionFindManyArgs>(args?: SelectSubset<T, optionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option.
     * @param {optionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
     */
    create<T extends optionCreateArgs>(args: SelectSubset<T, optionCreateArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Options.
     * @param {optionCreateManyArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends optionCreateManyArgs>(args?: SelectSubset<T, optionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Option.
     * @param {optionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
     */
    delete<T extends optionDeleteArgs>(args: SelectSubset<T, optionDeleteArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option.
     * @param {optionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends optionUpdateArgs>(args: SelectSubset<T, optionUpdateArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Options.
     * @param {optionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends optionDeleteManyArgs>(args?: SelectSubset<T, optionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends optionUpdateManyArgs>(args: SelectSubset<T, optionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Option.
     * @param {optionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
     */
    upsert<T extends optionUpsertArgs>(args: SelectSubset<T, optionUpsertArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends optionCountArgs>(
      args?: Subset<T, optionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends optionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: optionGroupByArgs['orderBy'] }
        : { orderBy?: optionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, optionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the option model
   */
  readonly fields: optionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__optionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qms_ticket<T extends option$qms_ticketArgs<ExtArgs> = {}>(args?: Subset<T, option$qms_ticketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the option model
   */
  interface optionFieldRefs {
    readonly id: FieldRef<"option", 'Int'>
    readonly name: FieldRef<"option", 'String'>
    readonly description: FieldRef<"option", 'String'>
    readonly type: FieldRef<"option", 'Int'>
    readonly parent_id: FieldRef<"option", 'Int'>
    readonly created_at: FieldRef<"option", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * option findUnique
   */
  export type optionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option findUniqueOrThrow
   */
  export type optionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option findFirst
   */
  export type optionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for options.
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * option findFirstOrThrow
   */
  export type optionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which option to fetch.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for options.
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * option findMany
   */
  export type optionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter, which options to fetch.
     */
    where?: optionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of options to fetch.
     */
    orderBy?: optionOrderByWithRelationInput | optionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing options.
     */
    cursor?: optionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` options.
     */
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * option create
   */
  export type optionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * The data needed to create a option.
     */
    data?: XOR<optionCreateInput, optionUncheckedCreateInput>
  }

  /**
   * option createMany
   */
  export type optionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many options.
     */
    data: optionCreateManyInput | optionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * option update
   */
  export type optionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * The data needed to update a option.
     */
    data: XOR<optionUpdateInput, optionUncheckedUpdateInput>
    /**
     * Choose, which option to update.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option updateMany
   */
  export type optionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update options.
     */
    data: XOR<optionUpdateManyMutationInput, optionUncheckedUpdateManyInput>
    /**
     * Filter which options to update
     */
    where?: optionWhereInput
    /**
     * Limit how many options to update.
     */
    limit?: number
  }

  /**
   * option upsert
   */
  export type optionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * The filter to search for the option to update in case it exists.
     */
    where: optionWhereUniqueInput
    /**
     * In case the option found by the `where` argument doesn't exist, create a new option with this data.
     */
    create: XOR<optionCreateInput, optionUncheckedCreateInput>
    /**
     * In case the option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<optionUpdateInput, optionUncheckedUpdateInput>
  }

  /**
   * option delete
   */
  export type optionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    /**
     * Filter which option to delete.
     */
    where: optionWhereUniqueInput
  }

  /**
   * option deleteMany
   */
  export type optionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which options to delete
     */
    where?: optionWhereInput
    /**
     * Limit how many options to delete.
     */
    limit?: number
  }

  /**
   * option.qms_ticket
   */
  export type option$qms_ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    where?: qms_ticketWhereInput
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    cursor?: qms_ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_ticketScalarFieldEnum | Qms_ticketScalarFieldEnum[]
  }

  /**
   * option without action
   */
  export type optionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
  }


  /**
   * Model popup_questions
   */

  export type AggregatePopup_questions = {
    _count: Popup_questionsCountAggregateOutputType | null
    _avg: Popup_questionsAvgAggregateOutputType | null
    _sum: Popup_questionsSumAggregateOutputType | null
    _min: Popup_questionsMinAggregateOutputType | null
    _max: Popup_questionsMaxAggregateOutputType | null
  }

  export type Popup_questionsAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    type: number | null
  }

  export type Popup_questionsSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    type: number | null
  }

  export type Popup_questionsMinAggregateOutputType = {
    id: number | null
    name_en: string | null
    name_fr: string | null
    name_rw: string | null
    name_sw: string | null
    service_id: string | null
    description_en: string | null
    description_fr: string | null
    description_rw: string | null
    description_sw: string | null
    applies_to_bad: boolean | null
    applies_to_good: boolean | null
    applies_to_excellent: boolean | null
    institution_id: number | null
    status: boolean | null
    type: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Popup_questionsMaxAggregateOutputType = {
    id: number | null
    name_en: string | null
    name_fr: string | null
    name_rw: string | null
    name_sw: string | null
    service_id: string | null
    description_en: string | null
    description_fr: string | null
    description_rw: string | null
    description_sw: string | null
    applies_to_bad: boolean | null
    applies_to_good: boolean | null
    applies_to_excellent: boolean | null
    institution_id: number | null
    status: boolean | null
    type: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Popup_questionsCountAggregateOutputType = {
    id: number
    name_en: number
    name_fr: number
    name_rw: number
    name_sw: number
    service_id: number
    description_en: number
    description_fr: number
    description_rw: number
    description_sw: number
    applies_to_bad: number
    applies_to_good: number
    applies_to_excellent: number
    institution_id: number
    status: number
    type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Popup_questionsAvgAggregateInputType = {
    id?: true
    institution_id?: true
    type?: true
  }

  export type Popup_questionsSumAggregateInputType = {
    id?: true
    institution_id?: true
    type?: true
  }

  export type Popup_questionsMinAggregateInputType = {
    id?: true
    name_en?: true
    name_fr?: true
    name_rw?: true
    name_sw?: true
    service_id?: true
    description_en?: true
    description_fr?: true
    description_rw?: true
    description_sw?: true
    applies_to_bad?: true
    applies_to_good?: true
    applies_to_excellent?: true
    institution_id?: true
    status?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type Popup_questionsMaxAggregateInputType = {
    id?: true
    name_en?: true
    name_fr?: true
    name_rw?: true
    name_sw?: true
    service_id?: true
    description_en?: true
    description_fr?: true
    description_rw?: true
    description_sw?: true
    applies_to_bad?: true
    applies_to_good?: true
    applies_to_excellent?: true
    institution_id?: true
    status?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type Popup_questionsCountAggregateInputType = {
    id?: true
    name_en?: true
    name_fr?: true
    name_rw?: true
    name_sw?: true
    service_id?: true
    description_en?: true
    description_fr?: true
    description_rw?: true
    description_sw?: true
    applies_to_bad?: true
    applies_to_good?: true
    applies_to_excellent?: true
    institution_id?: true
    status?: true
    type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Popup_questionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which popup_questions to aggregate.
     */
    where?: popup_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions to fetch.
     */
    orderBy?: popup_questionsOrderByWithRelationInput | popup_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: popup_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned popup_questions
    **/
    _count?: true | Popup_questionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Popup_questionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Popup_questionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Popup_questionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Popup_questionsMaxAggregateInputType
  }

  export type GetPopup_questionsAggregateType<T extends Popup_questionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePopup_questions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopup_questions[P]>
      : GetScalarType<T[P], AggregatePopup_questions[P]>
  }




  export type popup_questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: popup_questionsWhereInput
    orderBy?: popup_questionsOrderByWithAggregationInput | popup_questionsOrderByWithAggregationInput[]
    by: Popup_questionsScalarFieldEnum[] | Popup_questionsScalarFieldEnum
    having?: popup_questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Popup_questionsCountAggregateInputType | true
    _avg?: Popup_questionsAvgAggregateInputType
    _sum?: Popup_questionsSumAggregateInputType
    _min?: Popup_questionsMinAggregateInputType
    _max?: Popup_questionsMaxAggregateInputType
  }

  export type Popup_questionsGroupByOutputType = {
    id: number
    name_en: string
    name_fr: string | null
    name_rw: string | null
    name_sw: string | null
    service_id: string
    description_en: string
    description_fr: string | null
    description_rw: string | null
    description_sw: string | null
    applies_to_bad: boolean
    applies_to_good: boolean
    applies_to_excellent: boolean
    institution_id: number
    status: boolean | null
    type: number | null
    created_at: Date
    updated_at: Date
    _count: Popup_questionsCountAggregateOutputType | null
    _avg: Popup_questionsAvgAggregateOutputType | null
    _sum: Popup_questionsSumAggregateOutputType | null
    _min: Popup_questionsMinAggregateOutputType | null
    _max: Popup_questionsMaxAggregateOutputType | null
  }

  type GetPopup_questionsGroupByPayload<T extends popup_questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Popup_questionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Popup_questionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Popup_questionsGroupByOutputType[P]>
            : GetScalarType<T[P], Popup_questionsGroupByOutputType[P]>
        }
      >
    >


  export type popup_questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_fr?: boolean
    name_rw?: boolean
    name_sw?: boolean
    service_id?: boolean
    description_en?: boolean
    description_fr?: boolean
    description_rw?: boolean
    description_sw?: boolean
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    institution_id?: boolean
    status?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    popup_questions_possible_answers?: boolean | popup_questions$popup_questions_possible_answersArgs<ExtArgs>
    _count?: boolean | Popup_questionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["popup_questions"]>



  export type popup_questionsSelectScalar = {
    id?: boolean
    name_en?: boolean
    name_fr?: boolean
    name_rw?: boolean
    name_sw?: boolean
    service_id?: boolean
    description_en?: boolean
    description_fr?: boolean
    description_rw?: boolean
    description_sw?: boolean
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    institution_id?: boolean
    status?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type popup_questionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "name_fr" | "name_rw" | "name_sw" | "service_id" | "description_en" | "description_fr" | "description_rw" | "description_sw" | "applies_to_bad" | "applies_to_good" | "applies_to_excellent" | "institution_id" | "status" | "type" | "created_at" | "updated_at", ExtArgs["result"]["popup_questions"]>
  export type popup_questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    popup_questions_possible_answers?: boolean | popup_questions$popup_questions_possible_answersArgs<ExtArgs>
    _count?: boolean | Popup_questionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $popup_questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "popup_questions"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs>
      popup_questions_possible_answers: Prisma.$popup_questions_possible_answersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name_en: string
      name_fr: string | null
      name_rw: string | null
      name_sw: string | null
      service_id: string
      description_en: string
      description_fr: string | null
      description_rw: string | null
      description_sw: string | null
      applies_to_bad: boolean
      applies_to_good: boolean
      applies_to_excellent: boolean
      institution_id: number
      status: boolean | null
      type: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["popup_questions"]>
    composites: {}
  }

  type popup_questionsGetPayload<S extends boolean | null | undefined | popup_questionsDefaultArgs> = $Result.GetResult<Prisma.$popup_questionsPayload, S>

  type popup_questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<popup_questionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Popup_questionsCountAggregateInputType | true
    }

  export interface popup_questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['popup_questions'], meta: { name: 'popup_questions' } }
    /**
     * Find zero or one Popup_questions that matches the filter.
     * @param {popup_questionsFindUniqueArgs} args - Arguments to find a Popup_questions
     * @example
     * // Get one Popup_questions
     * const popup_questions = await prisma.popup_questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends popup_questionsFindUniqueArgs>(args: SelectSubset<T, popup_questionsFindUniqueArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Popup_questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {popup_questionsFindUniqueOrThrowArgs} args - Arguments to find a Popup_questions
     * @example
     * // Get one Popup_questions
     * const popup_questions = await prisma.popup_questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends popup_questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, popup_questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Popup_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questionsFindFirstArgs} args - Arguments to find a Popup_questions
     * @example
     * // Get one Popup_questions
     * const popup_questions = await prisma.popup_questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends popup_questionsFindFirstArgs>(args?: SelectSubset<T, popup_questionsFindFirstArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Popup_questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questionsFindFirstOrThrowArgs} args - Arguments to find a Popup_questions
     * @example
     * // Get one Popup_questions
     * const popup_questions = await prisma.popup_questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends popup_questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, popup_questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Popup_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Popup_questions
     * const popup_questions = await prisma.popup_questions.findMany()
     * 
     * // Get first 10 Popup_questions
     * const popup_questions = await prisma.popup_questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const popup_questionsWithIdOnly = await prisma.popup_questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends popup_questionsFindManyArgs>(args?: SelectSubset<T, popup_questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Popup_questions.
     * @param {popup_questionsCreateArgs} args - Arguments to create a Popup_questions.
     * @example
     * // Create one Popup_questions
     * const Popup_questions = await prisma.popup_questions.create({
     *   data: {
     *     // ... data to create a Popup_questions
     *   }
     * })
     * 
     */
    create<T extends popup_questionsCreateArgs>(args: SelectSubset<T, popup_questionsCreateArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Popup_questions.
     * @param {popup_questionsCreateManyArgs} args - Arguments to create many Popup_questions.
     * @example
     * // Create many Popup_questions
     * const popup_questions = await prisma.popup_questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends popup_questionsCreateManyArgs>(args?: SelectSubset<T, popup_questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Popup_questions.
     * @param {popup_questionsDeleteArgs} args - Arguments to delete one Popup_questions.
     * @example
     * // Delete one Popup_questions
     * const Popup_questions = await prisma.popup_questions.delete({
     *   where: {
     *     // ... filter to delete one Popup_questions
     *   }
     * })
     * 
     */
    delete<T extends popup_questionsDeleteArgs>(args: SelectSubset<T, popup_questionsDeleteArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Popup_questions.
     * @param {popup_questionsUpdateArgs} args - Arguments to update one Popup_questions.
     * @example
     * // Update one Popup_questions
     * const popup_questions = await prisma.popup_questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends popup_questionsUpdateArgs>(args: SelectSubset<T, popup_questionsUpdateArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Popup_questions.
     * @param {popup_questionsDeleteManyArgs} args - Arguments to filter Popup_questions to delete.
     * @example
     * // Delete a few Popup_questions
     * const { count } = await prisma.popup_questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends popup_questionsDeleteManyArgs>(args?: SelectSubset<T, popup_questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Popup_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Popup_questions
     * const popup_questions = await prisma.popup_questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends popup_questionsUpdateManyArgs>(args: SelectSubset<T, popup_questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Popup_questions.
     * @param {popup_questionsUpsertArgs} args - Arguments to update or create a Popup_questions.
     * @example
     * // Update or create a Popup_questions
     * const popup_questions = await prisma.popup_questions.upsert({
     *   create: {
     *     // ... data to create a Popup_questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Popup_questions we want to update
     *   }
     * })
     */
    upsert<T extends popup_questionsUpsertArgs>(args: SelectSubset<T, popup_questionsUpsertArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Popup_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questionsCountArgs} args - Arguments to filter Popup_questions to count.
     * @example
     * // Count the number of Popup_questions
     * const count = await prisma.popup_questions.count({
     *   where: {
     *     // ... the filter for the Popup_questions we want to count
     *   }
     * })
    **/
    count<T extends popup_questionsCountArgs>(
      args?: Subset<T, popup_questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Popup_questionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Popup_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Popup_questionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Popup_questionsAggregateArgs>(args: Subset<T, Popup_questionsAggregateArgs>): Prisma.PrismaPromise<GetPopup_questionsAggregateType<T>>

    /**
     * Group by Popup_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends popup_questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: popup_questionsGroupByArgs['orderBy'] }
        : { orderBy?: popup_questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, popup_questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopup_questionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the popup_questions model
   */
  readonly fields: popup_questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for popup_questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__popup_questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    popup_questions_possible_answers<T extends popup_questions$popup_questions_possible_answersArgs<ExtArgs> = {}>(args?: Subset<T, popup_questions$popup_questions_possible_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the popup_questions model
   */
  interface popup_questionsFieldRefs {
    readonly id: FieldRef<"popup_questions", 'Int'>
    readonly name_en: FieldRef<"popup_questions", 'String'>
    readonly name_fr: FieldRef<"popup_questions", 'String'>
    readonly name_rw: FieldRef<"popup_questions", 'String'>
    readonly name_sw: FieldRef<"popup_questions", 'String'>
    readonly service_id: FieldRef<"popup_questions", 'String'>
    readonly description_en: FieldRef<"popup_questions", 'String'>
    readonly description_fr: FieldRef<"popup_questions", 'String'>
    readonly description_rw: FieldRef<"popup_questions", 'String'>
    readonly description_sw: FieldRef<"popup_questions", 'String'>
    readonly applies_to_bad: FieldRef<"popup_questions", 'Boolean'>
    readonly applies_to_good: FieldRef<"popup_questions", 'Boolean'>
    readonly applies_to_excellent: FieldRef<"popup_questions", 'Boolean'>
    readonly institution_id: FieldRef<"popup_questions", 'Int'>
    readonly status: FieldRef<"popup_questions", 'Boolean'>
    readonly type: FieldRef<"popup_questions", 'Int'>
    readonly created_at: FieldRef<"popup_questions", 'DateTime'>
    readonly updated_at: FieldRef<"popup_questions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * popup_questions findUnique
   */
  export type popup_questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions to fetch.
     */
    where: popup_questionsWhereUniqueInput
  }

  /**
   * popup_questions findUniqueOrThrow
   */
  export type popup_questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions to fetch.
     */
    where: popup_questionsWhereUniqueInput
  }

  /**
   * popup_questions findFirst
   */
  export type popup_questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions to fetch.
     */
    where?: popup_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions to fetch.
     */
    orderBy?: popup_questionsOrderByWithRelationInput | popup_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popup_questions.
     */
    cursor?: popup_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popup_questions.
     */
    distinct?: Popup_questionsScalarFieldEnum | Popup_questionsScalarFieldEnum[]
  }

  /**
   * popup_questions findFirstOrThrow
   */
  export type popup_questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions to fetch.
     */
    where?: popup_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions to fetch.
     */
    orderBy?: popup_questionsOrderByWithRelationInput | popup_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popup_questions.
     */
    cursor?: popup_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popup_questions.
     */
    distinct?: Popup_questionsScalarFieldEnum | Popup_questionsScalarFieldEnum[]
  }

  /**
   * popup_questions findMany
   */
  export type popup_questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions to fetch.
     */
    where?: popup_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions to fetch.
     */
    orderBy?: popup_questionsOrderByWithRelationInput | popup_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing popup_questions.
     */
    cursor?: popup_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions.
     */
    skip?: number
    distinct?: Popup_questionsScalarFieldEnum | Popup_questionsScalarFieldEnum[]
  }

  /**
   * popup_questions create
   */
  export type popup_questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a popup_questions.
     */
    data: XOR<popup_questionsCreateInput, popup_questionsUncheckedCreateInput>
  }

  /**
   * popup_questions createMany
   */
  export type popup_questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many popup_questions.
     */
    data: popup_questionsCreateManyInput | popup_questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * popup_questions update
   */
  export type popup_questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a popup_questions.
     */
    data: XOR<popup_questionsUpdateInput, popup_questionsUncheckedUpdateInput>
    /**
     * Choose, which popup_questions to update.
     */
    where: popup_questionsWhereUniqueInput
  }

  /**
   * popup_questions updateMany
   */
  export type popup_questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update popup_questions.
     */
    data: XOR<popup_questionsUpdateManyMutationInput, popup_questionsUncheckedUpdateManyInput>
    /**
     * Filter which popup_questions to update
     */
    where?: popup_questionsWhereInput
    /**
     * Limit how many popup_questions to update.
     */
    limit?: number
  }

  /**
   * popup_questions upsert
   */
  export type popup_questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the popup_questions to update in case it exists.
     */
    where: popup_questionsWhereUniqueInput
    /**
     * In case the popup_questions found by the `where` argument doesn't exist, create a new popup_questions with this data.
     */
    create: XOR<popup_questionsCreateInput, popup_questionsUncheckedCreateInput>
    /**
     * In case the popup_questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<popup_questionsUpdateInput, popup_questionsUncheckedUpdateInput>
  }

  /**
   * popup_questions delete
   */
  export type popup_questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
    /**
     * Filter which popup_questions to delete.
     */
    where: popup_questionsWhereUniqueInput
  }

  /**
   * popup_questions deleteMany
   */
  export type popup_questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which popup_questions to delete
     */
    where?: popup_questionsWhereInput
    /**
     * Limit how many popup_questions to delete.
     */
    limit?: number
  }

  /**
   * popup_questions.popup_questions_possible_answers
   */
  export type popup_questions$popup_questions_possible_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    where?: popup_questions_possible_answersWhereInput
    orderBy?: popup_questions_possible_answersOrderByWithRelationInput | popup_questions_possible_answersOrderByWithRelationInput[]
    cursor?: popup_questions_possible_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Popup_questions_possible_answersScalarFieldEnum | Popup_questions_possible_answersScalarFieldEnum[]
  }

  /**
   * popup_questions without action
   */
  export type popup_questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions
     */
    select?: popup_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions
     */
    omit?: popup_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questionsInclude<ExtArgs> | null
  }


  /**
   * Model popup_questions_answers
   */

  export type AggregatePopup_questions_answers = {
    _count: Popup_questions_answersCountAggregateOutputType | null
    _avg: Popup_questions_answersAvgAggregateOutputType | null
    _sum: Popup_questions_answersSumAggregateOutputType | null
    _min: Popup_questions_answersMinAggregateOutputType | null
    _max: Popup_questions_answersMaxAggregateOutputType | null
  }

  export type Popup_questions_answersAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    rating_id: number | null
    ticket_id: number | null
    answer_id: number | null
  }

  export type Popup_questions_answersSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    rating_id: number | null
    ticket_id: number | null
    answer_id: number | null
  }

  export type Popup_questions_answersMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    rating_id: number | null
    ticket_id: number | null
    answer_id: number | null
    answered_at: Date | null
  }

  export type Popup_questions_answersMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    rating_id: number | null
    ticket_id: number | null
    answer_id: number | null
    answered_at: Date | null
  }

  export type Popup_questions_answersCountAggregateOutputType = {
    id: number
    device_id: number
    rating_id: number
    ticket_id: number
    answer_id: number
    answered_at: number
    _all: number
  }


  export type Popup_questions_answersAvgAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    ticket_id?: true
    answer_id?: true
  }

  export type Popup_questions_answersSumAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    ticket_id?: true
    answer_id?: true
  }

  export type Popup_questions_answersMinAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    ticket_id?: true
    answer_id?: true
    answered_at?: true
  }

  export type Popup_questions_answersMaxAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    ticket_id?: true
    answer_id?: true
    answered_at?: true
  }

  export type Popup_questions_answersCountAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    ticket_id?: true
    answer_id?: true
    answered_at?: true
    _all?: true
  }

  export type Popup_questions_answersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which popup_questions_answers to aggregate.
     */
    where?: popup_questions_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_answers to fetch.
     */
    orderBy?: popup_questions_answersOrderByWithRelationInput | popup_questions_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: popup_questions_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned popup_questions_answers
    **/
    _count?: true | Popup_questions_answersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Popup_questions_answersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Popup_questions_answersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Popup_questions_answersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Popup_questions_answersMaxAggregateInputType
  }

  export type GetPopup_questions_answersAggregateType<T extends Popup_questions_answersAggregateArgs> = {
        [P in keyof T & keyof AggregatePopup_questions_answers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopup_questions_answers[P]>
      : GetScalarType<T[P], AggregatePopup_questions_answers[P]>
  }




  export type popup_questions_answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: popup_questions_answersWhereInput
    orderBy?: popup_questions_answersOrderByWithAggregationInput | popup_questions_answersOrderByWithAggregationInput[]
    by: Popup_questions_answersScalarFieldEnum[] | Popup_questions_answersScalarFieldEnum
    having?: popup_questions_answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Popup_questions_answersCountAggregateInputType | true
    _avg?: Popup_questions_answersAvgAggregateInputType
    _sum?: Popup_questions_answersSumAggregateInputType
    _min?: Popup_questions_answersMinAggregateInputType
    _max?: Popup_questions_answersMaxAggregateInputType
  }

  export type Popup_questions_answersGroupByOutputType = {
    id: number
    device_id: number
    rating_id: number | null
    ticket_id: number | null
    answer_id: number
    answered_at: Date
    _count: Popup_questions_answersCountAggregateOutputType | null
    _avg: Popup_questions_answersAvgAggregateOutputType | null
    _sum: Popup_questions_answersSumAggregateOutputType | null
    _min: Popup_questions_answersMinAggregateOutputType | null
    _max: Popup_questions_answersMaxAggregateOutputType | null
  }

  type GetPopup_questions_answersGroupByPayload<T extends popup_questions_answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Popup_questions_answersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Popup_questions_answersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Popup_questions_answersGroupByOutputType[P]>
            : GetScalarType<T[P], Popup_questions_answersGroupByOutputType[P]>
        }
      >
    >


  export type popup_questions_answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    rating_id?: boolean
    ticket_id?: boolean
    answer_id?: boolean
    answered_at?: boolean
    popup_questions_possible_answers?: boolean | popup_questions_possible_answersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["popup_questions_answers"]>



  export type popup_questions_answersSelectScalar = {
    id?: boolean
    device_id?: boolean
    rating_id?: boolean
    ticket_id?: boolean
    answer_id?: boolean
    answered_at?: boolean
  }

  export type popup_questions_answersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "rating_id" | "ticket_id" | "answer_id" | "answered_at", ExtArgs["result"]["popup_questions_answers"]>
  export type popup_questions_answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    popup_questions_possible_answers?: boolean | popup_questions_possible_answersDefaultArgs<ExtArgs>
  }

  export type $popup_questions_answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "popup_questions_answers"
    objects: {
      popup_questions_possible_answers: Prisma.$popup_questions_possible_answersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number
      rating_id: number | null
      ticket_id: number | null
      answer_id: number
      answered_at: Date
    }, ExtArgs["result"]["popup_questions_answers"]>
    composites: {}
  }

  type popup_questions_answersGetPayload<S extends boolean | null | undefined | popup_questions_answersDefaultArgs> = $Result.GetResult<Prisma.$popup_questions_answersPayload, S>

  type popup_questions_answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<popup_questions_answersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Popup_questions_answersCountAggregateInputType | true
    }

  export interface popup_questions_answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['popup_questions_answers'], meta: { name: 'popup_questions_answers' } }
    /**
     * Find zero or one Popup_questions_answers that matches the filter.
     * @param {popup_questions_answersFindUniqueArgs} args - Arguments to find a Popup_questions_answers
     * @example
     * // Get one Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends popup_questions_answersFindUniqueArgs>(args: SelectSubset<T, popup_questions_answersFindUniqueArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Popup_questions_answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {popup_questions_answersFindUniqueOrThrowArgs} args - Arguments to find a Popup_questions_answers
     * @example
     * // Get one Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends popup_questions_answersFindUniqueOrThrowArgs>(args: SelectSubset<T, popup_questions_answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Popup_questions_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_answersFindFirstArgs} args - Arguments to find a Popup_questions_answers
     * @example
     * // Get one Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends popup_questions_answersFindFirstArgs>(args?: SelectSubset<T, popup_questions_answersFindFirstArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Popup_questions_answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_answersFindFirstOrThrowArgs} args - Arguments to find a Popup_questions_answers
     * @example
     * // Get one Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends popup_questions_answersFindFirstOrThrowArgs>(args?: SelectSubset<T, popup_questions_answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Popup_questions_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.findMany()
     * 
     * // Get first 10 Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const popup_questions_answersWithIdOnly = await prisma.popup_questions_answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends popup_questions_answersFindManyArgs>(args?: SelectSubset<T, popup_questions_answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Popup_questions_answers.
     * @param {popup_questions_answersCreateArgs} args - Arguments to create a Popup_questions_answers.
     * @example
     * // Create one Popup_questions_answers
     * const Popup_questions_answers = await prisma.popup_questions_answers.create({
     *   data: {
     *     // ... data to create a Popup_questions_answers
     *   }
     * })
     * 
     */
    create<T extends popup_questions_answersCreateArgs>(args: SelectSubset<T, popup_questions_answersCreateArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Popup_questions_answers.
     * @param {popup_questions_answersCreateManyArgs} args - Arguments to create many Popup_questions_answers.
     * @example
     * // Create many Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends popup_questions_answersCreateManyArgs>(args?: SelectSubset<T, popup_questions_answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Popup_questions_answers.
     * @param {popup_questions_answersDeleteArgs} args - Arguments to delete one Popup_questions_answers.
     * @example
     * // Delete one Popup_questions_answers
     * const Popup_questions_answers = await prisma.popup_questions_answers.delete({
     *   where: {
     *     // ... filter to delete one Popup_questions_answers
     *   }
     * })
     * 
     */
    delete<T extends popup_questions_answersDeleteArgs>(args: SelectSubset<T, popup_questions_answersDeleteArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Popup_questions_answers.
     * @param {popup_questions_answersUpdateArgs} args - Arguments to update one Popup_questions_answers.
     * @example
     * // Update one Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends popup_questions_answersUpdateArgs>(args: SelectSubset<T, popup_questions_answersUpdateArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Popup_questions_answers.
     * @param {popup_questions_answersDeleteManyArgs} args - Arguments to filter Popup_questions_answers to delete.
     * @example
     * // Delete a few Popup_questions_answers
     * const { count } = await prisma.popup_questions_answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends popup_questions_answersDeleteManyArgs>(args?: SelectSubset<T, popup_questions_answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Popup_questions_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends popup_questions_answersUpdateManyArgs>(args: SelectSubset<T, popup_questions_answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Popup_questions_answers.
     * @param {popup_questions_answersUpsertArgs} args - Arguments to update or create a Popup_questions_answers.
     * @example
     * // Update or create a Popup_questions_answers
     * const popup_questions_answers = await prisma.popup_questions_answers.upsert({
     *   create: {
     *     // ... data to create a Popup_questions_answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Popup_questions_answers we want to update
     *   }
     * })
     */
    upsert<T extends popup_questions_answersUpsertArgs>(args: SelectSubset<T, popup_questions_answersUpsertArgs<ExtArgs>>): Prisma__popup_questions_answersClient<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Popup_questions_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_answersCountArgs} args - Arguments to filter Popup_questions_answers to count.
     * @example
     * // Count the number of Popup_questions_answers
     * const count = await prisma.popup_questions_answers.count({
     *   where: {
     *     // ... the filter for the Popup_questions_answers we want to count
     *   }
     * })
    **/
    count<T extends popup_questions_answersCountArgs>(
      args?: Subset<T, popup_questions_answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Popup_questions_answersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Popup_questions_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Popup_questions_answersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Popup_questions_answersAggregateArgs>(args: Subset<T, Popup_questions_answersAggregateArgs>): Prisma.PrismaPromise<GetPopup_questions_answersAggregateType<T>>

    /**
     * Group by Popup_questions_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends popup_questions_answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: popup_questions_answersGroupByArgs['orderBy'] }
        : { orderBy?: popup_questions_answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, popup_questions_answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopup_questions_answersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the popup_questions_answers model
   */
  readonly fields: popup_questions_answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for popup_questions_answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__popup_questions_answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    popup_questions_possible_answers<T extends popup_questions_possible_answersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, popup_questions_possible_answersDefaultArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the popup_questions_answers model
   */
  interface popup_questions_answersFieldRefs {
    readonly id: FieldRef<"popup_questions_answers", 'Int'>
    readonly device_id: FieldRef<"popup_questions_answers", 'Int'>
    readonly rating_id: FieldRef<"popup_questions_answers", 'Int'>
    readonly ticket_id: FieldRef<"popup_questions_answers", 'Int'>
    readonly answer_id: FieldRef<"popup_questions_answers", 'Int'>
    readonly answered_at: FieldRef<"popup_questions_answers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * popup_questions_answers findUnique
   */
  export type popup_questions_answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_answers to fetch.
     */
    where: popup_questions_answersWhereUniqueInput
  }

  /**
   * popup_questions_answers findUniqueOrThrow
   */
  export type popup_questions_answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_answers to fetch.
     */
    where: popup_questions_answersWhereUniqueInput
  }

  /**
   * popup_questions_answers findFirst
   */
  export type popup_questions_answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_answers to fetch.
     */
    where?: popup_questions_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_answers to fetch.
     */
    orderBy?: popup_questions_answersOrderByWithRelationInput | popup_questions_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popup_questions_answers.
     */
    cursor?: popup_questions_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popup_questions_answers.
     */
    distinct?: Popup_questions_answersScalarFieldEnum | Popup_questions_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_answers findFirstOrThrow
   */
  export type popup_questions_answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_answers to fetch.
     */
    where?: popup_questions_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_answers to fetch.
     */
    orderBy?: popup_questions_answersOrderByWithRelationInput | popup_questions_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popup_questions_answers.
     */
    cursor?: popup_questions_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popup_questions_answers.
     */
    distinct?: Popup_questions_answersScalarFieldEnum | Popup_questions_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_answers findMany
   */
  export type popup_questions_answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_answers to fetch.
     */
    where?: popup_questions_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_answers to fetch.
     */
    orderBy?: popup_questions_answersOrderByWithRelationInput | popup_questions_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing popup_questions_answers.
     */
    cursor?: popup_questions_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_answers.
     */
    skip?: number
    distinct?: Popup_questions_answersScalarFieldEnum | Popup_questions_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_answers create
   */
  export type popup_questions_answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * The data needed to create a popup_questions_answers.
     */
    data: XOR<popup_questions_answersCreateInput, popup_questions_answersUncheckedCreateInput>
  }

  /**
   * popup_questions_answers createMany
   */
  export type popup_questions_answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many popup_questions_answers.
     */
    data: popup_questions_answersCreateManyInput | popup_questions_answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * popup_questions_answers update
   */
  export type popup_questions_answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * The data needed to update a popup_questions_answers.
     */
    data: XOR<popup_questions_answersUpdateInput, popup_questions_answersUncheckedUpdateInput>
    /**
     * Choose, which popup_questions_answers to update.
     */
    where: popup_questions_answersWhereUniqueInput
  }

  /**
   * popup_questions_answers updateMany
   */
  export type popup_questions_answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update popup_questions_answers.
     */
    data: XOR<popup_questions_answersUpdateManyMutationInput, popup_questions_answersUncheckedUpdateManyInput>
    /**
     * Filter which popup_questions_answers to update
     */
    where?: popup_questions_answersWhereInput
    /**
     * Limit how many popup_questions_answers to update.
     */
    limit?: number
  }

  /**
   * popup_questions_answers upsert
   */
  export type popup_questions_answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * The filter to search for the popup_questions_answers to update in case it exists.
     */
    where: popup_questions_answersWhereUniqueInput
    /**
     * In case the popup_questions_answers found by the `where` argument doesn't exist, create a new popup_questions_answers with this data.
     */
    create: XOR<popup_questions_answersCreateInput, popup_questions_answersUncheckedCreateInput>
    /**
     * In case the popup_questions_answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<popup_questions_answersUpdateInput, popup_questions_answersUncheckedUpdateInput>
  }

  /**
   * popup_questions_answers delete
   */
  export type popup_questions_answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    /**
     * Filter which popup_questions_answers to delete.
     */
    where: popup_questions_answersWhereUniqueInput
  }

  /**
   * popup_questions_answers deleteMany
   */
  export type popup_questions_answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which popup_questions_answers to delete
     */
    where?: popup_questions_answersWhereInput
    /**
     * Limit how many popup_questions_answers to delete.
     */
    limit?: number
  }

  /**
   * popup_questions_answers without action
   */
  export type popup_questions_answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
  }


  /**
   * Model popup_questions_possible_answers
   */

  export type AggregatePopup_questions_possible_answers = {
    _count: Popup_questions_possible_answersCountAggregateOutputType | null
    _avg: Popup_questions_possible_answersAvgAggregateOutputType | null
    _sum: Popup_questions_possible_answersSumAggregateOutputType | null
    _min: Popup_questions_possible_answersMinAggregateOutputType | null
    _max: Popup_questions_possible_answersMaxAggregateOutputType | null
  }

  export type Popup_questions_possible_answersAvgAggregateOutputType = {
    id: number | null
    popup_question_id: number | null
    priority: number | null
  }

  export type Popup_questions_possible_answersSumAggregateOutputType = {
    id: number | null
    popup_question_id: number | null
    priority: number | null
  }

  export type Popup_questions_possible_answersMinAggregateOutputType = {
    id: number | null
    popup_question_id: number | null
    answer_en: string | null
    answer_fr: string | null
    answer_rw: string | null
    answer_sw: string | null
    created_at: Date | null
    updated_at: Date | null
    priority: number | null
  }

  export type Popup_questions_possible_answersMaxAggregateOutputType = {
    id: number | null
    popup_question_id: number | null
    answer_en: string | null
    answer_fr: string | null
    answer_rw: string | null
    answer_sw: string | null
    created_at: Date | null
    updated_at: Date | null
    priority: number | null
  }

  export type Popup_questions_possible_answersCountAggregateOutputType = {
    id: number
    popup_question_id: number
    answer_en: number
    answer_fr: number
    answer_rw: number
    answer_sw: number
    created_at: number
    updated_at: number
    priority: number
    _all: number
  }


  export type Popup_questions_possible_answersAvgAggregateInputType = {
    id?: true
    popup_question_id?: true
    priority?: true
  }

  export type Popup_questions_possible_answersSumAggregateInputType = {
    id?: true
    popup_question_id?: true
    priority?: true
  }

  export type Popup_questions_possible_answersMinAggregateInputType = {
    id?: true
    popup_question_id?: true
    answer_en?: true
    answer_fr?: true
    answer_rw?: true
    answer_sw?: true
    created_at?: true
    updated_at?: true
    priority?: true
  }

  export type Popup_questions_possible_answersMaxAggregateInputType = {
    id?: true
    popup_question_id?: true
    answer_en?: true
    answer_fr?: true
    answer_rw?: true
    answer_sw?: true
    created_at?: true
    updated_at?: true
    priority?: true
  }

  export type Popup_questions_possible_answersCountAggregateInputType = {
    id?: true
    popup_question_id?: true
    answer_en?: true
    answer_fr?: true
    answer_rw?: true
    answer_sw?: true
    created_at?: true
    updated_at?: true
    priority?: true
    _all?: true
  }

  export type Popup_questions_possible_answersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which popup_questions_possible_answers to aggregate.
     */
    where?: popup_questions_possible_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_possible_answers to fetch.
     */
    orderBy?: popup_questions_possible_answersOrderByWithRelationInput | popup_questions_possible_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: popup_questions_possible_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_possible_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_possible_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned popup_questions_possible_answers
    **/
    _count?: true | Popup_questions_possible_answersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Popup_questions_possible_answersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Popup_questions_possible_answersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Popup_questions_possible_answersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Popup_questions_possible_answersMaxAggregateInputType
  }

  export type GetPopup_questions_possible_answersAggregateType<T extends Popup_questions_possible_answersAggregateArgs> = {
        [P in keyof T & keyof AggregatePopup_questions_possible_answers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePopup_questions_possible_answers[P]>
      : GetScalarType<T[P], AggregatePopup_questions_possible_answers[P]>
  }




  export type popup_questions_possible_answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: popup_questions_possible_answersWhereInput
    orderBy?: popup_questions_possible_answersOrderByWithAggregationInput | popup_questions_possible_answersOrderByWithAggregationInput[]
    by: Popup_questions_possible_answersScalarFieldEnum[] | Popup_questions_possible_answersScalarFieldEnum
    having?: popup_questions_possible_answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Popup_questions_possible_answersCountAggregateInputType | true
    _avg?: Popup_questions_possible_answersAvgAggregateInputType
    _sum?: Popup_questions_possible_answersSumAggregateInputType
    _min?: Popup_questions_possible_answersMinAggregateInputType
    _max?: Popup_questions_possible_answersMaxAggregateInputType
  }

  export type Popup_questions_possible_answersGroupByOutputType = {
    id: number
    popup_question_id: number
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at: Date
    updated_at: Date
    priority: number | null
    _count: Popup_questions_possible_answersCountAggregateOutputType | null
    _avg: Popup_questions_possible_answersAvgAggregateOutputType | null
    _sum: Popup_questions_possible_answersSumAggregateOutputType | null
    _min: Popup_questions_possible_answersMinAggregateOutputType | null
    _max: Popup_questions_possible_answersMaxAggregateOutputType | null
  }

  type GetPopup_questions_possible_answersGroupByPayload<T extends popup_questions_possible_answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Popup_questions_possible_answersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Popup_questions_possible_answersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Popup_questions_possible_answersGroupByOutputType[P]>
            : GetScalarType<T[P], Popup_questions_possible_answersGroupByOutputType[P]>
        }
      >
    >


  export type popup_questions_possible_answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    popup_question_id?: boolean
    answer_en?: boolean
    answer_fr?: boolean
    answer_rw?: boolean
    answer_sw?: boolean
    created_at?: boolean
    updated_at?: boolean
    priority?: boolean
    popup_questions_answers?: boolean | popup_questions_possible_answers$popup_questions_answersArgs<ExtArgs>
    popup_questions?: boolean | popup_questionsDefaultArgs<ExtArgs>
    _count?: boolean | Popup_questions_possible_answersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["popup_questions_possible_answers"]>



  export type popup_questions_possible_answersSelectScalar = {
    id?: boolean
    popup_question_id?: boolean
    answer_en?: boolean
    answer_fr?: boolean
    answer_rw?: boolean
    answer_sw?: boolean
    created_at?: boolean
    updated_at?: boolean
    priority?: boolean
  }

  export type popup_questions_possible_answersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "popup_question_id" | "answer_en" | "answer_fr" | "answer_rw" | "answer_sw" | "created_at" | "updated_at" | "priority", ExtArgs["result"]["popup_questions_possible_answers"]>
  export type popup_questions_possible_answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    popup_questions_answers?: boolean | popup_questions_possible_answers$popup_questions_answersArgs<ExtArgs>
    popup_questions?: boolean | popup_questionsDefaultArgs<ExtArgs>
    _count?: boolean | Popup_questions_possible_answersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $popup_questions_possible_answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "popup_questions_possible_answers"
    objects: {
      popup_questions_answers: Prisma.$popup_questions_answersPayload<ExtArgs>[]
      popup_questions: Prisma.$popup_questionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      popup_question_id: number
      answer_en: string
      answer_fr: string
      answer_rw: string
      answer_sw: string
      created_at: Date
      updated_at: Date
      priority: number | null
    }, ExtArgs["result"]["popup_questions_possible_answers"]>
    composites: {}
  }

  type popup_questions_possible_answersGetPayload<S extends boolean | null | undefined | popup_questions_possible_answersDefaultArgs> = $Result.GetResult<Prisma.$popup_questions_possible_answersPayload, S>

  type popup_questions_possible_answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<popup_questions_possible_answersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Popup_questions_possible_answersCountAggregateInputType | true
    }

  export interface popup_questions_possible_answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['popup_questions_possible_answers'], meta: { name: 'popup_questions_possible_answers' } }
    /**
     * Find zero or one Popup_questions_possible_answers that matches the filter.
     * @param {popup_questions_possible_answersFindUniqueArgs} args - Arguments to find a Popup_questions_possible_answers
     * @example
     * // Get one Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends popup_questions_possible_answersFindUniqueArgs>(args: SelectSubset<T, popup_questions_possible_answersFindUniqueArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Popup_questions_possible_answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {popup_questions_possible_answersFindUniqueOrThrowArgs} args - Arguments to find a Popup_questions_possible_answers
     * @example
     * // Get one Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends popup_questions_possible_answersFindUniqueOrThrowArgs>(args: SelectSubset<T, popup_questions_possible_answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Popup_questions_possible_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_possible_answersFindFirstArgs} args - Arguments to find a Popup_questions_possible_answers
     * @example
     * // Get one Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends popup_questions_possible_answersFindFirstArgs>(args?: SelectSubset<T, popup_questions_possible_answersFindFirstArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Popup_questions_possible_answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_possible_answersFindFirstOrThrowArgs} args - Arguments to find a Popup_questions_possible_answers
     * @example
     * // Get one Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends popup_questions_possible_answersFindFirstOrThrowArgs>(args?: SelectSubset<T, popup_questions_possible_answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Popup_questions_possible_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_possible_answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findMany()
     * 
     * // Get first 10 Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const popup_questions_possible_answersWithIdOnly = await prisma.popup_questions_possible_answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends popup_questions_possible_answersFindManyArgs>(args?: SelectSubset<T, popup_questions_possible_answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Popup_questions_possible_answers.
     * @param {popup_questions_possible_answersCreateArgs} args - Arguments to create a Popup_questions_possible_answers.
     * @example
     * // Create one Popup_questions_possible_answers
     * const Popup_questions_possible_answers = await prisma.popup_questions_possible_answers.create({
     *   data: {
     *     // ... data to create a Popup_questions_possible_answers
     *   }
     * })
     * 
     */
    create<T extends popup_questions_possible_answersCreateArgs>(args: SelectSubset<T, popup_questions_possible_answersCreateArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Popup_questions_possible_answers.
     * @param {popup_questions_possible_answersCreateManyArgs} args - Arguments to create many Popup_questions_possible_answers.
     * @example
     * // Create many Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends popup_questions_possible_answersCreateManyArgs>(args?: SelectSubset<T, popup_questions_possible_answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Popup_questions_possible_answers.
     * @param {popup_questions_possible_answersDeleteArgs} args - Arguments to delete one Popup_questions_possible_answers.
     * @example
     * // Delete one Popup_questions_possible_answers
     * const Popup_questions_possible_answers = await prisma.popup_questions_possible_answers.delete({
     *   where: {
     *     // ... filter to delete one Popup_questions_possible_answers
     *   }
     * })
     * 
     */
    delete<T extends popup_questions_possible_answersDeleteArgs>(args: SelectSubset<T, popup_questions_possible_answersDeleteArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Popup_questions_possible_answers.
     * @param {popup_questions_possible_answersUpdateArgs} args - Arguments to update one Popup_questions_possible_answers.
     * @example
     * // Update one Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends popup_questions_possible_answersUpdateArgs>(args: SelectSubset<T, popup_questions_possible_answersUpdateArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Popup_questions_possible_answers.
     * @param {popup_questions_possible_answersDeleteManyArgs} args - Arguments to filter Popup_questions_possible_answers to delete.
     * @example
     * // Delete a few Popup_questions_possible_answers
     * const { count } = await prisma.popup_questions_possible_answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends popup_questions_possible_answersDeleteManyArgs>(args?: SelectSubset<T, popup_questions_possible_answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Popup_questions_possible_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_possible_answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends popup_questions_possible_answersUpdateManyArgs>(args: SelectSubset<T, popup_questions_possible_answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Popup_questions_possible_answers.
     * @param {popup_questions_possible_answersUpsertArgs} args - Arguments to update or create a Popup_questions_possible_answers.
     * @example
     * // Update or create a Popup_questions_possible_answers
     * const popup_questions_possible_answers = await prisma.popup_questions_possible_answers.upsert({
     *   create: {
     *     // ... data to create a Popup_questions_possible_answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Popup_questions_possible_answers we want to update
     *   }
     * })
     */
    upsert<T extends popup_questions_possible_answersUpsertArgs>(args: SelectSubset<T, popup_questions_possible_answersUpsertArgs<ExtArgs>>): Prisma__popup_questions_possible_answersClient<$Result.GetResult<Prisma.$popup_questions_possible_answersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Popup_questions_possible_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_possible_answersCountArgs} args - Arguments to filter Popup_questions_possible_answers to count.
     * @example
     * // Count the number of Popup_questions_possible_answers
     * const count = await prisma.popup_questions_possible_answers.count({
     *   where: {
     *     // ... the filter for the Popup_questions_possible_answers we want to count
     *   }
     * })
    **/
    count<T extends popup_questions_possible_answersCountArgs>(
      args?: Subset<T, popup_questions_possible_answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Popup_questions_possible_answersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Popup_questions_possible_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Popup_questions_possible_answersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Popup_questions_possible_answersAggregateArgs>(args: Subset<T, Popup_questions_possible_answersAggregateArgs>): Prisma.PrismaPromise<GetPopup_questions_possible_answersAggregateType<T>>

    /**
     * Group by Popup_questions_possible_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {popup_questions_possible_answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends popup_questions_possible_answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: popup_questions_possible_answersGroupByArgs['orderBy'] }
        : { orderBy?: popup_questions_possible_answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, popup_questions_possible_answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPopup_questions_possible_answersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the popup_questions_possible_answers model
   */
  readonly fields: popup_questions_possible_answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for popup_questions_possible_answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__popup_questions_possible_answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    popup_questions_answers<T extends popup_questions_possible_answers$popup_questions_answersArgs<ExtArgs> = {}>(args?: Subset<T, popup_questions_possible_answers$popup_questions_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$popup_questions_answersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    popup_questions<T extends popup_questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, popup_questionsDefaultArgs<ExtArgs>>): Prisma__popup_questionsClient<$Result.GetResult<Prisma.$popup_questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the popup_questions_possible_answers model
   */
  interface popup_questions_possible_answersFieldRefs {
    readonly id: FieldRef<"popup_questions_possible_answers", 'Int'>
    readonly popup_question_id: FieldRef<"popup_questions_possible_answers", 'Int'>
    readonly answer_en: FieldRef<"popup_questions_possible_answers", 'String'>
    readonly answer_fr: FieldRef<"popup_questions_possible_answers", 'String'>
    readonly answer_rw: FieldRef<"popup_questions_possible_answers", 'String'>
    readonly answer_sw: FieldRef<"popup_questions_possible_answers", 'String'>
    readonly created_at: FieldRef<"popup_questions_possible_answers", 'DateTime'>
    readonly updated_at: FieldRef<"popup_questions_possible_answers", 'DateTime'>
    readonly priority: FieldRef<"popup_questions_possible_answers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * popup_questions_possible_answers findUnique
   */
  export type popup_questions_possible_answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_possible_answers to fetch.
     */
    where: popup_questions_possible_answersWhereUniqueInput
  }

  /**
   * popup_questions_possible_answers findUniqueOrThrow
   */
  export type popup_questions_possible_answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_possible_answers to fetch.
     */
    where: popup_questions_possible_answersWhereUniqueInput
  }

  /**
   * popup_questions_possible_answers findFirst
   */
  export type popup_questions_possible_answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_possible_answers to fetch.
     */
    where?: popup_questions_possible_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_possible_answers to fetch.
     */
    orderBy?: popup_questions_possible_answersOrderByWithRelationInput | popup_questions_possible_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popup_questions_possible_answers.
     */
    cursor?: popup_questions_possible_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_possible_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_possible_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popup_questions_possible_answers.
     */
    distinct?: Popup_questions_possible_answersScalarFieldEnum | Popup_questions_possible_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_possible_answers findFirstOrThrow
   */
  export type popup_questions_possible_answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_possible_answers to fetch.
     */
    where?: popup_questions_possible_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_possible_answers to fetch.
     */
    orderBy?: popup_questions_possible_answersOrderByWithRelationInput | popup_questions_possible_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for popup_questions_possible_answers.
     */
    cursor?: popup_questions_possible_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_possible_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_possible_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of popup_questions_possible_answers.
     */
    distinct?: Popup_questions_possible_answersScalarFieldEnum | Popup_questions_possible_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_possible_answers findMany
   */
  export type popup_questions_possible_answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * Filter, which popup_questions_possible_answers to fetch.
     */
    where?: popup_questions_possible_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of popup_questions_possible_answers to fetch.
     */
    orderBy?: popup_questions_possible_answersOrderByWithRelationInput | popup_questions_possible_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing popup_questions_possible_answers.
     */
    cursor?: popup_questions_possible_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` popup_questions_possible_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` popup_questions_possible_answers.
     */
    skip?: number
    distinct?: Popup_questions_possible_answersScalarFieldEnum | Popup_questions_possible_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_possible_answers create
   */
  export type popup_questions_possible_answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * The data needed to create a popup_questions_possible_answers.
     */
    data: XOR<popup_questions_possible_answersCreateInput, popup_questions_possible_answersUncheckedCreateInput>
  }

  /**
   * popup_questions_possible_answers createMany
   */
  export type popup_questions_possible_answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many popup_questions_possible_answers.
     */
    data: popup_questions_possible_answersCreateManyInput | popup_questions_possible_answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * popup_questions_possible_answers update
   */
  export type popup_questions_possible_answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * The data needed to update a popup_questions_possible_answers.
     */
    data: XOR<popup_questions_possible_answersUpdateInput, popup_questions_possible_answersUncheckedUpdateInput>
    /**
     * Choose, which popup_questions_possible_answers to update.
     */
    where: popup_questions_possible_answersWhereUniqueInput
  }

  /**
   * popup_questions_possible_answers updateMany
   */
  export type popup_questions_possible_answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update popup_questions_possible_answers.
     */
    data: XOR<popup_questions_possible_answersUpdateManyMutationInput, popup_questions_possible_answersUncheckedUpdateManyInput>
    /**
     * Filter which popup_questions_possible_answers to update
     */
    where?: popup_questions_possible_answersWhereInput
    /**
     * Limit how many popup_questions_possible_answers to update.
     */
    limit?: number
  }

  /**
   * popup_questions_possible_answers upsert
   */
  export type popup_questions_possible_answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * The filter to search for the popup_questions_possible_answers to update in case it exists.
     */
    where: popup_questions_possible_answersWhereUniqueInput
    /**
     * In case the popup_questions_possible_answers found by the `where` argument doesn't exist, create a new popup_questions_possible_answers with this data.
     */
    create: XOR<popup_questions_possible_answersCreateInput, popup_questions_possible_answersUncheckedCreateInput>
    /**
     * In case the popup_questions_possible_answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<popup_questions_possible_answersUpdateInput, popup_questions_possible_answersUncheckedUpdateInput>
  }

  /**
   * popup_questions_possible_answers delete
   */
  export type popup_questions_possible_answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
    /**
     * Filter which popup_questions_possible_answers to delete.
     */
    where: popup_questions_possible_answersWhereUniqueInput
  }

  /**
   * popup_questions_possible_answers deleteMany
   */
  export type popup_questions_possible_answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which popup_questions_possible_answers to delete
     */
    where?: popup_questions_possible_answersWhereInput
    /**
     * Limit how many popup_questions_possible_answers to delete.
     */
    limit?: number
  }

  /**
   * popup_questions_possible_answers.popup_questions_answers
   */
  export type popup_questions_possible_answers$popup_questions_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_answers
     */
    select?: popup_questions_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_answers
     */
    omit?: popup_questions_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_answersInclude<ExtArgs> | null
    where?: popup_questions_answersWhereInput
    orderBy?: popup_questions_answersOrderByWithRelationInput | popup_questions_answersOrderByWithRelationInput[]
    cursor?: popup_questions_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Popup_questions_answersScalarFieldEnum | Popup_questions_answersScalarFieldEnum[]
  }

  /**
   * popup_questions_possible_answers without action
   */
  export type popup_questions_possible_answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the popup_questions_possible_answers
     */
    select?: popup_questions_possible_answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the popup_questions_possible_answers
     */
    omit?: popup_questions_possible_answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: popup_questions_possible_answersInclude<ExtArgs> | null
  }


  /**
   * Model qms_branch_operator
   */

  export type AggregateQms_branch_operator = {
    _count: Qms_branch_operatorCountAggregateOutputType | null
    _avg: Qms_branch_operatorAvgAggregateOutputType | null
    _sum: Qms_branch_operatorSumAggregateOutputType | null
    _min: Qms_branch_operatorMinAggregateOutputType | null
    _max: Qms_branch_operatorMaxAggregateOutputType | null
  }

  export type Qms_branch_operatorAvgAggregateOutputType = {
    id: number | null
    operator_id: number | null
    institution_id: number | null
    status: number | null
  }

  export type Qms_branch_operatorSumAggregateOutputType = {
    id: number | null
    operator_id: number | null
    institution_id: number | null
    status: number | null
  }

  export type Qms_branch_operatorMinAggregateOutputType = {
    id: number | null
    operator_id: number | null
    institution_id: number | null
    service_id: string | null
    linked_at: Date | null
    status: number | null
  }

  export type Qms_branch_operatorMaxAggregateOutputType = {
    id: number | null
    operator_id: number | null
    institution_id: number | null
    service_id: string | null
    linked_at: Date | null
    status: number | null
  }

  export type Qms_branch_operatorCountAggregateOutputType = {
    id: number
    operator_id: number
    institution_id: number
    service_id: number
    linked_at: number
    status: number
    _all: number
  }


  export type Qms_branch_operatorAvgAggregateInputType = {
    id?: true
    operator_id?: true
    institution_id?: true
    status?: true
  }

  export type Qms_branch_operatorSumAggregateInputType = {
    id?: true
    operator_id?: true
    institution_id?: true
    status?: true
  }

  export type Qms_branch_operatorMinAggregateInputType = {
    id?: true
    operator_id?: true
    institution_id?: true
    service_id?: true
    linked_at?: true
    status?: true
  }

  export type Qms_branch_operatorMaxAggregateInputType = {
    id?: true
    operator_id?: true
    institution_id?: true
    service_id?: true
    linked_at?: true
    status?: true
  }

  export type Qms_branch_operatorCountAggregateInputType = {
    id?: true
    operator_id?: true
    institution_id?: true
    service_id?: true
    linked_at?: true
    status?: true
    _all?: true
  }

  export type Qms_branch_operatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_branch_operator to aggregate.
     */
    where?: qms_branch_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_operators to fetch.
     */
    orderBy?: qms_branch_operatorOrderByWithRelationInput | qms_branch_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_branch_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_branch_operators
    **/
    _count?: true | Qms_branch_operatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_branch_operatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_branch_operatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_branch_operatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_branch_operatorMaxAggregateInputType
  }

  export type GetQms_branch_operatorAggregateType<T extends Qms_branch_operatorAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_branch_operator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_branch_operator[P]>
      : GetScalarType<T[P], AggregateQms_branch_operator[P]>
  }




  export type qms_branch_operatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_branch_operatorWhereInput
    orderBy?: qms_branch_operatorOrderByWithAggregationInput | qms_branch_operatorOrderByWithAggregationInput[]
    by: Qms_branch_operatorScalarFieldEnum[] | Qms_branch_operatorScalarFieldEnum
    having?: qms_branch_operatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_branch_operatorCountAggregateInputType | true
    _avg?: Qms_branch_operatorAvgAggregateInputType
    _sum?: Qms_branch_operatorSumAggregateInputType
    _min?: Qms_branch_operatorMinAggregateInputType
    _max?: Qms_branch_operatorMaxAggregateInputType
  }

  export type Qms_branch_operatorGroupByOutputType = {
    id: number
    operator_id: number
    institution_id: number
    service_id: string
    linked_at: Date
    status: number
    _count: Qms_branch_operatorCountAggregateOutputType | null
    _avg: Qms_branch_operatorAvgAggregateOutputType | null
    _sum: Qms_branch_operatorSumAggregateOutputType | null
    _min: Qms_branch_operatorMinAggregateOutputType | null
    _max: Qms_branch_operatorMaxAggregateOutputType | null
  }

  type GetQms_branch_operatorGroupByPayload<T extends qms_branch_operatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_branch_operatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_branch_operatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_branch_operatorGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_branch_operatorGroupByOutputType[P]>
        }
      >
    >


  export type qms_branch_operatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operator_id?: boolean
    institution_id?: boolean
    service_id?: boolean
    linked_at?: boolean
    status?: boolean
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_branch_operator"]>



  export type qms_branch_operatorSelectScalar = {
    id?: boolean
    operator_id?: boolean
    institution_id?: boolean
    service_id?: boolean
    linked_at?: boolean
    status?: boolean
  }

  export type qms_branch_operatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "operator_id" | "institution_id" | "service_id" | "linked_at" | "status", ExtArgs["result"]["qms_branch_operator"]>
  export type qms_branch_operatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_operatorDefaultArgs<ExtArgs>
  }

  export type $qms_branch_operatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_branch_operator"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs>
      qms_operator: Prisma.$qms_operatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operator_id: number
      institution_id: number
      service_id: string
      linked_at: Date
      status: number
    }, ExtArgs["result"]["qms_branch_operator"]>
    composites: {}
  }

  type qms_branch_operatorGetPayload<S extends boolean | null | undefined | qms_branch_operatorDefaultArgs> = $Result.GetResult<Prisma.$qms_branch_operatorPayload, S>

  type qms_branch_operatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_branch_operatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_branch_operatorCountAggregateInputType | true
    }

  export interface qms_branch_operatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_branch_operator'], meta: { name: 'qms_branch_operator' } }
    /**
     * Find zero or one Qms_branch_operator that matches the filter.
     * @param {qms_branch_operatorFindUniqueArgs} args - Arguments to find a Qms_branch_operator
     * @example
     * // Get one Qms_branch_operator
     * const qms_branch_operator = await prisma.qms_branch_operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_branch_operatorFindUniqueArgs>(args: SelectSubset<T, qms_branch_operatorFindUniqueArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_branch_operator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_branch_operatorFindUniqueOrThrowArgs} args - Arguments to find a Qms_branch_operator
     * @example
     * // Get one Qms_branch_operator
     * const qms_branch_operator = await prisma.qms_branch_operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_branch_operatorFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_branch_operatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_branch_operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_operatorFindFirstArgs} args - Arguments to find a Qms_branch_operator
     * @example
     * // Get one Qms_branch_operator
     * const qms_branch_operator = await prisma.qms_branch_operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_branch_operatorFindFirstArgs>(args?: SelectSubset<T, qms_branch_operatorFindFirstArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_branch_operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_operatorFindFirstOrThrowArgs} args - Arguments to find a Qms_branch_operator
     * @example
     * // Get one Qms_branch_operator
     * const qms_branch_operator = await prisma.qms_branch_operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_branch_operatorFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_branch_operatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_branch_operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_operatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_branch_operators
     * const qms_branch_operators = await prisma.qms_branch_operator.findMany()
     * 
     * // Get first 10 Qms_branch_operators
     * const qms_branch_operators = await prisma.qms_branch_operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_branch_operatorWithIdOnly = await prisma.qms_branch_operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_branch_operatorFindManyArgs>(args?: SelectSubset<T, qms_branch_operatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_branch_operator.
     * @param {qms_branch_operatorCreateArgs} args - Arguments to create a Qms_branch_operator.
     * @example
     * // Create one Qms_branch_operator
     * const Qms_branch_operator = await prisma.qms_branch_operator.create({
     *   data: {
     *     // ... data to create a Qms_branch_operator
     *   }
     * })
     * 
     */
    create<T extends qms_branch_operatorCreateArgs>(args: SelectSubset<T, qms_branch_operatorCreateArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_branch_operators.
     * @param {qms_branch_operatorCreateManyArgs} args - Arguments to create many Qms_branch_operators.
     * @example
     * // Create many Qms_branch_operators
     * const qms_branch_operator = await prisma.qms_branch_operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_branch_operatorCreateManyArgs>(args?: SelectSubset<T, qms_branch_operatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_branch_operator.
     * @param {qms_branch_operatorDeleteArgs} args - Arguments to delete one Qms_branch_operator.
     * @example
     * // Delete one Qms_branch_operator
     * const Qms_branch_operator = await prisma.qms_branch_operator.delete({
     *   where: {
     *     // ... filter to delete one Qms_branch_operator
     *   }
     * })
     * 
     */
    delete<T extends qms_branch_operatorDeleteArgs>(args: SelectSubset<T, qms_branch_operatorDeleteArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_branch_operator.
     * @param {qms_branch_operatorUpdateArgs} args - Arguments to update one Qms_branch_operator.
     * @example
     * // Update one Qms_branch_operator
     * const qms_branch_operator = await prisma.qms_branch_operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_branch_operatorUpdateArgs>(args: SelectSubset<T, qms_branch_operatorUpdateArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_branch_operators.
     * @param {qms_branch_operatorDeleteManyArgs} args - Arguments to filter Qms_branch_operators to delete.
     * @example
     * // Delete a few Qms_branch_operators
     * const { count } = await prisma.qms_branch_operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_branch_operatorDeleteManyArgs>(args?: SelectSubset<T, qms_branch_operatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_branch_operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_operatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_branch_operators
     * const qms_branch_operator = await prisma.qms_branch_operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_branch_operatorUpdateManyArgs>(args: SelectSubset<T, qms_branch_operatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_branch_operator.
     * @param {qms_branch_operatorUpsertArgs} args - Arguments to update or create a Qms_branch_operator.
     * @example
     * // Update or create a Qms_branch_operator
     * const qms_branch_operator = await prisma.qms_branch_operator.upsert({
     *   create: {
     *     // ... data to create a Qms_branch_operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_branch_operator we want to update
     *   }
     * })
     */
    upsert<T extends qms_branch_operatorUpsertArgs>(args: SelectSubset<T, qms_branch_operatorUpsertArgs<ExtArgs>>): Prisma__qms_branch_operatorClient<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_branch_operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_operatorCountArgs} args - Arguments to filter Qms_branch_operators to count.
     * @example
     * // Count the number of Qms_branch_operators
     * const count = await prisma.qms_branch_operator.count({
     *   where: {
     *     // ... the filter for the Qms_branch_operators we want to count
     *   }
     * })
    **/
    count<T extends qms_branch_operatorCountArgs>(
      args?: Subset<T, qms_branch_operatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_branch_operatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_branch_operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_branch_operatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_branch_operatorAggregateArgs>(args: Subset<T, Qms_branch_operatorAggregateArgs>): Prisma.PrismaPromise<GetQms_branch_operatorAggregateType<T>>

    /**
     * Group by Qms_branch_operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_operatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_branch_operatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_branch_operatorGroupByArgs['orderBy'] }
        : { orderBy?: qms_branch_operatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_branch_operatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_branch_operatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_branch_operator model
   */
  readonly fields: qms_branch_operatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_branch_operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_branch_operatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_operator<T extends qms_operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_operatorDefaultArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_branch_operator model
   */
  interface qms_branch_operatorFieldRefs {
    readonly id: FieldRef<"qms_branch_operator", 'Int'>
    readonly operator_id: FieldRef<"qms_branch_operator", 'Int'>
    readonly institution_id: FieldRef<"qms_branch_operator", 'Int'>
    readonly service_id: FieldRef<"qms_branch_operator", 'String'>
    readonly linked_at: FieldRef<"qms_branch_operator", 'DateTime'>
    readonly status: FieldRef<"qms_branch_operator", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * qms_branch_operator findUnique
   */
  export type qms_branch_operatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_operator to fetch.
     */
    where: qms_branch_operatorWhereUniqueInput
  }

  /**
   * qms_branch_operator findUniqueOrThrow
   */
  export type qms_branch_operatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_operator to fetch.
     */
    where: qms_branch_operatorWhereUniqueInput
  }

  /**
   * qms_branch_operator findFirst
   */
  export type qms_branch_operatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_operator to fetch.
     */
    where?: qms_branch_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_operators to fetch.
     */
    orderBy?: qms_branch_operatorOrderByWithRelationInput | qms_branch_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_branch_operators.
     */
    cursor?: qms_branch_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_branch_operators.
     */
    distinct?: Qms_branch_operatorScalarFieldEnum | Qms_branch_operatorScalarFieldEnum[]
  }

  /**
   * qms_branch_operator findFirstOrThrow
   */
  export type qms_branch_operatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_operator to fetch.
     */
    where?: qms_branch_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_operators to fetch.
     */
    orderBy?: qms_branch_operatorOrderByWithRelationInput | qms_branch_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_branch_operators.
     */
    cursor?: qms_branch_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_branch_operators.
     */
    distinct?: Qms_branch_operatorScalarFieldEnum | Qms_branch_operatorScalarFieldEnum[]
  }

  /**
   * qms_branch_operator findMany
   */
  export type qms_branch_operatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_operators to fetch.
     */
    where?: qms_branch_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_operators to fetch.
     */
    orderBy?: qms_branch_operatorOrderByWithRelationInput | qms_branch_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_branch_operators.
     */
    cursor?: qms_branch_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_operators.
     */
    skip?: number
    distinct?: Qms_branch_operatorScalarFieldEnum | Qms_branch_operatorScalarFieldEnum[]
  }

  /**
   * qms_branch_operator create
   */
  export type qms_branch_operatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_branch_operator.
     */
    data: XOR<qms_branch_operatorCreateInput, qms_branch_operatorUncheckedCreateInput>
  }

  /**
   * qms_branch_operator createMany
   */
  export type qms_branch_operatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_branch_operators.
     */
    data: qms_branch_operatorCreateManyInput | qms_branch_operatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_branch_operator update
   */
  export type qms_branch_operatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_branch_operator.
     */
    data: XOR<qms_branch_operatorUpdateInput, qms_branch_operatorUncheckedUpdateInput>
    /**
     * Choose, which qms_branch_operator to update.
     */
    where: qms_branch_operatorWhereUniqueInput
  }

  /**
   * qms_branch_operator updateMany
   */
  export type qms_branch_operatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_branch_operators.
     */
    data: XOR<qms_branch_operatorUpdateManyMutationInput, qms_branch_operatorUncheckedUpdateManyInput>
    /**
     * Filter which qms_branch_operators to update
     */
    where?: qms_branch_operatorWhereInput
    /**
     * Limit how many qms_branch_operators to update.
     */
    limit?: number
  }

  /**
   * qms_branch_operator upsert
   */
  export type qms_branch_operatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_branch_operator to update in case it exists.
     */
    where: qms_branch_operatorWhereUniqueInput
    /**
     * In case the qms_branch_operator found by the `where` argument doesn't exist, create a new qms_branch_operator with this data.
     */
    create: XOR<qms_branch_operatorCreateInput, qms_branch_operatorUncheckedCreateInput>
    /**
     * In case the qms_branch_operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_branch_operatorUpdateInput, qms_branch_operatorUncheckedUpdateInput>
  }

  /**
   * qms_branch_operator delete
   */
  export type qms_branch_operatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    /**
     * Filter which qms_branch_operator to delete.
     */
    where: qms_branch_operatorWhereUniqueInput
  }

  /**
   * qms_branch_operator deleteMany
   */
  export type qms_branch_operatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_branch_operators to delete
     */
    where?: qms_branch_operatorWhereInput
    /**
     * Limit how many qms_branch_operators to delete.
     */
    limit?: number
  }

  /**
   * qms_branch_operator without action
   */
  export type qms_branch_operatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
  }


  /**
   * Model qms_branch_transactions
   */

  export type AggregateQms_branch_transactions = {
    _count: Qms_branch_transactionsCountAggregateOutputType | null
    _avg: Qms_branch_transactionsAvgAggregateOutputType | null
    _sum: Qms_branch_transactionsSumAggregateOutputType | null
    _min: Qms_branch_transactionsMinAggregateOutputType | null
    _max: Qms_branch_transactionsMaxAggregateOutputType | null
  }

  export type Qms_branch_transactionsAvgAggregateOutputType = {
    id: number | null
    affiliate_id: number | null
  }

  export type Qms_branch_transactionsSumAggregateOutputType = {
    id: number | null
    affiliate_id: number | null
  }

  export type Qms_branch_transactionsMinAggregateOutputType = {
    id: number | null
    affiliate_id: number | null
    date: Date | null
    note: string | null
    created_at: Date | null
    last_updated: Date | null
  }

  export type Qms_branch_transactionsMaxAggregateOutputType = {
    id: number | null
    affiliate_id: number | null
    date: Date | null
    note: string | null
    created_at: Date | null
    last_updated: Date | null
  }

  export type Qms_branch_transactionsCountAggregateOutputType = {
    id: number
    affiliate_id: number
    date: number
    note: number
    created_at: number
    last_updated: number
    _all: number
  }


  export type Qms_branch_transactionsAvgAggregateInputType = {
    id?: true
    affiliate_id?: true
  }

  export type Qms_branch_transactionsSumAggregateInputType = {
    id?: true
    affiliate_id?: true
  }

  export type Qms_branch_transactionsMinAggregateInputType = {
    id?: true
    affiliate_id?: true
    date?: true
    note?: true
    created_at?: true
    last_updated?: true
  }

  export type Qms_branch_transactionsMaxAggregateInputType = {
    id?: true
    affiliate_id?: true
    date?: true
    note?: true
    created_at?: true
    last_updated?: true
  }

  export type Qms_branch_transactionsCountAggregateInputType = {
    id?: true
    affiliate_id?: true
    date?: true
    note?: true
    created_at?: true
    last_updated?: true
    _all?: true
  }

  export type Qms_branch_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_branch_transactions to aggregate.
     */
    where?: qms_branch_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_transactions to fetch.
     */
    orderBy?: qms_branch_transactionsOrderByWithRelationInput | qms_branch_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_branch_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_branch_transactions
    **/
    _count?: true | Qms_branch_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_branch_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_branch_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_branch_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_branch_transactionsMaxAggregateInputType
  }

  export type GetQms_branch_transactionsAggregateType<T extends Qms_branch_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_branch_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_branch_transactions[P]>
      : GetScalarType<T[P], AggregateQms_branch_transactions[P]>
  }




  export type qms_branch_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_branch_transactionsWhereInput
    orderBy?: qms_branch_transactionsOrderByWithAggregationInput | qms_branch_transactionsOrderByWithAggregationInput[]
    by: Qms_branch_transactionsScalarFieldEnum[] | Qms_branch_transactionsScalarFieldEnum
    having?: qms_branch_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_branch_transactionsCountAggregateInputType | true
    _avg?: Qms_branch_transactionsAvgAggregateInputType
    _sum?: Qms_branch_transactionsSumAggregateInputType
    _min?: Qms_branch_transactionsMinAggregateInputType
    _max?: Qms_branch_transactionsMaxAggregateInputType
  }

  export type Qms_branch_transactionsGroupByOutputType = {
    id: number
    affiliate_id: number
    date: Date
    note: string | null
    created_at: Date
    last_updated: Date
    _count: Qms_branch_transactionsCountAggregateOutputType | null
    _avg: Qms_branch_transactionsAvgAggregateOutputType | null
    _sum: Qms_branch_transactionsSumAggregateOutputType | null
    _min: Qms_branch_transactionsMinAggregateOutputType | null
    _max: Qms_branch_transactionsMaxAggregateOutputType | null
  }

  type GetQms_branch_transactionsGroupByPayload<T extends qms_branch_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_branch_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_branch_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_branch_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_branch_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type qms_branch_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliate_id?: boolean
    date?: boolean
    note?: boolean
    created_at?: boolean
    last_updated?: boolean
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    qms_operator_transactions?: boolean | qms_branch_transactions$qms_operator_transactionsArgs<ExtArgs>
    _count?: boolean | Qms_branch_transactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_branch_transactions"]>



  export type qms_branch_transactionsSelectScalar = {
    id?: boolean
    affiliate_id?: boolean
    date?: boolean
    note?: boolean
    created_at?: boolean
    last_updated?: boolean
  }

  export type qms_branch_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "affiliate_id" | "date" | "note" | "created_at" | "last_updated", ExtArgs["result"]["qms_branch_transactions"]>
  export type qms_branch_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    qms_operator_transactions?: boolean | qms_branch_transactions$qms_operator_transactionsArgs<ExtArgs>
    _count?: boolean | Qms_branch_transactionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $qms_branch_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_branch_transactions"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs>
      qms_operator_transactions: Prisma.$qms_operator_transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      affiliate_id: number
      date: Date
      note: string | null
      created_at: Date
      last_updated: Date
    }, ExtArgs["result"]["qms_branch_transactions"]>
    composites: {}
  }

  type qms_branch_transactionsGetPayload<S extends boolean | null | undefined | qms_branch_transactionsDefaultArgs> = $Result.GetResult<Prisma.$qms_branch_transactionsPayload, S>

  type qms_branch_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_branch_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_branch_transactionsCountAggregateInputType | true
    }

  export interface qms_branch_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_branch_transactions'], meta: { name: 'qms_branch_transactions' } }
    /**
     * Find zero or one Qms_branch_transactions that matches the filter.
     * @param {qms_branch_transactionsFindUniqueArgs} args - Arguments to find a Qms_branch_transactions
     * @example
     * // Get one Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_branch_transactionsFindUniqueArgs>(args: SelectSubset<T, qms_branch_transactionsFindUniqueArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_branch_transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_branch_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Qms_branch_transactions
     * @example
     * // Get one Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_branch_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_branch_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_branch_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_transactionsFindFirstArgs} args - Arguments to find a Qms_branch_transactions
     * @example
     * // Get one Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_branch_transactionsFindFirstArgs>(args?: SelectSubset<T, qms_branch_transactionsFindFirstArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_branch_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_transactionsFindFirstOrThrowArgs} args - Arguments to find a Qms_branch_transactions
     * @example
     * // Get one Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_branch_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_branch_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_branch_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.findMany()
     * 
     * // Get first 10 Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_branch_transactionsWithIdOnly = await prisma.qms_branch_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_branch_transactionsFindManyArgs>(args?: SelectSubset<T, qms_branch_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_branch_transactions.
     * @param {qms_branch_transactionsCreateArgs} args - Arguments to create a Qms_branch_transactions.
     * @example
     * // Create one Qms_branch_transactions
     * const Qms_branch_transactions = await prisma.qms_branch_transactions.create({
     *   data: {
     *     // ... data to create a Qms_branch_transactions
     *   }
     * })
     * 
     */
    create<T extends qms_branch_transactionsCreateArgs>(args: SelectSubset<T, qms_branch_transactionsCreateArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_branch_transactions.
     * @param {qms_branch_transactionsCreateManyArgs} args - Arguments to create many Qms_branch_transactions.
     * @example
     * // Create many Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_branch_transactionsCreateManyArgs>(args?: SelectSubset<T, qms_branch_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_branch_transactions.
     * @param {qms_branch_transactionsDeleteArgs} args - Arguments to delete one Qms_branch_transactions.
     * @example
     * // Delete one Qms_branch_transactions
     * const Qms_branch_transactions = await prisma.qms_branch_transactions.delete({
     *   where: {
     *     // ... filter to delete one Qms_branch_transactions
     *   }
     * })
     * 
     */
    delete<T extends qms_branch_transactionsDeleteArgs>(args: SelectSubset<T, qms_branch_transactionsDeleteArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_branch_transactions.
     * @param {qms_branch_transactionsUpdateArgs} args - Arguments to update one Qms_branch_transactions.
     * @example
     * // Update one Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_branch_transactionsUpdateArgs>(args: SelectSubset<T, qms_branch_transactionsUpdateArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_branch_transactions.
     * @param {qms_branch_transactionsDeleteManyArgs} args - Arguments to filter Qms_branch_transactions to delete.
     * @example
     * // Delete a few Qms_branch_transactions
     * const { count } = await prisma.qms_branch_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_branch_transactionsDeleteManyArgs>(args?: SelectSubset<T, qms_branch_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_branch_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_branch_transactionsUpdateManyArgs>(args: SelectSubset<T, qms_branch_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_branch_transactions.
     * @param {qms_branch_transactionsUpsertArgs} args - Arguments to update or create a Qms_branch_transactions.
     * @example
     * // Update or create a Qms_branch_transactions
     * const qms_branch_transactions = await prisma.qms_branch_transactions.upsert({
     *   create: {
     *     // ... data to create a Qms_branch_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_branch_transactions we want to update
     *   }
     * })
     */
    upsert<T extends qms_branch_transactionsUpsertArgs>(args: SelectSubset<T, qms_branch_transactionsUpsertArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_branch_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_transactionsCountArgs} args - Arguments to filter Qms_branch_transactions to count.
     * @example
     * // Count the number of Qms_branch_transactions
     * const count = await prisma.qms_branch_transactions.count({
     *   where: {
     *     // ... the filter for the Qms_branch_transactions we want to count
     *   }
     * })
    **/
    count<T extends qms_branch_transactionsCountArgs>(
      args?: Subset<T, qms_branch_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_branch_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_branch_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_branch_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_branch_transactionsAggregateArgs>(args: Subset<T, Qms_branch_transactionsAggregateArgs>): Prisma.PrismaPromise<GetQms_branch_transactionsAggregateType<T>>

    /**
     * Group by Qms_branch_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_branch_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_branch_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_branch_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: qms_branch_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_branch_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_branch_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_branch_transactions model
   */
  readonly fields: qms_branch_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_branch_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_branch_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_operator_transactions<T extends qms_branch_transactions$qms_operator_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, qms_branch_transactions$qms_operator_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_branch_transactions model
   */
  interface qms_branch_transactionsFieldRefs {
    readonly id: FieldRef<"qms_branch_transactions", 'Int'>
    readonly affiliate_id: FieldRef<"qms_branch_transactions", 'Int'>
    readonly date: FieldRef<"qms_branch_transactions", 'DateTime'>
    readonly note: FieldRef<"qms_branch_transactions", 'String'>
    readonly created_at: FieldRef<"qms_branch_transactions", 'DateTime'>
    readonly last_updated: FieldRef<"qms_branch_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * qms_branch_transactions findUnique
   */
  export type qms_branch_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_transactions to fetch.
     */
    where: qms_branch_transactionsWhereUniqueInput
  }

  /**
   * qms_branch_transactions findUniqueOrThrow
   */
  export type qms_branch_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_transactions to fetch.
     */
    where: qms_branch_transactionsWhereUniqueInput
  }

  /**
   * qms_branch_transactions findFirst
   */
  export type qms_branch_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_transactions to fetch.
     */
    where?: qms_branch_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_transactions to fetch.
     */
    orderBy?: qms_branch_transactionsOrderByWithRelationInput | qms_branch_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_branch_transactions.
     */
    cursor?: qms_branch_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_branch_transactions.
     */
    distinct?: Qms_branch_transactionsScalarFieldEnum | Qms_branch_transactionsScalarFieldEnum[]
  }

  /**
   * qms_branch_transactions findFirstOrThrow
   */
  export type qms_branch_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_transactions to fetch.
     */
    where?: qms_branch_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_transactions to fetch.
     */
    orderBy?: qms_branch_transactionsOrderByWithRelationInput | qms_branch_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_branch_transactions.
     */
    cursor?: qms_branch_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_branch_transactions.
     */
    distinct?: Qms_branch_transactionsScalarFieldEnum | Qms_branch_transactionsScalarFieldEnum[]
  }

  /**
   * qms_branch_transactions findMany
   */
  export type qms_branch_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_branch_transactions to fetch.
     */
    where?: qms_branch_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_branch_transactions to fetch.
     */
    orderBy?: qms_branch_transactionsOrderByWithRelationInput | qms_branch_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_branch_transactions.
     */
    cursor?: qms_branch_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_branch_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_branch_transactions.
     */
    skip?: number
    distinct?: Qms_branch_transactionsScalarFieldEnum | Qms_branch_transactionsScalarFieldEnum[]
  }

  /**
   * qms_branch_transactions create
   */
  export type qms_branch_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_branch_transactions.
     */
    data: XOR<qms_branch_transactionsCreateInput, qms_branch_transactionsUncheckedCreateInput>
  }

  /**
   * qms_branch_transactions createMany
   */
  export type qms_branch_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_branch_transactions.
     */
    data: qms_branch_transactionsCreateManyInput | qms_branch_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_branch_transactions update
   */
  export type qms_branch_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_branch_transactions.
     */
    data: XOR<qms_branch_transactionsUpdateInput, qms_branch_transactionsUncheckedUpdateInput>
    /**
     * Choose, which qms_branch_transactions to update.
     */
    where: qms_branch_transactionsWhereUniqueInput
  }

  /**
   * qms_branch_transactions updateMany
   */
  export type qms_branch_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_branch_transactions.
     */
    data: XOR<qms_branch_transactionsUpdateManyMutationInput, qms_branch_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which qms_branch_transactions to update
     */
    where?: qms_branch_transactionsWhereInput
    /**
     * Limit how many qms_branch_transactions to update.
     */
    limit?: number
  }

  /**
   * qms_branch_transactions upsert
   */
  export type qms_branch_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_branch_transactions to update in case it exists.
     */
    where: qms_branch_transactionsWhereUniqueInput
    /**
     * In case the qms_branch_transactions found by the `where` argument doesn't exist, create a new qms_branch_transactions with this data.
     */
    create: XOR<qms_branch_transactionsCreateInput, qms_branch_transactionsUncheckedCreateInput>
    /**
     * In case the qms_branch_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_branch_transactionsUpdateInput, qms_branch_transactionsUncheckedUpdateInput>
  }

  /**
   * qms_branch_transactions delete
   */
  export type qms_branch_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
    /**
     * Filter which qms_branch_transactions to delete.
     */
    where: qms_branch_transactionsWhereUniqueInput
  }

  /**
   * qms_branch_transactions deleteMany
   */
  export type qms_branch_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_branch_transactions to delete
     */
    where?: qms_branch_transactionsWhereInput
    /**
     * Limit how many qms_branch_transactions to delete.
     */
    limit?: number
  }

  /**
   * qms_branch_transactions.qms_operator_transactions
   */
  export type qms_branch_transactions$qms_operator_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    where?: qms_operator_transactionsWhereInput
    orderBy?: qms_operator_transactionsOrderByWithRelationInput | qms_operator_transactionsOrderByWithRelationInput[]
    cursor?: qms_operator_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_operator_transactionsScalarFieldEnum | Qms_operator_transactionsScalarFieldEnum[]
  }

  /**
   * qms_branch_transactions without action
   */
  export type qms_branch_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_transactions
     */
    select?: qms_branch_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_transactions
     */
    omit?: qms_branch_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_transactionsInclude<ExtArgs> | null
  }


  /**
   * Model qms_counter
   */

  export type AggregateQms_counter = {
    _count: Qms_counterCountAggregateOutputType | null
    _avg: Qms_counterAvgAggregateOutputType | null
    _sum: Qms_counterSumAggregateOutputType | null
    _min: Qms_counterMinAggregateOutputType | null
    _max: Qms_counterMaxAggregateOutputType | null
  }

  export type Qms_counterAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
  }

  export type Qms_counterSumAggregateOutputType = {
    id: number | null
    service_id: number | null
  }

  export type Qms_counterMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Qms_counterMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    service_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Qms_counterCountAggregateOutputType = {
    id: number
    name: number
    description: number
    service_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Qms_counterAvgAggregateInputType = {
    id?: true
    service_id?: true
  }

  export type Qms_counterSumAggregateInputType = {
    id?: true
    service_id?: true
  }

  export type Qms_counterMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Qms_counterMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Qms_counterCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Qms_counterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_counter to aggregate.
     */
    where?: qms_counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_counters to fetch.
     */
    orderBy?: qms_counterOrderByWithRelationInput | qms_counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_counters
    **/
    _count?: true | Qms_counterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_counterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_counterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_counterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_counterMaxAggregateInputType
  }

  export type GetQms_counterAggregateType<T extends Qms_counterAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_counter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_counter[P]>
      : GetScalarType<T[P], AggregateQms_counter[P]>
  }




  export type qms_counterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_counterWhereInput
    orderBy?: qms_counterOrderByWithAggregationInput | qms_counterOrderByWithAggregationInput[]
    by: Qms_counterScalarFieldEnum[] | Qms_counterScalarFieldEnum
    having?: qms_counterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_counterCountAggregateInputType | true
    _avg?: Qms_counterAvgAggregateInputType
    _sum?: Qms_counterSumAggregateInputType
    _min?: Qms_counterMinAggregateInputType
    _max?: Qms_counterMaxAggregateInputType
  }

  export type Qms_counterGroupByOutputType = {
    id: number
    name: string
    description: string | null
    service_id: number | null
    created_at: Date
    updated_at: Date
    _count: Qms_counterCountAggregateOutputType | null
    _avg: Qms_counterAvgAggregateOutputType | null
    _sum: Qms_counterSumAggregateOutputType | null
    _min: Qms_counterMinAggregateOutputType | null
    _max: Qms_counterMaxAggregateOutputType | null
  }

  type GetQms_counterGroupByPayload<T extends qms_counterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_counterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_counterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_counterGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_counterGroupByOutputType[P]>
        }
      >
    >


  export type qms_counterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | qms_counter$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["qms_counter"]>



  export type qms_counterSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type qms_counterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "service_id" | "created_at" | "updated_at", ExtArgs["result"]["qms_counter"]>
  export type qms_counterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | qms_counter$serviceArgs<ExtArgs>
  }

  export type $qms_counterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_counter"
    objects: {
      service: Prisma.$servicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      service_id: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["qms_counter"]>
    composites: {}
  }

  type qms_counterGetPayload<S extends boolean | null | undefined | qms_counterDefaultArgs> = $Result.GetResult<Prisma.$qms_counterPayload, S>

  type qms_counterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_counterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_counterCountAggregateInputType | true
    }

  export interface qms_counterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_counter'], meta: { name: 'qms_counter' } }
    /**
     * Find zero or one Qms_counter that matches the filter.
     * @param {qms_counterFindUniqueArgs} args - Arguments to find a Qms_counter
     * @example
     * // Get one Qms_counter
     * const qms_counter = await prisma.qms_counter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_counterFindUniqueArgs>(args: SelectSubset<T, qms_counterFindUniqueArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_counter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_counterFindUniqueOrThrowArgs} args - Arguments to find a Qms_counter
     * @example
     * // Get one Qms_counter
     * const qms_counter = await prisma.qms_counter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_counterFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_counterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_counter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_counterFindFirstArgs} args - Arguments to find a Qms_counter
     * @example
     * // Get one Qms_counter
     * const qms_counter = await prisma.qms_counter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_counterFindFirstArgs>(args?: SelectSubset<T, qms_counterFindFirstArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_counter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_counterFindFirstOrThrowArgs} args - Arguments to find a Qms_counter
     * @example
     * // Get one Qms_counter
     * const qms_counter = await prisma.qms_counter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_counterFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_counterFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_counters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_counterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_counters
     * const qms_counters = await prisma.qms_counter.findMany()
     * 
     * // Get first 10 Qms_counters
     * const qms_counters = await prisma.qms_counter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_counterWithIdOnly = await prisma.qms_counter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_counterFindManyArgs>(args?: SelectSubset<T, qms_counterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_counter.
     * @param {qms_counterCreateArgs} args - Arguments to create a Qms_counter.
     * @example
     * // Create one Qms_counter
     * const Qms_counter = await prisma.qms_counter.create({
     *   data: {
     *     // ... data to create a Qms_counter
     *   }
     * })
     * 
     */
    create<T extends qms_counterCreateArgs>(args: SelectSubset<T, qms_counterCreateArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_counters.
     * @param {qms_counterCreateManyArgs} args - Arguments to create many Qms_counters.
     * @example
     * // Create many Qms_counters
     * const qms_counter = await prisma.qms_counter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_counterCreateManyArgs>(args?: SelectSubset<T, qms_counterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_counter.
     * @param {qms_counterDeleteArgs} args - Arguments to delete one Qms_counter.
     * @example
     * // Delete one Qms_counter
     * const Qms_counter = await prisma.qms_counter.delete({
     *   where: {
     *     // ... filter to delete one Qms_counter
     *   }
     * })
     * 
     */
    delete<T extends qms_counterDeleteArgs>(args: SelectSubset<T, qms_counterDeleteArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_counter.
     * @param {qms_counterUpdateArgs} args - Arguments to update one Qms_counter.
     * @example
     * // Update one Qms_counter
     * const qms_counter = await prisma.qms_counter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_counterUpdateArgs>(args: SelectSubset<T, qms_counterUpdateArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_counters.
     * @param {qms_counterDeleteManyArgs} args - Arguments to filter Qms_counters to delete.
     * @example
     * // Delete a few Qms_counters
     * const { count } = await prisma.qms_counter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_counterDeleteManyArgs>(args?: SelectSubset<T, qms_counterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_counters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_counterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_counters
     * const qms_counter = await prisma.qms_counter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_counterUpdateManyArgs>(args: SelectSubset<T, qms_counterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_counter.
     * @param {qms_counterUpsertArgs} args - Arguments to update or create a Qms_counter.
     * @example
     * // Update or create a Qms_counter
     * const qms_counter = await prisma.qms_counter.upsert({
     *   create: {
     *     // ... data to create a Qms_counter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_counter we want to update
     *   }
     * })
     */
    upsert<T extends qms_counterUpsertArgs>(args: SelectSubset<T, qms_counterUpsertArgs<ExtArgs>>): Prisma__qms_counterClient<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_counters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_counterCountArgs} args - Arguments to filter Qms_counters to count.
     * @example
     * // Count the number of Qms_counters
     * const count = await prisma.qms_counter.count({
     *   where: {
     *     // ... the filter for the Qms_counters we want to count
     *   }
     * })
    **/
    count<T extends qms_counterCountArgs>(
      args?: Subset<T, qms_counterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_counterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_counter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_counterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_counterAggregateArgs>(args: Subset<T, Qms_counterAggregateArgs>): Prisma.PrismaPromise<GetQms_counterAggregateType<T>>

    /**
     * Group by Qms_counter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_counterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_counterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_counterGroupByArgs['orderBy'] }
        : { orderBy?: qms_counterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_counterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_counterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_counter model
   */
  readonly fields: qms_counterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_counter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_counterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends qms_counter$serviceArgs<ExtArgs> = {}>(args?: Subset<T, qms_counter$serviceArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_counter model
   */
  interface qms_counterFieldRefs {
    readonly id: FieldRef<"qms_counter", 'Int'>
    readonly name: FieldRef<"qms_counter", 'String'>
    readonly description: FieldRef<"qms_counter", 'String'>
    readonly service_id: FieldRef<"qms_counter", 'Int'>
    readonly created_at: FieldRef<"qms_counter", 'DateTime'>
    readonly updated_at: FieldRef<"qms_counter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * qms_counter findUnique
   */
  export type qms_counterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * Filter, which qms_counter to fetch.
     */
    where: qms_counterWhereUniqueInput
  }

  /**
   * qms_counter findUniqueOrThrow
   */
  export type qms_counterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * Filter, which qms_counter to fetch.
     */
    where: qms_counterWhereUniqueInput
  }

  /**
   * qms_counter findFirst
   */
  export type qms_counterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * Filter, which qms_counter to fetch.
     */
    where?: qms_counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_counters to fetch.
     */
    orderBy?: qms_counterOrderByWithRelationInput | qms_counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_counters.
     */
    cursor?: qms_counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_counters.
     */
    distinct?: Qms_counterScalarFieldEnum | Qms_counterScalarFieldEnum[]
  }

  /**
   * qms_counter findFirstOrThrow
   */
  export type qms_counterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * Filter, which qms_counter to fetch.
     */
    where?: qms_counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_counters to fetch.
     */
    orderBy?: qms_counterOrderByWithRelationInput | qms_counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_counters.
     */
    cursor?: qms_counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_counters.
     */
    distinct?: Qms_counterScalarFieldEnum | Qms_counterScalarFieldEnum[]
  }

  /**
   * qms_counter findMany
   */
  export type qms_counterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * Filter, which qms_counters to fetch.
     */
    where?: qms_counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_counters to fetch.
     */
    orderBy?: qms_counterOrderByWithRelationInput | qms_counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_counters.
     */
    cursor?: qms_counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_counters.
     */
    skip?: number
    distinct?: Qms_counterScalarFieldEnum | Qms_counterScalarFieldEnum[]
  }

  /**
   * qms_counter create
   */
  export type qms_counterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_counter.
     */
    data: XOR<qms_counterCreateInput, qms_counterUncheckedCreateInput>
  }

  /**
   * qms_counter createMany
   */
  export type qms_counterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_counters.
     */
    data: qms_counterCreateManyInput | qms_counterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_counter update
   */
  export type qms_counterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_counter.
     */
    data: XOR<qms_counterUpdateInput, qms_counterUncheckedUpdateInput>
    /**
     * Choose, which qms_counter to update.
     */
    where: qms_counterWhereUniqueInput
  }

  /**
   * qms_counter updateMany
   */
  export type qms_counterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_counters.
     */
    data: XOR<qms_counterUpdateManyMutationInput, qms_counterUncheckedUpdateManyInput>
    /**
     * Filter which qms_counters to update
     */
    where?: qms_counterWhereInput
    /**
     * Limit how many qms_counters to update.
     */
    limit?: number
  }

  /**
   * qms_counter upsert
   */
  export type qms_counterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_counter to update in case it exists.
     */
    where: qms_counterWhereUniqueInput
    /**
     * In case the qms_counter found by the `where` argument doesn't exist, create a new qms_counter with this data.
     */
    create: XOR<qms_counterCreateInput, qms_counterUncheckedCreateInput>
    /**
     * In case the qms_counter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_counterUpdateInput, qms_counterUncheckedUpdateInput>
  }

  /**
   * qms_counter delete
   */
  export type qms_counterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    /**
     * Filter which qms_counter to delete.
     */
    where: qms_counterWhereUniqueInput
  }

  /**
   * qms_counter deleteMany
   */
  export type qms_counterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_counters to delete
     */
    where?: qms_counterWhereInput
    /**
     * Limit how many qms_counters to delete.
     */
    limit?: number
  }

  /**
   * qms_counter.service
   */
  export type qms_counter$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
  }

  /**
   * qms_counter without action
   */
  export type qms_counterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
  }


  /**
   * Model qms_customer
   */

  export type AggregateQms_customer = {
    _count: Qms_customerCountAggregateOutputType | null
    _avg: Qms_customerAvgAggregateOutputType | null
    _sum: Qms_customerSumAggregateOutputType | null
    _min: Qms_customerMinAggregateOutputType | null
    _max: Qms_customerMaxAggregateOutputType | null
  }

  export type Qms_customerAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type Qms_customerSumAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type Qms_customerMinAggregateOutputType = {
    id: number | null
    customer_uuid: string | null
    device_id: number | null
    name: string | null
    phone_number: string | null
    email: string | null
    has_priority_service: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Qms_customerMaxAggregateOutputType = {
    id: number | null
    customer_uuid: string | null
    device_id: number | null
    name: string | null
    phone_number: string | null
    email: string | null
    has_priority_service: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Qms_customerCountAggregateOutputType = {
    id: number
    customer_uuid: number
    device_id: number
    name: number
    phone_number: number
    email: number
    has_priority_service: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Qms_customerAvgAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type Qms_customerSumAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type Qms_customerMinAggregateInputType = {
    id?: true
    customer_uuid?: true
    device_id?: true
    name?: true
    phone_number?: true
    email?: true
    has_priority_service?: true
    created_at?: true
    updated_at?: true
  }

  export type Qms_customerMaxAggregateInputType = {
    id?: true
    customer_uuid?: true
    device_id?: true
    name?: true
    phone_number?: true
    email?: true
    has_priority_service?: true
    created_at?: true
    updated_at?: true
  }

  export type Qms_customerCountAggregateInputType = {
    id?: true
    customer_uuid?: true
    device_id?: true
    name?: true
    phone_number?: true
    email?: true
    has_priority_service?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Qms_customerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_customer to aggregate.
     */
    where?: qms_customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_customers to fetch.
     */
    orderBy?: qms_customerOrderByWithRelationInput | qms_customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_customers
    **/
    _count?: true | Qms_customerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_customerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_customerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_customerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_customerMaxAggregateInputType
  }

  export type GetQms_customerAggregateType<T extends Qms_customerAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_customer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_customer[P]>
      : GetScalarType<T[P], AggregateQms_customer[P]>
  }




  export type qms_customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_customerWhereInput
    orderBy?: qms_customerOrderByWithAggregationInput | qms_customerOrderByWithAggregationInput[]
    by: Qms_customerScalarFieldEnum[] | Qms_customerScalarFieldEnum
    having?: qms_customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_customerCountAggregateInputType | true
    _avg?: Qms_customerAvgAggregateInputType
    _sum?: Qms_customerSumAggregateInputType
    _min?: Qms_customerMinAggregateInputType
    _max?: Qms_customerMaxAggregateInputType
  }

  export type Qms_customerGroupByOutputType = {
    id: number
    customer_uuid: string
    device_id: number | null
    name: string
    phone_number: string | null
    email: string | null
    has_priority_service: boolean | null
    created_at: Date
    updated_at: Date
    _count: Qms_customerCountAggregateOutputType | null
    _avg: Qms_customerAvgAggregateOutputType | null
    _sum: Qms_customerSumAggregateOutputType | null
    _min: Qms_customerMinAggregateOutputType | null
    _max: Qms_customerMaxAggregateOutputType | null
  }

  type GetQms_customerGroupByPayload<T extends qms_customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_customerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_customerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_customerGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_customerGroupByOutputType[P]>
        }
      >
    >


  export type qms_customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_uuid?: boolean
    device_id?: boolean
    name?: boolean
    phone_number?: boolean
    email?: boolean
    has_priority_service?: boolean
    created_at?: boolean
    updated_at?: boolean
    device?: boolean | qms_customer$deviceArgs<ExtArgs>
    qms_ticket?: boolean | qms_customer$qms_ticketArgs<ExtArgs>
    _count?: boolean | Qms_customerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_customer"]>



  export type qms_customerSelectScalar = {
    id?: boolean
    customer_uuid?: boolean
    device_id?: boolean
    name?: boolean
    phone_number?: boolean
    email?: boolean
    has_priority_service?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type qms_customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_uuid" | "device_id" | "name" | "phone_number" | "email" | "has_priority_service" | "created_at" | "updated_at", ExtArgs["result"]["qms_customer"]>
  export type qms_customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | qms_customer$deviceArgs<ExtArgs>
    qms_ticket?: boolean | qms_customer$qms_ticketArgs<ExtArgs>
    _count?: boolean | Qms_customerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $qms_customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_customer"
    objects: {
      device: Prisma.$devicePayload<ExtArgs> | null
      qms_ticket: Prisma.$qms_ticketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_uuid: string
      device_id: number | null
      name: string
      phone_number: string | null
      email: string | null
      has_priority_service: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["qms_customer"]>
    composites: {}
  }

  type qms_customerGetPayload<S extends boolean | null | undefined | qms_customerDefaultArgs> = $Result.GetResult<Prisma.$qms_customerPayload, S>

  type qms_customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_customerCountAggregateInputType | true
    }

  export interface qms_customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_customer'], meta: { name: 'qms_customer' } }
    /**
     * Find zero or one Qms_customer that matches the filter.
     * @param {qms_customerFindUniqueArgs} args - Arguments to find a Qms_customer
     * @example
     * // Get one Qms_customer
     * const qms_customer = await prisma.qms_customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_customerFindUniqueArgs>(args: SelectSubset<T, qms_customerFindUniqueArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_customerFindUniqueOrThrowArgs} args - Arguments to find a Qms_customer
     * @example
     * // Get one Qms_customer
     * const qms_customer = await prisma.qms_customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_customerFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_customerFindFirstArgs} args - Arguments to find a Qms_customer
     * @example
     * // Get one Qms_customer
     * const qms_customer = await prisma.qms_customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_customerFindFirstArgs>(args?: SelectSubset<T, qms_customerFindFirstArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_customerFindFirstOrThrowArgs} args - Arguments to find a Qms_customer
     * @example
     * // Get one Qms_customer
     * const qms_customer = await prisma.qms_customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_customerFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_customers
     * const qms_customers = await prisma.qms_customer.findMany()
     * 
     * // Get first 10 Qms_customers
     * const qms_customers = await prisma.qms_customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_customerWithIdOnly = await prisma.qms_customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_customerFindManyArgs>(args?: SelectSubset<T, qms_customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_customer.
     * @param {qms_customerCreateArgs} args - Arguments to create a Qms_customer.
     * @example
     * // Create one Qms_customer
     * const Qms_customer = await prisma.qms_customer.create({
     *   data: {
     *     // ... data to create a Qms_customer
     *   }
     * })
     * 
     */
    create<T extends qms_customerCreateArgs>(args: SelectSubset<T, qms_customerCreateArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_customers.
     * @param {qms_customerCreateManyArgs} args - Arguments to create many Qms_customers.
     * @example
     * // Create many Qms_customers
     * const qms_customer = await prisma.qms_customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_customerCreateManyArgs>(args?: SelectSubset<T, qms_customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_customer.
     * @param {qms_customerDeleteArgs} args - Arguments to delete one Qms_customer.
     * @example
     * // Delete one Qms_customer
     * const Qms_customer = await prisma.qms_customer.delete({
     *   where: {
     *     // ... filter to delete one Qms_customer
     *   }
     * })
     * 
     */
    delete<T extends qms_customerDeleteArgs>(args: SelectSubset<T, qms_customerDeleteArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_customer.
     * @param {qms_customerUpdateArgs} args - Arguments to update one Qms_customer.
     * @example
     * // Update one Qms_customer
     * const qms_customer = await prisma.qms_customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_customerUpdateArgs>(args: SelectSubset<T, qms_customerUpdateArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_customers.
     * @param {qms_customerDeleteManyArgs} args - Arguments to filter Qms_customers to delete.
     * @example
     * // Delete a few Qms_customers
     * const { count } = await prisma.qms_customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_customerDeleteManyArgs>(args?: SelectSubset<T, qms_customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_customers
     * const qms_customer = await prisma.qms_customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_customerUpdateManyArgs>(args: SelectSubset<T, qms_customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_customer.
     * @param {qms_customerUpsertArgs} args - Arguments to update or create a Qms_customer.
     * @example
     * // Update or create a Qms_customer
     * const qms_customer = await prisma.qms_customer.upsert({
     *   create: {
     *     // ... data to create a Qms_customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_customer we want to update
     *   }
     * })
     */
    upsert<T extends qms_customerUpsertArgs>(args: SelectSubset<T, qms_customerUpsertArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_customerCountArgs} args - Arguments to filter Qms_customers to count.
     * @example
     * // Count the number of Qms_customers
     * const count = await prisma.qms_customer.count({
     *   where: {
     *     // ... the filter for the Qms_customers we want to count
     *   }
     * })
    **/
    count<T extends qms_customerCountArgs>(
      args?: Subset<T, qms_customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_customerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_customerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_customerAggregateArgs>(args: Subset<T, Qms_customerAggregateArgs>): Prisma.PrismaPromise<GetQms_customerAggregateType<T>>

    /**
     * Group by Qms_customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_customerGroupByArgs['orderBy'] }
        : { orderBy?: qms_customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_customerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_customer model
   */
  readonly fields: qms_customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends qms_customer$deviceArgs<ExtArgs> = {}>(args?: Subset<T, qms_customer$deviceArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qms_ticket<T extends qms_customer$qms_ticketArgs<ExtArgs> = {}>(args?: Subset<T, qms_customer$qms_ticketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_customer model
   */
  interface qms_customerFieldRefs {
    readonly id: FieldRef<"qms_customer", 'Int'>
    readonly customer_uuid: FieldRef<"qms_customer", 'String'>
    readonly device_id: FieldRef<"qms_customer", 'Int'>
    readonly name: FieldRef<"qms_customer", 'String'>
    readonly phone_number: FieldRef<"qms_customer", 'String'>
    readonly email: FieldRef<"qms_customer", 'String'>
    readonly has_priority_service: FieldRef<"qms_customer", 'Boolean'>
    readonly created_at: FieldRef<"qms_customer", 'DateTime'>
    readonly updated_at: FieldRef<"qms_customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * qms_customer findUnique
   */
  export type qms_customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * Filter, which qms_customer to fetch.
     */
    where: qms_customerWhereUniqueInput
  }

  /**
   * qms_customer findUniqueOrThrow
   */
  export type qms_customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * Filter, which qms_customer to fetch.
     */
    where: qms_customerWhereUniqueInput
  }

  /**
   * qms_customer findFirst
   */
  export type qms_customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * Filter, which qms_customer to fetch.
     */
    where?: qms_customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_customers to fetch.
     */
    orderBy?: qms_customerOrderByWithRelationInput | qms_customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_customers.
     */
    cursor?: qms_customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_customers.
     */
    distinct?: Qms_customerScalarFieldEnum | Qms_customerScalarFieldEnum[]
  }

  /**
   * qms_customer findFirstOrThrow
   */
  export type qms_customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * Filter, which qms_customer to fetch.
     */
    where?: qms_customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_customers to fetch.
     */
    orderBy?: qms_customerOrderByWithRelationInput | qms_customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_customers.
     */
    cursor?: qms_customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_customers.
     */
    distinct?: Qms_customerScalarFieldEnum | Qms_customerScalarFieldEnum[]
  }

  /**
   * qms_customer findMany
   */
  export type qms_customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * Filter, which qms_customers to fetch.
     */
    where?: qms_customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_customers to fetch.
     */
    orderBy?: qms_customerOrderByWithRelationInput | qms_customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_customers.
     */
    cursor?: qms_customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_customers.
     */
    skip?: number
    distinct?: Qms_customerScalarFieldEnum | Qms_customerScalarFieldEnum[]
  }

  /**
   * qms_customer create
   */
  export type qms_customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_customer.
     */
    data: XOR<qms_customerCreateInput, qms_customerUncheckedCreateInput>
  }

  /**
   * qms_customer createMany
   */
  export type qms_customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_customers.
     */
    data: qms_customerCreateManyInput | qms_customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_customer update
   */
  export type qms_customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_customer.
     */
    data: XOR<qms_customerUpdateInput, qms_customerUncheckedUpdateInput>
    /**
     * Choose, which qms_customer to update.
     */
    where: qms_customerWhereUniqueInput
  }

  /**
   * qms_customer updateMany
   */
  export type qms_customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_customers.
     */
    data: XOR<qms_customerUpdateManyMutationInput, qms_customerUncheckedUpdateManyInput>
    /**
     * Filter which qms_customers to update
     */
    where?: qms_customerWhereInput
    /**
     * Limit how many qms_customers to update.
     */
    limit?: number
  }

  /**
   * qms_customer upsert
   */
  export type qms_customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_customer to update in case it exists.
     */
    where: qms_customerWhereUniqueInput
    /**
     * In case the qms_customer found by the `where` argument doesn't exist, create a new qms_customer with this data.
     */
    create: XOR<qms_customerCreateInput, qms_customerUncheckedCreateInput>
    /**
     * In case the qms_customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_customerUpdateInput, qms_customerUncheckedUpdateInput>
  }

  /**
   * qms_customer delete
   */
  export type qms_customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
    /**
     * Filter which qms_customer to delete.
     */
    where: qms_customerWhereUniqueInput
  }

  /**
   * qms_customer deleteMany
   */
  export type qms_customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_customers to delete
     */
    where?: qms_customerWhereInput
    /**
     * Limit how many qms_customers to delete.
     */
    limit?: number
  }

  /**
   * qms_customer.device
   */
  export type qms_customer$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
  }

  /**
   * qms_customer.qms_ticket
   */
  export type qms_customer$qms_ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    where?: qms_ticketWhereInput
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    cursor?: qms_ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_ticketScalarFieldEnum | Qms_ticketScalarFieldEnum[]
  }

  /**
   * qms_customer without action
   */
  export type qms_customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_customer
     */
    select?: qms_customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_customer
     */
    omit?: qms_customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_customerInclude<ExtArgs> | null
  }


  /**
   * Model qms_operator
   */

  export type AggregateQms_operator = {
    _count: Qms_operatorCountAggregateOutputType | null
    _avg: Qms_operatorAvgAggregateOutputType | null
    _sum: Qms_operatorSumAggregateOutputType | null
    _min: Qms_operatorMinAggregateOutputType | null
    _max: Qms_operatorMaxAggregateOutputType | null
  }

  export type Qms_operatorAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
  }

  export type Qms_operatorSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
  }

  export type Qms_operatorMinAggregateOutputType = {
    id: number | null
    operator_uuid: string | null
    institution_id: number | null
    name: string | null
    username: string | null
    password_hash: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    email_address: string | null
    phone_number: string | null
    terminal: boolean | null
  }

  export type Qms_operatorMaxAggregateOutputType = {
    id: number | null
    operator_uuid: string | null
    institution_id: number | null
    name: string | null
    username: string | null
    password_hash: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    email_address: string | null
    phone_number: string | null
    terminal: boolean | null
  }

  export type Qms_operatorCountAggregateOutputType = {
    id: number
    operator_uuid: number
    institution_id: number
    name: number
    username: number
    password_hash: number
    is_active: number
    created_at: number
    updated_at: number
    email_address: number
    phone_number: number
    terminal: number
    _all: number
  }


  export type Qms_operatorAvgAggregateInputType = {
    id?: true
    institution_id?: true
  }

  export type Qms_operatorSumAggregateInputType = {
    id?: true
    institution_id?: true
  }

  export type Qms_operatorMinAggregateInputType = {
    id?: true
    operator_uuid?: true
    institution_id?: true
    name?: true
    username?: true
    password_hash?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    email_address?: true
    phone_number?: true
    terminal?: true
  }

  export type Qms_operatorMaxAggregateInputType = {
    id?: true
    operator_uuid?: true
    institution_id?: true
    name?: true
    username?: true
    password_hash?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    email_address?: true
    phone_number?: true
    terminal?: true
  }

  export type Qms_operatorCountAggregateInputType = {
    id?: true
    operator_uuid?: true
    institution_id?: true
    name?: true
    username?: true
    password_hash?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    email_address?: true
    phone_number?: true
    terminal?: true
    _all?: true
  }

  export type Qms_operatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_operator to aggregate.
     */
    where?: qms_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operators to fetch.
     */
    orderBy?: qms_operatorOrderByWithRelationInput | qms_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_operators
    **/
    _count?: true | Qms_operatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_operatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_operatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_operatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_operatorMaxAggregateInputType
  }

  export type GetQms_operatorAggregateType<T extends Qms_operatorAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_operator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_operator[P]>
      : GetScalarType<T[P], AggregateQms_operator[P]>
  }




  export type qms_operatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_operatorWhereInput
    orderBy?: qms_operatorOrderByWithAggregationInput | qms_operatorOrderByWithAggregationInput[]
    by: Qms_operatorScalarFieldEnum[] | Qms_operatorScalarFieldEnum
    having?: qms_operatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_operatorCountAggregateInputType | true
    _avg?: Qms_operatorAvgAggregateInputType
    _sum?: Qms_operatorSumAggregateInputType
    _min?: Qms_operatorMinAggregateInputType
    _max?: Qms_operatorMaxAggregateInputType
  }

  export type Qms_operatorGroupByOutputType = {
    id: number
    operator_uuid: string
    institution_id: number | null
    name: string
    username: string
    password_hash: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    email_address: string
    phone_number: string | null
    terminal: boolean | null
    _count: Qms_operatorCountAggregateOutputType | null
    _avg: Qms_operatorAvgAggregateOutputType | null
    _sum: Qms_operatorSumAggregateOutputType | null
    _min: Qms_operatorMinAggregateOutputType | null
    _max: Qms_operatorMaxAggregateOutputType | null
  }

  type GetQms_operatorGroupByPayload<T extends qms_operatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_operatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_operatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_operatorGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_operatorGroupByOutputType[P]>
        }
      >
    >


  export type qms_operatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operator_uuid?: boolean
    institution_id?: boolean
    name?: boolean
    username?: boolean
    password_hash?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_address?: boolean
    phone_number?: boolean
    terminal?: boolean
    appointments?: boolean | qms_operator$appointmentsArgs<ExtArgs>
    qms_branch_operator?: boolean | qms_operator$qms_branch_operatorArgs<ExtArgs>
    institution?: boolean | qms_operator$institutionArgs<ExtArgs>
    qms_operator_transactions?: boolean | qms_operator$qms_operator_transactionsArgs<ExtArgs>
    qms_queue_operator_lnk?: boolean | qms_operator$qms_queue_operator_lnkArgs<ExtArgs>
    qms_ticket_assignment?: boolean | qms_operator$qms_ticket_assignmentArgs<ExtArgs>
    _count?: boolean | Qms_operatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_operator"]>



  export type qms_operatorSelectScalar = {
    id?: boolean
    operator_uuid?: boolean
    institution_id?: boolean
    name?: boolean
    username?: boolean
    password_hash?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_address?: boolean
    phone_number?: boolean
    terminal?: boolean
  }

  export type qms_operatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "operator_uuid" | "institution_id" | "name" | "username" | "password_hash" | "is_active" | "created_at" | "updated_at" | "email_address" | "phone_number" | "terminal", ExtArgs["result"]["qms_operator"]>
  export type qms_operatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | qms_operator$appointmentsArgs<ExtArgs>
    qms_branch_operator?: boolean | qms_operator$qms_branch_operatorArgs<ExtArgs>
    institution?: boolean | qms_operator$institutionArgs<ExtArgs>
    qms_operator_transactions?: boolean | qms_operator$qms_operator_transactionsArgs<ExtArgs>
    qms_queue_operator_lnk?: boolean | qms_operator$qms_queue_operator_lnkArgs<ExtArgs>
    qms_ticket_assignment?: boolean | qms_operator$qms_ticket_assignmentArgs<ExtArgs>
    _count?: boolean | Qms_operatorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $qms_operatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_operator"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      qms_branch_operator: Prisma.$qms_branch_operatorPayload<ExtArgs>[]
      institution: Prisma.$institutionPayload<ExtArgs> | null
      qms_operator_transactions: Prisma.$qms_operator_transactionsPayload<ExtArgs>[]
      qms_queue_operator_lnk: Prisma.$qms_queue_operator_lnkPayload<ExtArgs>[]
      qms_ticket_assignment: Prisma.$qms_ticket_assignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operator_uuid: string
      institution_id: number | null
      name: string
      username: string
      password_hash: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
      email_address: string
      phone_number: string | null
      terminal: boolean | null
    }, ExtArgs["result"]["qms_operator"]>
    composites: {}
  }

  type qms_operatorGetPayload<S extends boolean | null | undefined | qms_operatorDefaultArgs> = $Result.GetResult<Prisma.$qms_operatorPayload, S>

  type qms_operatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_operatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_operatorCountAggregateInputType | true
    }

  export interface qms_operatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_operator'], meta: { name: 'qms_operator' } }
    /**
     * Find zero or one Qms_operator that matches the filter.
     * @param {qms_operatorFindUniqueArgs} args - Arguments to find a Qms_operator
     * @example
     * // Get one Qms_operator
     * const qms_operator = await prisma.qms_operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_operatorFindUniqueArgs>(args: SelectSubset<T, qms_operatorFindUniqueArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_operator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_operatorFindUniqueOrThrowArgs} args - Arguments to find a Qms_operator
     * @example
     * // Get one Qms_operator
     * const qms_operator = await prisma.qms_operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_operatorFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_operatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operatorFindFirstArgs} args - Arguments to find a Qms_operator
     * @example
     * // Get one Qms_operator
     * const qms_operator = await prisma.qms_operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_operatorFindFirstArgs>(args?: SelectSubset<T, qms_operatorFindFirstArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operatorFindFirstOrThrowArgs} args - Arguments to find a Qms_operator
     * @example
     * // Get one Qms_operator
     * const qms_operator = await prisma.qms_operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_operatorFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_operatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_operators
     * const qms_operators = await prisma.qms_operator.findMany()
     * 
     * // Get first 10 Qms_operators
     * const qms_operators = await prisma.qms_operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_operatorWithIdOnly = await prisma.qms_operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_operatorFindManyArgs>(args?: SelectSubset<T, qms_operatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_operator.
     * @param {qms_operatorCreateArgs} args - Arguments to create a Qms_operator.
     * @example
     * // Create one Qms_operator
     * const Qms_operator = await prisma.qms_operator.create({
     *   data: {
     *     // ... data to create a Qms_operator
     *   }
     * })
     * 
     */
    create<T extends qms_operatorCreateArgs>(args: SelectSubset<T, qms_operatorCreateArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_operators.
     * @param {qms_operatorCreateManyArgs} args - Arguments to create many Qms_operators.
     * @example
     * // Create many Qms_operators
     * const qms_operator = await prisma.qms_operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_operatorCreateManyArgs>(args?: SelectSubset<T, qms_operatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_operator.
     * @param {qms_operatorDeleteArgs} args - Arguments to delete one Qms_operator.
     * @example
     * // Delete one Qms_operator
     * const Qms_operator = await prisma.qms_operator.delete({
     *   where: {
     *     // ... filter to delete one Qms_operator
     *   }
     * })
     * 
     */
    delete<T extends qms_operatorDeleteArgs>(args: SelectSubset<T, qms_operatorDeleteArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_operator.
     * @param {qms_operatorUpdateArgs} args - Arguments to update one Qms_operator.
     * @example
     * // Update one Qms_operator
     * const qms_operator = await prisma.qms_operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_operatorUpdateArgs>(args: SelectSubset<T, qms_operatorUpdateArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_operators.
     * @param {qms_operatorDeleteManyArgs} args - Arguments to filter Qms_operators to delete.
     * @example
     * // Delete a few Qms_operators
     * const { count } = await prisma.qms_operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_operatorDeleteManyArgs>(args?: SelectSubset<T, qms_operatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_operators
     * const qms_operator = await prisma.qms_operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_operatorUpdateManyArgs>(args: SelectSubset<T, qms_operatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_operator.
     * @param {qms_operatorUpsertArgs} args - Arguments to update or create a Qms_operator.
     * @example
     * // Update or create a Qms_operator
     * const qms_operator = await prisma.qms_operator.upsert({
     *   create: {
     *     // ... data to create a Qms_operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_operator we want to update
     *   }
     * })
     */
    upsert<T extends qms_operatorUpsertArgs>(args: SelectSubset<T, qms_operatorUpsertArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operatorCountArgs} args - Arguments to filter Qms_operators to count.
     * @example
     * // Count the number of Qms_operators
     * const count = await prisma.qms_operator.count({
     *   where: {
     *     // ... the filter for the Qms_operators we want to count
     *   }
     * })
    **/
    count<T extends qms_operatorCountArgs>(
      args?: Subset<T, qms_operatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_operatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_operatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_operatorAggregateArgs>(args: Subset<T, Qms_operatorAggregateArgs>): Prisma.PrismaPromise<GetQms_operatorAggregateType<T>>

    /**
     * Group by Qms_operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_operatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_operatorGroupByArgs['orderBy'] }
        : { orderBy?: qms_operatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_operatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_operatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_operator model
   */
  readonly fields: qms_operatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_operatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends qms_operator$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, qms_operator$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_branch_operator<T extends qms_operator$qms_branch_operatorArgs<ExtArgs> = {}>(args?: Subset<T, qms_operator$qms_branch_operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_branch_operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institution<T extends qms_operator$institutionArgs<ExtArgs> = {}>(args?: Subset<T, qms_operator$institutionArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qms_operator_transactions<T extends qms_operator$qms_operator_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, qms_operator$qms_operator_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_queue_operator_lnk<T extends qms_operator$qms_queue_operator_lnkArgs<ExtArgs> = {}>(args?: Subset<T, qms_operator$qms_queue_operator_lnkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_ticket_assignment<T extends qms_operator$qms_ticket_assignmentArgs<ExtArgs> = {}>(args?: Subset<T, qms_operator$qms_ticket_assignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_operator model
   */
  interface qms_operatorFieldRefs {
    readonly id: FieldRef<"qms_operator", 'Int'>
    readonly operator_uuid: FieldRef<"qms_operator", 'String'>
    readonly institution_id: FieldRef<"qms_operator", 'Int'>
    readonly name: FieldRef<"qms_operator", 'String'>
    readonly username: FieldRef<"qms_operator", 'String'>
    readonly password_hash: FieldRef<"qms_operator", 'String'>
    readonly is_active: FieldRef<"qms_operator", 'Boolean'>
    readonly created_at: FieldRef<"qms_operator", 'DateTime'>
    readonly updated_at: FieldRef<"qms_operator", 'DateTime'>
    readonly email_address: FieldRef<"qms_operator", 'String'>
    readonly phone_number: FieldRef<"qms_operator", 'String'>
    readonly terminal: FieldRef<"qms_operator", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * qms_operator findUnique
   */
  export type qms_operatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator to fetch.
     */
    where: qms_operatorWhereUniqueInput
  }

  /**
   * qms_operator findUniqueOrThrow
   */
  export type qms_operatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator to fetch.
     */
    where: qms_operatorWhereUniqueInput
  }

  /**
   * qms_operator findFirst
   */
  export type qms_operatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator to fetch.
     */
    where?: qms_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operators to fetch.
     */
    orderBy?: qms_operatorOrderByWithRelationInput | qms_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_operators.
     */
    cursor?: qms_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_operators.
     */
    distinct?: Qms_operatorScalarFieldEnum | Qms_operatorScalarFieldEnum[]
  }

  /**
   * qms_operator findFirstOrThrow
   */
  export type qms_operatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator to fetch.
     */
    where?: qms_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operators to fetch.
     */
    orderBy?: qms_operatorOrderByWithRelationInput | qms_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_operators.
     */
    cursor?: qms_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_operators.
     */
    distinct?: Qms_operatorScalarFieldEnum | Qms_operatorScalarFieldEnum[]
  }

  /**
   * qms_operator findMany
   */
  export type qms_operatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * Filter, which qms_operators to fetch.
     */
    where?: qms_operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operators to fetch.
     */
    orderBy?: qms_operatorOrderByWithRelationInput | qms_operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_operators.
     */
    cursor?: qms_operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operators.
     */
    skip?: number
    distinct?: Qms_operatorScalarFieldEnum | Qms_operatorScalarFieldEnum[]
  }

  /**
   * qms_operator create
   */
  export type qms_operatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_operator.
     */
    data: XOR<qms_operatorCreateInput, qms_operatorUncheckedCreateInput>
  }

  /**
   * qms_operator createMany
   */
  export type qms_operatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_operators.
     */
    data: qms_operatorCreateManyInput | qms_operatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_operator update
   */
  export type qms_operatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_operator.
     */
    data: XOR<qms_operatorUpdateInput, qms_operatorUncheckedUpdateInput>
    /**
     * Choose, which qms_operator to update.
     */
    where: qms_operatorWhereUniqueInput
  }

  /**
   * qms_operator updateMany
   */
  export type qms_operatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_operators.
     */
    data: XOR<qms_operatorUpdateManyMutationInput, qms_operatorUncheckedUpdateManyInput>
    /**
     * Filter which qms_operators to update
     */
    where?: qms_operatorWhereInput
    /**
     * Limit how many qms_operators to update.
     */
    limit?: number
  }

  /**
   * qms_operator upsert
   */
  export type qms_operatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_operator to update in case it exists.
     */
    where: qms_operatorWhereUniqueInput
    /**
     * In case the qms_operator found by the `where` argument doesn't exist, create a new qms_operator with this data.
     */
    create: XOR<qms_operatorCreateInput, qms_operatorUncheckedCreateInput>
    /**
     * In case the qms_operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_operatorUpdateInput, qms_operatorUncheckedUpdateInput>
  }

  /**
   * qms_operator delete
   */
  export type qms_operatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    /**
     * Filter which qms_operator to delete.
     */
    where: qms_operatorWhereUniqueInput
  }

  /**
   * qms_operator deleteMany
   */
  export type qms_operatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_operators to delete
     */
    where?: qms_operatorWhereInput
    /**
     * Limit how many qms_operators to delete.
     */
    limit?: number
  }

  /**
   * qms_operator.appointments
   */
  export type qms_operator$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * qms_operator.qms_branch_operator
   */
  export type qms_operator$qms_branch_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_branch_operator
     */
    select?: qms_branch_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_branch_operator
     */
    omit?: qms_branch_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_branch_operatorInclude<ExtArgs> | null
    where?: qms_branch_operatorWhereInput
    orderBy?: qms_branch_operatorOrderByWithRelationInput | qms_branch_operatorOrderByWithRelationInput[]
    cursor?: qms_branch_operatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_branch_operatorScalarFieldEnum | Qms_branch_operatorScalarFieldEnum[]
  }

  /**
   * qms_operator.institution
   */
  export type qms_operator$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
  }

  /**
   * qms_operator.qms_operator_transactions
   */
  export type qms_operator$qms_operator_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    where?: qms_operator_transactionsWhereInput
    orderBy?: qms_operator_transactionsOrderByWithRelationInput | qms_operator_transactionsOrderByWithRelationInput[]
    cursor?: qms_operator_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_operator_transactionsScalarFieldEnum | Qms_operator_transactionsScalarFieldEnum[]
  }

  /**
   * qms_operator.qms_queue_operator_lnk
   */
  export type qms_operator$qms_queue_operator_lnkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    where?: qms_queue_operator_lnkWhereInput
    orderBy?: qms_queue_operator_lnkOrderByWithRelationInput | qms_queue_operator_lnkOrderByWithRelationInput[]
    cursor?: qms_queue_operator_lnkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_queue_operator_lnkScalarFieldEnum | Qms_queue_operator_lnkScalarFieldEnum[]
  }

  /**
   * qms_operator.qms_ticket_assignment
   */
  export type qms_operator$qms_ticket_assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    where?: qms_ticket_assignmentWhereInput
    orderBy?: qms_ticket_assignmentOrderByWithRelationInput | qms_ticket_assignmentOrderByWithRelationInput[]
    cursor?: qms_ticket_assignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_ticket_assignmentScalarFieldEnum | Qms_ticket_assignmentScalarFieldEnum[]
  }

  /**
   * qms_operator without action
   */
  export type qms_operatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
  }


  /**
   * Model qms_operator_transactions
   */

  export type AggregateQms_operator_transactions = {
    _count: Qms_operator_transactionsCountAggregateOutputType | null
    _avg: Qms_operator_transactionsAvgAggregateOutputType | null
    _sum: Qms_operator_transactionsSumAggregateOutputType | null
    _min: Qms_operator_transactionsMinAggregateOutputType | null
    _max: Qms_operator_transactionsMaxAggregateOutputType | null
  }

  export type Qms_operator_transactionsAvgAggregateOutputType = {
    id: number | null
    branch_transaction_id: number | null
    operator_id: number | null
    transaction: number | null
  }

  export type Qms_operator_transactionsSumAggregateOutputType = {
    id: number | null
    branch_transaction_id: number | null
    operator_id: number | null
    transaction: number | null
  }

  export type Qms_operator_transactionsMinAggregateOutputType = {
    id: number | null
    branch_transaction_id: number | null
    operator_id: number | null
    transaction: number | null
    created_at: Date | null
    last_updated: Date | null
  }

  export type Qms_operator_transactionsMaxAggregateOutputType = {
    id: number | null
    branch_transaction_id: number | null
    operator_id: number | null
    transaction: number | null
    created_at: Date | null
    last_updated: Date | null
  }

  export type Qms_operator_transactionsCountAggregateOutputType = {
    id: number
    branch_transaction_id: number
    operator_id: number
    transaction: number
    created_at: number
    last_updated: number
    _all: number
  }


  export type Qms_operator_transactionsAvgAggregateInputType = {
    id?: true
    branch_transaction_id?: true
    operator_id?: true
    transaction?: true
  }

  export type Qms_operator_transactionsSumAggregateInputType = {
    id?: true
    branch_transaction_id?: true
    operator_id?: true
    transaction?: true
  }

  export type Qms_operator_transactionsMinAggregateInputType = {
    id?: true
    branch_transaction_id?: true
    operator_id?: true
    transaction?: true
    created_at?: true
    last_updated?: true
  }

  export type Qms_operator_transactionsMaxAggregateInputType = {
    id?: true
    branch_transaction_id?: true
    operator_id?: true
    transaction?: true
    created_at?: true
    last_updated?: true
  }

  export type Qms_operator_transactionsCountAggregateInputType = {
    id?: true
    branch_transaction_id?: true
    operator_id?: true
    transaction?: true
    created_at?: true
    last_updated?: true
    _all?: true
  }

  export type Qms_operator_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_operator_transactions to aggregate.
     */
    where?: qms_operator_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operator_transactions to fetch.
     */
    orderBy?: qms_operator_transactionsOrderByWithRelationInput | qms_operator_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_operator_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operator_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operator_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_operator_transactions
    **/
    _count?: true | Qms_operator_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_operator_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_operator_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_operator_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_operator_transactionsMaxAggregateInputType
  }

  export type GetQms_operator_transactionsAggregateType<T extends Qms_operator_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_operator_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_operator_transactions[P]>
      : GetScalarType<T[P], AggregateQms_operator_transactions[P]>
  }




  export type qms_operator_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_operator_transactionsWhereInput
    orderBy?: qms_operator_transactionsOrderByWithAggregationInput | qms_operator_transactionsOrderByWithAggregationInput[]
    by: Qms_operator_transactionsScalarFieldEnum[] | Qms_operator_transactionsScalarFieldEnum
    having?: qms_operator_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_operator_transactionsCountAggregateInputType | true
    _avg?: Qms_operator_transactionsAvgAggregateInputType
    _sum?: Qms_operator_transactionsSumAggregateInputType
    _min?: Qms_operator_transactionsMinAggregateInputType
    _max?: Qms_operator_transactionsMaxAggregateInputType
  }

  export type Qms_operator_transactionsGroupByOutputType = {
    id: number
    branch_transaction_id: number
    operator_id: number
    transaction: number
    created_at: Date
    last_updated: Date
    _count: Qms_operator_transactionsCountAggregateOutputType | null
    _avg: Qms_operator_transactionsAvgAggregateOutputType | null
    _sum: Qms_operator_transactionsSumAggregateOutputType | null
    _min: Qms_operator_transactionsMinAggregateOutputType | null
    _max: Qms_operator_transactionsMaxAggregateOutputType | null
  }

  type GetQms_operator_transactionsGroupByPayload<T extends qms_operator_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_operator_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_operator_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_operator_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_operator_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type qms_operator_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branch_transaction_id?: boolean
    operator_id?: boolean
    transaction?: boolean
    created_at?: boolean
    last_updated?: boolean
    qms_branch_transactions?: boolean | qms_branch_transactionsDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_operator_transactions"]>



  export type qms_operator_transactionsSelectScalar = {
    id?: boolean
    branch_transaction_id?: boolean
    operator_id?: boolean
    transaction?: boolean
    created_at?: boolean
    last_updated?: boolean
  }

  export type qms_operator_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "branch_transaction_id" | "operator_id" | "transaction" | "created_at" | "last_updated", ExtArgs["result"]["qms_operator_transactions"]>
  export type qms_operator_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_branch_transactions?: boolean | qms_branch_transactionsDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_operatorDefaultArgs<ExtArgs>
  }

  export type $qms_operator_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_operator_transactions"
    objects: {
      qms_branch_transactions: Prisma.$qms_branch_transactionsPayload<ExtArgs>
      qms_operator: Prisma.$qms_operatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branch_transaction_id: number
      operator_id: number
      transaction: number
      created_at: Date
      last_updated: Date
    }, ExtArgs["result"]["qms_operator_transactions"]>
    composites: {}
  }

  type qms_operator_transactionsGetPayload<S extends boolean | null | undefined | qms_operator_transactionsDefaultArgs> = $Result.GetResult<Prisma.$qms_operator_transactionsPayload, S>

  type qms_operator_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_operator_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_operator_transactionsCountAggregateInputType | true
    }

  export interface qms_operator_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_operator_transactions'], meta: { name: 'qms_operator_transactions' } }
    /**
     * Find zero or one Qms_operator_transactions that matches the filter.
     * @param {qms_operator_transactionsFindUniqueArgs} args - Arguments to find a Qms_operator_transactions
     * @example
     * // Get one Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_operator_transactionsFindUniqueArgs>(args: SelectSubset<T, qms_operator_transactionsFindUniqueArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_operator_transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_operator_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Qms_operator_transactions
     * @example
     * // Get one Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_operator_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_operator_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_operator_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operator_transactionsFindFirstArgs} args - Arguments to find a Qms_operator_transactions
     * @example
     * // Get one Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_operator_transactionsFindFirstArgs>(args?: SelectSubset<T, qms_operator_transactionsFindFirstArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_operator_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operator_transactionsFindFirstOrThrowArgs} args - Arguments to find a Qms_operator_transactions
     * @example
     * // Get one Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_operator_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_operator_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_operator_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operator_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.findMany()
     * 
     * // Get first 10 Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_operator_transactionsWithIdOnly = await prisma.qms_operator_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_operator_transactionsFindManyArgs>(args?: SelectSubset<T, qms_operator_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_operator_transactions.
     * @param {qms_operator_transactionsCreateArgs} args - Arguments to create a Qms_operator_transactions.
     * @example
     * // Create one Qms_operator_transactions
     * const Qms_operator_transactions = await prisma.qms_operator_transactions.create({
     *   data: {
     *     // ... data to create a Qms_operator_transactions
     *   }
     * })
     * 
     */
    create<T extends qms_operator_transactionsCreateArgs>(args: SelectSubset<T, qms_operator_transactionsCreateArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_operator_transactions.
     * @param {qms_operator_transactionsCreateManyArgs} args - Arguments to create many Qms_operator_transactions.
     * @example
     * // Create many Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_operator_transactionsCreateManyArgs>(args?: SelectSubset<T, qms_operator_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_operator_transactions.
     * @param {qms_operator_transactionsDeleteArgs} args - Arguments to delete one Qms_operator_transactions.
     * @example
     * // Delete one Qms_operator_transactions
     * const Qms_operator_transactions = await prisma.qms_operator_transactions.delete({
     *   where: {
     *     // ... filter to delete one Qms_operator_transactions
     *   }
     * })
     * 
     */
    delete<T extends qms_operator_transactionsDeleteArgs>(args: SelectSubset<T, qms_operator_transactionsDeleteArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_operator_transactions.
     * @param {qms_operator_transactionsUpdateArgs} args - Arguments to update one Qms_operator_transactions.
     * @example
     * // Update one Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_operator_transactionsUpdateArgs>(args: SelectSubset<T, qms_operator_transactionsUpdateArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_operator_transactions.
     * @param {qms_operator_transactionsDeleteManyArgs} args - Arguments to filter Qms_operator_transactions to delete.
     * @example
     * // Delete a few Qms_operator_transactions
     * const { count } = await prisma.qms_operator_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_operator_transactionsDeleteManyArgs>(args?: SelectSubset<T, qms_operator_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_operator_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operator_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_operator_transactionsUpdateManyArgs>(args: SelectSubset<T, qms_operator_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_operator_transactions.
     * @param {qms_operator_transactionsUpsertArgs} args - Arguments to update or create a Qms_operator_transactions.
     * @example
     * // Update or create a Qms_operator_transactions
     * const qms_operator_transactions = await prisma.qms_operator_transactions.upsert({
     *   create: {
     *     // ... data to create a Qms_operator_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_operator_transactions we want to update
     *   }
     * })
     */
    upsert<T extends qms_operator_transactionsUpsertArgs>(args: SelectSubset<T, qms_operator_transactionsUpsertArgs<ExtArgs>>): Prisma__qms_operator_transactionsClient<$Result.GetResult<Prisma.$qms_operator_transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_operator_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operator_transactionsCountArgs} args - Arguments to filter Qms_operator_transactions to count.
     * @example
     * // Count the number of Qms_operator_transactions
     * const count = await prisma.qms_operator_transactions.count({
     *   where: {
     *     // ... the filter for the Qms_operator_transactions we want to count
     *   }
     * })
    **/
    count<T extends qms_operator_transactionsCountArgs>(
      args?: Subset<T, qms_operator_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_operator_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_operator_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_operator_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_operator_transactionsAggregateArgs>(args: Subset<T, Qms_operator_transactionsAggregateArgs>): Prisma.PrismaPromise<GetQms_operator_transactionsAggregateType<T>>

    /**
     * Group by Qms_operator_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_operator_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_operator_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_operator_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: qms_operator_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_operator_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_operator_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_operator_transactions model
   */
  readonly fields: qms_operator_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_operator_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_operator_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qms_branch_transactions<T extends qms_branch_transactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_branch_transactionsDefaultArgs<ExtArgs>>): Prisma__qms_branch_transactionsClient<$Result.GetResult<Prisma.$qms_branch_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_operator<T extends qms_operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_operatorDefaultArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_operator_transactions model
   */
  interface qms_operator_transactionsFieldRefs {
    readonly id: FieldRef<"qms_operator_transactions", 'Int'>
    readonly branch_transaction_id: FieldRef<"qms_operator_transactions", 'Int'>
    readonly operator_id: FieldRef<"qms_operator_transactions", 'Int'>
    readonly transaction: FieldRef<"qms_operator_transactions", 'Int'>
    readonly created_at: FieldRef<"qms_operator_transactions", 'DateTime'>
    readonly last_updated: FieldRef<"qms_operator_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * qms_operator_transactions findUnique
   */
  export type qms_operator_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator_transactions to fetch.
     */
    where: qms_operator_transactionsWhereUniqueInput
  }

  /**
   * qms_operator_transactions findUniqueOrThrow
   */
  export type qms_operator_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator_transactions to fetch.
     */
    where: qms_operator_transactionsWhereUniqueInput
  }

  /**
   * qms_operator_transactions findFirst
   */
  export type qms_operator_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator_transactions to fetch.
     */
    where?: qms_operator_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operator_transactions to fetch.
     */
    orderBy?: qms_operator_transactionsOrderByWithRelationInput | qms_operator_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_operator_transactions.
     */
    cursor?: qms_operator_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operator_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operator_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_operator_transactions.
     */
    distinct?: Qms_operator_transactionsScalarFieldEnum | Qms_operator_transactionsScalarFieldEnum[]
  }

  /**
   * qms_operator_transactions findFirstOrThrow
   */
  export type qms_operator_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator_transactions to fetch.
     */
    where?: qms_operator_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operator_transactions to fetch.
     */
    orderBy?: qms_operator_transactionsOrderByWithRelationInput | qms_operator_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_operator_transactions.
     */
    cursor?: qms_operator_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operator_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operator_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_operator_transactions.
     */
    distinct?: Qms_operator_transactionsScalarFieldEnum | Qms_operator_transactionsScalarFieldEnum[]
  }

  /**
   * qms_operator_transactions findMany
   */
  export type qms_operator_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which qms_operator_transactions to fetch.
     */
    where?: qms_operator_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_operator_transactions to fetch.
     */
    orderBy?: qms_operator_transactionsOrderByWithRelationInput | qms_operator_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_operator_transactions.
     */
    cursor?: qms_operator_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_operator_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_operator_transactions.
     */
    skip?: number
    distinct?: Qms_operator_transactionsScalarFieldEnum | Qms_operator_transactionsScalarFieldEnum[]
  }

  /**
   * qms_operator_transactions create
   */
  export type qms_operator_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_operator_transactions.
     */
    data: XOR<qms_operator_transactionsCreateInput, qms_operator_transactionsUncheckedCreateInput>
  }

  /**
   * qms_operator_transactions createMany
   */
  export type qms_operator_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_operator_transactions.
     */
    data: qms_operator_transactionsCreateManyInput | qms_operator_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_operator_transactions update
   */
  export type qms_operator_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_operator_transactions.
     */
    data: XOR<qms_operator_transactionsUpdateInput, qms_operator_transactionsUncheckedUpdateInput>
    /**
     * Choose, which qms_operator_transactions to update.
     */
    where: qms_operator_transactionsWhereUniqueInput
  }

  /**
   * qms_operator_transactions updateMany
   */
  export type qms_operator_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_operator_transactions.
     */
    data: XOR<qms_operator_transactionsUpdateManyMutationInput, qms_operator_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which qms_operator_transactions to update
     */
    where?: qms_operator_transactionsWhereInput
    /**
     * Limit how many qms_operator_transactions to update.
     */
    limit?: number
  }

  /**
   * qms_operator_transactions upsert
   */
  export type qms_operator_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_operator_transactions to update in case it exists.
     */
    where: qms_operator_transactionsWhereUniqueInput
    /**
     * In case the qms_operator_transactions found by the `where` argument doesn't exist, create a new qms_operator_transactions with this data.
     */
    create: XOR<qms_operator_transactionsCreateInput, qms_operator_transactionsUncheckedCreateInput>
    /**
     * In case the qms_operator_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_operator_transactionsUpdateInput, qms_operator_transactionsUncheckedUpdateInput>
  }

  /**
   * qms_operator_transactions delete
   */
  export type qms_operator_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
    /**
     * Filter which qms_operator_transactions to delete.
     */
    where: qms_operator_transactionsWhereUniqueInput
  }

  /**
   * qms_operator_transactions deleteMany
   */
  export type qms_operator_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_operator_transactions to delete
     */
    where?: qms_operator_transactionsWhereInput
    /**
     * Limit how many qms_operator_transactions to delete.
     */
    limit?: number
  }

  /**
   * qms_operator_transactions without action
   */
  export type qms_operator_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator_transactions
     */
    select?: qms_operator_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator_transactions
     */
    omit?: qms_operator_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operator_transactionsInclude<ExtArgs> | null
  }


  /**
   * Model qms_queue
   */

  export type AggregateQms_queue = {
    _count: Qms_queueCountAggregateOutputType | null
    _avg: Qms_queueAvgAggregateOutputType | null
    _sum: Qms_queueSumAggregateOutputType | null
    _min: Qms_queueMinAggregateOutputType | null
    _max: Qms_queueMaxAggregateOutputType | null
  }

  export type Qms_queueAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    avg_service_time: number | null
    closure_notification: number | null
    inter_arrival_time: number | null
  }

  export type Qms_queueSumAggregateOutputType = {
    id: number | null
    service_id: number | null
    avg_service_time: number | null
    closure_notification: number | null
    inter_arrival_time: number | null
  }

  export type Qms_queueMinAggregateOutputType = {
    id: number | null
    queue_uuid: string | null
    service_id: number | null
    queue_date: Date | null
    start_time: Date | null
    end_time: Date | null
    status: $Enums.qms_queue_status | null
    avg_service_time: number | null
    created_at: Date | null
    updated_at: Date | null
    closure_notification: number | null
    inter_arrival_time: number | null
  }

  export type Qms_queueMaxAggregateOutputType = {
    id: number | null
    queue_uuid: string | null
    service_id: number | null
    queue_date: Date | null
    start_time: Date | null
    end_time: Date | null
    status: $Enums.qms_queue_status | null
    avg_service_time: number | null
    created_at: Date | null
    updated_at: Date | null
    closure_notification: number | null
    inter_arrival_time: number | null
  }

  export type Qms_queueCountAggregateOutputType = {
    id: number
    queue_uuid: number
    service_id: number
    queue_date: number
    start_time: number
    end_time: number
    status: number
    avg_service_time: number
    created_at: number
    updated_at: number
    closure_notification: number
    inter_arrival_time: number
    _all: number
  }


  export type Qms_queueAvgAggregateInputType = {
    id?: true
    service_id?: true
    avg_service_time?: true
    closure_notification?: true
    inter_arrival_time?: true
  }

  export type Qms_queueSumAggregateInputType = {
    id?: true
    service_id?: true
    avg_service_time?: true
    closure_notification?: true
    inter_arrival_time?: true
  }

  export type Qms_queueMinAggregateInputType = {
    id?: true
    queue_uuid?: true
    service_id?: true
    queue_date?: true
    start_time?: true
    end_time?: true
    status?: true
    avg_service_time?: true
    created_at?: true
    updated_at?: true
    closure_notification?: true
    inter_arrival_time?: true
  }

  export type Qms_queueMaxAggregateInputType = {
    id?: true
    queue_uuid?: true
    service_id?: true
    queue_date?: true
    start_time?: true
    end_time?: true
    status?: true
    avg_service_time?: true
    created_at?: true
    updated_at?: true
    closure_notification?: true
    inter_arrival_time?: true
  }

  export type Qms_queueCountAggregateInputType = {
    id?: true
    queue_uuid?: true
    service_id?: true
    queue_date?: true
    start_time?: true
    end_time?: true
    status?: true
    avg_service_time?: true
    created_at?: true
    updated_at?: true
    closure_notification?: true
    inter_arrival_time?: true
    _all?: true
  }

  export type Qms_queueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_queue to aggregate.
     */
    where?: qms_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queues to fetch.
     */
    orderBy?: qms_queueOrderByWithRelationInput | qms_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_queues
    **/
    _count?: true | Qms_queueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_queueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_queueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_queueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_queueMaxAggregateInputType
  }

  export type GetQms_queueAggregateType<T extends Qms_queueAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_queue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_queue[P]>
      : GetScalarType<T[P], AggregateQms_queue[P]>
  }




  export type qms_queueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_queueWhereInput
    orderBy?: qms_queueOrderByWithAggregationInput | qms_queueOrderByWithAggregationInput[]
    by: Qms_queueScalarFieldEnum[] | Qms_queueScalarFieldEnum
    having?: qms_queueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_queueCountAggregateInputType | true
    _avg?: Qms_queueAvgAggregateInputType
    _sum?: Qms_queueSumAggregateInputType
    _min?: Qms_queueMinAggregateInputType
    _max?: Qms_queueMaxAggregateInputType
  }

  export type Qms_queueGroupByOutputType = {
    id: number
    queue_uuid: string
    service_id: number
    queue_date: Date
    start_time: Date
    end_time: Date
    status: $Enums.qms_queue_status
    avg_service_time: number | null
    created_at: Date
    updated_at: Date
    closure_notification: number
    inter_arrival_time: number | null
    _count: Qms_queueCountAggregateOutputType | null
    _avg: Qms_queueAvgAggregateOutputType | null
    _sum: Qms_queueSumAggregateOutputType | null
    _min: Qms_queueMinAggregateOutputType | null
    _max: Qms_queueMaxAggregateOutputType | null
  }

  type GetQms_queueGroupByPayload<T extends qms_queueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_queueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_queueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_queueGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_queueGroupByOutputType[P]>
        }
      >
    >


  export type qms_queueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queue_uuid?: boolean
    service_id?: boolean
    queue_date?: boolean
    start_time?: boolean
    end_time?: boolean
    status?: boolean
    avg_service_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    closure_notification?: boolean
    inter_arrival_time?: boolean
    service?: boolean | serviceDefaultArgs<ExtArgs>
    qms_queue_operator_lnk?: boolean | qms_queue$qms_queue_operator_lnkArgs<ExtArgs>
    qms_ticket?: boolean | qms_queue$qms_ticketArgs<ExtArgs>
    _count?: boolean | Qms_queueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_queue"]>



  export type qms_queueSelectScalar = {
    id?: boolean
    queue_uuid?: boolean
    service_id?: boolean
    queue_date?: boolean
    start_time?: boolean
    end_time?: boolean
    status?: boolean
    avg_service_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    closure_notification?: boolean
    inter_arrival_time?: boolean
  }

  export type qms_queueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queue_uuid" | "service_id" | "queue_date" | "start_time" | "end_time" | "status" | "avg_service_time" | "created_at" | "updated_at" | "closure_notification" | "inter_arrival_time", ExtArgs["result"]["qms_queue"]>
  export type qms_queueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | serviceDefaultArgs<ExtArgs>
    qms_queue_operator_lnk?: boolean | qms_queue$qms_queue_operator_lnkArgs<ExtArgs>
    qms_ticket?: boolean | qms_queue$qms_ticketArgs<ExtArgs>
    _count?: boolean | Qms_queueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $qms_queuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_queue"
    objects: {
      service: Prisma.$servicePayload<ExtArgs>
      qms_queue_operator_lnk: Prisma.$qms_queue_operator_lnkPayload<ExtArgs>[]
      qms_ticket: Prisma.$qms_ticketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      queue_uuid: string
      service_id: number
      queue_date: Date
      start_time: Date
      end_time: Date
      status: $Enums.qms_queue_status
      avg_service_time: number | null
      created_at: Date
      updated_at: Date
      closure_notification: number
      inter_arrival_time: number | null
    }, ExtArgs["result"]["qms_queue"]>
    composites: {}
  }

  type qms_queueGetPayload<S extends boolean | null | undefined | qms_queueDefaultArgs> = $Result.GetResult<Prisma.$qms_queuePayload, S>

  type qms_queueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_queueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_queueCountAggregateInputType | true
    }

  export interface qms_queueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_queue'], meta: { name: 'qms_queue' } }
    /**
     * Find zero or one Qms_queue that matches the filter.
     * @param {qms_queueFindUniqueArgs} args - Arguments to find a Qms_queue
     * @example
     * // Get one Qms_queue
     * const qms_queue = await prisma.qms_queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_queueFindUniqueArgs>(args: SelectSubset<T, qms_queueFindUniqueArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_queue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_queueFindUniqueOrThrowArgs} args - Arguments to find a Qms_queue
     * @example
     * // Get one Qms_queue
     * const qms_queue = await prisma.qms_queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_queueFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_queueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queueFindFirstArgs} args - Arguments to find a Qms_queue
     * @example
     * // Get one Qms_queue
     * const qms_queue = await prisma.qms_queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_queueFindFirstArgs>(args?: SelectSubset<T, qms_queueFindFirstArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_queue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queueFindFirstOrThrowArgs} args - Arguments to find a Qms_queue
     * @example
     * // Get one Qms_queue
     * const qms_queue = await prisma.qms_queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_queueFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_queueFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_queues
     * const qms_queues = await prisma.qms_queue.findMany()
     * 
     * // Get first 10 Qms_queues
     * const qms_queues = await prisma.qms_queue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_queueWithIdOnly = await prisma.qms_queue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_queueFindManyArgs>(args?: SelectSubset<T, qms_queueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_queue.
     * @param {qms_queueCreateArgs} args - Arguments to create a Qms_queue.
     * @example
     * // Create one Qms_queue
     * const Qms_queue = await prisma.qms_queue.create({
     *   data: {
     *     // ... data to create a Qms_queue
     *   }
     * })
     * 
     */
    create<T extends qms_queueCreateArgs>(args: SelectSubset<T, qms_queueCreateArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_queues.
     * @param {qms_queueCreateManyArgs} args - Arguments to create many Qms_queues.
     * @example
     * // Create many Qms_queues
     * const qms_queue = await prisma.qms_queue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_queueCreateManyArgs>(args?: SelectSubset<T, qms_queueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_queue.
     * @param {qms_queueDeleteArgs} args - Arguments to delete one Qms_queue.
     * @example
     * // Delete one Qms_queue
     * const Qms_queue = await prisma.qms_queue.delete({
     *   where: {
     *     // ... filter to delete one Qms_queue
     *   }
     * })
     * 
     */
    delete<T extends qms_queueDeleteArgs>(args: SelectSubset<T, qms_queueDeleteArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_queue.
     * @param {qms_queueUpdateArgs} args - Arguments to update one Qms_queue.
     * @example
     * // Update one Qms_queue
     * const qms_queue = await prisma.qms_queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_queueUpdateArgs>(args: SelectSubset<T, qms_queueUpdateArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_queues.
     * @param {qms_queueDeleteManyArgs} args - Arguments to filter Qms_queues to delete.
     * @example
     * // Delete a few Qms_queues
     * const { count } = await prisma.qms_queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_queueDeleteManyArgs>(args?: SelectSubset<T, qms_queueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_queues
     * const qms_queue = await prisma.qms_queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_queueUpdateManyArgs>(args: SelectSubset<T, qms_queueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_queue.
     * @param {qms_queueUpsertArgs} args - Arguments to update or create a Qms_queue.
     * @example
     * // Update or create a Qms_queue
     * const qms_queue = await prisma.qms_queue.upsert({
     *   create: {
     *     // ... data to create a Qms_queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_queue we want to update
     *   }
     * })
     */
    upsert<T extends qms_queueUpsertArgs>(args: SelectSubset<T, qms_queueUpsertArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queueCountArgs} args - Arguments to filter Qms_queues to count.
     * @example
     * // Count the number of Qms_queues
     * const count = await prisma.qms_queue.count({
     *   where: {
     *     // ... the filter for the Qms_queues we want to count
     *   }
     * })
    **/
    count<T extends qms_queueCountArgs>(
      args?: Subset<T, qms_queueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_queueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_queueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_queueAggregateArgs>(args: Subset<T, Qms_queueAggregateArgs>): Prisma.PrismaPromise<GetQms_queueAggregateType<T>>

    /**
     * Group by Qms_queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_queueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_queueGroupByArgs['orderBy'] }
        : { orderBy?: qms_queueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_queueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_queueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_queue model
   */
  readonly fields: qms_queueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_queueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends serviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviceDefaultArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_queue_operator_lnk<T extends qms_queue$qms_queue_operator_lnkArgs<ExtArgs> = {}>(args?: Subset<T, qms_queue$qms_queue_operator_lnkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_ticket<T extends qms_queue$qms_ticketArgs<ExtArgs> = {}>(args?: Subset<T, qms_queue$qms_ticketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_queue model
   */
  interface qms_queueFieldRefs {
    readonly id: FieldRef<"qms_queue", 'Int'>
    readonly queue_uuid: FieldRef<"qms_queue", 'String'>
    readonly service_id: FieldRef<"qms_queue", 'Int'>
    readonly queue_date: FieldRef<"qms_queue", 'DateTime'>
    readonly start_time: FieldRef<"qms_queue", 'DateTime'>
    readonly end_time: FieldRef<"qms_queue", 'DateTime'>
    readonly status: FieldRef<"qms_queue", 'qms_queue_status'>
    readonly avg_service_time: FieldRef<"qms_queue", 'Float'>
    readonly created_at: FieldRef<"qms_queue", 'DateTime'>
    readonly updated_at: FieldRef<"qms_queue", 'DateTime'>
    readonly closure_notification: FieldRef<"qms_queue", 'Int'>
    readonly inter_arrival_time: FieldRef<"qms_queue", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * qms_queue findUnique
   */
  export type qms_queueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue to fetch.
     */
    where: qms_queueWhereUniqueInput
  }

  /**
   * qms_queue findUniqueOrThrow
   */
  export type qms_queueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue to fetch.
     */
    where: qms_queueWhereUniqueInput
  }

  /**
   * qms_queue findFirst
   */
  export type qms_queueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue to fetch.
     */
    where?: qms_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queues to fetch.
     */
    orderBy?: qms_queueOrderByWithRelationInput | qms_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_queues.
     */
    cursor?: qms_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_queues.
     */
    distinct?: Qms_queueScalarFieldEnum | Qms_queueScalarFieldEnum[]
  }

  /**
   * qms_queue findFirstOrThrow
   */
  export type qms_queueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue to fetch.
     */
    where?: qms_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queues to fetch.
     */
    orderBy?: qms_queueOrderByWithRelationInput | qms_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_queues.
     */
    cursor?: qms_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_queues.
     */
    distinct?: Qms_queueScalarFieldEnum | Qms_queueScalarFieldEnum[]
  }

  /**
   * qms_queue findMany
   */
  export type qms_queueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * Filter, which qms_queues to fetch.
     */
    where?: qms_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queues to fetch.
     */
    orderBy?: qms_queueOrderByWithRelationInput | qms_queueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_queues.
     */
    cursor?: qms_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queues.
     */
    skip?: number
    distinct?: Qms_queueScalarFieldEnum | Qms_queueScalarFieldEnum[]
  }

  /**
   * qms_queue create
   */
  export type qms_queueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_queue.
     */
    data: XOR<qms_queueCreateInput, qms_queueUncheckedCreateInput>
  }

  /**
   * qms_queue createMany
   */
  export type qms_queueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_queues.
     */
    data: qms_queueCreateManyInput | qms_queueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_queue update
   */
  export type qms_queueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_queue.
     */
    data: XOR<qms_queueUpdateInput, qms_queueUncheckedUpdateInput>
    /**
     * Choose, which qms_queue to update.
     */
    where: qms_queueWhereUniqueInput
  }

  /**
   * qms_queue updateMany
   */
  export type qms_queueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_queues.
     */
    data: XOR<qms_queueUpdateManyMutationInput, qms_queueUncheckedUpdateManyInput>
    /**
     * Filter which qms_queues to update
     */
    where?: qms_queueWhereInput
    /**
     * Limit how many qms_queues to update.
     */
    limit?: number
  }

  /**
   * qms_queue upsert
   */
  export type qms_queueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_queue to update in case it exists.
     */
    where: qms_queueWhereUniqueInput
    /**
     * In case the qms_queue found by the `where` argument doesn't exist, create a new qms_queue with this data.
     */
    create: XOR<qms_queueCreateInput, qms_queueUncheckedCreateInput>
    /**
     * In case the qms_queue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_queueUpdateInput, qms_queueUncheckedUpdateInput>
  }

  /**
   * qms_queue delete
   */
  export type qms_queueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    /**
     * Filter which qms_queue to delete.
     */
    where: qms_queueWhereUniqueInput
  }

  /**
   * qms_queue deleteMany
   */
  export type qms_queueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_queues to delete
     */
    where?: qms_queueWhereInput
    /**
     * Limit how many qms_queues to delete.
     */
    limit?: number
  }

  /**
   * qms_queue.qms_queue_operator_lnk
   */
  export type qms_queue$qms_queue_operator_lnkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    where?: qms_queue_operator_lnkWhereInput
    orderBy?: qms_queue_operator_lnkOrderByWithRelationInput | qms_queue_operator_lnkOrderByWithRelationInput[]
    cursor?: qms_queue_operator_lnkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_queue_operator_lnkScalarFieldEnum | Qms_queue_operator_lnkScalarFieldEnum[]
  }

  /**
   * qms_queue.qms_ticket
   */
  export type qms_queue$qms_ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    where?: qms_ticketWhereInput
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    cursor?: qms_ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_ticketScalarFieldEnum | Qms_ticketScalarFieldEnum[]
  }

  /**
   * qms_queue without action
   */
  export type qms_queueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
  }


  /**
   * Model qms_queue_operator_lnk
   */

  export type AggregateQms_queue_operator_lnk = {
    _count: Qms_queue_operator_lnkCountAggregateOutputType | null
    _avg: Qms_queue_operator_lnkAvgAggregateOutputType | null
    _sum: Qms_queue_operator_lnkSumAggregateOutputType | null
    _min: Qms_queue_operator_lnkMinAggregateOutputType | null
    _max: Qms_queue_operator_lnkMaxAggregateOutputType | null
  }

  export type Qms_queue_operator_lnkAvgAggregateOutputType = {
    id: number | null
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
  }

  export type Qms_queue_operator_lnkSumAggregateOutputType = {
    id: number | null
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
  }

  export type Qms_queue_operator_lnkMinAggregateOutputType = {
    id: number | null
    queue_id: number | null
    operator_id: number | null
    operator_uuid: string | null
    counter_id: number | null
    first_login: Date | null
    last_logout: Date | null
    api_key: string | null
  }

  export type Qms_queue_operator_lnkMaxAggregateOutputType = {
    id: number | null
    queue_id: number | null
    operator_id: number | null
    operator_uuid: string | null
    counter_id: number | null
    first_login: Date | null
    last_logout: Date | null
    api_key: string | null
  }

  export type Qms_queue_operator_lnkCountAggregateOutputType = {
    id: number
    queue_id: number
    operator_id: number
    operator_uuid: number
    counter_id: number
    first_login: number
    last_logout: number
    api_key: number
    _all: number
  }


  export type Qms_queue_operator_lnkAvgAggregateInputType = {
    id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
  }

  export type Qms_queue_operator_lnkSumAggregateInputType = {
    id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
  }

  export type Qms_queue_operator_lnkMinAggregateInputType = {
    id?: true
    queue_id?: true
    operator_id?: true
    operator_uuid?: true
    counter_id?: true
    first_login?: true
    last_logout?: true
    api_key?: true
  }

  export type Qms_queue_operator_lnkMaxAggregateInputType = {
    id?: true
    queue_id?: true
    operator_id?: true
    operator_uuid?: true
    counter_id?: true
    first_login?: true
    last_logout?: true
    api_key?: true
  }

  export type Qms_queue_operator_lnkCountAggregateInputType = {
    id?: true
    queue_id?: true
    operator_id?: true
    operator_uuid?: true
    counter_id?: true
    first_login?: true
    last_logout?: true
    api_key?: true
    _all?: true
  }

  export type Qms_queue_operator_lnkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_queue_operator_lnk to aggregate.
     */
    where?: qms_queue_operator_lnkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queue_operator_lnks to fetch.
     */
    orderBy?: qms_queue_operator_lnkOrderByWithRelationInput | qms_queue_operator_lnkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_queue_operator_lnkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queue_operator_lnks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queue_operator_lnks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_queue_operator_lnks
    **/
    _count?: true | Qms_queue_operator_lnkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_queue_operator_lnkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_queue_operator_lnkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_queue_operator_lnkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_queue_operator_lnkMaxAggregateInputType
  }

  export type GetQms_queue_operator_lnkAggregateType<T extends Qms_queue_operator_lnkAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_queue_operator_lnk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_queue_operator_lnk[P]>
      : GetScalarType<T[P], AggregateQms_queue_operator_lnk[P]>
  }




  export type qms_queue_operator_lnkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_queue_operator_lnkWhereInput
    orderBy?: qms_queue_operator_lnkOrderByWithAggregationInput | qms_queue_operator_lnkOrderByWithAggregationInput[]
    by: Qms_queue_operator_lnkScalarFieldEnum[] | Qms_queue_operator_lnkScalarFieldEnum
    having?: qms_queue_operator_lnkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_queue_operator_lnkCountAggregateInputType | true
    _avg?: Qms_queue_operator_lnkAvgAggregateInputType
    _sum?: Qms_queue_operator_lnkSumAggregateInputType
    _min?: Qms_queue_operator_lnkMinAggregateInputType
    _max?: Qms_queue_operator_lnkMaxAggregateInputType
  }

  export type Qms_queue_operator_lnkGroupByOutputType = {
    id: number
    queue_id: number
    operator_id: number
    operator_uuid: string | null
    counter_id: number | null
    first_login: Date | null
    last_logout: Date | null
    api_key: string | null
    _count: Qms_queue_operator_lnkCountAggregateOutputType | null
    _avg: Qms_queue_operator_lnkAvgAggregateOutputType | null
    _sum: Qms_queue_operator_lnkSumAggregateOutputType | null
    _min: Qms_queue_operator_lnkMinAggregateOutputType | null
    _max: Qms_queue_operator_lnkMaxAggregateOutputType | null
  }

  type GetQms_queue_operator_lnkGroupByPayload<T extends qms_queue_operator_lnkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_queue_operator_lnkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_queue_operator_lnkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_queue_operator_lnkGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_queue_operator_lnkGroupByOutputType[P]>
        }
      >
    >


  export type qms_queue_operator_lnkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queue_id?: boolean
    operator_id?: boolean
    operator_uuid?: boolean
    counter_id?: boolean
    first_login?: boolean
    last_logout?: boolean
    api_key?: boolean
    qms_queue?: boolean | qms_queueDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_queue_operator_lnk"]>



  export type qms_queue_operator_lnkSelectScalar = {
    id?: boolean
    queue_id?: boolean
    operator_id?: boolean
    operator_uuid?: boolean
    counter_id?: boolean
    first_login?: boolean
    last_logout?: boolean
    api_key?: boolean
  }

  export type qms_queue_operator_lnkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queue_id" | "operator_id" | "operator_uuid" | "counter_id" | "first_login" | "last_logout" | "api_key", ExtArgs["result"]["qms_queue_operator_lnk"]>
  export type qms_queue_operator_lnkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_queue?: boolean | qms_queueDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_operatorDefaultArgs<ExtArgs>
  }

  export type $qms_queue_operator_lnkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_queue_operator_lnk"
    objects: {
      qms_queue: Prisma.$qms_queuePayload<ExtArgs>
      qms_operator: Prisma.$qms_operatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      queue_id: number
      operator_id: number
      operator_uuid: string | null
      counter_id: number | null
      first_login: Date | null
      last_logout: Date | null
      api_key: string | null
    }, ExtArgs["result"]["qms_queue_operator_lnk"]>
    composites: {}
  }

  type qms_queue_operator_lnkGetPayload<S extends boolean | null | undefined | qms_queue_operator_lnkDefaultArgs> = $Result.GetResult<Prisma.$qms_queue_operator_lnkPayload, S>

  type qms_queue_operator_lnkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_queue_operator_lnkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_queue_operator_lnkCountAggregateInputType | true
    }

  export interface qms_queue_operator_lnkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_queue_operator_lnk'], meta: { name: 'qms_queue_operator_lnk' } }
    /**
     * Find zero or one Qms_queue_operator_lnk that matches the filter.
     * @param {qms_queue_operator_lnkFindUniqueArgs} args - Arguments to find a Qms_queue_operator_lnk
     * @example
     * // Get one Qms_queue_operator_lnk
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_queue_operator_lnkFindUniqueArgs>(args: SelectSubset<T, qms_queue_operator_lnkFindUniqueArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_queue_operator_lnk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_queue_operator_lnkFindUniqueOrThrowArgs} args - Arguments to find a Qms_queue_operator_lnk
     * @example
     * // Get one Qms_queue_operator_lnk
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_queue_operator_lnkFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_queue_operator_lnkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_queue_operator_lnk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queue_operator_lnkFindFirstArgs} args - Arguments to find a Qms_queue_operator_lnk
     * @example
     * // Get one Qms_queue_operator_lnk
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_queue_operator_lnkFindFirstArgs>(args?: SelectSubset<T, qms_queue_operator_lnkFindFirstArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_queue_operator_lnk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queue_operator_lnkFindFirstOrThrowArgs} args - Arguments to find a Qms_queue_operator_lnk
     * @example
     * // Get one Qms_queue_operator_lnk
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_queue_operator_lnkFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_queue_operator_lnkFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_queue_operator_lnks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queue_operator_lnkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_queue_operator_lnks
     * const qms_queue_operator_lnks = await prisma.qms_queue_operator_lnk.findMany()
     * 
     * // Get first 10 Qms_queue_operator_lnks
     * const qms_queue_operator_lnks = await prisma.qms_queue_operator_lnk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_queue_operator_lnkWithIdOnly = await prisma.qms_queue_operator_lnk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_queue_operator_lnkFindManyArgs>(args?: SelectSubset<T, qms_queue_operator_lnkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_queue_operator_lnk.
     * @param {qms_queue_operator_lnkCreateArgs} args - Arguments to create a Qms_queue_operator_lnk.
     * @example
     * // Create one Qms_queue_operator_lnk
     * const Qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.create({
     *   data: {
     *     // ... data to create a Qms_queue_operator_lnk
     *   }
     * })
     * 
     */
    create<T extends qms_queue_operator_lnkCreateArgs>(args: SelectSubset<T, qms_queue_operator_lnkCreateArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_queue_operator_lnks.
     * @param {qms_queue_operator_lnkCreateManyArgs} args - Arguments to create many Qms_queue_operator_lnks.
     * @example
     * // Create many Qms_queue_operator_lnks
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_queue_operator_lnkCreateManyArgs>(args?: SelectSubset<T, qms_queue_operator_lnkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_queue_operator_lnk.
     * @param {qms_queue_operator_lnkDeleteArgs} args - Arguments to delete one Qms_queue_operator_lnk.
     * @example
     * // Delete one Qms_queue_operator_lnk
     * const Qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.delete({
     *   where: {
     *     // ... filter to delete one Qms_queue_operator_lnk
     *   }
     * })
     * 
     */
    delete<T extends qms_queue_operator_lnkDeleteArgs>(args: SelectSubset<T, qms_queue_operator_lnkDeleteArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_queue_operator_lnk.
     * @param {qms_queue_operator_lnkUpdateArgs} args - Arguments to update one Qms_queue_operator_lnk.
     * @example
     * // Update one Qms_queue_operator_lnk
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_queue_operator_lnkUpdateArgs>(args: SelectSubset<T, qms_queue_operator_lnkUpdateArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_queue_operator_lnks.
     * @param {qms_queue_operator_lnkDeleteManyArgs} args - Arguments to filter Qms_queue_operator_lnks to delete.
     * @example
     * // Delete a few Qms_queue_operator_lnks
     * const { count } = await prisma.qms_queue_operator_lnk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_queue_operator_lnkDeleteManyArgs>(args?: SelectSubset<T, qms_queue_operator_lnkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_queue_operator_lnks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queue_operator_lnkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_queue_operator_lnks
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_queue_operator_lnkUpdateManyArgs>(args: SelectSubset<T, qms_queue_operator_lnkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_queue_operator_lnk.
     * @param {qms_queue_operator_lnkUpsertArgs} args - Arguments to update or create a Qms_queue_operator_lnk.
     * @example
     * // Update or create a Qms_queue_operator_lnk
     * const qms_queue_operator_lnk = await prisma.qms_queue_operator_lnk.upsert({
     *   create: {
     *     // ... data to create a Qms_queue_operator_lnk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_queue_operator_lnk we want to update
     *   }
     * })
     */
    upsert<T extends qms_queue_operator_lnkUpsertArgs>(args: SelectSubset<T, qms_queue_operator_lnkUpsertArgs<ExtArgs>>): Prisma__qms_queue_operator_lnkClient<$Result.GetResult<Prisma.$qms_queue_operator_lnkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_queue_operator_lnks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queue_operator_lnkCountArgs} args - Arguments to filter Qms_queue_operator_lnks to count.
     * @example
     * // Count the number of Qms_queue_operator_lnks
     * const count = await prisma.qms_queue_operator_lnk.count({
     *   where: {
     *     // ... the filter for the Qms_queue_operator_lnks we want to count
     *   }
     * })
    **/
    count<T extends qms_queue_operator_lnkCountArgs>(
      args?: Subset<T, qms_queue_operator_lnkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_queue_operator_lnkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_queue_operator_lnk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_queue_operator_lnkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_queue_operator_lnkAggregateArgs>(args: Subset<T, Qms_queue_operator_lnkAggregateArgs>): Prisma.PrismaPromise<GetQms_queue_operator_lnkAggregateType<T>>

    /**
     * Group by Qms_queue_operator_lnk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_queue_operator_lnkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_queue_operator_lnkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_queue_operator_lnkGroupByArgs['orderBy'] }
        : { orderBy?: qms_queue_operator_lnkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_queue_operator_lnkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_queue_operator_lnkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_queue_operator_lnk model
   */
  readonly fields: qms_queue_operator_lnkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_queue_operator_lnk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_queue_operator_lnkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qms_queue<T extends qms_queueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_queueDefaultArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_operator<T extends qms_operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_operatorDefaultArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_queue_operator_lnk model
   */
  interface qms_queue_operator_lnkFieldRefs {
    readonly id: FieldRef<"qms_queue_operator_lnk", 'Int'>
    readonly queue_id: FieldRef<"qms_queue_operator_lnk", 'Int'>
    readonly operator_id: FieldRef<"qms_queue_operator_lnk", 'Int'>
    readonly operator_uuid: FieldRef<"qms_queue_operator_lnk", 'String'>
    readonly counter_id: FieldRef<"qms_queue_operator_lnk", 'Int'>
    readonly first_login: FieldRef<"qms_queue_operator_lnk", 'DateTime'>
    readonly last_logout: FieldRef<"qms_queue_operator_lnk", 'DateTime'>
    readonly api_key: FieldRef<"qms_queue_operator_lnk", 'String'>
  }
    

  // Custom InputTypes
  /**
   * qms_queue_operator_lnk findUnique
   */
  export type qms_queue_operator_lnkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue_operator_lnk to fetch.
     */
    where: qms_queue_operator_lnkWhereUniqueInput
  }

  /**
   * qms_queue_operator_lnk findUniqueOrThrow
   */
  export type qms_queue_operator_lnkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue_operator_lnk to fetch.
     */
    where: qms_queue_operator_lnkWhereUniqueInput
  }

  /**
   * qms_queue_operator_lnk findFirst
   */
  export type qms_queue_operator_lnkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue_operator_lnk to fetch.
     */
    where?: qms_queue_operator_lnkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queue_operator_lnks to fetch.
     */
    orderBy?: qms_queue_operator_lnkOrderByWithRelationInput | qms_queue_operator_lnkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_queue_operator_lnks.
     */
    cursor?: qms_queue_operator_lnkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queue_operator_lnks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queue_operator_lnks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_queue_operator_lnks.
     */
    distinct?: Qms_queue_operator_lnkScalarFieldEnum | Qms_queue_operator_lnkScalarFieldEnum[]
  }

  /**
   * qms_queue_operator_lnk findFirstOrThrow
   */
  export type qms_queue_operator_lnkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue_operator_lnk to fetch.
     */
    where?: qms_queue_operator_lnkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queue_operator_lnks to fetch.
     */
    orderBy?: qms_queue_operator_lnkOrderByWithRelationInput | qms_queue_operator_lnkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_queue_operator_lnks.
     */
    cursor?: qms_queue_operator_lnkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queue_operator_lnks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queue_operator_lnks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_queue_operator_lnks.
     */
    distinct?: Qms_queue_operator_lnkScalarFieldEnum | Qms_queue_operator_lnkScalarFieldEnum[]
  }

  /**
   * qms_queue_operator_lnk findMany
   */
  export type qms_queue_operator_lnkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * Filter, which qms_queue_operator_lnks to fetch.
     */
    where?: qms_queue_operator_lnkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_queue_operator_lnks to fetch.
     */
    orderBy?: qms_queue_operator_lnkOrderByWithRelationInput | qms_queue_operator_lnkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_queue_operator_lnks.
     */
    cursor?: qms_queue_operator_lnkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_queue_operator_lnks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_queue_operator_lnks.
     */
    skip?: number
    distinct?: Qms_queue_operator_lnkScalarFieldEnum | Qms_queue_operator_lnkScalarFieldEnum[]
  }

  /**
   * qms_queue_operator_lnk create
   */
  export type qms_queue_operator_lnkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_queue_operator_lnk.
     */
    data: XOR<qms_queue_operator_lnkCreateInput, qms_queue_operator_lnkUncheckedCreateInput>
  }

  /**
   * qms_queue_operator_lnk createMany
   */
  export type qms_queue_operator_lnkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_queue_operator_lnks.
     */
    data: qms_queue_operator_lnkCreateManyInput | qms_queue_operator_lnkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_queue_operator_lnk update
   */
  export type qms_queue_operator_lnkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_queue_operator_lnk.
     */
    data: XOR<qms_queue_operator_lnkUpdateInput, qms_queue_operator_lnkUncheckedUpdateInput>
    /**
     * Choose, which qms_queue_operator_lnk to update.
     */
    where: qms_queue_operator_lnkWhereUniqueInput
  }

  /**
   * qms_queue_operator_lnk updateMany
   */
  export type qms_queue_operator_lnkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_queue_operator_lnks.
     */
    data: XOR<qms_queue_operator_lnkUpdateManyMutationInput, qms_queue_operator_lnkUncheckedUpdateManyInput>
    /**
     * Filter which qms_queue_operator_lnks to update
     */
    where?: qms_queue_operator_lnkWhereInput
    /**
     * Limit how many qms_queue_operator_lnks to update.
     */
    limit?: number
  }

  /**
   * qms_queue_operator_lnk upsert
   */
  export type qms_queue_operator_lnkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_queue_operator_lnk to update in case it exists.
     */
    where: qms_queue_operator_lnkWhereUniqueInput
    /**
     * In case the qms_queue_operator_lnk found by the `where` argument doesn't exist, create a new qms_queue_operator_lnk with this data.
     */
    create: XOR<qms_queue_operator_lnkCreateInput, qms_queue_operator_lnkUncheckedCreateInput>
    /**
     * In case the qms_queue_operator_lnk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_queue_operator_lnkUpdateInput, qms_queue_operator_lnkUncheckedUpdateInput>
  }

  /**
   * qms_queue_operator_lnk delete
   */
  export type qms_queue_operator_lnkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
    /**
     * Filter which qms_queue_operator_lnk to delete.
     */
    where: qms_queue_operator_lnkWhereUniqueInput
  }

  /**
   * qms_queue_operator_lnk deleteMany
   */
  export type qms_queue_operator_lnkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_queue_operator_lnks to delete
     */
    where?: qms_queue_operator_lnkWhereInput
    /**
     * Limit how many qms_queue_operator_lnks to delete.
     */
    limit?: number
  }

  /**
   * qms_queue_operator_lnk without action
   */
  export type qms_queue_operator_lnkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue_operator_lnk
     */
    select?: qms_queue_operator_lnkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue_operator_lnk
     */
    omit?: qms_queue_operator_lnkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queue_operator_lnkInclude<ExtArgs> | null
  }


  /**
   * Model qms_ticket
   */

  export type AggregateQms_ticket = {
    _count: Qms_ticketCountAggregateOutputType | null
    _avg: Qms_ticketAvgAggregateOutputType | null
    _sum: Qms_ticketSumAggregateOutputType | null
    _min: Qms_ticketMinAggregateOutputType | null
    _max: Qms_ticketMaxAggregateOutputType | null
  }

  export type Qms_ticketAvgAggregateOutputType = {
    id: number | null
    queue_id: number | null
    customer_id: number | null
    pin: number | null
    status: number | null
    service_time: number | null
    estimated_waiting_time: number | null
    skips_count: number | null
    reason_id: number | null
    prev_ticket_id: number | null
    rating_notification_sent: number | null
    source: number | null
  }

  export type Qms_ticketSumAggregateOutputType = {
    id: number | null
    queue_id: number | null
    customer_id: number | null
    pin: number | null
    status: number | null
    service_time: number | null
    estimated_waiting_time: number | null
    skips_count: number | null
    reason_id: number | null
    prev_ticket_id: number | null
    rating_notification_sent: number | null
    source: number | null
  }

  export type Qms_ticketMinAggregateOutputType = {
    id: number | null
    ticket_uuid: string | null
    queue_id: number | null
    customer_id: number | null
    ticket_number: string | null
    full_ticket_number: string | null
    pin: number | null
    status: number | null
    service_time: number | null
    estimated_waiting_time: number | null
    created_at: Date | null
    waiting_ended_on: Date | null
    skipped_at: Date | null
    cancelled_at: Date | null
    on_hold_from: Date | null
    skips_count: number | null
    prioritized: boolean | null
    reason_id: number | null
    prioritized_at: Date | null
    is_next: boolean | null
    prev_ticket_id: number | null
    rating_notification_sent: number | null
    source: number | null
  }

  export type Qms_ticketMaxAggregateOutputType = {
    id: number | null
    ticket_uuid: string | null
    queue_id: number | null
    customer_id: number | null
    ticket_number: string | null
    full_ticket_number: string | null
    pin: number | null
    status: number | null
    service_time: number | null
    estimated_waiting_time: number | null
    created_at: Date | null
    waiting_ended_on: Date | null
    skipped_at: Date | null
    cancelled_at: Date | null
    on_hold_from: Date | null
    skips_count: number | null
    prioritized: boolean | null
    reason_id: number | null
    prioritized_at: Date | null
    is_next: boolean | null
    prev_ticket_id: number | null
    rating_notification_sent: number | null
    source: number | null
  }

  export type Qms_ticketCountAggregateOutputType = {
    id: number
    ticket_uuid: number
    queue_id: number
    customer_id: number
    ticket_number: number
    full_ticket_number: number
    pin: number
    status: number
    service_time: number
    estimated_waiting_time: number
    created_at: number
    waiting_ended_on: number
    skipped_at: number
    cancelled_at: number
    on_hold_from: number
    skips_count: number
    prioritized: number
    reason_id: number
    prioritized_at: number
    is_next: number
    prev_ticket_id: number
    rating_notification_sent: number
    source: number
    _all: number
  }


  export type Qms_ticketAvgAggregateInputType = {
    id?: true
    queue_id?: true
    customer_id?: true
    pin?: true
    status?: true
    service_time?: true
    estimated_waiting_time?: true
    skips_count?: true
    reason_id?: true
    prev_ticket_id?: true
    rating_notification_sent?: true
    source?: true
  }

  export type Qms_ticketSumAggregateInputType = {
    id?: true
    queue_id?: true
    customer_id?: true
    pin?: true
    status?: true
    service_time?: true
    estimated_waiting_time?: true
    skips_count?: true
    reason_id?: true
    prev_ticket_id?: true
    rating_notification_sent?: true
    source?: true
  }

  export type Qms_ticketMinAggregateInputType = {
    id?: true
    ticket_uuid?: true
    queue_id?: true
    customer_id?: true
    ticket_number?: true
    full_ticket_number?: true
    pin?: true
    status?: true
    service_time?: true
    estimated_waiting_time?: true
    created_at?: true
    waiting_ended_on?: true
    skipped_at?: true
    cancelled_at?: true
    on_hold_from?: true
    skips_count?: true
    prioritized?: true
    reason_id?: true
    prioritized_at?: true
    is_next?: true
    prev_ticket_id?: true
    rating_notification_sent?: true
    source?: true
  }

  export type Qms_ticketMaxAggregateInputType = {
    id?: true
    ticket_uuid?: true
    queue_id?: true
    customer_id?: true
    ticket_number?: true
    full_ticket_number?: true
    pin?: true
    status?: true
    service_time?: true
    estimated_waiting_time?: true
    created_at?: true
    waiting_ended_on?: true
    skipped_at?: true
    cancelled_at?: true
    on_hold_from?: true
    skips_count?: true
    prioritized?: true
    reason_id?: true
    prioritized_at?: true
    is_next?: true
    prev_ticket_id?: true
    rating_notification_sent?: true
    source?: true
  }

  export type Qms_ticketCountAggregateInputType = {
    id?: true
    ticket_uuid?: true
    queue_id?: true
    customer_id?: true
    ticket_number?: true
    full_ticket_number?: true
    pin?: true
    status?: true
    service_time?: true
    estimated_waiting_time?: true
    created_at?: true
    waiting_ended_on?: true
    skipped_at?: true
    cancelled_at?: true
    on_hold_from?: true
    skips_count?: true
    prioritized?: true
    reason_id?: true
    prioritized_at?: true
    is_next?: true
    prev_ticket_id?: true
    rating_notification_sent?: true
    source?: true
    _all?: true
  }

  export type Qms_ticketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_ticket to aggregate.
     */
    where?: qms_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_tickets to fetch.
     */
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_tickets
    **/
    _count?: true | Qms_ticketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_ticketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_ticketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_ticketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_ticketMaxAggregateInputType
  }

  export type GetQms_ticketAggregateType<T extends Qms_ticketAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_ticket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_ticket[P]>
      : GetScalarType<T[P], AggregateQms_ticket[P]>
  }




  export type qms_ticketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticketWhereInput
    orderBy?: qms_ticketOrderByWithAggregationInput | qms_ticketOrderByWithAggregationInput[]
    by: Qms_ticketScalarFieldEnum[] | Qms_ticketScalarFieldEnum
    having?: qms_ticketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_ticketCountAggregateInputType | true
    _avg?: Qms_ticketAvgAggregateInputType
    _sum?: Qms_ticketSumAggregateInputType
    _min?: Qms_ticketMinAggregateInputType
    _max?: Qms_ticketMaxAggregateInputType
  }

  export type Qms_ticketGroupByOutputType = {
    id: number
    ticket_uuid: string
    queue_id: number
    customer_id: number
    ticket_number: string
    full_ticket_number: string | null
    pin: number
    status: number | null
    service_time: number | null
    estimated_waiting_time: number | null
    created_at: Date
    waiting_ended_on: Date | null
    skipped_at: Date | null
    cancelled_at: Date | null
    on_hold_from: Date | null
    skips_count: number | null
    prioritized: boolean | null
    reason_id: number | null
    prioritized_at: Date | null
    is_next: boolean | null
    prev_ticket_id: number | null
    rating_notification_sent: number
    source: number
    _count: Qms_ticketCountAggregateOutputType | null
    _avg: Qms_ticketAvgAggregateOutputType | null
    _sum: Qms_ticketSumAggregateOutputType | null
    _min: Qms_ticketMinAggregateOutputType | null
    _max: Qms_ticketMaxAggregateOutputType | null
  }

  type GetQms_ticketGroupByPayload<T extends qms_ticketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_ticketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_ticketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_ticketGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_ticketGroupByOutputType[P]>
        }
      >
    >


  export type qms_ticketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_uuid?: boolean
    queue_id?: boolean
    customer_id?: boolean
    ticket_number?: boolean
    full_ticket_number?: boolean
    pin?: boolean
    status?: boolean
    service_time?: boolean
    estimated_waiting_time?: boolean
    created_at?: boolean
    waiting_ended_on?: boolean
    skipped_at?: boolean
    cancelled_at?: boolean
    on_hold_from?: boolean
    skips_count?: boolean
    prioritized?: boolean
    reason_id?: boolean
    prioritized_at?: boolean
    is_next?: boolean
    prev_ticket_id?: boolean
    rating_notification_sent?: boolean
    source?: boolean
    option?: boolean | qms_ticket$optionArgs<ExtArgs>
    qms_customer?: boolean | qms_customerDefaultArgs<ExtArgs>
    qms_queue?: boolean | qms_queueDefaultArgs<ExtArgs>
    qms_ticket_assignment?: boolean | qms_ticket$qms_ticket_assignmentArgs<ExtArgs>
    _count?: boolean | Qms_ticketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qms_ticket"]>



  export type qms_ticketSelectScalar = {
    id?: boolean
    ticket_uuid?: boolean
    queue_id?: boolean
    customer_id?: boolean
    ticket_number?: boolean
    full_ticket_number?: boolean
    pin?: boolean
    status?: boolean
    service_time?: boolean
    estimated_waiting_time?: boolean
    created_at?: boolean
    waiting_ended_on?: boolean
    skipped_at?: boolean
    cancelled_at?: boolean
    on_hold_from?: boolean
    skips_count?: boolean
    prioritized?: boolean
    reason_id?: boolean
    prioritized_at?: boolean
    is_next?: boolean
    prev_ticket_id?: boolean
    rating_notification_sent?: boolean
    source?: boolean
  }

  export type qms_ticketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_uuid" | "queue_id" | "customer_id" | "ticket_number" | "full_ticket_number" | "pin" | "status" | "service_time" | "estimated_waiting_time" | "created_at" | "waiting_ended_on" | "skipped_at" | "cancelled_at" | "on_hold_from" | "skips_count" | "prioritized" | "reason_id" | "prioritized_at" | "is_next" | "prev_ticket_id" | "rating_notification_sent" | "source", ExtArgs["result"]["qms_ticket"]>
  export type qms_ticketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | qms_ticket$optionArgs<ExtArgs>
    qms_customer?: boolean | qms_customerDefaultArgs<ExtArgs>
    qms_queue?: boolean | qms_queueDefaultArgs<ExtArgs>
    qms_ticket_assignment?: boolean | qms_ticket$qms_ticket_assignmentArgs<ExtArgs>
    _count?: boolean | Qms_ticketCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $qms_ticketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_ticket"
    objects: {
      option: Prisma.$optionPayload<ExtArgs> | null
      qms_customer: Prisma.$qms_customerPayload<ExtArgs>
      qms_queue: Prisma.$qms_queuePayload<ExtArgs>
      qms_ticket_assignment: Prisma.$qms_ticket_assignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_uuid: string
      queue_id: number
      customer_id: number
      ticket_number: string
      full_ticket_number: string | null
      pin: number
      status: number | null
      service_time: number | null
      estimated_waiting_time: number | null
      created_at: Date
      waiting_ended_on: Date | null
      skipped_at: Date | null
      cancelled_at: Date | null
      on_hold_from: Date | null
      skips_count: number | null
      prioritized: boolean | null
      reason_id: number | null
      prioritized_at: Date | null
      is_next: boolean | null
      prev_ticket_id: number | null
      rating_notification_sent: number
      source: number
    }, ExtArgs["result"]["qms_ticket"]>
    composites: {}
  }

  type qms_ticketGetPayload<S extends boolean | null | undefined | qms_ticketDefaultArgs> = $Result.GetResult<Prisma.$qms_ticketPayload, S>

  type qms_ticketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_ticketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_ticketCountAggregateInputType | true
    }

  export interface qms_ticketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_ticket'], meta: { name: 'qms_ticket' } }
    /**
     * Find zero or one Qms_ticket that matches the filter.
     * @param {qms_ticketFindUniqueArgs} args - Arguments to find a Qms_ticket
     * @example
     * // Get one Qms_ticket
     * const qms_ticket = await prisma.qms_ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_ticketFindUniqueArgs>(args: SelectSubset<T, qms_ticketFindUniqueArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_ticketFindUniqueOrThrowArgs} args - Arguments to find a Qms_ticket
     * @example
     * // Get one Qms_ticket
     * const qms_ticket = await prisma.qms_ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_ticketFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_ticketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticketFindFirstArgs} args - Arguments to find a Qms_ticket
     * @example
     * // Get one Qms_ticket
     * const qms_ticket = await prisma.qms_ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_ticketFindFirstArgs>(args?: SelectSubset<T, qms_ticketFindFirstArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticketFindFirstOrThrowArgs} args - Arguments to find a Qms_ticket
     * @example
     * // Get one Qms_ticket
     * const qms_ticket = await prisma.qms_ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_ticketFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_ticketFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_tickets
     * const qms_tickets = await prisma.qms_ticket.findMany()
     * 
     * // Get first 10 Qms_tickets
     * const qms_tickets = await prisma.qms_ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_ticketWithIdOnly = await prisma.qms_ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_ticketFindManyArgs>(args?: SelectSubset<T, qms_ticketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_ticket.
     * @param {qms_ticketCreateArgs} args - Arguments to create a Qms_ticket.
     * @example
     * // Create one Qms_ticket
     * const Qms_ticket = await prisma.qms_ticket.create({
     *   data: {
     *     // ... data to create a Qms_ticket
     *   }
     * })
     * 
     */
    create<T extends qms_ticketCreateArgs>(args: SelectSubset<T, qms_ticketCreateArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_tickets.
     * @param {qms_ticketCreateManyArgs} args - Arguments to create many Qms_tickets.
     * @example
     * // Create many Qms_tickets
     * const qms_ticket = await prisma.qms_ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_ticketCreateManyArgs>(args?: SelectSubset<T, qms_ticketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_ticket.
     * @param {qms_ticketDeleteArgs} args - Arguments to delete one Qms_ticket.
     * @example
     * // Delete one Qms_ticket
     * const Qms_ticket = await prisma.qms_ticket.delete({
     *   where: {
     *     // ... filter to delete one Qms_ticket
     *   }
     * })
     * 
     */
    delete<T extends qms_ticketDeleteArgs>(args: SelectSubset<T, qms_ticketDeleteArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_ticket.
     * @param {qms_ticketUpdateArgs} args - Arguments to update one Qms_ticket.
     * @example
     * // Update one Qms_ticket
     * const qms_ticket = await prisma.qms_ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_ticketUpdateArgs>(args: SelectSubset<T, qms_ticketUpdateArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_tickets.
     * @param {qms_ticketDeleteManyArgs} args - Arguments to filter Qms_tickets to delete.
     * @example
     * // Delete a few Qms_tickets
     * const { count } = await prisma.qms_ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_ticketDeleteManyArgs>(args?: SelectSubset<T, qms_ticketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_tickets
     * const qms_ticket = await prisma.qms_ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_ticketUpdateManyArgs>(args: SelectSubset<T, qms_ticketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_ticket.
     * @param {qms_ticketUpsertArgs} args - Arguments to update or create a Qms_ticket.
     * @example
     * // Update or create a Qms_ticket
     * const qms_ticket = await prisma.qms_ticket.upsert({
     *   create: {
     *     // ... data to create a Qms_ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_ticket we want to update
     *   }
     * })
     */
    upsert<T extends qms_ticketUpsertArgs>(args: SelectSubset<T, qms_ticketUpsertArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticketCountArgs} args - Arguments to filter Qms_tickets to count.
     * @example
     * // Count the number of Qms_tickets
     * const count = await prisma.qms_ticket.count({
     *   where: {
     *     // ... the filter for the Qms_tickets we want to count
     *   }
     * })
    **/
    count<T extends qms_ticketCountArgs>(
      args?: Subset<T, qms_ticketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_ticketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_ticketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_ticketAggregateArgs>(args: Subset<T, Qms_ticketAggregateArgs>): Prisma.PrismaPromise<GetQms_ticketAggregateType<T>>

    /**
     * Group by Qms_ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_ticketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_ticketGroupByArgs['orderBy'] }
        : { orderBy?: qms_ticketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_ticketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_ticketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_ticket model
   */
  readonly fields: qms_ticketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_ticketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option<T extends qms_ticket$optionArgs<ExtArgs> = {}>(args?: Subset<T, qms_ticket$optionArgs<ExtArgs>>): Prisma__optionClient<$Result.GetResult<Prisma.$optionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    qms_customer<T extends qms_customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_customerDefaultArgs<ExtArgs>>): Prisma__qms_customerClient<$Result.GetResult<Prisma.$qms_customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_queue<T extends qms_queueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_queueDefaultArgs<ExtArgs>>): Prisma__qms_queueClient<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_ticket_assignment<T extends qms_ticket$qms_ticket_assignmentArgs<ExtArgs> = {}>(args?: Subset<T, qms_ticket$qms_ticket_assignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_ticket model
   */
  interface qms_ticketFieldRefs {
    readonly id: FieldRef<"qms_ticket", 'Int'>
    readonly ticket_uuid: FieldRef<"qms_ticket", 'String'>
    readonly queue_id: FieldRef<"qms_ticket", 'Int'>
    readonly customer_id: FieldRef<"qms_ticket", 'Int'>
    readonly ticket_number: FieldRef<"qms_ticket", 'String'>
    readonly full_ticket_number: FieldRef<"qms_ticket", 'String'>
    readonly pin: FieldRef<"qms_ticket", 'Int'>
    readonly status: FieldRef<"qms_ticket", 'Int'>
    readonly service_time: FieldRef<"qms_ticket", 'Float'>
    readonly estimated_waiting_time: FieldRef<"qms_ticket", 'Int'>
    readonly created_at: FieldRef<"qms_ticket", 'DateTime'>
    readonly waiting_ended_on: FieldRef<"qms_ticket", 'DateTime'>
    readonly skipped_at: FieldRef<"qms_ticket", 'DateTime'>
    readonly cancelled_at: FieldRef<"qms_ticket", 'DateTime'>
    readonly on_hold_from: FieldRef<"qms_ticket", 'DateTime'>
    readonly skips_count: FieldRef<"qms_ticket", 'Int'>
    readonly prioritized: FieldRef<"qms_ticket", 'Boolean'>
    readonly reason_id: FieldRef<"qms_ticket", 'Int'>
    readonly prioritized_at: FieldRef<"qms_ticket", 'DateTime'>
    readonly is_next: FieldRef<"qms_ticket", 'Boolean'>
    readonly prev_ticket_id: FieldRef<"qms_ticket", 'Int'>
    readonly rating_notification_sent: FieldRef<"qms_ticket", 'Int'>
    readonly source: FieldRef<"qms_ticket", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * qms_ticket findUnique
   */
  export type qms_ticketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket to fetch.
     */
    where: qms_ticketWhereUniqueInput
  }

  /**
   * qms_ticket findUniqueOrThrow
   */
  export type qms_ticketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket to fetch.
     */
    where: qms_ticketWhereUniqueInput
  }

  /**
   * qms_ticket findFirst
   */
  export type qms_ticketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket to fetch.
     */
    where?: qms_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_tickets to fetch.
     */
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_tickets.
     */
    cursor?: qms_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_tickets.
     */
    distinct?: Qms_ticketScalarFieldEnum | Qms_ticketScalarFieldEnum[]
  }

  /**
   * qms_ticket findFirstOrThrow
   */
  export type qms_ticketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket to fetch.
     */
    where?: qms_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_tickets to fetch.
     */
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_tickets.
     */
    cursor?: qms_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_tickets.
     */
    distinct?: Qms_ticketScalarFieldEnum | Qms_ticketScalarFieldEnum[]
  }

  /**
   * qms_ticket findMany
   */
  export type qms_ticketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * Filter, which qms_tickets to fetch.
     */
    where?: qms_ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_tickets to fetch.
     */
    orderBy?: qms_ticketOrderByWithRelationInput | qms_ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_tickets.
     */
    cursor?: qms_ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_tickets.
     */
    skip?: number
    distinct?: Qms_ticketScalarFieldEnum | Qms_ticketScalarFieldEnum[]
  }

  /**
   * qms_ticket create
   */
  export type qms_ticketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_ticket.
     */
    data: XOR<qms_ticketCreateInput, qms_ticketUncheckedCreateInput>
  }

  /**
   * qms_ticket createMany
   */
  export type qms_ticketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_tickets.
     */
    data: qms_ticketCreateManyInput | qms_ticketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_ticket update
   */
  export type qms_ticketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_ticket.
     */
    data: XOR<qms_ticketUpdateInput, qms_ticketUncheckedUpdateInput>
    /**
     * Choose, which qms_ticket to update.
     */
    where: qms_ticketWhereUniqueInput
  }

  /**
   * qms_ticket updateMany
   */
  export type qms_ticketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_tickets.
     */
    data: XOR<qms_ticketUpdateManyMutationInput, qms_ticketUncheckedUpdateManyInput>
    /**
     * Filter which qms_tickets to update
     */
    where?: qms_ticketWhereInput
    /**
     * Limit how many qms_tickets to update.
     */
    limit?: number
  }

  /**
   * qms_ticket upsert
   */
  export type qms_ticketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_ticket to update in case it exists.
     */
    where: qms_ticketWhereUniqueInput
    /**
     * In case the qms_ticket found by the `where` argument doesn't exist, create a new qms_ticket with this data.
     */
    create: XOR<qms_ticketCreateInput, qms_ticketUncheckedCreateInput>
    /**
     * In case the qms_ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_ticketUpdateInput, qms_ticketUncheckedUpdateInput>
  }

  /**
   * qms_ticket delete
   */
  export type qms_ticketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
    /**
     * Filter which qms_ticket to delete.
     */
    where: qms_ticketWhereUniqueInput
  }

  /**
   * qms_ticket deleteMany
   */
  export type qms_ticketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_tickets to delete
     */
    where?: qms_ticketWhereInput
    /**
     * Limit how many qms_tickets to delete.
     */
    limit?: number
  }

  /**
   * qms_ticket.option
   */
  export type qms_ticket$optionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the option
     */
    select?: optionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the option
     */
    omit?: optionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optionInclude<ExtArgs> | null
    where?: optionWhereInput
  }

  /**
   * qms_ticket.qms_ticket_assignment
   */
  export type qms_ticket$qms_ticket_assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    where?: qms_ticket_assignmentWhereInput
    orderBy?: qms_ticket_assignmentOrderByWithRelationInput | qms_ticket_assignmentOrderByWithRelationInput[]
    cursor?: qms_ticket_assignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_ticket_assignmentScalarFieldEnum | Qms_ticket_assignmentScalarFieldEnum[]
  }

  /**
   * qms_ticket without action
   */
  export type qms_ticketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket
     */
    select?: qms_ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket
     */
    omit?: qms_ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticketInclude<ExtArgs> | null
  }


  /**
   * Model qms_ticket_assignment
   */

  export type AggregateQms_ticket_assignment = {
    _count: Qms_ticket_assignmentCountAggregateOutputType | null
    _avg: Qms_ticket_assignmentAvgAggregateOutputType | null
    _sum: Qms_ticket_assignmentSumAggregateOutputType | null
    _min: Qms_ticket_assignmentMinAggregateOutputType | null
    _max: Qms_ticket_assignmentMaxAggregateOutputType | null
  }

  export type Qms_ticket_assignmentAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
    status: number | null
    state: number | null
  }

  export type Qms_ticket_assignmentSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
    status: number | null
    state: number | null
  }

  export type Qms_ticket_assignmentMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
    status: number | null
    started_at: Date | null
    completed_at: Date | null
    assigned_at: Date | null
    state: number | null
    comment: string | null
  }

  export type Qms_ticket_assignmentMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
    status: number | null
    started_at: Date | null
    completed_at: Date | null
    assigned_at: Date | null
    state: number | null
    comment: string | null
  }

  export type Qms_ticket_assignmentCountAggregateOutputType = {
    id: number
    ticket_id: number
    queue_id: number
    operator_id: number
    counter_id: number
    status: number
    started_at: number
    completed_at: number
    assigned_at: number
    state: number
    comment: number
    _all: number
  }


  export type Qms_ticket_assignmentAvgAggregateInputType = {
    id?: true
    ticket_id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
    status?: true
    state?: true
  }

  export type Qms_ticket_assignmentSumAggregateInputType = {
    id?: true
    ticket_id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
    status?: true
    state?: true
  }

  export type Qms_ticket_assignmentMinAggregateInputType = {
    id?: true
    ticket_id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    assigned_at?: true
    state?: true
    comment?: true
  }

  export type Qms_ticket_assignmentMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    assigned_at?: true
    state?: true
    comment?: true
  }

  export type Qms_ticket_assignmentCountAggregateInputType = {
    id?: true
    ticket_id?: true
    queue_id?: true
    operator_id?: true
    counter_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    assigned_at?: true
    state?: true
    comment?: true
    _all?: true
  }

  export type Qms_ticket_assignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_ticket_assignment to aggregate.
     */
    where?: qms_ticket_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_ticket_assignments to fetch.
     */
    orderBy?: qms_ticket_assignmentOrderByWithRelationInput | qms_ticket_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qms_ticket_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_ticket_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_ticket_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qms_ticket_assignments
    **/
    _count?: true | Qms_ticket_assignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qms_ticket_assignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qms_ticket_assignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qms_ticket_assignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qms_ticket_assignmentMaxAggregateInputType
  }

  export type GetQms_ticket_assignmentAggregateType<T extends Qms_ticket_assignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateQms_ticket_assignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQms_ticket_assignment[P]>
      : GetScalarType<T[P], AggregateQms_ticket_assignment[P]>
  }




  export type qms_ticket_assignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qms_ticket_assignmentWhereInput
    orderBy?: qms_ticket_assignmentOrderByWithAggregationInput | qms_ticket_assignmentOrderByWithAggregationInput[]
    by: Qms_ticket_assignmentScalarFieldEnum[] | Qms_ticket_assignmentScalarFieldEnum
    having?: qms_ticket_assignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qms_ticket_assignmentCountAggregateInputType | true
    _avg?: Qms_ticket_assignmentAvgAggregateInputType
    _sum?: Qms_ticket_assignmentSumAggregateInputType
    _min?: Qms_ticket_assignmentMinAggregateInputType
    _max?: Qms_ticket_assignmentMaxAggregateInputType
  }

  export type Qms_ticket_assignmentGroupByOutputType = {
    id: number
    ticket_id: number
    queue_id: number | null
    operator_id: number | null
    counter_id: number | null
    status: number | null
    started_at: Date | null
    completed_at: Date | null
    assigned_at: Date | null
    state: number | null
    comment: string | null
    _count: Qms_ticket_assignmentCountAggregateOutputType | null
    _avg: Qms_ticket_assignmentAvgAggregateOutputType | null
    _sum: Qms_ticket_assignmentSumAggregateOutputType | null
    _min: Qms_ticket_assignmentMinAggregateOutputType | null
    _max: Qms_ticket_assignmentMaxAggregateOutputType | null
  }

  type GetQms_ticket_assignmentGroupByPayload<T extends qms_ticket_assignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qms_ticket_assignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qms_ticket_assignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qms_ticket_assignmentGroupByOutputType[P]>
            : GetScalarType<T[P], Qms_ticket_assignmentGroupByOutputType[P]>
        }
      >
    >


  export type qms_ticket_assignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    queue_id?: boolean
    operator_id?: boolean
    counter_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    assigned_at?: boolean
    state?: boolean
    comment?: boolean
    qms_ticket?: boolean | qms_ticketDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_ticket_assignment$qms_operatorArgs<ExtArgs>
  }, ExtArgs["result"]["qms_ticket_assignment"]>



  export type qms_ticket_assignmentSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    queue_id?: boolean
    operator_id?: boolean
    counter_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    assigned_at?: boolean
    state?: boolean
    comment?: boolean
  }

  export type qms_ticket_assignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "queue_id" | "operator_id" | "counter_id" | "status" | "started_at" | "completed_at" | "assigned_at" | "state" | "comment", ExtArgs["result"]["qms_ticket_assignment"]>
  export type qms_ticket_assignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qms_ticket?: boolean | qms_ticketDefaultArgs<ExtArgs>
    qms_operator?: boolean | qms_ticket_assignment$qms_operatorArgs<ExtArgs>
  }

  export type $qms_ticket_assignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qms_ticket_assignment"
    objects: {
      qms_ticket: Prisma.$qms_ticketPayload<ExtArgs>
      qms_operator: Prisma.$qms_operatorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      queue_id: number | null
      operator_id: number | null
      counter_id: number | null
      status: number | null
      started_at: Date | null
      completed_at: Date | null
      assigned_at: Date | null
      state: number | null
      comment: string | null
    }, ExtArgs["result"]["qms_ticket_assignment"]>
    composites: {}
  }

  type qms_ticket_assignmentGetPayload<S extends boolean | null | undefined | qms_ticket_assignmentDefaultArgs> = $Result.GetResult<Prisma.$qms_ticket_assignmentPayload, S>

  type qms_ticket_assignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qms_ticket_assignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qms_ticket_assignmentCountAggregateInputType | true
    }

  export interface qms_ticket_assignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qms_ticket_assignment'], meta: { name: 'qms_ticket_assignment' } }
    /**
     * Find zero or one Qms_ticket_assignment that matches the filter.
     * @param {qms_ticket_assignmentFindUniqueArgs} args - Arguments to find a Qms_ticket_assignment
     * @example
     * // Get one Qms_ticket_assignment
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qms_ticket_assignmentFindUniqueArgs>(args: SelectSubset<T, qms_ticket_assignmentFindUniqueArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qms_ticket_assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qms_ticket_assignmentFindUniqueOrThrowArgs} args - Arguments to find a Qms_ticket_assignment
     * @example
     * // Get one Qms_ticket_assignment
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qms_ticket_assignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, qms_ticket_assignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_ticket_assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticket_assignmentFindFirstArgs} args - Arguments to find a Qms_ticket_assignment
     * @example
     * // Get one Qms_ticket_assignment
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qms_ticket_assignmentFindFirstArgs>(args?: SelectSubset<T, qms_ticket_assignmentFindFirstArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qms_ticket_assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticket_assignmentFindFirstOrThrowArgs} args - Arguments to find a Qms_ticket_assignment
     * @example
     * // Get one Qms_ticket_assignment
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qms_ticket_assignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, qms_ticket_assignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qms_ticket_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticket_assignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qms_ticket_assignments
     * const qms_ticket_assignments = await prisma.qms_ticket_assignment.findMany()
     * 
     * // Get first 10 Qms_ticket_assignments
     * const qms_ticket_assignments = await prisma.qms_ticket_assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qms_ticket_assignmentWithIdOnly = await prisma.qms_ticket_assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qms_ticket_assignmentFindManyArgs>(args?: SelectSubset<T, qms_ticket_assignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qms_ticket_assignment.
     * @param {qms_ticket_assignmentCreateArgs} args - Arguments to create a Qms_ticket_assignment.
     * @example
     * // Create one Qms_ticket_assignment
     * const Qms_ticket_assignment = await prisma.qms_ticket_assignment.create({
     *   data: {
     *     // ... data to create a Qms_ticket_assignment
     *   }
     * })
     * 
     */
    create<T extends qms_ticket_assignmentCreateArgs>(args: SelectSubset<T, qms_ticket_assignmentCreateArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qms_ticket_assignments.
     * @param {qms_ticket_assignmentCreateManyArgs} args - Arguments to create many Qms_ticket_assignments.
     * @example
     * // Create many Qms_ticket_assignments
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qms_ticket_assignmentCreateManyArgs>(args?: SelectSubset<T, qms_ticket_assignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qms_ticket_assignment.
     * @param {qms_ticket_assignmentDeleteArgs} args - Arguments to delete one Qms_ticket_assignment.
     * @example
     * // Delete one Qms_ticket_assignment
     * const Qms_ticket_assignment = await prisma.qms_ticket_assignment.delete({
     *   where: {
     *     // ... filter to delete one Qms_ticket_assignment
     *   }
     * })
     * 
     */
    delete<T extends qms_ticket_assignmentDeleteArgs>(args: SelectSubset<T, qms_ticket_assignmentDeleteArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qms_ticket_assignment.
     * @param {qms_ticket_assignmentUpdateArgs} args - Arguments to update one Qms_ticket_assignment.
     * @example
     * // Update one Qms_ticket_assignment
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qms_ticket_assignmentUpdateArgs>(args: SelectSubset<T, qms_ticket_assignmentUpdateArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qms_ticket_assignments.
     * @param {qms_ticket_assignmentDeleteManyArgs} args - Arguments to filter Qms_ticket_assignments to delete.
     * @example
     * // Delete a few Qms_ticket_assignments
     * const { count } = await prisma.qms_ticket_assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qms_ticket_assignmentDeleteManyArgs>(args?: SelectSubset<T, qms_ticket_assignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qms_ticket_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticket_assignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qms_ticket_assignments
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qms_ticket_assignmentUpdateManyArgs>(args: SelectSubset<T, qms_ticket_assignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qms_ticket_assignment.
     * @param {qms_ticket_assignmentUpsertArgs} args - Arguments to update or create a Qms_ticket_assignment.
     * @example
     * // Update or create a Qms_ticket_assignment
     * const qms_ticket_assignment = await prisma.qms_ticket_assignment.upsert({
     *   create: {
     *     // ... data to create a Qms_ticket_assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qms_ticket_assignment we want to update
     *   }
     * })
     */
    upsert<T extends qms_ticket_assignmentUpsertArgs>(args: SelectSubset<T, qms_ticket_assignmentUpsertArgs<ExtArgs>>): Prisma__qms_ticket_assignmentClient<$Result.GetResult<Prisma.$qms_ticket_assignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qms_ticket_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticket_assignmentCountArgs} args - Arguments to filter Qms_ticket_assignments to count.
     * @example
     * // Count the number of Qms_ticket_assignments
     * const count = await prisma.qms_ticket_assignment.count({
     *   where: {
     *     // ... the filter for the Qms_ticket_assignments we want to count
     *   }
     * })
    **/
    count<T extends qms_ticket_assignmentCountArgs>(
      args?: Subset<T, qms_ticket_assignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qms_ticket_assignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qms_ticket_assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qms_ticket_assignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qms_ticket_assignmentAggregateArgs>(args: Subset<T, Qms_ticket_assignmentAggregateArgs>): Prisma.PrismaPromise<GetQms_ticket_assignmentAggregateType<T>>

    /**
     * Group by Qms_ticket_assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qms_ticket_assignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qms_ticket_assignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qms_ticket_assignmentGroupByArgs['orderBy'] }
        : { orderBy?: qms_ticket_assignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qms_ticket_assignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQms_ticket_assignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qms_ticket_assignment model
   */
  readonly fields: qms_ticket_assignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qms_ticket_assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qms_ticket_assignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qms_ticket<T extends qms_ticketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, qms_ticketDefaultArgs<ExtArgs>>): Prisma__qms_ticketClient<$Result.GetResult<Prisma.$qms_ticketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qms_operator<T extends qms_ticket_assignment$qms_operatorArgs<ExtArgs> = {}>(args?: Subset<T, qms_ticket_assignment$qms_operatorArgs<ExtArgs>>): Prisma__qms_operatorClient<$Result.GetResult<Prisma.$qms_operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qms_ticket_assignment model
   */
  interface qms_ticket_assignmentFieldRefs {
    readonly id: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly ticket_id: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly queue_id: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly operator_id: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly counter_id: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly status: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly started_at: FieldRef<"qms_ticket_assignment", 'DateTime'>
    readonly completed_at: FieldRef<"qms_ticket_assignment", 'DateTime'>
    readonly assigned_at: FieldRef<"qms_ticket_assignment", 'DateTime'>
    readonly state: FieldRef<"qms_ticket_assignment", 'Int'>
    readonly comment: FieldRef<"qms_ticket_assignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * qms_ticket_assignment findUnique
   */
  export type qms_ticket_assignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket_assignment to fetch.
     */
    where: qms_ticket_assignmentWhereUniqueInput
  }

  /**
   * qms_ticket_assignment findUniqueOrThrow
   */
  export type qms_ticket_assignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket_assignment to fetch.
     */
    where: qms_ticket_assignmentWhereUniqueInput
  }

  /**
   * qms_ticket_assignment findFirst
   */
  export type qms_ticket_assignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket_assignment to fetch.
     */
    where?: qms_ticket_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_ticket_assignments to fetch.
     */
    orderBy?: qms_ticket_assignmentOrderByWithRelationInput | qms_ticket_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_ticket_assignments.
     */
    cursor?: qms_ticket_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_ticket_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_ticket_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_ticket_assignments.
     */
    distinct?: Qms_ticket_assignmentScalarFieldEnum | Qms_ticket_assignmentScalarFieldEnum[]
  }

  /**
   * qms_ticket_assignment findFirstOrThrow
   */
  export type qms_ticket_assignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket_assignment to fetch.
     */
    where?: qms_ticket_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_ticket_assignments to fetch.
     */
    orderBy?: qms_ticket_assignmentOrderByWithRelationInput | qms_ticket_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qms_ticket_assignments.
     */
    cursor?: qms_ticket_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_ticket_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_ticket_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qms_ticket_assignments.
     */
    distinct?: Qms_ticket_assignmentScalarFieldEnum | Qms_ticket_assignmentScalarFieldEnum[]
  }

  /**
   * qms_ticket_assignment findMany
   */
  export type qms_ticket_assignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * Filter, which qms_ticket_assignments to fetch.
     */
    where?: qms_ticket_assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qms_ticket_assignments to fetch.
     */
    orderBy?: qms_ticket_assignmentOrderByWithRelationInput | qms_ticket_assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qms_ticket_assignments.
     */
    cursor?: qms_ticket_assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qms_ticket_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qms_ticket_assignments.
     */
    skip?: number
    distinct?: Qms_ticket_assignmentScalarFieldEnum | Qms_ticket_assignmentScalarFieldEnum[]
  }

  /**
   * qms_ticket_assignment create
   */
  export type qms_ticket_assignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a qms_ticket_assignment.
     */
    data: XOR<qms_ticket_assignmentCreateInput, qms_ticket_assignmentUncheckedCreateInput>
  }

  /**
   * qms_ticket_assignment createMany
   */
  export type qms_ticket_assignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qms_ticket_assignments.
     */
    data: qms_ticket_assignmentCreateManyInput | qms_ticket_assignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qms_ticket_assignment update
   */
  export type qms_ticket_assignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a qms_ticket_assignment.
     */
    data: XOR<qms_ticket_assignmentUpdateInput, qms_ticket_assignmentUncheckedUpdateInput>
    /**
     * Choose, which qms_ticket_assignment to update.
     */
    where: qms_ticket_assignmentWhereUniqueInput
  }

  /**
   * qms_ticket_assignment updateMany
   */
  export type qms_ticket_assignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qms_ticket_assignments.
     */
    data: XOR<qms_ticket_assignmentUpdateManyMutationInput, qms_ticket_assignmentUncheckedUpdateManyInput>
    /**
     * Filter which qms_ticket_assignments to update
     */
    where?: qms_ticket_assignmentWhereInput
    /**
     * Limit how many qms_ticket_assignments to update.
     */
    limit?: number
  }

  /**
   * qms_ticket_assignment upsert
   */
  export type qms_ticket_assignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the qms_ticket_assignment to update in case it exists.
     */
    where: qms_ticket_assignmentWhereUniqueInput
    /**
     * In case the qms_ticket_assignment found by the `where` argument doesn't exist, create a new qms_ticket_assignment with this data.
     */
    create: XOR<qms_ticket_assignmentCreateInput, qms_ticket_assignmentUncheckedCreateInput>
    /**
     * In case the qms_ticket_assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qms_ticket_assignmentUpdateInput, qms_ticket_assignmentUncheckedUpdateInput>
  }

  /**
   * qms_ticket_assignment delete
   */
  export type qms_ticket_assignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
    /**
     * Filter which qms_ticket_assignment to delete.
     */
    where: qms_ticket_assignmentWhereUniqueInput
  }

  /**
   * qms_ticket_assignment deleteMany
   */
  export type qms_ticket_assignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qms_ticket_assignments to delete
     */
    where?: qms_ticket_assignmentWhereInput
    /**
     * Limit how many qms_ticket_assignments to delete.
     */
    limit?: number
  }

  /**
   * qms_ticket_assignment.qms_operator
   */
  export type qms_ticket_assignment$qms_operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_operator
     */
    select?: qms_operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_operator
     */
    omit?: qms_operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_operatorInclude<ExtArgs> | null
    where?: qms_operatorWhereInput
  }

  /**
   * qms_ticket_assignment without action
   */
  export type qms_ticket_assignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_ticket_assignment
     */
    select?: qms_ticket_assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_ticket_assignment
     */
    omit?: qms_ticket_assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_ticket_assignmentInclude<ExtArgs> | null
  }


  /**
   * Model rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
    gender: number | null
    age_range: number | null
    location: number | null
    device_id: number | null
    nps_score: number | null
    ticket_id: number | null
  }

  export type RatingSumAggregateOutputType = {
    id: bigint | null
    service_id: number | null
    gender: number | null
    age_range: number | null
    location: number | null
    device_id: number | null
    nps_score: number | null
    ticket_id: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: bigint | null
    state: boolean | null
    time: Date | null
    service_id: number | null
    comment: string | null
    gender: number | null
    age_range: number | null
    location: number | null
    device_id: number | null
    nps_score: number | null
    ticket_id: number | null
    finger_print: string | null
  }

  export type RatingMaxAggregateOutputType = {
    id: bigint | null
    state: boolean | null
    time: Date | null
    service_id: number | null
    comment: string | null
    gender: number | null
    age_range: number | null
    location: number | null
    device_id: number | null
    nps_score: number | null
    ticket_id: number | null
    finger_print: string | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    state: number
    time: number
    service_id: number
    comment: number
    gender: number
    age_range: number
    location: number
    device_id: number
    nps_score: number
    ticket_id: number
    finger_print: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    id?: true
    service_id?: true
    gender?: true
    age_range?: true
    location?: true
    device_id?: true
    nps_score?: true
    ticket_id?: true
  }

  export type RatingSumAggregateInputType = {
    id?: true
    service_id?: true
    gender?: true
    age_range?: true
    location?: true
    device_id?: true
    nps_score?: true
    ticket_id?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    state?: true
    time?: true
    service_id?: true
    comment?: true
    gender?: true
    age_range?: true
    location?: true
    device_id?: true
    nps_score?: true
    ticket_id?: true
    finger_print?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    state?: true
    time?: true
    service_id?: true
    comment?: true
    gender?: true
    age_range?: true
    location?: true
    device_id?: true
    nps_score?: true
    ticket_id?: true
    finger_print?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    state?: true
    time?: true
    service_id?: true
    comment?: true
    gender?: true
    age_range?: true
    location?: true
    device_id?: true
    nps_score?: true
    ticket_id?: true
    finger_print?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating to aggregate.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type ratingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithAggregationInput | ratingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: ratingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: bigint
    state: boolean
    time: Date
    service_id: number
    comment: string | null
    gender: number | null
    age_range: number | null
    location: number | null
    device_id: number | null
    nps_score: number | null
    ticket_id: number | null
    finger_print: string | null
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends ratingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type ratingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    time?: boolean
    service_id?: boolean
    comment?: boolean
    gender?: boolean
    age_range?: boolean
    location?: boolean
    device_id?: boolean
    nps_score?: boolean
    ticket_id?: boolean
    finger_print?: boolean
    service?: boolean | serviceDefaultArgs<ExtArgs>
    device?: boolean | rating$deviceArgs<ExtArgs>
    rating_assets?: boolean | rating$rating_assetsArgs<ExtArgs>
    tip?: boolean | rating$tipArgs<ExtArgs>
    _count?: boolean | RatingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>



  export type ratingSelectScalar = {
    id?: boolean
    state?: boolean
    time?: boolean
    service_id?: boolean
    comment?: boolean
    gender?: boolean
    age_range?: boolean
    location?: boolean
    device_id?: boolean
    nps_score?: boolean
    ticket_id?: boolean
    finger_print?: boolean
  }

  export type ratingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "state" | "time" | "service_id" | "comment" | "gender" | "age_range" | "location" | "device_id" | "nps_score" | "ticket_id" | "finger_print", ExtArgs["result"]["rating"]>
  export type ratingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | serviceDefaultArgs<ExtArgs>
    device?: boolean | rating$deviceArgs<ExtArgs>
    rating_assets?: boolean | rating$rating_assetsArgs<ExtArgs>
    tip?: boolean | rating$tipArgs<ExtArgs>
    _count?: boolean | RatingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ratingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rating"
    objects: {
      service: Prisma.$servicePayload<ExtArgs>
      device: Prisma.$devicePayload<ExtArgs> | null
      rating_assets: Prisma.$rating_assetsPayload<ExtArgs>[]
      tip: Prisma.$tipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      state: boolean
      time: Date
      service_id: number
      comment: string | null
      gender: number | null
      age_range: number | null
      location: number | null
      device_id: number | null
      nps_score: number | null
      ticket_id: number | null
      finger_print: string | null
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type ratingGetPayload<S extends boolean | null | undefined | ratingDefaultArgs> = $Result.GetResult<Prisma.$ratingPayload, S>

  type ratingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ratingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface ratingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rating'], meta: { name: 'rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {ratingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ratingFindUniqueArgs>(args: SelectSubset<T, ratingFindUniqueArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ratingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ratingFindUniqueOrThrowArgs>(args: SelectSubset<T, ratingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ratingFindFirstArgs>(args?: SelectSubset<T, ratingFindFirstArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ratingFindFirstOrThrowArgs>(args?: SelectSubset<T, ratingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ratingFindManyArgs>(args?: SelectSubset<T, ratingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {ratingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends ratingCreateArgs>(args: SelectSubset<T, ratingCreateArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {ratingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ratingCreateManyArgs>(args?: SelectSubset<T, ratingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating.
     * @param {ratingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends ratingDeleteArgs>(args: SelectSubset<T, ratingDeleteArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {ratingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ratingUpdateArgs>(args: SelectSubset<T, ratingUpdateArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {ratingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ratingDeleteManyArgs>(args?: SelectSubset<T, ratingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ratingUpdateManyArgs>(args: SelectSubset<T, ratingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating.
     * @param {ratingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends ratingUpsertArgs>(args: SelectSubset<T, ratingUpsertArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends ratingCountArgs>(
      args?: Subset<T, ratingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ratingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ratingGroupByArgs['orderBy'] }
        : { orderBy?: ratingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ratingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rating model
   */
  readonly fields: ratingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ratingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends serviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviceDefaultArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends rating$deviceArgs<ExtArgs> = {}>(args?: Subset<T, rating$deviceArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rating_assets<T extends rating$rating_assetsArgs<ExtArgs> = {}>(args?: Subset<T, rating$rating_assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tip<T extends rating$tipArgs<ExtArgs> = {}>(args?: Subset<T, rating$tipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rating model
   */
  interface ratingFieldRefs {
    readonly id: FieldRef<"rating", 'BigInt'>
    readonly state: FieldRef<"rating", 'Boolean'>
    readonly time: FieldRef<"rating", 'DateTime'>
    readonly service_id: FieldRef<"rating", 'Int'>
    readonly comment: FieldRef<"rating", 'String'>
    readonly gender: FieldRef<"rating", 'Int'>
    readonly age_range: FieldRef<"rating", 'Int'>
    readonly location: FieldRef<"rating", 'Int'>
    readonly device_id: FieldRef<"rating", 'Int'>
    readonly nps_score: FieldRef<"rating", 'Int'>
    readonly ticket_id: FieldRef<"rating", 'Int'>
    readonly finger_print: FieldRef<"rating", 'String'>
  }
    

  // Custom InputTypes
  /**
   * rating findUnique
   */
  export type ratingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where: ratingWhereUniqueInput
  }

  /**
   * rating findUniqueOrThrow
   */
  export type ratingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where: ratingWhereUniqueInput
  }

  /**
   * rating findFirst
   */
  export type ratingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * rating findFirstOrThrow
   */
  export type ratingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which rating to fetch.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * rating findMany
   */
  export type ratingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ratings.
     */
    cursor?: ratingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * rating create
   */
  export type ratingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * The data needed to create a rating.
     */
    data: XOR<ratingCreateInput, ratingUncheckedCreateInput>
  }

  /**
   * rating createMany
   */
  export type ratingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ratings.
     */
    data: ratingCreateManyInput | ratingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rating update
   */
  export type ratingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * The data needed to update a rating.
     */
    data: XOR<ratingUpdateInput, ratingUncheckedUpdateInput>
    /**
     * Choose, which rating to update.
     */
    where: ratingWhereUniqueInput
  }

  /**
   * rating updateMany
   */
  export type ratingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ratings.
     */
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyInput>
    /**
     * Filter which ratings to update
     */
    where?: ratingWhereInput
    /**
     * Limit how many ratings to update.
     */
    limit?: number
  }

  /**
   * rating upsert
   */
  export type ratingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * The filter to search for the rating to update in case it exists.
     */
    where: ratingWhereUniqueInput
    /**
     * In case the rating found by the `where` argument doesn't exist, create a new rating with this data.
     */
    create: XOR<ratingCreateInput, ratingUncheckedCreateInput>
    /**
     * In case the rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ratingUpdateInput, ratingUncheckedUpdateInput>
  }

  /**
   * rating delete
   */
  export type ratingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    /**
     * Filter which rating to delete.
     */
    where: ratingWhereUniqueInput
  }

  /**
   * rating deleteMany
   */
  export type ratingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to delete
     */
    where?: ratingWhereInput
    /**
     * Limit how many ratings to delete.
     */
    limit?: number
  }

  /**
   * rating.device
   */
  export type rating$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device
     */
    select?: deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the device
     */
    omit?: deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deviceInclude<ExtArgs> | null
    where?: deviceWhereInput
  }

  /**
   * rating.rating_assets
   */
  export type rating$rating_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    where?: rating_assetsWhereInput
    orderBy?: rating_assetsOrderByWithRelationInput | rating_assetsOrderByWithRelationInput[]
    cursor?: rating_assetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rating_assetsScalarFieldEnum | Rating_assetsScalarFieldEnum[]
  }

  /**
   * rating.tip
   */
  export type rating$tipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    where?: tipWhereInput
    orderBy?: tipOrderByWithRelationInput | tipOrderByWithRelationInput[]
    cursor?: tipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TipScalarFieldEnum | TipScalarFieldEnum[]
  }

  /**
   * rating without action
   */
  export type ratingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
  }


  /**
   * Model rating_assets
   */

  export type AggregateRating_assets = {
    _count: Rating_assetsCountAggregateOutputType | null
    _avg: Rating_assetsAvgAggregateOutputType | null
    _sum: Rating_assetsSumAggregateOutputType | null
    _min: Rating_assetsMinAggregateOutputType | null
    _max: Rating_assetsMaxAggregateOutputType | null
  }

  export type Rating_assetsAvgAggregateOutputType = {
    rating_assets_id: number | null
    rating_id: number | null
  }

  export type Rating_assetsSumAggregateOutputType = {
    rating_assets_id: number | null
    rating_id: bigint | null
  }

  export type Rating_assetsMinAggregateOutputType = {
    rating_assets_id: number | null
    rating_assets_image: string | null
    rating_assets_video: string | null
    rating_id: bigint | null
  }

  export type Rating_assetsMaxAggregateOutputType = {
    rating_assets_id: number | null
    rating_assets_image: string | null
    rating_assets_video: string | null
    rating_id: bigint | null
  }

  export type Rating_assetsCountAggregateOutputType = {
    rating_assets_id: number
    rating_assets_image: number
    rating_assets_video: number
    rating_id: number
    _all: number
  }


  export type Rating_assetsAvgAggregateInputType = {
    rating_assets_id?: true
    rating_id?: true
  }

  export type Rating_assetsSumAggregateInputType = {
    rating_assets_id?: true
    rating_id?: true
  }

  export type Rating_assetsMinAggregateInputType = {
    rating_assets_id?: true
    rating_assets_image?: true
    rating_assets_video?: true
    rating_id?: true
  }

  export type Rating_assetsMaxAggregateInputType = {
    rating_assets_id?: true
    rating_assets_image?: true
    rating_assets_video?: true
    rating_id?: true
  }

  export type Rating_assetsCountAggregateInputType = {
    rating_assets_id?: true
    rating_assets_image?: true
    rating_assets_video?: true
    rating_id?: true
    _all?: true
  }

  export type Rating_assetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating_assets to aggregate.
     */
    where?: rating_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_assets to fetch.
     */
    orderBy?: rating_assetsOrderByWithRelationInput | rating_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rating_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rating_assets
    **/
    _count?: true | Rating_assetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rating_assetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rating_assetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rating_assetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rating_assetsMaxAggregateInputType
  }

  export type GetRating_assetsAggregateType<T extends Rating_assetsAggregateArgs> = {
        [P in keyof T & keyof AggregateRating_assets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating_assets[P]>
      : GetScalarType<T[P], AggregateRating_assets[P]>
  }




  export type rating_assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rating_assetsWhereInput
    orderBy?: rating_assetsOrderByWithAggregationInput | rating_assetsOrderByWithAggregationInput[]
    by: Rating_assetsScalarFieldEnum[] | Rating_assetsScalarFieldEnum
    having?: rating_assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rating_assetsCountAggregateInputType | true
    _avg?: Rating_assetsAvgAggregateInputType
    _sum?: Rating_assetsSumAggregateInputType
    _min?: Rating_assetsMinAggregateInputType
    _max?: Rating_assetsMaxAggregateInputType
  }

  export type Rating_assetsGroupByOutputType = {
    rating_assets_id: number
    rating_assets_image: string | null
    rating_assets_video: string | null
    rating_id: bigint | null
    _count: Rating_assetsCountAggregateOutputType | null
    _avg: Rating_assetsAvgAggregateOutputType | null
    _sum: Rating_assetsSumAggregateOutputType | null
    _min: Rating_assetsMinAggregateOutputType | null
    _max: Rating_assetsMaxAggregateOutputType | null
  }

  type GetRating_assetsGroupByPayload<T extends rating_assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rating_assetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rating_assetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rating_assetsGroupByOutputType[P]>
            : GetScalarType<T[P], Rating_assetsGroupByOutputType[P]>
        }
      >
    >


  export type rating_assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    rating_assets_id?: boolean
    rating_assets_image?: boolean
    rating_assets_video?: boolean
    rating_id?: boolean
    rating?: boolean | rating_assets$ratingArgs<ExtArgs>
  }, ExtArgs["result"]["rating_assets"]>



  export type rating_assetsSelectScalar = {
    rating_assets_id?: boolean
    rating_assets_image?: boolean
    rating_assets_video?: boolean
    rating_id?: boolean
  }

  export type rating_assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"rating_assets_id" | "rating_assets_image" | "rating_assets_video" | "rating_id", ExtArgs["result"]["rating_assets"]>
  export type rating_assetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rating?: boolean | rating_assets$ratingArgs<ExtArgs>
  }

  export type $rating_assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rating_assets"
    objects: {
      rating: Prisma.$ratingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      rating_assets_id: number
      rating_assets_image: string | null
      rating_assets_video: string | null
      rating_id: bigint | null
    }, ExtArgs["result"]["rating_assets"]>
    composites: {}
  }

  type rating_assetsGetPayload<S extends boolean | null | undefined | rating_assetsDefaultArgs> = $Result.GetResult<Prisma.$rating_assetsPayload, S>

  type rating_assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rating_assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rating_assetsCountAggregateInputType | true
    }

  export interface rating_assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rating_assets'], meta: { name: 'rating_assets' } }
    /**
     * Find zero or one Rating_assets that matches the filter.
     * @param {rating_assetsFindUniqueArgs} args - Arguments to find a Rating_assets
     * @example
     * // Get one Rating_assets
     * const rating_assets = await prisma.rating_assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rating_assetsFindUniqueArgs>(args: SelectSubset<T, rating_assetsFindUniqueArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating_assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rating_assetsFindUniqueOrThrowArgs} args - Arguments to find a Rating_assets
     * @example
     * // Get one Rating_assets
     * const rating_assets = await prisma.rating_assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rating_assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, rating_assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_assetsFindFirstArgs} args - Arguments to find a Rating_assets
     * @example
     * // Get one Rating_assets
     * const rating_assets = await prisma.rating_assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rating_assetsFindFirstArgs>(args?: SelectSubset<T, rating_assetsFindFirstArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating_assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_assetsFindFirstOrThrowArgs} args - Arguments to find a Rating_assets
     * @example
     * // Get one Rating_assets
     * const rating_assets = await prisma.rating_assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rating_assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, rating_assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rating_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rating_assets
     * const rating_assets = await prisma.rating_assets.findMany()
     * 
     * // Get first 10 Rating_assets
     * const rating_assets = await prisma.rating_assets.findMany({ take: 10 })
     * 
     * // Only select the `rating_assets_id`
     * const rating_assetsWithRating_assets_idOnly = await prisma.rating_assets.findMany({ select: { rating_assets_id: true } })
     * 
     */
    findMany<T extends rating_assetsFindManyArgs>(args?: SelectSubset<T, rating_assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating_assets.
     * @param {rating_assetsCreateArgs} args - Arguments to create a Rating_assets.
     * @example
     * // Create one Rating_assets
     * const Rating_assets = await prisma.rating_assets.create({
     *   data: {
     *     // ... data to create a Rating_assets
     *   }
     * })
     * 
     */
    create<T extends rating_assetsCreateArgs>(args: SelectSubset<T, rating_assetsCreateArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rating_assets.
     * @param {rating_assetsCreateManyArgs} args - Arguments to create many Rating_assets.
     * @example
     * // Create many Rating_assets
     * const rating_assets = await prisma.rating_assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rating_assetsCreateManyArgs>(args?: SelectSubset<T, rating_assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating_assets.
     * @param {rating_assetsDeleteArgs} args - Arguments to delete one Rating_assets.
     * @example
     * // Delete one Rating_assets
     * const Rating_assets = await prisma.rating_assets.delete({
     *   where: {
     *     // ... filter to delete one Rating_assets
     *   }
     * })
     * 
     */
    delete<T extends rating_assetsDeleteArgs>(args: SelectSubset<T, rating_assetsDeleteArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating_assets.
     * @param {rating_assetsUpdateArgs} args - Arguments to update one Rating_assets.
     * @example
     * // Update one Rating_assets
     * const rating_assets = await prisma.rating_assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rating_assetsUpdateArgs>(args: SelectSubset<T, rating_assetsUpdateArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rating_assets.
     * @param {rating_assetsDeleteManyArgs} args - Arguments to filter Rating_assets to delete.
     * @example
     * // Delete a few Rating_assets
     * const { count } = await prisma.rating_assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rating_assetsDeleteManyArgs>(args?: SelectSubset<T, rating_assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rating_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rating_assets
     * const rating_assets = await prisma.rating_assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rating_assetsUpdateManyArgs>(args: SelectSubset<T, rating_assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating_assets.
     * @param {rating_assetsUpsertArgs} args - Arguments to update or create a Rating_assets.
     * @example
     * // Update or create a Rating_assets
     * const rating_assets = await prisma.rating_assets.upsert({
     *   create: {
     *     // ... data to create a Rating_assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating_assets we want to update
     *   }
     * })
     */
    upsert<T extends rating_assetsUpsertArgs>(args: SelectSubset<T, rating_assetsUpsertArgs<ExtArgs>>): Prisma__rating_assetsClient<$Result.GetResult<Prisma.$rating_assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rating_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_assetsCountArgs} args - Arguments to filter Rating_assets to count.
     * @example
     * // Count the number of Rating_assets
     * const count = await prisma.rating_assets.count({
     *   where: {
     *     // ... the filter for the Rating_assets we want to count
     *   }
     * })
    **/
    count<T extends rating_assetsCountArgs>(
      args?: Subset<T, rating_assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rating_assetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rating_assetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rating_assetsAggregateArgs>(args: Subset<T, Rating_assetsAggregateArgs>): Prisma.PrismaPromise<GetRating_assetsAggregateType<T>>

    /**
     * Group by Rating_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rating_assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rating_assetsGroupByArgs['orderBy'] }
        : { orderBy?: rating_assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rating_assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRating_assetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rating_assets model
   */
  readonly fields: rating_assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rating_assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rating_assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rating<T extends rating_assets$ratingArgs<ExtArgs> = {}>(args?: Subset<T, rating_assets$ratingArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rating_assets model
   */
  interface rating_assetsFieldRefs {
    readonly rating_assets_id: FieldRef<"rating_assets", 'Int'>
    readonly rating_assets_image: FieldRef<"rating_assets", 'String'>
    readonly rating_assets_video: FieldRef<"rating_assets", 'String'>
    readonly rating_id: FieldRef<"rating_assets", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * rating_assets findUnique
   */
  export type rating_assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * Filter, which rating_assets to fetch.
     */
    where: rating_assetsWhereUniqueInput
  }

  /**
   * rating_assets findUniqueOrThrow
   */
  export type rating_assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * Filter, which rating_assets to fetch.
     */
    where: rating_assetsWhereUniqueInput
  }

  /**
   * rating_assets findFirst
   */
  export type rating_assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * Filter, which rating_assets to fetch.
     */
    where?: rating_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_assets to fetch.
     */
    orderBy?: rating_assetsOrderByWithRelationInput | rating_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_assets.
     */
    cursor?: rating_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_assets.
     */
    distinct?: Rating_assetsScalarFieldEnum | Rating_assetsScalarFieldEnum[]
  }

  /**
   * rating_assets findFirstOrThrow
   */
  export type rating_assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * Filter, which rating_assets to fetch.
     */
    where?: rating_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_assets to fetch.
     */
    orderBy?: rating_assetsOrderByWithRelationInput | rating_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_assets.
     */
    cursor?: rating_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_assets.
     */
    distinct?: Rating_assetsScalarFieldEnum | Rating_assetsScalarFieldEnum[]
  }

  /**
   * rating_assets findMany
   */
  export type rating_assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * Filter, which rating_assets to fetch.
     */
    where?: rating_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_assets to fetch.
     */
    orderBy?: rating_assetsOrderByWithRelationInput | rating_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rating_assets.
     */
    cursor?: rating_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_assets.
     */
    skip?: number
    distinct?: Rating_assetsScalarFieldEnum | Rating_assetsScalarFieldEnum[]
  }

  /**
   * rating_assets create
   */
  export type rating_assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * The data needed to create a rating_assets.
     */
    data?: XOR<rating_assetsCreateInput, rating_assetsUncheckedCreateInput>
  }

  /**
   * rating_assets createMany
   */
  export type rating_assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rating_assets.
     */
    data: rating_assetsCreateManyInput | rating_assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rating_assets update
   */
  export type rating_assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * The data needed to update a rating_assets.
     */
    data: XOR<rating_assetsUpdateInput, rating_assetsUncheckedUpdateInput>
    /**
     * Choose, which rating_assets to update.
     */
    where: rating_assetsWhereUniqueInput
  }

  /**
   * rating_assets updateMany
   */
  export type rating_assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rating_assets.
     */
    data: XOR<rating_assetsUpdateManyMutationInput, rating_assetsUncheckedUpdateManyInput>
    /**
     * Filter which rating_assets to update
     */
    where?: rating_assetsWhereInput
    /**
     * Limit how many rating_assets to update.
     */
    limit?: number
  }

  /**
   * rating_assets upsert
   */
  export type rating_assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * The filter to search for the rating_assets to update in case it exists.
     */
    where: rating_assetsWhereUniqueInput
    /**
     * In case the rating_assets found by the `where` argument doesn't exist, create a new rating_assets with this data.
     */
    create: XOR<rating_assetsCreateInput, rating_assetsUncheckedCreateInput>
    /**
     * In case the rating_assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rating_assetsUpdateInput, rating_assetsUncheckedUpdateInput>
  }

  /**
   * rating_assets delete
   */
  export type rating_assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
    /**
     * Filter which rating_assets to delete.
     */
    where: rating_assetsWhereUniqueInput
  }

  /**
   * rating_assets deleteMany
   */
  export type rating_assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating_assets to delete
     */
    where?: rating_assetsWhereInput
    /**
     * Limit how many rating_assets to delete.
     */
    limit?: number
  }

  /**
   * rating_assets.rating
   */
  export type rating_assets$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
  }

  /**
   * rating_assets without action
   */
  export type rating_assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_assets
     */
    select?: rating_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_assets
     */
    omit?: rating_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rating_assetsInclude<ExtArgs> | null
  }


  /**
   * Model rating_qr_code_sessions
   */

  export type AggregateRating_qr_code_sessions = {
    _count: Rating_qr_code_sessionsCountAggregateOutputType | null
    _avg: Rating_qr_code_sessionsAvgAggregateOutputType | null
    _sum: Rating_qr_code_sessionsSumAggregateOutputType | null
    _min: Rating_qr_code_sessionsMinAggregateOutputType | null
    _max: Rating_qr_code_sessionsMaxAggregateOutputType | null
  }

  export type Rating_qr_code_sessionsAvgAggregateOutputType = {
    id: number | null
  }

  export type Rating_qr_code_sessionsSumAggregateOutputType = {
    id: number | null
  }

  export type Rating_qr_code_sessionsMinAggregateOutputType = {
    id: number | null
    institution_uuid: string | null
    service_uuid: string | null
    user_agent: string | null
    finger_print: string | null
    ip_address: string | null
    session_token: string | null
    session_expiration: Date | null
    status: $Enums.rating_qr_code_sessions_status | null
    created_at: Date | null
  }

  export type Rating_qr_code_sessionsMaxAggregateOutputType = {
    id: number | null
    institution_uuid: string | null
    service_uuid: string | null
    user_agent: string | null
    finger_print: string | null
    ip_address: string | null
    session_token: string | null
    session_expiration: Date | null
    status: $Enums.rating_qr_code_sessions_status | null
    created_at: Date | null
  }

  export type Rating_qr_code_sessionsCountAggregateOutputType = {
    id: number
    institution_uuid: number
    service_uuid: number
    user_agent: number
    finger_print: number
    ip_address: number
    session_token: number
    session_expiration: number
    status: number
    created_at: number
    _all: number
  }


  export type Rating_qr_code_sessionsAvgAggregateInputType = {
    id?: true
  }

  export type Rating_qr_code_sessionsSumAggregateInputType = {
    id?: true
  }

  export type Rating_qr_code_sessionsMinAggregateInputType = {
    id?: true
    institution_uuid?: true
    service_uuid?: true
    user_agent?: true
    finger_print?: true
    ip_address?: true
    session_token?: true
    session_expiration?: true
    status?: true
    created_at?: true
  }

  export type Rating_qr_code_sessionsMaxAggregateInputType = {
    id?: true
    institution_uuid?: true
    service_uuid?: true
    user_agent?: true
    finger_print?: true
    ip_address?: true
    session_token?: true
    session_expiration?: true
    status?: true
    created_at?: true
  }

  export type Rating_qr_code_sessionsCountAggregateInputType = {
    id?: true
    institution_uuid?: true
    service_uuid?: true
    user_agent?: true
    finger_print?: true
    ip_address?: true
    session_token?: true
    session_expiration?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Rating_qr_code_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating_qr_code_sessions to aggregate.
     */
    where?: rating_qr_code_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_qr_code_sessions to fetch.
     */
    orderBy?: rating_qr_code_sessionsOrderByWithRelationInput | rating_qr_code_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rating_qr_code_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_qr_code_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_qr_code_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rating_qr_code_sessions
    **/
    _count?: true | Rating_qr_code_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rating_qr_code_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rating_qr_code_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rating_qr_code_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rating_qr_code_sessionsMaxAggregateInputType
  }

  export type GetRating_qr_code_sessionsAggregateType<T extends Rating_qr_code_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRating_qr_code_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating_qr_code_sessions[P]>
      : GetScalarType<T[P], AggregateRating_qr_code_sessions[P]>
  }




  export type rating_qr_code_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rating_qr_code_sessionsWhereInput
    orderBy?: rating_qr_code_sessionsOrderByWithAggregationInput | rating_qr_code_sessionsOrderByWithAggregationInput[]
    by: Rating_qr_code_sessionsScalarFieldEnum[] | Rating_qr_code_sessionsScalarFieldEnum
    having?: rating_qr_code_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rating_qr_code_sessionsCountAggregateInputType | true
    _avg?: Rating_qr_code_sessionsAvgAggregateInputType
    _sum?: Rating_qr_code_sessionsSumAggregateInputType
    _min?: Rating_qr_code_sessionsMinAggregateInputType
    _max?: Rating_qr_code_sessionsMaxAggregateInputType
  }

  export type Rating_qr_code_sessionsGroupByOutputType = {
    id: number
    institution_uuid: string | null
    service_uuid: string | null
    user_agent: string
    finger_print: string
    ip_address: string
    session_token: string
    session_expiration: Date
    status: $Enums.rating_qr_code_sessions_status
    created_at: Date
    _count: Rating_qr_code_sessionsCountAggregateOutputType | null
    _avg: Rating_qr_code_sessionsAvgAggregateOutputType | null
    _sum: Rating_qr_code_sessionsSumAggregateOutputType | null
    _min: Rating_qr_code_sessionsMinAggregateOutputType | null
    _max: Rating_qr_code_sessionsMaxAggregateOutputType | null
  }

  type GetRating_qr_code_sessionsGroupByPayload<T extends rating_qr_code_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rating_qr_code_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rating_qr_code_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rating_qr_code_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Rating_qr_code_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type rating_qr_code_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution_uuid?: boolean
    service_uuid?: boolean
    user_agent?: boolean
    finger_print?: boolean
    ip_address?: boolean
    session_token?: boolean
    session_expiration?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["rating_qr_code_sessions"]>



  export type rating_qr_code_sessionsSelectScalar = {
    id?: boolean
    institution_uuid?: boolean
    service_uuid?: boolean
    user_agent?: boolean
    finger_print?: boolean
    ip_address?: boolean
    session_token?: boolean
    session_expiration?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type rating_qr_code_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution_uuid" | "service_uuid" | "user_agent" | "finger_print" | "ip_address" | "session_token" | "session_expiration" | "status" | "created_at", ExtArgs["result"]["rating_qr_code_sessions"]>

  export type $rating_qr_code_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rating_qr_code_sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institution_uuid: string | null
      service_uuid: string | null
      user_agent: string
      finger_print: string
      ip_address: string
      session_token: string
      session_expiration: Date
      status: $Enums.rating_qr_code_sessions_status
      created_at: Date
    }, ExtArgs["result"]["rating_qr_code_sessions"]>
    composites: {}
  }

  type rating_qr_code_sessionsGetPayload<S extends boolean | null | undefined | rating_qr_code_sessionsDefaultArgs> = $Result.GetResult<Prisma.$rating_qr_code_sessionsPayload, S>

  type rating_qr_code_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rating_qr_code_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rating_qr_code_sessionsCountAggregateInputType | true
    }

  export interface rating_qr_code_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rating_qr_code_sessions'], meta: { name: 'rating_qr_code_sessions' } }
    /**
     * Find zero or one Rating_qr_code_sessions that matches the filter.
     * @param {rating_qr_code_sessionsFindUniqueArgs} args - Arguments to find a Rating_qr_code_sessions
     * @example
     * // Get one Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rating_qr_code_sessionsFindUniqueArgs>(args: SelectSubset<T, rating_qr_code_sessionsFindUniqueArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating_qr_code_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rating_qr_code_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Rating_qr_code_sessions
     * @example
     * // Get one Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rating_qr_code_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, rating_qr_code_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating_qr_code_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_qr_code_sessionsFindFirstArgs} args - Arguments to find a Rating_qr_code_sessions
     * @example
     * // Get one Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rating_qr_code_sessionsFindFirstArgs>(args?: SelectSubset<T, rating_qr_code_sessionsFindFirstArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating_qr_code_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_qr_code_sessionsFindFirstOrThrowArgs} args - Arguments to find a Rating_qr_code_sessions
     * @example
     * // Get one Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rating_qr_code_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, rating_qr_code_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rating_qr_code_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_qr_code_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findMany()
     * 
     * // Get first 10 Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rating_qr_code_sessionsWithIdOnly = await prisma.rating_qr_code_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rating_qr_code_sessionsFindManyArgs>(args?: SelectSubset<T, rating_qr_code_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating_qr_code_sessions.
     * @param {rating_qr_code_sessionsCreateArgs} args - Arguments to create a Rating_qr_code_sessions.
     * @example
     * // Create one Rating_qr_code_sessions
     * const Rating_qr_code_sessions = await prisma.rating_qr_code_sessions.create({
     *   data: {
     *     // ... data to create a Rating_qr_code_sessions
     *   }
     * })
     * 
     */
    create<T extends rating_qr_code_sessionsCreateArgs>(args: SelectSubset<T, rating_qr_code_sessionsCreateArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rating_qr_code_sessions.
     * @param {rating_qr_code_sessionsCreateManyArgs} args - Arguments to create many Rating_qr_code_sessions.
     * @example
     * // Create many Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rating_qr_code_sessionsCreateManyArgs>(args?: SelectSubset<T, rating_qr_code_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating_qr_code_sessions.
     * @param {rating_qr_code_sessionsDeleteArgs} args - Arguments to delete one Rating_qr_code_sessions.
     * @example
     * // Delete one Rating_qr_code_sessions
     * const Rating_qr_code_sessions = await prisma.rating_qr_code_sessions.delete({
     *   where: {
     *     // ... filter to delete one Rating_qr_code_sessions
     *   }
     * })
     * 
     */
    delete<T extends rating_qr_code_sessionsDeleteArgs>(args: SelectSubset<T, rating_qr_code_sessionsDeleteArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating_qr_code_sessions.
     * @param {rating_qr_code_sessionsUpdateArgs} args - Arguments to update one Rating_qr_code_sessions.
     * @example
     * // Update one Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rating_qr_code_sessionsUpdateArgs>(args: SelectSubset<T, rating_qr_code_sessionsUpdateArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rating_qr_code_sessions.
     * @param {rating_qr_code_sessionsDeleteManyArgs} args - Arguments to filter Rating_qr_code_sessions to delete.
     * @example
     * // Delete a few Rating_qr_code_sessions
     * const { count } = await prisma.rating_qr_code_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rating_qr_code_sessionsDeleteManyArgs>(args?: SelectSubset<T, rating_qr_code_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rating_qr_code_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_qr_code_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rating_qr_code_sessionsUpdateManyArgs>(args: SelectSubset<T, rating_qr_code_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating_qr_code_sessions.
     * @param {rating_qr_code_sessionsUpsertArgs} args - Arguments to update or create a Rating_qr_code_sessions.
     * @example
     * // Update or create a Rating_qr_code_sessions
     * const rating_qr_code_sessions = await prisma.rating_qr_code_sessions.upsert({
     *   create: {
     *     // ... data to create a Rating_qr_code_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating_qr_code_sessions we want to update
     *   }
     * })
     */
    upsert<T extends rating_qr_code_sessionsUpsertArgs>(args: SelectSubset<T, rating_qr_code_sessionsUpsertArgs<ExtArgs>>): Prisma__rating_qr_code_sessionsClient<$Result.GetResult<Prisma.$rating_qr_code_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rating_qr_code_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_qr_code_sessionsCountArgs} args - Arguments to filter Rating_qr_code_sessions to count.
     * @example
     * // Count the number of Rating_qr_code_sessions
     * const count = await prisma.rating_qr_code_sessions.count({
     *   where: {
     *     // ... the filter for the Rating_qr_code_sessions we want to count
     *   }
     * })
    **/
    count<T extends rating_qr_code_sessionsCountArgs>(
      args?: Subset<T, rating_qr_code_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rating_qr_code_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating_qr_code_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rating_qr_code_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rating_qr_code_sessionsAggregateArgs>(args: Subset<T, Rating_qr_code_sessionsAggregateArgs>): Prisma.PrismaPromise<GetRating_qr_code_sessionsAggregateType<T>>

    /**
     * Group by Rating_qr_code_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_qr_code_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rating_qr_code_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rating_qr_code_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: rating_qr_code_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rating_qr_code_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRating_qr_code_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rating_qr_code_sessions model
   */
  readonly fields: rating_qr_code_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rating_qr_code_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rating_qr_code_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rating_qr_code_sessions model
   */
  interface rating_qr_code_sessionsFieldRefs {
    readonly id: FieldRef<"rating_qr_code_sessions", 'Int'>
    readonly institution_uuid: FieldRef<"rating_qr_code_sessions", 'String'>
    readonly service_uuid: FieldRef<"rating_qr_code_sessions", 'String'>
    readonly user_agent: FieldRef<"rating_qr_code_sessions", 'String'>
    readonly finger_print: FieldRef<"rating_qr_code_sessions", 'String'>
    readonly ip_address: FieldRef<"rating_qr_code_sessions", 'String'>
    readonly session_token: FieldRef<"rating_qr_code_sessions", 'String'>
    readonly session_expiration: FieldRef<"rating_qr_code_sessions", 'DateTime'>
    readonly status: FieldRef<"rating_qr_code_sessions", 'rating_qr_code_sessions_status'>
    readonly created_at: FieldRef<"rating_qr_code_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rating_qr_code_sessions findUnique
   */
  export type rating_qr_code_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which rating_qr_code_sessions to fetch.
     */
    where: rating_qr_code_sessionsWhereUniqueInput
  }

  /**
   * rating_qr_code_sessions findUniqueOrThrow
   */
  export type rating_qr_code_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which rating_qr_code_sessions to fetch.
     */
    where: rating_qr_code_sessionsWhereUniqueInput
  }

  /**
   * rating_qr_code_sessions findFirst
   */
  export type rating_qr_code_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which rating_qr_code_sessions to fetch.
     */
    where?: rating_qr_code_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_qr_code_sessions to fetch.
     */
    orderBy?: rating_qr_code_sessionsOrderByWithRelationInput | rating_qr_code_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_qr_code_sessions.
     */
    cursor?: rating_qr_code_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_qr_code_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_qr_code_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_qr_code_sessions.
     */
    distinct?: Rating_qr_code_sessionsScalarFieldEnum | Rating_qr_code_sessionsScalarFieldEnum[]
  }

  /**
   * rating_qr_code_sessions findFirstOrThrow
   */
  export type rating_qr_code_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which rating_qr_code_sessions to fetch.
     */
    where?: rating_qr_code_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_qr_code_sessions to fetch.
     */
    orderBy?: rating_qr_code_sessionsOrderByWithRelationInput | rating_qr_code_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_qr_code_sessions.
     */
    cursor?: rating_qr_code_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_qr_code_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_qr_code_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_qr_code_sessions.
     */
    distinct?: Rating_qr_code_sessionsScalarFieldEnum | Rating_qr_code_sessionsScalarFieldEnum[]
  }

  /**
   * rating_qr_code_sessions findMany
   */
  export type rating_qr_code_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * Filter, which rating_qr_code_sessions to fetch.
     */
    where?: rating_qr_code_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_qr_code_sessions to fetch.
     */
    orderBy?: rating_qr_code_sessionsOrderByWithRelationInput | rating_qr_code_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rating_qr_code_sessions.
     */
    cursor?: rating_qr_code_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_qr_code_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_qr_code_sessions.
     */
    skip?: number
    distinct?: Rating_qr_code_sessionsScalarFieldEnum | Rating_qr_code_sessionsScalarFieldEnum[]
  }

  /**
   * rating_qr_code_sessions create
   */
  export type rating_qr_code_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a rating_qr_code_sessions.
     */
    data: XOR<rating_qr_code_sessionsCreateInput, rating_qr_code_sessionsUncheckedCreateInput>
  }

  /**
   * rating_qr_code_sessions createMany
   */
  export type rating_qr_code_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rating_qr_code_sessions.
     */
    data: rating_qr_code_sessionsCreateManyInput | rating_qr_code_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rating_qr_code_sessions update
   */
  export type rating_qr_code_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a rating_qr_code_sessions.
     */
    data: XOR<rating_qr_code_sessionsUpdateInput, rating_qr_code_sessionsUncheckedUpdateInput>
    /**
     * Choose, which rating_qr_code_sessions to update.
     */
    where: rating_qr_code_sessionsWhereUniqueInput
  }

  /**
   * rating_qr_code_sessions updateMany
   */
  export type rating_qr_code_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rating_qr_code_sessions.
     */
    data: XOR<rating_qr_code_sessionsUpdateManyMutationInput, rating_qr_code_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which rating_qr_code_sessions to update
     */
    where?: rating_qr_code_sessionsWhereInput
    /**
     * Limit how many rating_qr_code_sessions to update.
     */
    limit?: number
  }

  /**
   * rating_qr_code_sessions upsert
   */
  export type rating_qr_code_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the rating_qr_code_sessions to update in case it exists.
     */
    where: rating_qr_code_sessionsWhereUniqueInput
    /**
     * In case the rating_qr_code_sessions found by the `where` argument doesn't exist, create a new rating_qr_code_sessions with this data.
     */
    create: XOR<rating_qr_code_sessionsCreateInput, rating_qr_code_sessionsUncheckedCreateInput>
    /**
     * In case the rating_qr_code_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rating_qr_code_sessionsUpdateInput, rating_qr_code_sessionsUncheckedUpdateInput>
  }

  /**
   * rating_qr_code_sessions delete
   */
  export type rating_qr_code_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
    /**
     * Filter which rating_qr_code_sessions to delete.
     */
    where: rating_qr_code_sessionsWhereUniqueInput
  }

  /**
   * rating_qr_code_sessions deleteMany
   */
  export type rating_qr_code_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating_qr_code_sessions to delete
     */
    where?: rating_qr_code_sessionsWhereInput
    /**
     * Limit how many rating_qr_code_sessions to delete.
     */
    limit?: number
  }

  /**
   * rating_qr_code_sessions without action
   */
  export type rating_qr_code_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_qr_code_sessions
     */
    select?: rating_qr_code_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_qr_code_sessions
     */
    omit?: rating_qr_code_sessionsOmit<ExtArgs> | null
  }


  /**
   * Model rating_reply
   */

  export type AggregateRating_reply = {
    _count: Rating_replyCountAggregateOutputType | null
    _avg: Rating_replyAvgAggregateOutputType | null
    _sum: Rating_replySumAggregateOutputType | null
    _min: Rating_replyMinAggregateOutputType | null
    _max: Rating_replyMaxAggregateOutputType | null
  }

  export type Rating_replyAvgAggregateOutputType = {
    id: number | null
    rating_id: number | null
  }

  export type Rating_replySumAggregateOutputType = {
    id: number | null
    rating_id: number | null
  }

  export type Rating_replyMinAggregateOutputType = {
    id: number | null
    specific: boolean | null
    rating_id: number | null
    time: Date | null
    reply: string | null
  }

  export type Rating_replyMaxAggregateOutputType = {
    id: number | null
    specific: boolean | null
    rating_id: number | null
    time: Date | null
    reply: string | null
  }

  export type Rating_replyCountAggregateOutputType = {
    id: number
    specific: number
    rating_id: number
    time: number
    reply: number
    _all: number
  }


  export type Rating_replyAvgAggregateInputType = {
    id?: true
    rating_id?: true
  }

  export type Rating_replySumAggregateInputType = {
    id?: true
    rating_id?: true
  }

  export type Rating_replyMinAggregateInputType = {
    id?: true
    specific?: true
    rating_id?: true
    time?: true
    reply?: true
  }

  export type Rating_replyMaxAggregateInputType = {
    id?: true
    specific?: true
    rating_id?: true
    time?: true
    reply?: true
  }

  export type Rating_replyCountAggregateInputType = {
    id?: true
    specific?: true
    rating_id?: true
    time?: true
    reply?: true
    _all?: true
  }

  export type Rating_replyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating_reply to aggregate.
     */
    where?: rating_replyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_replies to fetch.
     */
    orderBy?: rating_replyOrderByWithRelationInput | rating_replyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rating_replyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rating_replies
    **/
    _count?: true | Rating_replyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rating_replyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rating_replySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rating_replyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rating_replyMaxAggregateInputType
  }

  export type GetRating_replyAggregateType<T extends Rating_replyAggregateArgs> = {
        [P in keyof T & keyof AggregateRating_reply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating_reply[P]>
      : GetScalarType<T[P], AggregateRating_reply[P]>
  }




  export type rating_replyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rating_replyWhereInput
    orderBy?: rating_replyOrderByWithAggregationInput | rating_replyOrderByWithAggregationInput[]
    by: Rating_replyScalarFieldEnum[] | Rating_replyScalarFieldEnum
    having?: rating_replyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rating_replyCountAggregateInputType | true
    _avg?: Rating_replyAvgAggregateInputType
    _sum?: Rating_replySumAggregateInputType
    _min?: Rating_replyMinAggregateInputType
    _max?: Rating_replyMaxAggregateInputType
  }

  export type Rating_replyGroupByOutputType = {
    id: number
    specific: boolean | null
    rating_id: number | null
    time: Date | null
    reply: string | null
    _count: Rating_replyCountAggregateOutputType | null
    _avg: Rating_replyAvgAggregateOutputType | null
    _sum: Rating_replySumAggregateOutputType | null
    _min: Rating_replyMinAggregateOutputType | null
    _max: Rating_replyMaxAggregateOutputType | null
  }

  type GetRating_replyGroupByPayload<T extends rating_replyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rating_replyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rating_replyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rating_replyGroupByOutputType[P]>
            : GetScalarType<T[P], Rating_replyGroupByOutputType[P]>
        }
      >
    >


  export type rating_replySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specific?: boolean
    rating_id?: boolean
    time?: boolean
    reply?: boolean
  }, ExtArgs["result"]["rating_reply"]>



  export type rating_replySelectScalar = {
    id?: boolean
    specific?: boolean
    rating_id?: boolean
    time?: boolean
    reply?: boolean
  }

  export type rating_replyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "specific" | "rating_id" | "time" | "reply", ExtArgs["result"]["rating_reply"]>

  export type $rating_replyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rating_reply"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      specific: boolean | null
      rating_id: number | null
      time: Date | null
      reply: string | null
    }, ExtArgs["result"]["rating_reply"]>
    composites: {}
  }

  type rating_replyGetPayload<S extends boolean | null | undefined | rating_replyDefaultArgs> = $Result.GetResult<Prisma.$rating_replyPayload, S>

  type rating_replyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rating_replyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rating_replyCountAggregateInputType | true
    }

  export interface rating_replyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rating_reply'], meta: { name: 'rating_reply' } }
    /**
     * Find zero or one Rating_reply that matches the filter.
     * @param {rating_replyFindUniqueArgs} args - Arguments to find a Rating_reply
     * @example
     * // Get one Rating_reply
     * const rating_reply = await prisma.rating_reply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rating_replyFindUniqueArgs>(args: SelectSubset<T, rating_replyFindUniqueArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating_reply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rating_replyFindUniqueOrThrowArgs} args - Arguments to find a Rating_reply
     * @example
     * // Get one Rating_reply
     * const rating_reply = await prisma.rating_reply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rating_replyFindUniqueOrThrowArgs>(args: SelectSubset<T, rating_replyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating_reply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_replyFindFirstArgs} args - Arguments to find a Rating_reply
     * @example
     * // Get one Rating_reply
     * const rating_reply = await prisma.rating_reply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rating_replyFindFirstArgs>(args?: SelectSubset<T, rating_replyFindFirstArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating_reply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_replyFindFirstOrThrowArgs} args - Arguments to find a Rating_reply
     * @example
     * // Get one Rating_reply
     * const rating_reply = await prisma.rating_reply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rating_replyFindFirstOrThrowArgs>(args?: SelectSubset<T, rating_replyFindFirstOrThrowArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rating_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_replyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rating_replies
     * const rating_replies = await prisma.rating_reply.findMany()
     * 
     * // Get first 10 Rating_replies
     * const rating_replies = await prisma.rating_reply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rating_replyWithIdOnly = await prisma.rating_reply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rating_replyFindManyArgs>(args?: SelectSubset<T, rating_replyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating_reply.
     * @param {rating_replyCreateArgs} args - Arguments to create a Rating_reply.
     * @example
     * // Create one Rating_reply
     * const Rating_reply = await prisma.rating_reply.create({
     *   data: {
     *     // ... data to create a Rating_reply
     *   }
     * })
     * 
     */
    create<T extends rating_replyCreateArgs>(args: SelectSubset<T, rating_replyCreateArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rating_replies.
     * @param {rating_replyCreateManyArgs} args - Arguments to create many Rating_replies.
     * @example
     * // Create many Rating_replies
     * const rating_reply = await prisma.rating_reply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rating_replyCreateManyArgs>(args?: SelectSubset<T, rating_replyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating_reply.
     * @param {rating_replyDeleteArgs} args - Arguments to delete one Rating_reply.
     * @example
     * // Delete one Rating_reply
     * const Rating_reply = await prisma.rating_reply.delete({
     *   where: {
     *     // ... filter to delete one Rating_reply
     *   }
     * })
     * 
     */
    delete<T extends rating_replyDeleteArgs>(args: SelectSubset<T, rating_replyDeleteArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating_reply.
     * @param {rating_replyUpdateArgs} args - Arguments to update one Rating_reply.
     * @example
     * // Update one Rating_reply
     * const rating_reply = await prisma.rating_reply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rating_replyUpdateArgs>(args: SelectSubset<T, rating_replyUpdateArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rating_replies.
     * @param {rating_replyDeleteManyArgs} args - Arguments to filter Rating_replies to delete.
     * @example
     * // Delete a few Rating_replies
     * const { count } = await prisma.rating_reply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rating_replyDeleteManyArgs>(args?: SelectSubset<T, rating_replyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rating_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_replyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rating_replies
     * const rating_reply = await prisma.rating_reply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rating_replyUpdateManyArgs>(args: SelectSubset<T, rating_replyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating_reply.
     * @param {rating_replyUpsertArgs} args - Arguments to update or create a Rating_reply.
     * @example
     * // Update or create a Rating_reply
     * const rating_reply = await prisma.rating_reply.upsert({
     *   create: {
     *     // ... data to create a Rating_reply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating_reply we want to update
     *   }
     * })
     */
    upsert<T extends rating_replyUpsertArgs>(args: SelectSubset<T, rating_replyUpsertArgs<ExtArgs>>): Prisma__rating_replyClient<$Result.GetResult<Prisma.$rating_replyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rating_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_replyCountArgs} args - Arguments to filter Rating_replies to count.
     * @example
     * // Count the number of Rating_replies
     * const count = await prisma.rating_reply.count({
     *   where: {
     *     // ... the filter for the Rating_replies we want to count
     *   }
     * })
    **/
    count<T extends rating_replyCountArgs>(
      args?: Subset<T, rating_replyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rating_replyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating_reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rating_replyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rating_replyAggregateArgs>(args: Subset<T, Rating_replyAggregateArgs>): Prisma.PrismaPromise<GetRating_replyAggregateType<T>>

    /**
     * Group by Rating_reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rating_replyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rating_replyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rating_replyGroupByArgs['orderBy'] }
        : { orderBy?: rating_replyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rating_replyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRating_replyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rating_reply model
   */
  readonly fields: rating_replyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rating_reply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rating_replyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rating_reply model
   */
  interface rating_replyFieldRefs {
    readonly id: FieldRef<"rating_reply", 'Int'>
    readonly specific: FieldRef<"rating_reply", 'Boolean'>
    readonly rating_id: FieldRef<"rating_reply", 'Int'>
    readonly time: FieldRef<"rating_reply", 'DateTime'>
    readonly reply: FieldRef<"rating_reply", 'String'>
  }
    

  // Custom InputTypes
  /**
   * rating_reply findUnique
   */
  export type rating_replyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * Filter, which rating_reply to fetch.
     */
    where: rating_replyWhereUniqueInput
  }

  /**
   * rating_reply findUniqueOrThrow
   */
  export type rating_replyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * Filter, which rating_reply to fetch.
     */
    where: rating_replyWhereUniqueInput
  }

  /**
   * rating_reply findFirst
   */
  export type rating_replyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * Filter, which rating_reply to fetch.
     */
    where?: rating_replyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_replies to fetch.
     */
    orderBy?: rating_replyOrderByWithRelationInput | rating_replyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_replies.
     */
    cursor?: rating_replyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_replies.
     */
    distinct?: Rating_replyScalarFieldEnum | Rating_replyScalarFieldEnum[]
  }

  /**
   * rating_reply findFirstOrThrow
   */
  export type rating_replyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * Filter, which rating_reply to fetch.
     */
    where?: rating_replyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_replies to fetch.
     */
    orderBy?: rating_replyOrderByWithRelationInput | rating_replyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rating_replies.
     */
    cursor?: rating_replyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rating_replies.
     */
    distinct?: Rating_replyScalarFieldEnum | Rating_replyScalarFieldEnum[]
  }

  /**
   * rating_reply findMany
   */
  export type rating_replyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * Filter, which rating_replies to fetch.
     */
    where?: rating_replyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rating_replies to fetch.
     */
    orderBy?: rating_replyOrderByWithRelationInput | rating_replyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rating_replies.
     */
    cursor?: rating_replyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rating_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rating_replies.
     */
    skip?: number
    distinct?: Rating_replyScalarFieldEnum | Rating_replyScalarFieldEnum[]
  }

  /**
   * rating_reply create
   */
  export type rating_replyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * The data needed to create a rating_reply.
     */
    data?: XOR<rating_replyCreateInput, rating_replyUncheckedCreateInput>
  }

  /**
   * rating_reply createMany
   */
  export type rating_replyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rating_replies.
     */
    data: rating_replyCreateManyInput | rating_replyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rating_reply update
   */
  export type rating_replyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * The data needed to update a rating_reply.
     */
    data: XOR<rating_replyUpdateInput, rating_replyUncheckedUpdateInput>
    /**
     * Choose, which rating_reply to update.
     */
    where: rating_replyWhereUniqueInput
  }

  /**
   * rating_reply updateMany
   */
  export type rating_replyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rating_replies.
     */
    data: XOR<rating_replyUpdateManyMutationInput, rating_replyUncheckedUpdateManyInput>
    /**
     * Filter which rating_replies to update
     */
    where?: rating_replyWhereInput
    /**
     * Limit how many rating_replies to update.
     */
    limit?: number
  }

  /**
   * rating_reply upsert
   */
  export type rating_replyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * The filter to search for the rating_reply to update in case it exists.
     */
    where: rating_replyWhereUniqueInput
    /**
     * In case the rating_reply found by the `where` argument doesn't exist, create a new rating_reply with this data.
     */
    create: XOR<rating_replyCreateInput, rating_replyUncheckedCreateInput>
    /**
     * In case the rating_reply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rating_replyUpdateInput, rating_replyUncheckedUpdateInput>
  }

  /**
   * rating_reply delete
   */
  export type rating_replyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
    /**
     * Filter which rating_reply to delete.
     */
    where: rating_replyWhereUniqueInput
  }

  /**
   * rating_reply deleteMany
   */
  export type rating_replyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rating_replies to delete
     */
    where?: rating_replyWhereInput
    /**
     * Limit how many rating_replies to delete.
     */
    limit?: number
  }

  /**
   * rating_reply without action
   */
  export type rating_replyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating_reply
     */
    select?: rating_replySelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating_reply
     */
    omit?: rating_replyOmit<ExtArgs> | null
  }


  /**
   * Model reports
   */

  export type AggregateReports = {
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  export type ReportsAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    report_created_by: number | null
    status: number | null
  }

  export type ReportsSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    report_created_by: number | null
    status: number | null
  }

  export type ReportsMinAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    institution_id: number | null
    service_ids: string | null
    start_date: Date | null
    end_date: Date | null
    report_created_by: number | null
    report_institution_id: string | null
    report_recipient: string | null
    report_queue_uuid: string | null
    report_content_key: string | null
    status: number | null
    created_at: Date | null
  }

  export type ReportsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    institution_id: number | null
    service_ids: string | null
    start_date: Date | null
    end_date: Date | null
    report_created_by: number | null
    report_institution_id: string | null
    report_recipient: string | null
    report_queue_uuid: string | null
    report_content_key: string | null
    status: number | null
    created_at: Date | null
  }

  export type ReportsCountAggregateOutputType = {
    id: number
    title: number
    type: number
    institution_id: number
    service_ids: number
    start_date: number
    end_date: number
    report_created_by: number
    report_institution_id: number
    report_recipient: number
    report_queue_uuid: number
    report_content_key: number
    status: number
    created_at: number
    _all: number
  }


  export type ReportsAvgAggregateInputType = {
    id?: true
    institution_id?: true
    report_created_by?: true
    status?: true
  }

  export type ReportsSumAggregateInputType = {
    id?: true
    institution_id?: true
    report_created_by?: true
    status?: true
  }

  export type ReportsMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    institution_id?: true
    service_ids?: true
    start_date?: true
    end_date?: true
    report_created_by?: true
    report_institution_id?: true
    report_recipient?: true
    report_queue_uuid?: true
    report_content_key?: true
    status?: true
    created_at?: true
  }

  export type ReportsMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    institution_id?: true
    service_ids?: true
    start_date?: true
    end_date?: true
    report_created_by?: true
    report_institution_id?: true
    report_recipient?: true
    report_queue_uuid?: true
    report_content_key?: true
    status?: true
    created_at?: true
  }

  export type ReportsCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    institution_id?: true
    service_ids?: true
    start_date?: true
    end_date?: true
    report_created_by?: true
    report_institution_id?: true
    report_recipient?: true
    report_queue_uuid?: true
    report_content_key?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type ReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to aggregate.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportsMaxAggregateInputType
  }

  export type GetReportsAggregateType<T extends ReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReports[P]>
      : GetScalarType<T[P], AggregateReports[P]>
  }




  export type reportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportsWhereInput
    orderBy?: reportsOrderByWithAggregationInput | reportsOrderByWithAggregationInput[]
    by: ReportsScalarFieldEnum[] | ReportsScalarFieldEnum
    having?: reportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportsCountAggregateInputType | true
    _avg?: ReportsAvgAggregateInputType
    _sum?: ReportsSumAggregateInputType
    _min?: ReportsMinAggregateInputType
    _max?: ReportsMaxAggregateInputType
  }

  export type ReportsGroupByOutputType = {
    id: number
    title: string
    type: string
    institution_id: number
    service_ids: string
    start_date: Date
    end_date: Date
    report_created_by: number
    report_institution_id: string
    report_recipient: string
    report_queue_uuid: string
    report_content_key: string | null
    status: number
    created_at: Date
    _count: ReportsCountAggregateOutputType | null
    _avg: ReportsAvgAggregateOutputType | null
    _sum: ReportsSumAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  type GetReportsGroupByPayload<T extends reportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportsGroupByOutputType[P]>
        }
      >
    >


  export type reportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    institution_id?: boolean
    service_ids?: boolean
    start_date?: boolean
    end_date?: boolean
    report_created_by?: boolean
    report_institution_id?: boolean
    report_recipient?: boolean
    report_queue_uuid?: boolean
    report_content_key?: boolean
    status?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["reports"]>



  export type reportsSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    institution_id?: boolean
    service_ids?: boolean
    start_date?: boolean
    end_date?: boolean
    report_created_by?: boolean
    report_institution_id?: boolean
    report_recipient?: boolean
    report_queue_uuid?: boolean
    report_content_key?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type reportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "institution_id" | "service_ids" | "start_date" | "end_date" | "report_created_by" | "report_institution_id" | "report_recipient" | "report_queue_uuid" | "report_content_key" | "status" | "created_at", ExtArgs["result"]["reports"]>

  export type $reportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reports"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      type: string
      institution_id: number
      service_ids: string
      start_date: Date
      end_date: Date
      report_created_by: number
      report_institution_id: string
      report_recipient: string
      report_queue_uuid: string
      report_content_key: string | null
      status: number
      created_at: Date
    }, ExtArgs["result"]["reports"]>
    composites: {}
  }

  type reportsGetPayload<S extends boolean | null | undefined | reportsDefaultArgs> = $Result.GetResult<Prisma.$reportsPayload, S>

  type reportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportsCountAggregateInputType | true
    }

  export interface reportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reports'], meta: { name: 'reports' } }
    /**
     * Find zero or one Reports that matches the filter.
     * @param {reportsFindUniqueArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportsFindUniqueArgs>(args: SelectSubset<T, reportsFindUniqueArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reportsFindUniqueOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportsFindUniqueOrThrowArgs>(args: SelectSubset<T, reportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindFirstArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportsFindFirstArgs>(args?: SelectSubset<T, reportsFindFirstArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindFirstOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportsFindFirstOrThrowArgs>(args?: SelectSubset<T, reportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.reports.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportsWithIdOnly = await prisma.reports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reportsFindManyArgs>(args?: SelectSubset<T, reportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reports.
     * @param {reportsCreateArgs} args - Arguments to create a Reports.
     * @example
     * // Create one Reports
     * const Reports = await prisma.reports.create({
     *   data: {
     *     // ... data to create a Reports
     *   }
     * })
     * 
     */
    create<T extends reportsCreateArgs>(args: SelectSubset<T, reportsCreateArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {reportsCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const reports = await prisma.reports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportsCreateManyArgs>(args?: SelectSubset<T, reportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reports.
     * @param {reportsDeleteArgs} args - Arguments to delete one Reports.
     * @example
     * // Delete one Reports
     * const Reports = await prisma.reports.delete({
     *   where: {
     *     // ... filter to delete one Reports
     *   }
     * })
     * 
     */
    delete<T extends reportsDeleteArgs>(args: SelectSubset<T, reportsDeleteArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reports.
     * @param {reportsUpdateArgs} args - Arguments to update one Reports.
     * @example
     * // Update one Reports
     * const reports = await prisma.reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportsUpdateArgs>(args: SelectSubset<T, reportsUpdateArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {reportsDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportsDeleteManyArgs>(args?: SelectSubset<T, reportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const reports = await prisma.reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportsUpdateManyArgs>(args: SelectSubset<T, reportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reports.
     * @param {reportsUpsertArgs} args - Arguments to update or create a Reports.
     * @example
     * // Update or create a Reports
     * const reports = await prisma.reports.upsert({
     *   create: {
     *     // ... data to create a Reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reports we want to update
     *   }
     * })
     */
    upsert<T extends reportsUpsertArgs>(args: SelectSubset<T, reportsUpsertArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.reports.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportsCountArgs>(
      args?: Subset<T, reportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportsAggregateArgs>(args: Subset<T, ReportsAggregateArgs>): Prisma.PrismaPromise<GetReportsAggregateType<T>>

    /**
     * Group by Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportsGroupByArgs['orderBy'] }
        : { orderBy?: reportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reports model
   */
  readonly fields: reportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reports model
   */
  interface reportsFieldRefs {
    readonly id: FieldRef<"reports", 'Int'>
    readonly title: FieldRef<"reports", 'String'>
    readonly type: FieldRef<"reports", 'String'>
    readonly institution_id: FieldRef<"reports", 'Int'>
    readonly service_ids: FieldRef<"reports", 'String'>
    readonly start_date: FieldRef<"reports", 'DateTime'>
    readonly end_date: FieldRef<"reports", 'DateTime'>
    readonly report_created_by: FieldRef<"reports", 'Int'>
    readonly report_institution_id: FieldRef<"reports", 'String'>
    readonly report_recipient: FieldRef<"reports", 'String'>
    readonly report_queue_uuid: FieldRef<"reports", 'String'>
    readonly report_content_key: FieldRef<"reports", 'String'>
    readonly status: FieldRef<"reports", 'Int'>
    readonly created_at: FieldRef<"reports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reports findUnique
   */
  export type reportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports findUniqueOrThrow
   */
  export type reportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports findFirst
   */
  export type reportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports findFirstOrThrow
   */
  export type reportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports findMany
   */
  export type reportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports create
   */
  export type reportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * The data needed to create a reports.
     */
    data: XOR<reportsCreateInput, reportsUncheckedCreateInput>
  }

  /**
   * reports createMany
   */
  export type reportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reports.
     */
    data: reportsCreateManyInput | reportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reports update
   */
  export type reportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * The data needed to update a reports.
     */
    data: XOR<reportsUpdateInput, reportsUncheckedUpdateInput>
    /**
     * Choose, which reports to update.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports updateMany
   */
  export type reportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportsUpdateManyMutationInput, reportsUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportsWhereInput
    /**
     * Limit how many reports to update.
     */
    limit?: number
  }

  /**
   * reports upsert
   */
  export type reportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * The filter to search for the reports to update in case it exists.
     */
    where: reportsWhereUniqueInput
    /**
     * In case the reports found by the `where` argument doesn't exist, create a new reports with this data.
     */
    create: XOR<reportsCreateInput, reportsUncheckedCreateInput>
    /**
     * In case the reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportsUpdateInput, reportsUncheckedUpdateInput>
  }

  /**
   * reports delete
   */
  export type reportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
    /**
     * Filter which reports to delete.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports deleteMany
   */
  export type reportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to delete
     */
    where?: reportsWhereInput
    /**
     * Limit how many reports to delete.
     */
    limit?: number
  }

  /**
   * reports without action
   */
  export type reportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reports
     */
    omit?: reportsOmit<ExtArgs> | null
  }


  /**
   * Model request_institution
   */

  export type AggregateRequest_institution = {
    _count: Request_institutionCountAggregateOutputType | null
    _avg: Request_institutionAvgAggregateOutputType | null
    _sum: Request_institutionSumAggregateOutputType | null
    _min: Request_institutionMinAggregateOutputType | null
    _max: Request_institutionMaxAggregateOutputType | null
  }

  export type Request_institutionAvgAggregateOutputType = {
    id: number | null
    approval_status: number | null
  }

  export type Request_institutionSumAggregateOutputType = {
    id: number | null
    approval_status: number | null
  }

  export type Request_institutionMinAggregateOutputType = {
    id: number | null
    owner_name: string | null
    address: string | null
    phone_number: string | null
    email: string | null
    name: string | null
    category: string | null
    location: string | null
    type: string | null
    business_certificate: string | null
    product_type: string | null
    approval_status: number | null
  }

  export type Request_institutionMaxAggregateOutputType = {
    id: number | null
    owner_name: string | null
    address: string | null
    phone_number: string | null
    email: string | null
    name: string | null
    category: string | null
    location: string | null
    type: string | null
    business_certificate: string | null
    product_type: string | null
    approval_status: number | null
  }

  export type Request_institutionCountAggregateOutputType = {
    id: number
    owner_name: number
    address: number
    phone_number: number
    email: number
    name: number
    category: number
    location: number
    type: number
    business_certificate: number
    product_type: number
    approval_status: number
    _all: number
  }


  export type Request_institutionAvgAggregateInputType = {
    id?: true
    approval_status?: true
  }

  export type Request_institutionSumAggregateInputType = {
    id?: true
    approval_status?: true
  }

  export type Request_institutionMinAggregateInputType = {
    id?: true
    owner_name?: true
    address?: true
    phone_number?: true
    email?: true
    name?: true
    category?: true
    location?: true
    type?: true
    business_certificate?: true
    product_type?: true
    approval_status?: true
  }

  export type Request_institutionMaxAggregateInputType = {
    id?: true
    owner_name?: true
    address?: true
    phone_number?: true
    email?: true
    name?: true
    category?: true
    location?: true
    type?: true
    business_certificate?: true
    product_type?: true
    approval_status?: true
  }

  export type Request_institutionCountAggregateInputType = {
    id?: true
    owner_name?: true
    address?: true
    phone_number?: true
    email?: true
    name?: true
    category?: true
    location?: true
    type?: true
    business_certificate?: true
    product_type?: true
    approval_status?: true
    _all?: true
  }

  export type Request_institutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which request_institution to aggregate.
     */
    where?: request_institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_institutions to fetch.
     */
    orderBy?: request_institutionOrderByWithRelationInput | request_institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: request_institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned request_institutions
    **/
    _count?: true | Request_institutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Request_institutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Request_institutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Request_institutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Request_institutionMaxAggregateInputType
  }

  export type GetRequest_institutionAggregateType<T extends Request_institutionAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest_institution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest_institution[P]>
      : GetScalarType<T[P], AggregateRequest_institution[P]>
  }




  export type request_institutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: request_institutionWhereInput
    orderBy?: request_institutionOrderByWithAggregationInput | request_institutionOrderByWithAggregationInput[]
    by: Request_institutionScalarFieldEnum[] | Request_institutionScalarFieldEnum
    having?: request_institutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Request_institutionCountAggregateInputType | true
    _avg?: Request_institutionAvgAggregateInputType
    _sum?: Request_institutionSumAggregateInputType
    _min?: Request_institutionMinAggregateInputType
    _max?: Request_institutionMaxAggregateInputType
  }

  export type Request_institutionGroupByOutputType = {
    id: number
    owner_name: string
    address: string
    phone_number: string
    email: string
    name: string
    category: string
    location: string
    type: string
    business_certificate: string
    product_type: string
    approval_status: number
    _count: Request_institutionCountAggregateOutputType | null
    _avg: Request_institutionAvgAggregateOutputType | null
    _sum: Request_institutionSumAggregateOutputType | null
    _min: Request_institutionMinAggregateOutputType | null
    _max: Request_institutionMaxAggregateOutputType | null
  }

  type GetRequest_institutionGroupByPayload<T extends request_institutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Request_institutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Request_institutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Request_institutionGroupByOutputType[P]>
            : GetScalarType<T[P], Request_institutionGroupByOutputType[P]>
        }
      >
    >


  export type request_institutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    owner_name?: boolean
    address?: boolean
    phone_number?: boolean
    email?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    type?: boolean
    business_certificate?: boolean
    product_type?: boolean
    approval_status?: boolean
  }, ExtArgs["result"]["request_institution"]>



  export type request_institutionSelectScalar = {
    id?: boolean
    owner_name?: boolean
    address?: boolean
    phone_number?: boolean
    email?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    type?: boolean
    business_certificate?: boolean
    product_type?: boolean
    approval_status?: boolean
  }

  export type request_institutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "owner_name" | "address" | "phone_number" | "email" | "name" | "category" | "location" | "type" | "business_certificate" | "product_type" | "approval_status", ExtArgs["result"]["request_institution"]>

  export type $request_institutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "request_institution"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      owner_name: string
      address: string
      phone_number: string
      email: string
      name: string
      category: string
      location: string
      type: string
      business_certificate: string
      product_type: string
      approval_status: number
    }, ExtArgs["result"]["request_institution"]>
    composites: {}
  }

  type request_institutionGetPayload<S extends boolean | null | undefined | request_institutionDefaultArgs> = $Result.GetResult<Prisma.$request_institutionPayload, S>

  type request_institutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<request_institutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Request_institutionCountAggregateInputType | true
    }

  export interface request_institutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['request_institution'], meta: { name: 'request_institution' } }
    /**
     * Find zero or one Request_institution that matches the filter.
     * @param {request_institutionFindUniqueArgs} args - Arguments to find a Request_institution
     * @example
     * // Get one Request_institution
     * const request_institution = await prisma.request_institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends request_institutionFindUniqueArgs>(args: SelectSubset<T, request_institutionFindUniqueArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Request_institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {request_institutionFindUniqueOrThrowArgs} args - Arguments to find a Request_institution
     * @example
     * // Get one Request_institution
     * const request_institution = await prisma.request_institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends request_institutionFindUniqueOrThrowArgs>(args: SelectSubset<T, request_institutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request_institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_institutionFindFirstArgs} args - Arguments to find a Request_institution
     * @example
     * // Get one Request_institution
     * const request_institution = await prisma.request_institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends request_institutionFindFirstArgs>(args?: SelectSubset<T, request_institutionFindFirstArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request_institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_institutionFindFirstOrThrowArgs} args - Arguments to find a Request_institution
     * @example
     * // Get one Request_institution
     * const request_institution = await prisma.request_institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends request_institutionFindFirstOrThrowArgs>(args?: SelectSubset<T, request_institutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Request_institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_institutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Request_institutions
     * const request_institutions = await prisma.request_institution.findMany()
     * 
     * // Get first 10 Request_institutions
     * const request_institutions = await prisma.request_institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const request_institutionWithIdOnly = await prisma.request_institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends request_institutionFindManyArgs>(args?: SelectSubset<T, request_institutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Request_institution.
     * @param {request_institutionCreateArgs} args - Arguments to create a Request_institution.
     * @example
     * // Create one Request_institution
     * const Request_institution = await prisma.request_institution.create({
     *   data: {
     *     // ... data to create a Request_institution
     *   }
     * })
     * 
     */
    create<T extends request_institutionCreateArgs>(args: SelectSubset<T, request_institutionCreateArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Request_institutions.
     * @param {request_institutionCreateManyArgs} args - Arguments to create many Request_institutions.
     * @example
     * // Create many Request_institutions
     * const request_institution = await prisma.request_institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends request_institutionCreateManyArgs>(args?: SelectSubset<T, request_institutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Request_institution.
     * @param {request_institutionDeleteArgs} args - Arguments to delete one Request_institution.
     * @example
     * // Delete one Request_institution
     * const Request_institution = await prisma.request_institution.delete({
     *   where: {
     *     // ... filter to delete one Request_institution
     *   }
     * })
     * 
     */
    delete<T extends request_institutionDeleteArgs>(args: SelectSubset<T, request_institutionDeleteArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Request_institution.
     * @param {request_institutionUpdateArgs} args - Arguments to update one Request_institution.
     * @example
     * // Update one Request_institution
     * const request_institution = await prisma.request_institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends request_institutionUpdateArgs>(args: SelectSubset<T, request_institutionUpdateArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Request_institutions.
     * @param {request_institutionDeleteManyArgs} args - Arguments to filter Request_institutions to delete.
     * @example
     * // Delete a few Request_institutions
     * const { count } = await prisma.request_institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends request_institutionDeleteManyArgs>(args?: SelectSubset<T, request_institutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Request_institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_institutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Request_institutions
     * const request_institution = await prisma.request_institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends request_institutionUpdateManyArgs>(args: SelectSubset<T, request_institutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Request_institution.
     * @param {request_institutionUpsertArgs} args - Arguments to update or create a Request_institution.
     * @example
     * // Update or create a Request_institution
     * const request_institution = await prisma.request_institution.upsert({
     *   create: {
     *     // ... data to create a Request_institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request_institution we want to update
     *   }
     * })
     */
    upsert<T extends request_institutionUpsertArgs>(args: SelectSubset<T, request_institutionUpsertArgs<ExtArgs>>): Prisma__request_institutionClient<$Result.GetResult<Prisma.$request_institutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Request_institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_institutionCountArgs} args - Arguments to filter Request_institutions to count.
     * @example
     * // Count the number of Request_institutions
     * const count = await prisma.request_institution.count({
     *   where: {
     *     // ... the filter for the Request_institutions we want to count
     *   }
     * })
    **/
    count<T extends request_institutionCountArgs>(
      args?: Subset<T, request_institutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Request_institutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request_institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Request_institutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Request_institutionAggregateArgs>(args: Subset<T, Request_institutionAggregateArgs>): Prisma.PrismaPromise<GetRequest_institutionAggregateType<T>>

    /**
     * Group by Request_institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {request_institutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends request_institutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: request_institutionGroupByArgs['orderBy'] }
        : { orderBy?: request_institutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, request_institutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequest_institutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the request_institution model
   */
  readonly fields: request_institutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for request_institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__request_institutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the request_institution model
   */
  interface request_institutionFieldRefs {
    readonly id: FieldRef<"request_institution", 'Int'>
    readonly owner_name: FieldRef<"request_institution", 'String'>
    readonly address: FieldRef<"request_institution", 'String'>
    readonly phone_number: FieldRef<"request_institution", 'String'>
    readonly email: FieldRef<"request_institution", 'String'>
    readonly name: FieldRef<"request_institution", 'String'>
    readonly category: FieldRef<"request_institution", 'String'>
    readonly location: FieldRef<"request_institution", 'String'>
    readonly type: FieldRef<"request_institution", 'String'>
    readonly business_certificate: FieldRef<"request_institution", 'String'>
    readonly product_type: FieldRef<"request_institution", 'String'>
    readonly approval_status: FieldRef<"request_institution", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * request_institution findUnique
   */
  export type request_institutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * Filter, which request_institution to fetch.
     */
    where: request_institutionWhereUniqueInput
  }

  /**
   * request_institution findUniqueOrThrow
   */
  export type request_institutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * Filter, which request_institution to fetch.
     */
    where: request_institutionWhereUniqueInput
  }

  /**
   * request_institution findFirst
   */
  export type request_institutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * Filter, which request_institution to fetch.
     */
    where?: request_institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_institutions to fetch.
     */
    orderBy?: request_institutionOrderByWithRelationInput | request_institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for request_institutions.
     */
    cursor?: request_institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of request_institutions.
     */
    distinct?: Request_institutionScalarFieldEnum | Request_institutionScalarFieldEnum[]
  }

  /**
   * request_institution findFirstOrThrow
   */
  export type request_institutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * Filter, which request_institution to fetch.
     */
    where?: request_institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_institutions to fetch.
     */
    orderBy?: request_institutionOrderByWithRelationInput | request_institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for request_institutions.
     */
    cursor?: request_institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of request_institutions.
     */
    distinct?: Request_institutionScalarFieldEnum | Request_institutionScalarFieldEnum[]
  }

  /**
   * request_institution findMany
   */
  export type request_institutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * Filter, which request_institutions to fetch.
     */
    where?: request_institutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of request_institutions to fetch.
     */
    orderBy?: request_institutionOrderByWithRelationInput | request_institutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing request_institutions.
     */
    cursor?: request_institutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` request_institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` request_institutions.
     */
    skip?: number
    distinct?: Request_institutionScalarFieldEnum | Request_institutionScalarFieldEnum[]
  }

  /**
   * request_institution create
   */
  export type request_institutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * The data needed to create a request_institution.
     */
    data: XOR<request_institutionCreateInput, request_institutionUncheckedCreateInput>
  }

  /**
   * request_institution createMany
   */
  export type request_institutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many request_institutions.
     */
    data: request_institutionCreateManyInput | request_institutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * request_institution update
   */
  export type request_institutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * The data needed to update a request_institution.
     */
    data: XOR<request_institutionUpdateInput, request_institutionUncheckedUpdateInput>
    /**
     * Choose, which request_institution to update.
     */
    where: request_institutionWhereUniqueInput
  }

  /**
   * request_institution updateMany
   */
  export type request_institutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update request_institutions.
     */
    data: XOR<request_institutionUpdateManyMutationInput, request_institutionUncheckedUpdateManyInput>
    /**
     * Filter which request_institutions to update
     */
    where?: request_institutionWhereInput
    /**
     * Limit how many request_institutions to update.
     */
    limit?: number
  }

  /**
   * request_institution upsert
   */
  export type request_institutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * The filter to search for the request_institution to update in case it exists.
     */
    where: request_institutionWhereUniqueInput
    /**
     * In case the request_institution found by the `where` argument doesn't exist, create a new request_institution with this data.
     */
    create: XOR<request_institutionCreateInput, request_institutionUncheckedCreateInput>
    /**
     * In case the request_institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<request_institutionUpdateInput, request_institutionUncheckedUpdateInput>
  }

  /**
   * request_institution delete
   */
  export type request_institutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
    /**
     * Filter which request_institution to delete.
     */
    where: request_institutionWhereUniqueInput
  }

  /**
   * request_institution deleteMany
   */
  export type request_institutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which request_institutions to delete
     */
    where?: request_institutionWhereInput
    /**
     * Limit how many request_institutions to delete.
     */
    limit?: number
  }

  /**
   * request_institution without action
   */
  export type request_institutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the request_institution
     */
    select?: request_institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the request_institution
     */
    omit?: request_institutionOmit<ExtArgs> | null
  }


  /**
   * Model service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    status: number | null
    bad_rating_threshold: number | null
    group: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    avg_service_time: number | null
    inter_arrival_time: number | null
    estimated_time: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    status: number | null
    bad_rating_threshold: number | null
    group: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    avg_service_time: number | null
    inter_arrival_time: number | null
    estimated_time: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    institution_id: number | null
    status: number | null
    created_at: Date | null
    bad_rating_threshold: number | null
    group: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    avg_service_time: number | null
    uuid: string | null
    inter_arrival_time: number | null
    estimated_time: number | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    institution_id: number | null
    status: number | null
    created_at: Date | null
    bad_rating_threshold: number | null
    group: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    avg_service_time: number | null
    uuid: string | null
    inter_arrival_time: number | null
    estimated_time: number | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    institution_id: number
    status: number
    created_at: number
    bad_rating_threshold: number
    group: number
    good_ratings: number
    bad_ratings: number
    excellent_ratings: number
    nps: number
    csat: number
    mean_service_time: number
    avg_service_time: number
    uuid: number
    inter_arrival_time: number
    estimated_time: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    bad_rating_threshold?: true
    group?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    avg_service_time?: true
    inter_arrival_time?: true
    estimated_time?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    bad_rating_threshold?: true
    group?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    avg_service_time?: true
    inter_arrival_time?: true
    estimated_time?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    created_at?: true
    bad_rating_threshold?: true
    group?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    avg_service_time?: true
    uuid?: true
    inter_arrival_time?: true
    estimated_time?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    created_at?: true
    bad_rating_threshold?: true
    group?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    avg_service_time?: true
    uuid?: true
    inter_arrival_time?: true
    estimated_time?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    created_at?: true
    bad_rating_threshold?: true
    group?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    avg_service_time?: true
    uuid?: true
    inter_arrival_time?: true
    estimated_time?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service to aggregate.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type serviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithAggregationInput | serviceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: serviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    institution_id: number | null
    status: number | null
    created_at: Date
    bad_rating_threshold: number | null
    group: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    avg_service_time: number | null
    uuid: string | null
    inter_arrival_time: number | null
    estimated_time: number | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends serviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type serviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution_id?: boolean
    status?: boolean
    created_at?: boolean
    bad_rating_threshold?: boolean
    group?: boolean
    good_ratings?: boolean
    bad_ratings?: boolean
    excellent_ratings?: boolean
    nps?: boolean
    csat?: boolean
    mean_service_time?: boolean
    avg_service_time?: boolean
    uuid?: boolean
    inter_arrival_time?: boolean
    estimated_time?: boolean
    appointments?: boolean | service$appointmentsArgs<ExtArgs>
    qms_counter?: boolean | service$qms_counterArgs<ExtArgs>
    qms_queue?: boolean | service$qms_queueArgs<ExtArgs>
    rating?: boolean | service$ratingArgs<ExtArgs>
    service_group?: boolean | service$service_groupArgs<ExtArgs>
    institution?: boolean | service$institutionArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type serviceSelectScalar = {
    id?: boolean
    institution_id?: boolean
    status?: boolean
    created_at?: boolean
    bad_rating_threshold?: boolean
    group?: boolean
    good_ratings?: boolean
    bad_ratings?: boolean
    excellent_ratings?: boolean
    nps?: boolean
    csat?: boolean
    mean_service_time?: boolean
    avg_service_time?: boolean
    uuid?: boolean
    inter_arrival_time?: boolean
    estimated_time?: boolean
  }

  export type serviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution_id" | "status" | "created_at" | "bad_rating_threshold" | "group" | "good_ratings" | "bad_ratings" | "excellent_ratings" | "nps" | "csat" | "mean_service_time" | "avg_service_time" | "uuid" | "inter_arrival_time" | "estimated_time", ExtArgs["result"]["service"]>
  export type serviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | service$appointmentsArgs<ExtArgs>
    qms_counter?: boolean | service$qms_counterArgs<ExtArgs>
    qms_queue?: boolean | service$qms_queueArgs<ExtArgs>
    rating?: boolean | service$ratingArgs<ExtArgs>
    service_group?: boolean | service$service_groupArgs<ExtArgs>
    institution?: boolean | service$institutionArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $servicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      qms_counter: Prisma.$qms_counterPayload<ExtArgs>[]
      qms_queue: Prisma.$qms_queuePayload<ExtArgs>[]
      rating: Prisma.$ratingPayload<ExtArgs>[]
      service_group: Prisma.$service_groupPayload<ExtArgs> | null
      institution: Prisma.$institutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institution_id: number | null
      status: number | null
      created_at: Date
      bad_rating_threshold: number | null
      group: number | null
      good_ratings: number | null
      bad_ratings: number | null
      excellent_ratings: number | null
      nps: number | null
      csat: number | null
      mean_service_time: number | null
      avg_service_time: number | null
      uuid: string | null
      inter_arrival_time: number | null
      estimated_time: number | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type serviceGetPayload<S extends boolean | null | undefined | serviceDefaultArgs> = $Result.GetResult<Prisma.$servicePayload, S>

  type serviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface serviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service'], meta: { name: 'service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {serviceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceFindUniqueArgs>(args: SelectSubset<T, serviceFindUniqueArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceFindFirstArgs>(args?: SelectSubset<T, serviceFindFirstArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serviceFindManyArgs>(args?: SelectSubset<T, serviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {serviceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends serviceCreateArgs>(args: SelectSubset<T, serviceCreateArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {serviceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceCreateManyArgs>(args?: SelectSubset<T, serviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {serviceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends serviceDeleteArgs>(args: SelectSubset<T, serviceDeleteArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {serviceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceUpdateArgs>(args: SelectSubset<T, serviceUpdateArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {serviceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceDeleteManyArgs>(args?: SelectSubset<T, serviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceUpdateManyArgs>(args: SelectSubset<T, serviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {serviceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends serviceUpsertArgs>(args: SelectSubset<T, serviceUpsertArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends serviceCountArgs>(
      args?: Subset<T, serviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceGroupByArgs['orderBy'] }
        : { orderBy?: serviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service model
   */
  readonly fields: serviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends service$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, service$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_counter<T extends service$qms_counterArgs<ExtArgs> = {}>(args?: Subset<T, service$qms_counterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_counterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qms_queue<T extends service$qms_queueArgs<ExtArgs> = {}>(args?: Subset<T, service$qms_queueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qms_queuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rating<T extends service$ratingArgs<ExtArgs> = {}>(args?: Subset<T, service$ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_group<T extends service$service_groupArgs<ExtArgs> = {}>(args?: Subset<T, service$service_groupArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    institution<T extends service$institutionArgs<ExtArgs> = {}>(args?: Subset<T, service$institutionArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service model
   */
  interface serviceFieldRefs {
    readonly id: FieldRef<"service", 'Int'>
    readonly institution_id: FieldRef<"service", 'Int'>
    readonly status: FieldRef<"service", 'Int'>
    readonly created_at: FieldRef<"service", 'DateTime'>
    readonly bad_rating_threshold: FieldRef<"service", 'Int'>
    readonly group: FieldRef<"service", 'Int'>
    readonly good_ratings: FieldRef<"service", 'Int'>
    readonly bad_ratings: FieldRef<"service", 'Int'>
    readonly excellent_ratings: FieldRef<"service", 'Int'>
    readonly nps: FieldRef<"service", 'Int'>
    readonly csat: FieldRef<"service", 'Int'>
    readonly mean_service_time: FieldRef<"service", 'Int'>
    readonly avg_service_time: FieldRef<"service", 'Float'>
    readonly uuid: FieldRef<"service", 'String'>
    readonly inter_arrival_time: FieldRef<"service", 'Float'>
    readonly estimated_time: FieldRef<"service", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * service findUnique
   */
  export type serviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service findUniqueOrThrow
   */
  export type serviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service findFirst
   */
  export type serviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service findFirstOrThrow
   */
  export type serviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service findMany
   */
  export type serviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service create
   */
  export type serviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The data needed to create a service.
     */
    data?: XOR<serviceCreateInput, serviceUncheckedCreateInput>
  }

  /**
   * service createMany
   */
  export type serviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: serviceCreateManyInput | serviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service update
   */
  export type serviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The data needed to update a service.
     */
    data: XOR<serviceUpdateInput, serviceUncheckedUpdateInput>
    /**
     * Choose, which service to update.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service updateMany
   */
  export type serviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
  }

  /**
   * service upsert
   */
  export type serviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The filter to search for the service to update in case it exists.
     */
    where: serviceWhereUniqueInput
    /**
     * In case the service found by the `where` argument doesn't exist, create a new service with this data.
     */
    create: XOR<serviceCreateInput, serviceUncheckedCreateInput>
    /**
     * In case the service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceUpdateInput, serviceUncheckedUpdateInput>
  }

  /**
   * service delete
   */
  export type serviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter which service to delete.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service deleteMany
   */
  export type serviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to delete.
     */
    limit?: number
  }

  /**
   * service.appointments
   */
  export type service$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * service.qms_counter
   */
  export type service$qms_counterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_counter
     */
    select?: qms_counterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_counter
     */
    omit?: qms_counterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_counterInclude<ExtArgs> | null
    where?: qms_counterWhereInput
    orderBy?: qms_counterOrderByWithRelationInput | qms_counterOrderByWithRelationInput[]
    cursor?: qms_counterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_counterScalarFieldEnum | Qms_counterScalarFieldEnum[]
  }

  /**
   * service.qms_queue
   */
  export type service$qms_queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qms_queue
     */
    select?: qms_queueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qms_queue
     */
    omit?: qms_queueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qms_queueInclude<ExtArgs> | null
    where?: qms_queueWhereInput
    orderBy?: qms_queueOrderByWithRelationInput | qms_queueOrderByWithRelationInput[]
    cursor?: qms_queueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Qms_queueScalarFieldEnum | Qms_queueScalarFieldEnum[]
  }

  /**
   * service.rating
   */
  export type service$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
    orderBy?: ratingOrderByWithRelationInput | ratingOrderByWithRelationInput[]
    cursor?: ratingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * service.service_group
   */
  export type service$service_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    where?: service_groupWhereInput
  }

  /**
   * service.institution
   */
  export type service$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
  }

  /**
   * service without action
   */
  export type serviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
  }


  /**
   * Model service_group
   */

  export type AggregateService_group = {
    _count: Service_groupCountAggregateOutputType | null
    _avg: Service_groupAvgAggregateOutputType | null
    _sum: Service_groupSumAggregateOutputType | null
    _min: Service_groupMinAggregateOutputType | null
    _max: Service_groupMaxAggregateOutputType | null
  }

  export type Service_groupAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    status: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    bad_rating_threshold: number | null
  }

  export type Service_groupSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    status: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    bad_rating_threshold: number | null
  }

  export type Service_groupMinAggregateOutputType = {
    id: number | null
    name: string | null
    name_rw: string | null
    name_fr: string | null
    name_sw: string | null
    search_term: string | null
    institution_id: number | null
    created_at: Date | null
    updated_at: Date | null
    uuid: string | null
    status: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    ticket_prefix: string | null
    bad_rating_threshold: number | null
  }

  export type Service_groupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    name_rw: string | null
    name_fr: string | null
    name_sw: string | null
    search_term: string | null
    institution_id: number | null
    created_at: Date | null
    updated_at: Date | null
    uuid: string | null
    status: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    ticket_prefix: string | null
    bad_rating_threshold: number | null
  }

  export type Service_groupCountAggregateOutputType = {
    id: number
    name: number
    name_rw: number
    name_fr: number
    name_sw: number
    search_term: number
    institution_id: number
    created_at: number
    updated_at: number
    uuid: number
    status: number
    good_ratings: number
    bad_ratings: number
    excellent_ratings: number
    nps: number
    csat: number
    mean_service_time: number
    ticket_prefix: number
    bad_rating_threshold: number
    _all: number
  }


  export type Service_groupAvgAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    bad_rating_threshold?: true
  }

  export type Service_groupSumAggregateInputType = {
    id?: true
    institution_id?: true
    status?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    bad_rating_threshold?: true
  }

  export type Service_groupMinAggregateInputType = {
    id?: true
    name?: true
    name_rw?: true
    name_fr?: true
    name_sw?: true
    search_term?: true
    institution_id?: true
    created_at?: true
    updated_at?: true
    uuid?: true
    status?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    ticket_prefix?: true
    bad_rating_threshold?: true
  }

  export type Service_groupMaxAggregateInputType = {
    id?: true
    name?: true
    name_rw?: true
    name_fr?: true
    name_sw?: true
    search_term?: true
    institution_id?: true
    created_at?: true
    updated_at?: true
    uuid?: true
    status?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    ticket_prefix?: true
    bad_rating_threshold?: true
  }

  export type Service_groupCountAggregateInputType = {
    id?: true
    name?: true
    name_rw?: true
    name_fr?: true
    name_sw?: true
    search_term?: true
    institution_id?: true
    created_at?: true
    updated_at?: true
    uuid?: true
    status?: true
    good_ratings?: true
    bad_ratings?: true
    excellent_ratings?: true
    nps?: true
    csat?: true
    mean_service_time?: true
    ticket_prefix?: true
    bad_rating_threshold?: true
    _all?: true
  }

  export type Service_groupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_group to aggregate.
     */
    where?: service_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_groups to fetch.
     */
    orderBy?: service_groupOrderByWithRelationInput | service_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_groups
    **/
    _count?: true | Service_groupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Service_groupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Service_groupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_groupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_groupMaxAggregateInputType
  }

  export type GetService_groupAggregateType<T extends Service_groupAggregateArgs> = {
        [P in keyof T & keyof AggregateService_group]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_group[P]>
      : GetScalarType<T[P], AggregateService_group[P]>
  }




  export type service_groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_groupWhereInput
    orderBy?: service_groupOrderByWithAggregationInput | service_groupOrderByWithAggregationInput[]
    by: Service_groupScalarFieldEnum[] | Service_groupScalarFieldEnum
    having?: service_groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_groupCountAggregateInputType | true
    _avg?: Service_groupAvgAggregateInputType
    _sum?: Service_groupSumAggregateInputType
    _min?: Service_groupMinAggregateInputType
    _max?: Service_groupMaxAggregateInputType
  }

  export type Service_groupGroupByOutputType = {
    id: number
    name: string
    name_rw: string | null
    name_fr: string | null
    name_sw: string | null
    search_term: string | null
    institution_id: number
    created_at: Date
    updated_at: Date
    uuid: string | null
    status: number | null
    good_ratings: number | null
    bad_ratings: number | null
    excellent_ratings: number | null
    nps: number | null
    csat: number | null
    mean_service_time: number | null
    ticket_prefix: string | null
    bad_rating_threshold: number | null
    _count: Service_groupCountAggregateOutputType | null
    _avg: Service_groupAvgAggregateOutputType | null
    _sum: Service_groupSumAggregateOutputType | null
    _min: Service_groupMinAggregateOutputType | null
    _max: Service_groupMaxAggregateOutputType | null
  }

  type GetService_groupGroupByPayload<T extends service_groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_groupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_groupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_groupGroupByOutputType[P]>
            : GetScalarType<T[P], Service_groupGroupByOutputType[P]>
        }
      >
    >


  export type service_groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_rw?: boolean
    name_fr?: boolean
    name_sw?: boolean
    search_term?: boolean
    institution_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    uuid?: boolean
    status?: boolean
    good_ratings?: boolean
    bad_ratings?: boolean
    excellent_ratings?: boolean
    nps?: boolean
    csat?: boolean
    mean_service_time?: boolean
    ticket_prefix?: boolean
    bad_rating_threshold?: boolean
    service?: boolean | service_group$serviceArgs<ExtArgs>
    serviceReview?: boolean | service_group$serviceReviewArgs<ExtArgs>
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    surveyQuestions?: boolean | service_group$surveyQuestionsArgs<ExtArgs>
    _count?: boolean | Service_groupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_group"]>



  export type service_groupSelectScalar = {
    id?: boolean
    name?: boolean
    name_rw?: boolean
    name_fr?: boolean
    name_sw?: boolean
    search_term?: boolean
    institution_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    uuid?: boolean
    status?: boolean
    good_ratings?: boolean
    bad_ratings?: boolean
    excellent_ratings?: boolean
    nps?: boolean
    csat?: boolean
    mean_service_time?: boolean
    ticket_prefix?: boolean
    bad_rating_threshold?: boolean
  }

  export type service_groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_rw" | "name_fr" | "name_sw" | "search_term" | "institution_id" | "created_at" | "updated_at" | "uuid" | "status" | "good_ratings" | "bad_ratings" | "excellent_ratings" | "nps" | "csat" | "mean_service_time" | "ticket_prefix" | "bad_rating_threshold", ExtArgs["result"]["service_group"]>
  export type service_groupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | service_group$serviceArgs<ExtArgs>
    serviceReview?: boolean | service_group$serviceReviewArgs<ExtArgs>
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    surveyQuestions?: boolean | service_group$surveyQuestionsArgs<ExtArgs>
    _count?: boolean | Service_groupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $service_groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_group"
    objects: {
      service: Prisma.$servicePayload<ExtArgs>[]
      serviceReview: Prisma.$serviceReviewPayload<ExtArgs>[]
      institution: Prisma.$institutionPayload<ExtArgs>
      surveyQuestions: Prisma.$surveyQuestionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      name_rw: string | null
      name_fr: string | null
      name_sw: string | null
      search_term: string | null
      institution_id: number
      created_at: Date
      updated_at: Date
      uuid: string | null
      status: number | null
      good_ratings: number | null
      bad_ratings: number | null
      excellent_ratings: number | null
      nps: number | null
      csat: number | null
      mean_service_time: number | null
      ticket_prefix: string | null
      bad_rating_threshold: number | null
    }, ExtArgs["result"]["service_group"]>
    composites: {}
  }

  type service_groupGetPayload<S extends boolean | null | undefined | service_groupDefaultArgs> = $Result.GetResult<Prisma.$service_groupPayload, S>

  type service_groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<service_groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Service_groupCountAggregateInputType | true
    }

  export interface service_groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_group'], meta: { name: 'service_group' } }
    /**
     * Find zero or one Service_group that matches the filter.
     * @param {service_groupFindUniqueArgs} args - Arguments to find a Service_group
     * @example
     * // Get one Service_group
     * const service_group = await prisma.service_group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_groupFindUniqueArgs>(args: SelectSubset<T, service_groupFindUniqueArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service_group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {service_groupFindUniqueOrThrowArgs} args - Arguments to find a Service_group
     * @example
     * // Get one Service_group
     * const service_group = await prisma.service_group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_groupFindUniqueOrThrowArgs>(args: SelectSubset<T, service_groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_groupFindFirstArgs} args - Arguments to find a Service_group
     * @example
     * // Get one Service_group
     * const service_group = await prisma.service_group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_groupFindFirstArgs>(args?: SelectSubset<T, service_groupFindFirstArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_groupFindFirstOrThrowArgs} args - Arguments to find a Service_group
     * @example
     * // Get one Service_group
     * const service_group = await prisma.service_group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_groupFindFirstOrThrowArgs>(args?: SelectSubset<T, service_groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Service_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_groups
     * const service_groups = await prisma.service_group.findMany()
     * 
     * // Get first 10 Service_groups
     * const service_groups = await prisma.service_group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_groupWithIdOnly = await prisma.service_group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_groupFindManyArgs>(args?: SelectSubset<T, service_groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service_group.
     * @param {service_groupCreateArgs} args - Arguments to create a Service_group.
     * @example
     * // Create one Service_group
     * const Service_group = await prisma.service_group.create({
     *   data: {
     *     // ... data to create a Service_group
     *   }
     * })
     * 
     */
    create<T extends service_groupCreateArgs>(args: SelectSubset<T, service_groupCreateArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Service_groups.
     * @param {service_groupCreateManyArgs} args - Arguments to create many Service_groups.
     * @example
     * // Create many Service_groups
     * const service_group = await prisma.service_group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_groupCreateManyArgs>(args?: SelectSubset<T, service_groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service_group.
     * @param {service_groupDeleteArgs} args - Arguments to delete one Service_group.
     * @example
     * // Delete one Service_group
     * const Service_group = await prisma.service_group.delete({
     *   where: {
     *     // ... filter to delete one Service_group
     *   }
     * })
     * 
     */
    delete<T extends service_groupDeleteArgs>(args: SelectSubset<T, service_groupDeleteArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service_group.
     * @param {service_groupUpdateArgs} args - Arguments to update one Service_group.
     * @example
     * // Update one Service_group
     * const service_group = await prisma.service_group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_groupUpdateArgs>(args: SelectSubset<T, service_groupUpdateArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Service_groups.
     * @param {service_groupDeleteManyArgs} args - Arguments to filter Service_groups to delete.
     * @example
     * // Delete a few Service_groups
     * const { count } = await prisma.service_group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_groupDeleteManyArgs>(args?: SelectSubset<T, service_groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_groups
     * const service_group = await prisma.service_group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_groupUpdateManyArgs>(args: SelectSubset<T, service_groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service_group.
     * @param {service_groupUpsertArgs} args - Arguments to update or create a Service_group.
     * @example
     * // Update or create a Service_group
     * const service_group = await prisma.service_group.upsert({
     *   create: {
     *     // ... data to create a Service_group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_group we want to update
     *   }
     * })
     */
    upsert<T extends service_groupUpsertArgs>(args: SelectSubset<T, service_groupUpsertArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Service_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_groupCountArgs} args - Arguments to filter Service_groups to count.
     * @example
     * // Count the number of Service_groups
     * const count = await prisma.service_group.count({
     *   where: {
     *     // ... the filter for the Service_groups we want to count
     *   }
     * })
    **/
    count<T extends service_groupCountArgs>(
      args?: Subset<T, service_groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_groupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_groupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_groupAggregateArgs>(args: Subset<T, Service_groupAggregateArgs>): Prisma.PrismaPromise<GetService_groupAggregateType<T>>

    /**
     * Group by Service_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_groupGroupByArgs['orderBy'] }
        : { orderBy?: service_groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_groupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_group model
   */
  readonly fields: service_groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends service_group$serviceArgs<ExtArgs> = {}>(args?: Subset<T, service_group$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceReview<T extends service_group$serviceReviewArgs<ExtArgs> = {}>(args?: Subset<T, service_group$serviceReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    surveyQuestions<T extends service_group$surveyQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, service_group$surveyQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_group model
   */
  interface service_groupFieldRefs {
    readonly id: FieldRef<"service_group", 'Int'>
    readonly name: FieldRef<"service_group", 'String'>
    readonly name_rw: FieldRef<"service_group", 'String'>
    readonly name_fr: FieldRef<"service_group", 'String'>
    readonly name_sw: FieldRef<"service_group", 'String'>
    readonly search_term: FieldRef<"service_group", 'String'>
    readonly institution_id: FieldRef<"service_group", 'Int'>
    readonly created_at: FieldRef<"service_group", 'DateTime'>
    readonly updated_at: FieldRef<"service_group", 'DateTime'>
    readonly uuid: FieldRef<"service_group", 'String'>
    readonly status: FieldRef<"service_group", 'Int'>
    readonly good_ratings: FieldRef<"service_group", 'Int'>
    readonly bad_ratings: FieldRef<"service_group", 'Int'>
    readonly excellent_ratings: FieldRef<"service_group", 'Int'>
    readonly nps: FieldRef<"service_group", 'Int'>
    readonly csat: FieldRef<"service_group", 'Int'>
    readonly mean_service_time: FieldRef<"service_group", 'Int'>
    readonly ticket_prefix: FieldRef<"service_group", 'String'>
    readonly bad_rating_threshold: FieldRef<"service_group", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * service_group findUnique
   */
  export type service_groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * Filter, which service_group to fetch.
     */
    where: service_groupWhereUniqueInput
  }

  /**
   * service_group findUniqueOrThrow
   */
  export type service_groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * Filter, which service_group to fetch.
     */
    where: service_groupWhereUniqueInput
  }

  /**
   * service_group findFirst
   */
  export type service_groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * Filter, which service_group to fetch.
     */
    where?: service_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_groups to fetch.
     */
    orderBy?: service_groupOrderByWithRelationInput | service_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_groups.
     */
    cursor?: service_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_groups.
     */
    distinct?: Service_groupScalarFieldEnum | Service_groupScalarFieldEnum[]
  }

  /**
   * service_group findFirstOrThrow
   */
  export type service_groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * Filter, which service_group to fetch.
     */
    where?: service_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_groups to fetch.
     */
    orderBy?: service_groupOrderByWithRelationInput | service_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_groups.
     */
    cursor?: service_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_groups.
     */
    distinct?: Service_groupScalarFieldEnum | Service_groupScalarFieldEnum[]
  }

  /**
   * service_group findMany
   */
  export type service_groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * Filter, which service_groups to fetch.
     */
    where?: service_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_groups to fetch.
     */
    orderBy?: service_groupOrderByWithRelationInput | service_groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_groups.
     */
    cursor?: service_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_groups.
     */
    skip?: number
    distinct?: Service_groupScalarFieldEnum | Service_groupScalarFieldEnum[]
  }

  /**
   * service_group create
   */
  export type service_groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * The data needed to create a service_group.
     */
    data: XOR<service_groupCreateInput, service_groupUncheckedCreateInput>
  }

  /**
   * service_group createMany
   */
  export type service_groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_groups.
     */
    data: service_groupCreateManyInput | service_groupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_group update
   */
  export type service_groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * The data needed to update a service_group.
     */
    data: XOR<service_groupUpdateInput, service_groupUncheckedUpdateInput>
    /**
     * Choose, which service_group to update.
     */
    where: service_groupWhereUniqueInput
  }

  /**
   * service_group updateMany
   */
  export type service_groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_groups.
     */
    data: XOR<service_groupUpdateManyMutationInput, service_groupUncheckedUpdateManyInput>
    /**
     * Filter which service_groups to update
     */
    where?: service_groupWhereInput
    /**
     * Limit how many service_groups to update.
     */
    limit?: number
  }

  /**
   * service_group upsert
   */
  export type service_groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * The filter to search for the service_group to update in case it exists.
     */
    where: service_groupWhereUniqueInput
    /**
     * In case the service_group found by the `where` argument doesn't exist, create a new service_group with this data.
     */
    create: XOR<service_groupCreateInput, service_groupUncheckedCreateInput>
    /**
     * In case the service_group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_groupUpdateInput, service_groupUncheckedUpdateInput>
  }

  /**
   * service_group delete
   */
  export type service_groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    /**
     * Filter which service_group to delete.
     */
    where: service_groupWhereUniqueInput
  }

  /**
   * service_group deleteMany
   */
  export type service_groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_groups to delete
     */
    where?: service_groupWhereInput
    /**
     * Limit how many service_groups to delete.
     */
    limit?: number
  }

  /**
   * service_group.service
   */
  export type service_group$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    cursor?: serviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service_group.serviceReview
   */
  export type service_group$serviceReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    where?: serviceReviewWhereInput
    orderBy?: serviceReviewOrderByWithRelationInput | serviceReviewOrderByWithRelationInput[]
    cursor?: serviceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceReviewScalarFieldEnum | ServiceReviewScalarFieldEnum[]
  }

  /**
   * service_group.surveyQuestions
   */
  export type service_group$surveyQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    where?: surveyQuestionsWhereInput
    orderBy?: surveyQuestionsOrderByWithRelationInput | surveyQuestionsOrderByWithRelationInput[]
    cursor?: surveyQuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyQuestionsScalarFieldEnum | SurveyQuestionsScalarFieldEnum[]
  }

  /**
   * service_group without action
   */
  export type service_groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
  }


  /**
   * Model survey
   */

  export type AggregateSurvey = {
    _count: SurveyCountAggregateOutputType | null
    _avg: SurveyAvgAggregateOutputType | null
    _sum: SurveySumAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  export type SurveyAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
  }

  export type SurveySumAggregateOutputType = {
    id: number | null
    institution_id: number | null
  }

  export type SurveyMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    type: boolean | null
    name: string | null
    description: string | null
    url: string | null
    survey_data: string | null
    institution_id: number | null
    service_id: string | null
    created_at: Date | null
    updated_at: Date | null
    status: boolean | null
    access_key: string | null
  }

  export type SurveyMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    type: boolean | null
    name: string | null
    description: string | null
    url: string | null
    survey_data: string | null
    institution_id: number | null
    service_id: string | null
    created_at: Date | null
    updated_at: Date | null
    status: boolean | null
    access_key: string | null
  }

  export type SurveyCountAggregateOutputType = {
    id: number
    uuid: number
    type: number
    name: number
    description: number
    url: number
    survey_data: number
    institution_id: number
    service_id: number
    created_at: number
    updated_at: number
    status: number
    access_key: number
    _all: number
  }


  export type SurveyAvgAggregateInputType = {
    id?: true
    institution_id?: true
  }

  export type SurveySumAggregateInputType = {
    id?: true
    institution_id?: true
  }

  export type SurveyMinAggregateInputType = {
    id?: true
    uuid?: true
    type?: true
    name?: true
    description?: true
    url?: true
    survey_data?: true
    institution_id?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    status?: true
    access_key?: true
  }

  export type SurveyMaxAggregateInputType = {
    id?: true
    uuid?: true
    type?: true
    name?: true
    description?: true
    url?: true
    survey_data?: true
    institution_id?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    status?: true
    access_key?: true
  }

  export type SurveyCountAggregateInputType = {
    id?: true
    uuid?: true
    type?: true
    name?: true
    description?: true
    url?: true
    survey_data?: true
    institution_id?: true
    service_id?: true
    created_at?: true
    updated_at?: true
    status?: true
    access_key?: true
    _all?: true
  }

  export type SurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which survey to aggregate.
     */
    where?: surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveyOrderByWithRelationInput | surveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surveys
    **/
    _count?: true | SurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyMaxAggregateInputType
  }

  export type GetSurveyAggregateType<T extends SurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvey[P]>
      : GetScalarType<T[P], AggregateSurvey[P]>
  }




  export type surveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyWhereInput
    orderBy?: surveyOrderByWithAggregationInput | surveyOrderByWithAggregationInput[]
    by: SurveyScalarFieldEnum[] | SurveyScalarFieldEnum
    having?: surveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyCountAggregateInputType | true
    _avg?: SurveyAvgAggregateInputType
    _sum?: SurveySumAggregateInputType
    _min?: SurveyMinAggregateInputType
    _max?: SurveyMaxAggregateInputType
  }

  export type SurveyGroupByOutputType = {
    id: number
    uuid: string | null
    type: boolean | null
    name: string
    description: string
    url: string | null
    survey_data: string | null
    institution_id: number
    service_id: string
    created_at: Date
    updated_at: Date
    status: boolean | null
    access_key: string | null
    _count: SurveyCountAggregateOutputType | null
    _avg: SurveyAvgAggregateOutputType | null
    _sum: SurveySumAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  type GetSurveyGroupByPayload<T extends surveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyGroupByOutputType[P]>
        }
      >
    >


  export type surveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    survey_data?: boolean
    institution_id?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    access_key?: boolean
  }, ExtArgs["result"]["survey"]>



  export type surveySelectScalar = {
    id?: boolean
    uuid?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    survey_data?: boolean
    institution_id?: boolean
    service_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    access_key?: boolean
  }

  export type surveyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "type" | "name" | "description" | "url" | "survey_data" | "institution_id" | "service_id" | "created_at" | "updated_at" | "status" | "access_key", ExtArgs["result"]["survey"]>

  export type $surveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "survey"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string | null
      type: boolean | null
      name: string
      description: string
      url: string | null
      survey_data: string | null
      institution_id: number
      service_id: string
      created_at: Date
      updated_at: Date
      status: boolean | null
      access_key: string | null
    }, ExtArgs["result"]["survey"]>
    composites: {}
  }

  type surveyGetPayload<S extends boolean | null | undefined | surveyDefaultArgs> = $Result.GetResult<Prisma.$surveyPayload, S>

  type surveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surveyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyCountAggregateInputType | true
    }

  export interface surveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['survey'], meta: { name: 'survey' } }
    /**
     * Find zero or one Survey that matches the filter.
     * @param {surveyFindUniqueArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surveyFindUniqueArgs>(args: SelectSubset<T, surveyFindUniqueArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Survey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surveyFindUniqueOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surveyFindUniqueOrThrowArgs>(args: SelectSubset<T, surveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Survey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyFindFirstArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surveyFindFirstArgs>(args?: SelectSubset<T, surveyFindFirstArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Survey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyFindFirstOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surveyFindFirstOrThrowArgs>(args?: SelectSubset<T, surveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.survey.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.survey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyWithIdOnly = await prisma.survey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends surveyFindManyArgs>(args?: SelectSubset<T, surveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Survey.
     * @param {surveyCreateArgs} args - Arguments to create a Survey.
     * @example
     * // Create one Survey
     * const Survey = await prisma.survey.create({
     *   data: {
     *     // ... data to create a Survey
     *   }
     * })
     * 
     */
    create<T extends surveyCreateArgs>(args: SelectSubset<T, surveyCreateArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Surveys.
     * @param {surveyCreateManyArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const survey = await prisma.survey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surveyCreateManyArgs>(args?: SelectSubset<T, surveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Survey.
     * @param {surveyDeleteArgs} args - Arguments to delete one Survey.
     * @example
     * // Delete one Survey
     * const Survey = await prisma.survey.delete({
     *   where: {
     *     // ... filter to delete one Survey
     *   }
     * })
     * 
     */
    delete<T extends surveyDeleteArgs>(args: SelectSubset<T, surveyDeleteArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Survey.
     * @param {surveyUpdateArgs} args - Arguments to update one Survey.
     * @example
     * // Update one Survey
     * const survey = await prisma.survey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surveyUpdateArgs>(args: SelectSubset<T, surveyUpdateArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Surveys.
     * @param {surveyDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.survey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surveyDeleteManyArgs>(args?: SelectSubset<T, surveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const survey = await prisma.survey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surveyUpdateManyArgs>(args: SelectSubset<T, surveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Survey.
     * @param {surveyUpsertArgs} args - Arguments to update or create a Survey.
     * @example
     * // Update or create a Survey
     * const survey = await prisma.survey.upsert({
     *   create: {
     *     // ... data to create a Survey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Survey we want to update
     *   }
     * })
     */
    upsert<T extends surveyUpsertArgs>(args: SelectSubset<T, surveyUpsertArgs<ExtArgs>>): Prisma__surveyClient<$Result.GetResult<Prisma.$surveyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.survey.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends surveyCountArgs>(
      args?: Subset<T, surveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAggregateArgs>(args: Subset<T, SurveyAggregateArgs>): Prisma.PrismaPromise<GetSurveyAggregateType<T>>

    /**
     * Group by Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surveyGroupByArgs['orderBy'] }
        : { orderBy?: surveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the survey model
   */
  readonly fields: surveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for survey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the survey model
   */
  interface surveyFieldRefs {
    readonly id: FieldRef<"survey", 'Int'>
    readonly uuid: FieldRef<"survey", 'String'>
    readonly type: FieldRef<"survey", 'Boolean'>
    readonly name: FieldRef<"survey", 'String'>
    readonly description: FieldRef<"survey", 'String'>
    readonly url: FieldRef<"survey", 'String'>
    readonly survey_data: FieldRef<"survey", 'String'>
    readonly institution_id: FieldRef<"survey", 'Int'>
    readonly service_id: FieldRef<"survey", 'String'>
    readonly created_at: FieldRef<"survey", 'DateTime'>
    readonly updated_at: FieldRef<"survey", 'DateTime'>
    readonly status: FieldRef<"survey", 'Boolean'>
    readonly access_key: FieldRef<"survey", 'String'>
  }
    

  // Custom InputTypes
  /**
   * survey findUnique
   */
  export type surveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * Filter, which survey to fetch.
     */
    where: surveyWhereUniqueInput
  }

  /**
   * survey findUniqueOrThrow
   */
  export type surveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * Filter, which survey to fetch.
     */
    where: surveyWhereUniqueInput
  }

  /**
   * survey findFirst
   */
  export type surveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * Filter, which survey to fetch.
     */
    where?: surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveyOrderByWithRelationInput | surveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveys.
     */
    cursor?: surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * survey findFirstOrThrow
   */
  export type surveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * Filter, which survey to fetch.
     */
    where?: surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveyOrderByWithRelationInput | surveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveys.
     */
    cursor?: surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * survey findMany
   */
  export type surveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveyOrderByWithRelationInput | surveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surveys.
     */
    cursor?: surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * survey create
   */
  export type surveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * The data needed to create a survey.
     */
    data: XOR<surveyCreateInput, surveyUncheckedCreateInput>
  }

  /**
   * survey createMany
   */
  export type surveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surveys.
     */
    data: surveyCreateManyInput | surveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * survey update
   */
  export type surveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * The data needed to update a survey.
     */
    data: XOR<surveyUpdateInput, surveyUncheckedUpdateInput>
    /**
     * Choose, which survey to update.
     */
    where: surveyWhereUniqueInput
  }

  /**
   * survey updateMany
   */
  export type surveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surveys.
     */
    data: XOR<surveyUpdateManyMutationInput, surveyUncheckedUpdateManyInput>
    /**
     * Filter which surveys to update
     */
    where?: surveyWhereInput
    /**
     * Limit how many surveys to update.
     */
    limit?: number
  }

  /**
   * survey upsert
   */
  export type surveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * The filter to search for the survey to update in case it exists.
     */
    where: surveyWhereUniqueInput
    /**
     * In case the survey found by the `where` argument doesn't exist, create a new survey with this data.
     */
    create: XOR<surveyCreateInput, surveyUncheckedCreateInput>
    /**
     * In case the survey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surveyUpdateInput, surveyUncheckedUpdateInput>
  }

  /**
   * survey delete
   */
  export type surveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
    /**
     * Filter which survey to delete.
     */
    where: surveyWhereUniqueInput
  }

  /**
   * survey deleteMany
   */
  export type surveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveys to delete
     */
    where?: surveyWhereInput
    /**
     * Limit how many surveys to delete.
     */
    limit?: number
  }

  /**
   * survey without action
   */
  export type surveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey
     */
    select?: surveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey
     */
    omit?: surveyOmit<ExtArgs> | null
  }


  /**
   * Model survey_result
   */

  export type AggregateSurvey_result = {
    _count: Survey_resultCountAggregateOutputType | null
    _avg: Survey_resultAvgAggregateOutputType | null
    _sum: Survey_resultSumAggregateOutputType | null
    _min: Survey_resultMinAggregateOutputType | null
    _max: Survey_resultMaxAggregateOutputType | null
  }

  export type Survey_resultAvgAggregateOutputType = {
    id: number | null
    survey_id: number | null
    rating_id: number | null
    service_id: number | null
    device_id: number | null
  }

  export type Survey_resultSumAggregateOutputType = {
    id: number | null
    survey_id: number | null
    rating_id: number | null
    service_id: number | null
    device_id: number | null
  }

  export type Survey_resultMinAggregateOutputType = {
    id: number | null
    survey_id: number | null
    rating_id: number | null
    service_id: number | null
    device_id: number | null
    agent: string | null
    result_data: string | null
    replied_at: Date | null
  }

  export type Survey_resultMaxAggregateOutputType = {
    id: number | null
    survey_id: number | null
    rating_id: number | null
    service_id: number | null
    device_id: number | null
    agent: string | null
    result_data: string | null
    replied_at: Date | null
  }

  export type Survey_resultCountAggregateOutputType = {
    id: number
    survey_id: number
    rating_id: number
    service_id: number
    device_id: number
    agent: number
    result_data: number
    replied_at: number
    _all: number
  }


  export type Survey_resultAvgAggregateInputType = {
    id?: true
    survey_id?: true
    rating_id?: true
    service_id?: true
    device_id?: true
  }

  export type Survey_resultSumAggregateInputType = {
    id?: true
    survey_id?: true
    rating_id?: true
    service_id?: true
    device_id?: true
  }

  export type Survey_resultMinAggregateInputType = {
    id?: true
    survey_id?: true
    rating_id?: true
    service_id?: true
    device_id?: true
    agent?: true
    result_data?: true
    replied_at?: true
  }

  export type Survey_resultMaxAggregateInputType = {
    id?: true
    survey_id?: true
    rating_id?: true
    service_id?: true
    device_id?: true
    agent?: true
    result_data?: true
    replied_at?: true
  }

  export type Survey_resultCountAggregateInputType = {
    id?: true
    survey_id?: true
    rating_id?: true
    service_id?: true
    device_id?: true
    agent?: true
    result_data?: true
    replied_at?: true
    _all?: true
  }

  export type Survey_resultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which survey_result to aggregate.
     */
    where?: survey_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of survey_results to fetch.
     */
    orderBy?: survey_resultOrderByWithRelationInput | survey_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: survey_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` survey_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` survey_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned survey_results
    **/
    _count?: true | Survey_resultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Survey_resultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Survey_resultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Survey_resultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Survey_resultMaxAggregateInputType
  }

  export type GetSurvey_resultAggregateType<T extends Survey_resultAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvey_result]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvey_result[P]>
      : GetScalarType<T[P], AggregateSurvey_result[P]>
  }




  export type survey_resultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: survey_resultWhereInput
    orderBy?: survey_resultOrderByWithAggregationInput | survey_resultOrderByWithAggregationInput[]
    by: Survey_resultScalarFieldEnum[] | Survey_resultScalarFieldEnum
    having?: survey_resultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Survey_resultCountAggregateInputType | true
    _avg?: Survey_resultAvgAggregateInputType
    _sum?: Survey_resultSumAggregateInputType
    _min?: Survey_resultMinAggregateInputType
    _max?: Survey_resultMaxAggregateInputType
  }

  export type Survey_resultGroupByOutputType = {
    id: number
    survey_id: number
    rating_id: number | null
    service_id: number | null
    device_id: number | null
    agent: string | null
    result_data: string
    replied_at: Date | null
    _count: Survey_resultCountAggregateOutputType | null
    _avg: Survey_resultAvgAggregateOutputType | null
    _sum: Survey_resultSumAggregateOutputType | null
    _min: Survey_resultMinAggregateOutputType | null
    _max: Survey_resultMaxAggregateOutputType | null
  }

  type GetSurvey_resultGroupByPayload<T extends survey_resultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Survey_resultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Survey_resultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Survey_resultGroupByOutputType[P]>
            : GetScalarType<T[P], Survey_resultGroupByOutputType[P]>
        }
      >
    >


  export type survey_resultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    survey_id?: boolean
    rating_id?: boolean
    service_id?: boolean
    device_id?: boolean
    agent?: boolean
    result_data?: boolean
    replied_at?: boolean
  }, ExtArgs["result"]["survey_result"]>



  export type survey_resultSelectScalar = {
    id?: boolean
    survey_id?: boolean
    rating_id?: boolean
    service_id?: boolean
    device_id?: boolean
    agent?: boolean
    result_data?: boolean
    replied_at?: boolean
  }

  export type survey_resultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "survey_id" | "rating_id" | "service_id" | "device_id" | "agent" | "result_data" | "replied_at", ExtArgs["result"]["survey_result"]>

  export type $survey_resultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "survey_result"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      survey_id: number
      rating_id: number | null
      service_id: number | null
      device_id: number | null
      agent: string | null
      result_data: string
      replied_at: Date | null
    }, ExtArgs["result"]["survey_result"]>
    composites: {}
  }

  type survey_resultGetPayload<S extends boolean | null | undefined | survey_resultDefaultArgs> = $Result.GetResult<Prisma.$survey_resultPayload, S>

  type survey_resultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<survey_resultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Survey_resultCountAggregateInputType | true
    }

  export interface survey_resultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['survey_result'], meta: { name: 'survey_result' } }
    /**
     * Find zero or one Survey_result that matches the filter.
     * @param {survey_resultFindUniqueArgs} args - Arguments to find a Survey_result
     * @example
     * // Get one Survey_result
     * const survey_result = await prisma.survey_result.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends survey_resultFindUniqueArgs>(args: SelectSubset<T, survey_resultFindUniqueArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Survey_result that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {survey_resultFindUniqueOrThrowArgs} args - Arguments to find a Survey_result
     * @example
     * // Get one Survey_result
     * const survey_result = await prisma.survey_result.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends survey_resultFindUniqueOrThrowArgs>(args: SelectSubset<T, survey_resultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Survey_result that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {survey_resultFindFirstArgs} args - Arguments to find a Survey_result
     * @example
     * // Get one Survey_result
     * const survey_result = await prisma.survey_result.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends survey_resultFindFirstArgs>(args?: SelectSubset<T, survey_resultFindFirstArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Survey_result that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {survey_resultFindFirstOrThrowArgs} args - Arguments to find a Survey_result
     * @example
     * // Get one Survey_result
     * const survey_result = await prisma.survey_result.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends survey_resultFindFirstOrThrowArgs>(args?: SelectSubset<T, survey_resultFindFirstOrThrowArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Survey_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {survey_resultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Survey_results
     * const survey_results = await prisma.survey_result.findMany()
     * 
     * // Get first 10 Survey_results
     * const survey_results = await prisma.survey_result.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const survey_resultWithIdOnly = await prisma.survey_result.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends survey_resultFindManyArgs>(args?: SelectSubset<T, survey_resultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Survey_result.
     * @param {survey_resultCreateArgs} args - Arguments to create a Survey_result.
     * @example
     * // Create one Survey_result
     * const Survey_result = await prisma.survey_result.create({
     *   data: {
     *     // ... data to create a Survey_result
     *   }
     * })
     * 
     */
    create<T extends survey_resultCreateArgs>(args: SelectSubset<T, survey_resultCreateArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Survey_results.
     * @param {survey_resultCreateManyArgs} args - Arguments to create many Survey_results.
     * @example
     * // Create many Survey_results
     * const survey_result = await prisma.survey_result.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends survey_resultCreateManyArgs>(args?: SelectSubset<T, survey_resultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Survey_result.
     * @param {survey_resultDeleteArgs} args - Arguments to delete one Survey_result.
     * @example
     * // Delete one Survey_result
     * const Survey_result = await prisma.survey_result.delete({
     *   where: {
     *     // ... filter to delete one Survey_result
     *   }
     * })
     * 
     */
    delete<T extends survey_resultDeleteArgs>(args: SelectSubset<T, survey_resultDeleteArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Survey_result.
     * @param {survey_resultUpdateArgs} args - Arguments to update one Survey_result.
     * @example
     * // Update one Survey_result
     * const survey_result = await prisma.survey_result.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends survey_resultUpdateArgs>(args: SelectSubset<T, survey_resultUpdateArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Survey_results.
     * @param {survey_resultDeleteManyArgs} args - Arguments to filter Survey_results to delete.
     * @example
     * // Delete a few Survey_results
     * const { count } = await prisma.survey_result.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends survey_resultDeleteManyArgs>(args?: SelectSubset<T, survey_resultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Survey_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {survey_resultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Survey_results
     * const survey_result = await prisma.survey_result.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends survey_resultUpdateManyArgs>(args: SelectSubset<T, survey_resultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Survey_result.
     * @param {survey_resultUpsertArgs} args - Arguments to update or create a Survey_result.
     * @example
     * // Update or create a Survey_result
     * const survey_result = await prisma.survey_result.upsert({
     *   create: {
     *     // ... data to create a Survey_result
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Survey_result we want to update
     *   }
     * })
     */
    upsert<T extends survey_resultUpsertArgs>(args: SelectSubset<T, survey_resultUpsertArgs<ExtArgs>>): Prisma__survey_resultClient<$Result.GetResult<Prisma.$survey_resultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Survey_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {survey_resultCountArgs} args - Arguments to filter Survey_results to count.
     * @example
     * // Count the number of Survey_results
     * const count = await prisma.survey_result.count({
     *   where: {
     *     // ... the filter for the Survey_results we want to count
     *   }
     * })
    **/
    count<T extends survey_resultCountArgs>(
      args?: Subset<T, survey_resultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Survey_resultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Survey_result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Survey_resultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Survey_resultAggregateArgs>(args: Subset<T, Survey_resultAggregateArgs>): Prisma.PrismaPromise<GetSurvey_resultAggregateType<T>>

    /**
     * Group by Survey_result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {survey_resultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends survey_resultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: survey_resultGroupByArgs['orderBy'] }
        : { orderBy?: survey_resultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, survey_resultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurvey_resultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the survey_result model
   */
  readonly fields: survey_resultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for survey_result.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__survey_resultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the survey_result model
   */
  interface survey_resultFieldRefs {
    readonly id: FieldRef<"survey_result", 'Int'>
    readonly survey_id: FieldRef<"survey_result", 'Int'>
    readonly rating_id: FieldRef<"survey_result", 'Int'>
    readonly service_id: FieldRef<"survey_result", 'Int'>
    readonly device_id: FieldRef<"survey_result", 'Int'>
    readonly agent: FieldRef<"survey_result", 'String'>
    readonly result_data: FieldRef<"survey_result", 'String'>
    readonly replied_at: FieldRef<"survey_result", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * survey_result findUnique
   */
  export type survey_resultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * Filter, which survey_result to fetch.
     */
    where: survey_resultWhereUniqueInput
  }

  /**
   * survey_result findUniqueOrThrow
   */
  export type survey_resultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * Filter, which survey_result to fetch.
     */
    where: survey_resultWhereUniqueInput
  }

  /**
   * survey_result findFirst
   */
  export type survey_resultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * Filter, which survey_result to fetch.
     */
    where?: survey_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of survey_results to fetch.
     */
    orderBy?: survey_resultOrderByWithRelationInput | survey_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for survey_results.
     */
    cursor?: survey_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` survey_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` survey_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of survey_results.
     */
    distinct?: Survey_resultScalarFieldEnum | Survey_resultScalarFieldEnum[]
  }

  /**
   * survey_result findFirstOrThrow
   */
  export type survey_resultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * Filter, which survey_result to fetch.
     */
    where?: survey_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of survey_results to fetch.
     */
    orderBy?: survey_resultOrderByWithRelationInput | survey_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for survey_results.
     */
    cursor?: survey_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` survey_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` survey_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of survey_results.
     */
    distinct?: Survey_resultScalarFieldEnum | Survey_resultScalarFieldEnum[]
  }

  /**
   * survey_result findMany
   */
  export type survey_resultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * Filter, which survey_results to fetch.
     */
    where?: survey_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of survey_results to fetch.
     */
    orderBy?: survey_resultOrderByWithRelationInput | survey_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing survey_results.
     */
    cursor?: survey_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` survey_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` survey_results.
     */
    skip?: number
    distinct?: Survey_resultScalarFieldEnum | Survey_resultScalarFieldEnum[]
  }

  /**
   * survey_result create
   */
  export type survey_resultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * The data needed to create a survey_result.
     */
    data: XOR<survey_resultCreateInput, survey_resultUncheckedCreateInput>
  }

  /**
   * survey_result createMany
   */
  export type survey_resultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many survey_results.
     */
    data: survey_resultCreateManyInput | survey_resultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * survey_result update
   */
  export type survey_resultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * The data needed to update a survey_result.
     */
    data: XOR<survey_resultUpdateInput, survey_resultUncheckedUpdateInput>
    /**
     * Choose, which survey_result to update.
     */
    where: survey_resultWhereUniqueInput
  }

  /**
   * survey_result updateMany
   */
  export type survey_resultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update survey_results.
     */
    data: XOR<survey_resultUpdateManyMutationInput, survey_resultUncheckedUpdateManyInput>
    /**
     * Filter which survey_results to update
     */
    where?: survey_resultWhereInput
    /**
     * Limit how many survey_results to update.
     */
    limit?: number
  }

  /**
   * survey_result upsert
   */
  export type survey_resultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * The filter to search for the survey_result to update in case it exists.
     */
    where: survey_resultWhereUniqueInput
    /**
     * In case the survey_result found by the `where` argument doesn't exist, create a new survey_result with this data.
     */
    create: XOR<survey_resultCreateInput, survey_resultUncheckedCreateInput>
    /**
     * In case the survey_result was found with the provided `where` argument, update it with this data.
     */
    update: XOR<survey_resultUpdateInput, survey_resultUncheckedUpdateInput>
  }

  /**
   * survey_result delete
   */
  export type survey_resultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
    /**
     * Filter which survey_result to delete.
     */
    where: survey_resultWhereUniqueInput
  }

  /**
   * survey_result deleteMany
   */
  export type survey_resultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which survey_results to delete
     */
    where?: survey_resultWhereInput
    /**
     * Limit how many survey_results to delete.
     */
    limit?: number
  }

  /**
   * survey_result without action
   */
  export type survey_resultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the survey_result
     */
    select?: survey_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the survey_result
     */
    omit?: survey_resultOmit<ExtArgs> | null
  }


  /**
   * Model tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type TagsSumAggregateOutputType = {
    id: number | null
    created_by: number | null
    updated_by: number | null
  }

  export type TagsMinAggregateOutputType = {
    id: number | null
    name: string | null
    services: string | null
    created_at: Date | null
    created_by: number | null
    updated_by: number | null
    status: boolean | null
  }

  export type TagsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    services: string | null
    created_at: Date | null
    created_by: number | null
    updated_by: number | null
    status: boolean | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    services: number
    created_at: number
    created_by: number
    updated_by: number
    status: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type TagsSumAggregateInputType = {
    id?: true
    created_by?: true
    updated_by?: true
  }

  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    services?: true
    created_at?: true
    created_by?: true
    updated_by?: true
    status?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    services?: true
    created_at?: true
    created_by?: true
    updated_by?: true
    status?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    services?: true
    created_at?: true
    created_by?: true
    updated_by?: true
    status?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to aggregate.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithAggregationInput | tagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: number
    name: string
    services: string
    created_at: Date | null
    created_by: number
    updated_by: number | null
    status: boolean | null
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    services?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    status?: boolean
    user_tags_created_byTouser?: boolean | userDefaultArgs<ExtArgs>
    user_tags_updated_byTouser?: boolean | tags$user_tags_updated_byTouserArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>



  export type tagsSelectScalar = {
    id?: boolean
    name?: boolean
    services?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_by?: boolean
    status?: boolean
  }

  export type tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "services" | "created_at" | "created_by" | "updated_by" | "status", ExtArgs["result"]["tags"]>
  export type tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_tags_created_byTouser?: boolean | userDefaultArgs<ExtArgs>
    user_tags_updated_byTouser?: boolean | tags$user_tags_updated_byTouserArgs<ExtArgs>
  }

  export type $tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tags"
    objects: {
      user_tags_created_byTouser: Prisma.$userPayload<ExtArgs>
      user_tags_updated_byTouser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      services: string
      created_at: Date | null
      created_by: number
      updated_by: number | null
      status: boolean | null
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type tagsGetPayload<S extends boolean | null | undefined | tagsDefaultArgs> = $Result.GetResult<Prisma.$tagsPayload, S>

  type tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tags'], meta: { name: 'tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {tagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagsFindUniqueArgs>(args: SelectSubset<T, tagsFindUniqueArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagsFindFirstArgs>(args?: SelectSubset<T, tagsFindFirstArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagsFindManyArgs>(args?: SelectSubset<T, tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {tagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends tagsCreateArgs>(args: SelectSubset<T, tagsCreateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {tagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagsCreateManyArgs>(args?: SelectSubset<T, tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {tagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends tagsDeleteArgs>(args: SelectSubset<T, tagsDeleteArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {tagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagsUpdateArgs>(args: SelectSubset<T, tagsUpdateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagsDeleteManyArgs>(args?: SelectSubset<T, tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagsUpdateManyArgs>(args: SelectSubset<T, tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {tagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends tagsUpsertArgs>(args: SelectSubset<T, tagsUpsertArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagsCountArgs>(
      args?: Subset<T, tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsGroupByArgs['orderBy'] }
        : { orderBy?: tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tags model
   */
  readonly fields: tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_tags_created_byTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_tags_updated_byTouser<T extends tags$user_tags_updated_byTouserArgs<ExtArgs> = {}>(args?: Subset<T, tags$user_tags_updated_byTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tags model
   */
  interface tagsFieldRefs {
    readonly id: FieldRef<"tags", 'Int'>
    readonly name: FieldRef<"tags", 'String'>
    readonly services: FieldRef<"tags", 'String'>
    readonly created_at: FieldRef<"tags", 'DateTime'>
    readonly created_by: FieldRef<"tags", 'Int'>
    readonly updated_by: FieldRef<"tags", 'Int'>
    readonly status: FieldRef<"tags", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * tags findUnique
   */
  export type tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findUniqueOrThrow
   */
  export type tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findFirst
   */
  export type tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findFirstOrThrow
   */
  export type tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findMany
   */
  export type tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags create
   */
  export type tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a tags.
     */
    data: XOR<tagsCreateInput, tagsUncheckedCreateInput>
  }

  /**
   * tags createMany
   */
  export type tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags update
   */
  export type tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a tags.
     */
    data: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
    /**
     * Choose, which tags to update.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags updateMany
   */
  export type tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tags upsert
   */
  export type tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the tags to update in case it exists.
     */
    where: tagsWhereUniqueInput
    /**
     * In case the tags found by the `where` argument doesn't exist, create a new tags with this data.
     */
    create: XOR<tagsCreateInput, tagsUncheckedCreateInput>
    /**
     * In case the tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
  }

  /**
   * tags delete
   */
  export type tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter which tags to delete.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags deleteMany
   */
  export type tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to delete.
     */
    limit?: number
  }

  /**
   * tags.user_tags_updated_byTouser
   */
  export type tags$user_tags_updated_byTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * tags without action
   */
  export type tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
  }


  /**
   * Model tip
   */

  export type AggregateTip = {
    _count: TipCountAggregateOutputType | null
    _avg: TipAvgAggregateOutputType | null
    _sum: TipSumAggregateOutputType | null
    _min: TipMinAggregateOutputType | null
    _max: TipMaxAggregateOutputType | null
  }

  export type TipAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    rating_id: number | null
    amount: number | null
    tip_amount: number | null
  }

  export type TipSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    rating_id: bigint | null
    amount: number | null
    tip_amount: number | null
  }

  export type TipMinAggregateOutputType = {
    id: number | null
    collection_reference_id: string | null
    disbursement_reference_id: string | null
    device_id: number | null
    rating_id: bigint | null
    payee: string | null
    payer: string | null
    amount: number | null
    tip_amount: number | null
    collection_status: string | null
    collection_status_details: string | null
    closed_at: Date | null
    disbursed_at: Date | null
    disbursement_status: string | null
    disbursement_status_details: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TipMaxAggregateOutputType = {
    id: number | null
    collection_reference_id: string | null
    disbursement_reference_id: string | null
    device_id: number | null
    rating_id: bigint | null
    payee: string | null
    payer: string | null
    amount: number | null
    tip_amount: number | null
    collection_status: string | null
    collection_status_details: string | null
    closed_at: Date | null
    disbursed_at: Date | null
    disbursement_status: string | null
    disbursement_status_details: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TipCountAggregateOutputType = {
    id: number
    collection_reference_id: number
    disbursement_reference_id: number
    device_id: number
    rating_id: number
    payee: number
    payer: number
    amount: number
    tip_amount: number
    collection_status: number
    collection_status_details: number
    closed_at: number
    disbursed_at: number
    disbursement_status: number
    disbursement_status_details: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TipAvgAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    amount?: true
    tip_amount?: true
  }

  export type TipSumAggregateInputType = {
    id?: true
    device_id?: true
    rating_id?: true
    amount?: true
    tip_amount?: true
  }

  export type TipMinAggregateInputType = {
    id?: true
    collection_reference_id?: true
    disbursement_reference_id?: true
    device_id?: true
    rating_id?: true
    payee?: true
    payer?: true
    amount?: true
    tip_amount?: true
    collection_status?: true
    collection_status_details?: true
    closed_at?: true
    disbursed_at?: true
    disbursement_status?: true
    disbursement_status_details?: true
    created_at?: true
    updated_at?: true
  }

  export type TipMaxAggregateInputType = {
    id?: true
    collection_reference_id?: true
    disbursement_reference_id?: true
    device_id?: true
    rating_id?: true
    payee?: true
    payer?: true
    amount?: true
    tip_amount?: true
    collection_status?: true
    collection_status_details?: true
    closed_at?: true
    disbursed_at?: true
    disbursement_status?: true
    disbursement_status_details?: true
    created_at?: true
    updated_at?: true
  }

  export type TipCountAggregateInputType = {
    id?: true
    collection_reference_id?: true
    disbursement_reference_id?: true
    device_id?: true
    rating_id?: true
    payee?: true
    payer?: true
    amount?: true
    tip_amount?: true
    collection_status?: true
    collection_status_details?: true
    closed_at?: true
    disbursed_at?: true
    disbursement_status?: true
    disbursement_status_details?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tip to aggregate.
     */
    where?: tipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tips to fetch.
     */
    orderBy?: tipOrderByWithRelationInput | tipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tips
    **/
    _count?: true | TipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipMaxAggregateInputType
  }

  export type GetTipAggregateType<T extends TipAggregateArgs> = {
        [P in keyof T & keyof AggregateTip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTip[P]>
      : GetScalarType<T[P], AggregateTip[P]>
  }




  export type tipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipWhereInput
    orderBy?: tipOrderByWithAggregationInput | tipOrderByWithAggregationInput[]
    by: TipScalarFieldEnum[] | TipScalarFieldEnum
    having?: tipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipCountAggregateInputType | true
    _avg?: TipAvgAggregateInputType
    _sum?: TipSumAggregateInputType
    _min?: TipMinAggregateInputType
    _max?: TipMaxAggregateInputType
  }

  export type TipGroupByOutputType = {
    id: number
    collection_reference_id: string
    disbursement_reference_id: string
    device_id: number
    rating_id: bigint | null
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status: string | null
    collection_status_details: string | null
    closed_at: Date | null
    disbursed_at: Date | null
    disbursement_status: string | null
    disbursement_status_details: string | null
    created_at: Date
    updated_at: Date
    _count: TipCountAggregateOutputType | null
    _avg: TipAvgAggregateOutputType | null
    _sum: TipSumAggregateOutputType | null
    _min: TipMinAggregateOutputType | null
    _max: TipMaxAggregateOutputType | null
  }

  type GetTipGroupByPayload<T extends tipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipGroupByOutputType[P]>
            : GetScalarType<T[P], TipGroupByOutputType[P]>
        }
      >
    >


  export type tipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_reference_id?: boolean
    disbursement_reference_id?: boolean
    device_id?: boolean
    rating_id?: boolean
    payee?: boolean
    payer?: boolean
    amount?: boolean
    tip_amount?: boolean
    collection_status?: boolean
    collection_status_details?: boolean
    closed_at?: boolean
    disbursed_at?: boolean
    disbursement_status?: boolean
    disbursement_status_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    device?: boolean | deviceDefaultArgs<ExtArgs>
    rating?: boolean | tip$ratingArgs<ExtArgs>
  }, ExtArgs["result"]["tip"]>



  export type tipSelectScalar = {
    id?: boolean
    collection_reference_id?: boolean
    disbursement_reference_id?: boolean
    device_id?: boolean
    rating_id?: boolean
    payee?: boolean
    payer?: boolean
    amount?: boolean
    tip_amount?: boolean
    collection_status?: boolean
    collection_status_details?: boolean
    closed_at?: boolean
    disbursed_at?: boolean
    disbursement_status?: boolean
    disbursement_status_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collection_reference_id" | "disbursement_reference_id" | "device_id" | "rating_id" | "payee" | "payer" | "amount" | "tip_amount" | "collection_status" | "collection_status_details" | "closed_at" | "disbursed_at" | "disbursement_status" | "disbursement_status_details" | "created_at" | "updated_at", ExtArgs["result"]["tip"]>
  export type tipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | deviceDefaultArgs<ExtArgs>
    rating?: boolean | tip$ratingArgs<ExtArgs>
  }

  export type $tipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tip"
    objects: {
      device: Prisma.$devicePayload<ExtArgs>
      rating: Prisma.$ratingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      collection_reference_id: string
      disbursement_reference_id: string
      device_id: number
      rating_id: bigint | null
      payee: string
      payer: string
      amount: number
      tip_amount: number
      collection_status: string | null
      collection_status_details: string | null
      closed_at: Date | null
      disbursed_at: Date | null
      disbursement_status: string | null
      disbursement_status_details: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tip"]>
    composites: {}
  }

  type tipGetPayload<S extends boolean | null | undefined | tipDefaultArgs> = $Result.GetResult<Prisma.$tipPayload, S>

  type tipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipCountAggregateInputType | true
    }

  export interface tipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tip'], meta: { name: 'tip' } }
    /**
     * Find zero or one Tip that matches the filter.
     * @param {tipFindUniqueArgs} args - Arguments to find a Tip
     * @example
     * // Get one Tip
     * const tip = await prisma.tip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipFindUniqueArgs>(args: SelectSubset<T, tipFindUniqueArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipFindUniqueOrThrowArgs} args - Arguments to find a Tip
     * @example
     * // Get one Tip
     * const tip = await prisma.tip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipFindUniqueOrThrowArgs>(args: SelectSubset<T, tipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipFindFirstArgs} args - Arguments to find a Tip
     * @example
     * // Get one Tip
     * const tip = await prisma.tip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipFindFirstArgs>(args?: SelectSubset<T, tipFindFirstArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipFindFirstOrThrowArgs} args - Arguments to find a Tip
     * @example
     * // Get one Tip
     * const tip = await prisma.tip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipFindFirstOrThrowArgs>(args?: SelectSubset<T, tipFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tips
     * const tips = await prisma.tip.findMany()
     * 
     * // Get first 10 Tips
     * const tips = await prisma.tip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipWithIdOnly = await prisma.tip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipFindManyArgs>(args?: SelectSubset<T, tipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tip.
     * @param {tipCreateArgs} args - Arguments to create a Tip.
     * @example
     * // Create one Tip
     * const Tip = await prisma.tip.create({
     *   data: {
     *     // ... data to create a Tip
     *   }
     * })
     * 
     */
    create<T extends tipCreateArgs>(args: SelectSubset<T, tipCreateArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tips.
     * @param {tipCreateManyArgs} args - Arguments to create many Tips.
     * @example
     * // Create many Tips
     * const tip = await prisma.tip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipCreateManyArgs>(args?: SelectSubset<T, tipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tip.
     * @param {tipDeleteArgs} args - Arguments to delete one Tip.
     * @example
     * // Delete one Tip
     * const Tip = await prisma.tip.delete({
     *   where: {
     *     // ... filter to delete one Tip
     *   }
     * })
     * 
     */
    delete<T extends tipDeleteArgs>(args: SelectSubset<T, tipDeleteArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tip.
     * @param {tipUpdateArgs} args - Arguments to update one Tip.
     * @example
     * // Update one Tip
     * const tip = await prisma.tip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipUpdateArgs>(args: SelectSubset<T, tipUpdateArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tips.
     * @param {tipDeleteManyArgs} args - Arguments to filter Tips to delete.
     * @example
     * // Delete a few Tips
     * const { count } = await prisma.tip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipDeleteManyArgs>(args?: SelectSubset<T, tipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tips
     * const tip = await prisma.tip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipUpdateManyArgs>(args: SelectSubset<T, tipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tip.
     * @param {tipUpsertArgs} args - Arguments to update or create a Tip.
     * @example
     * // Update or create a Tip
     * const tip = await prisma.tip.upsert({
     *   create: {
     *     // ... data to create a Tip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tip we want to update
     *   }
     * })
     */
    upsert<T extends tipUpsertArgs>(args: SelectSubset<T, tipUpsertArgs<ExtArgs>>): Prisma__tipClient<$Result.GetResult<Prisma.$tipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipCountArgs} args - Arguments to filter Tips to count.
     * @example
     * // Count the number of Tips
     * const count = await prisma.tip.count({
     *   where: {
     *     // ... the filter for the Tips we want to count
     *   }
     * })
    **/
    count<T extends tipCountArgs>(
      args?: Subset<T, tipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipAggregateArgs>(args: Subset<T, TipAggregateArgs>): Prisma.PrismaPromise<GetTipAggregateType<T>>

    /**
     * Group by Tip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipGroupByArgs['orderBy'] }
        : { orderBy?: tipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tip model
   */
  readonly fields: tipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, deviceDefaultArgs<ExtArgs>>): Prisma__deviceClient<$Result.GetResult<Prisma.$devicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rating<T extends tip$ratingArgs<ExtArgs> = {}>(args?: Subset<T, tip$ratingArgs<ExtArgs>>): Prisma__ratingClient<$Result.GetResult<Prisma.$ratingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tip model
   */
  interface tipFieldRefs {
    readonly id: FieldRef<"tip", 'Int'>
    readonly collection_reference_id: FieldRef<"tip", 'String'>
    readonly disbursement_reference_id: FieldRef<"tip", 'String'>
    readonly device_id: FieldRef<"tip", 'Int'>
    readonly rating_id: FieldRef<"tip", 'BigInt'>
    readonly payee: FieldRef<"tip", 'String'>
    readonly payer: FieldRef<"tip", 'String'>
    readonly amount: FieldRef<"tip", 'Int'>
    readonly tip_amount: FieldRef<"tip", 'Int'>
    readonly collection_status: FieldRef<"tip", 'String'>
    readonly collection_status_details: FieldRef<"tip", 'String'>
    readonly closed_at: FieldRef<"tip", 'DateTime'>
    readonly disbursed_at: FieldRef<"tip", 'DateTime'>
    readonly disbursement_status: FieldRef<"tip", 'String'>
    readonly disbursement_status_details: FieldRef<"tip", 'String'>
    readonly created_at: FieldRef<"tip", 'DateTime'>
    readonly updated_at: FieldRef<"tip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tip findUnique
   */
  export type tipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * Filter, which tip to fetch.
     */
    where: tipWhereUniqueInput
  }

  /**
   * tip findUniqueOrThrow
   */
  export type tipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * Filter, which tip to fetch.
     */
    where: tipWhereUniqueInput
  }

  /**
   * tip findFirst
   */
  export type tipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * Filter, which tip to fetch.
     */
    where?: tipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tips to fetch.
     */
    orderBy?: tipOrderByWithRelationInput | tipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tips.
     */
    cursor?: tipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tips.
     */
    distinct?: TipScalarFieldEnum | TipScalarFieldEnum[]
  }

  /**
   * tip findFirstOrThrow
   */
  export type tipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * Filter, which tip to fetch.
     */
    where?: tipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tips to fetch.
     */
    orderBy?: tipOrderByWithRelationInput | tipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tips.
     */
    cursor?: tipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tips.
     */
    distinct?: TipScalarFieldEnum | TipScalarFieldEnum[]
  }

  /**
   * tip findMany
   */
  export type tipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * Filter, which tips to fetch.
     */
    where?: tipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tips to fetch.
     */
    orderBy?: tipOrderByWithRelationInput | tipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tips.
     */
    cursor?: tipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tips.
     */
    skip?: number
    distinct?: TipScalarFieldEnum | TipScalarFieldEnum[]
  }

  /**
   * tip create
   */
  export type tipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * The data needed to create a tip.
     */
    data: XOR<tipCreateInput, tipUncheckedCreateInput>
  }

  /**
   * tip createMany
   */
  export type tipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tips.
     */
    data: tipCreateManyInput | tipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tip update
   */
  export type tipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * The data needed to update a tip.
     */
    data: XOR<tipUpdateInput, tipUncheckedUpdateInput>
    /**
     * Choose, which tip to update.
     */
    where: tipWhereUniqueInput
  }

  /**
   * tip updateMany
   */
  export type tipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tips.
     */
    data: XOR<tipUpdateManyMutationInput, tipUncheckedUpdateManyInput>
    /**
     * Filter which tips to update
     */
    where?: tipWhereInput
    /**
     * Limit how many tips to update.
     */
    limit?: number
  }

  /**
   * tip upsert
   */
  export type tipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * The filter to search for the tip to update in case it exists.
     */
    where: tipWhereUniqueInput
    /**
     * In case the tip found by the `where` argument doesn't exist, create a new tip with this data.
     */
    create: XOR<tipCreateInput, tipUncheckedCreateInput>
    /**
     * In case the tip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipUpdateInput, tipUncheckedUpdateInput>
  }

  /**
   * tip delete
   */
  export type tipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
    /**
     * Filter which tip to delete.
     */
    where: tipWhereUniqueInput
  }

  /**
   * tip deleteMany
   */
  export type tipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tips to delete
     */
    where?: tipWhereInput
    /**
     * Limit how many tips to delete.
     */
    limit?: number
  }

  /**
   * tip.rating
   */
  export type tip$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rating
     */
    select?: ratingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rating
     */
    omit?: ratingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingInclude<ExtArgs> | null
    where?: ratingWhereInput
  }

  /**
   * tip without action
   */
  export type tipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tip
     */
    select?: tipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tip
     */
    omit?: tipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    allowed_context: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    allowed_context: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    title: string | null
    phone_number: string | null
    username: string | null
    auth_key: string | null
    password_hash: string | null
    password_reset_token: string | null
    email: string | null
    status: boolean | null
    role: boolean | null
    created_at: Date | null
    updated_at: Date | null
    verification_token: string | null
    allowed_context: number | null
    institution_id: string | null
    last_received_hb_alert_at: Date | null
    last_received_rating_notification_at: Date | null
    language: string | null
    notifications_enabled: boolean | null
    last_login: Date | null
    allow_auto_approved_changes: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    title: string | null
    phone_number: string | null
    username: string | null
    auth_key: string | null
    password_hash: string | null
    password_reset_token: string | null
    email: string | null
    status: boolean | null
    role: boolean | null
    created_at: Date | null
    updated_at: Date | null
    verification_token: string | null
    allowed_context: number | null
    institution_id: string | null
    last_received_hb_alert_at: Date | null
    last_received_rating_notification_at: Date | null
    language: string | null
    notifications_enabled: boolean | null
    last_login: Date | null
    allow_auto_approved_changes: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    title: number
    phone_number: number
    username: number
    auth_key: number
    password_hash: number
    password_reset_token: number
    email: number
    status: number
    role: number
    created_at: number
    updated_at: number
    verification_token: number
    allowed_context: number
    institution_id: number
    last_received_hb_alert_at: number
    last_received_rating_notification_at: number
    language: number
    notifications_enabled: number
    last_login: number
    allow_auto_approved_changes: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    allowed_context?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    allowed_context?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    phone_number?: true
    username?: true
    auth_key?: true
    password_hash?: true
    password_reset_token?: true
    email?: true
    status?: true
    role?: true
    created_at?: true
    updated_at?: true
    verification_token?: true
    allowed_context?: true
    institution_id?: true
    last_received_hb_alert_at?: true
    last_received_rating_notification_at?: true
    language?: true
    notifications_enabled?: true
    last_login?: true
    allow_auto_approved_changes?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    phone_number?: true
    username?: true
    auth_key?: true
    password_hash?: true
    password_reset_token?: true
    email?: true
    status?: true
    role?: true
    created_at?: true
    updated_at?: true
    verification_token?: true
    allowed_context?: true
    institution_id?: true
    last_received_hb_alert_at?: true
    last_received_rating_notification_at?: true
    language?: true
    notifications_enabled?: true
    last_login?: true
    allow_auto_approved_changes?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    phone_number?: true
    username?: true
    auth_key?: true
    password_hash?: true
    password_reset_token?: true
    email?: true
    status?: true
    role?: true
    created_at?: true
    updated_at?: true
    verification_token?: true
    allowed_context?: true
    institution_id?: true
    last_received_hb_alert_at?: true
    last_received_rating_notification_at?: true
    language?: true
    notifications_enabled?: true
    last_login?: true
    allow_auto_approved_changes?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string | null
    title: string | null
    phone_number: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token: string | null
    email: string | null
    status: boolean
    role: boolean
    created_at: Date
    updated_at: Date
    verification_token: string | null
    allowed_context: number | null
    institution_id: string | null
    last_received_hb_alert_at: Date
    last_received_rating_notification_at: Date
    language: string | null
    notifications_enabled: boolean | null
    last_login: Date | null
    allow_auto_approved_changes: boolean | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    phone_number?: boolean
    username?: boolean
    auth_key?: boolean
    password_hash?: boolean
    password_reset_token?: boolean
    email?: boolean
    status?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    verification_token?: boolean
    allowed_context?: boolean
    institution_id?: boolean
    last_received_hb_alert_at?: boolean
    last_received_rating_notification_at?: boolean
    language?: boolean
    notifications_enabled?: boolean
    last_login?: boolean
    allow_auto_approved_changes?: boolean
    appointments_appointments_creator_idTouser?: boolean | user$appointments_appointments_creator_idTouserArgs<ExtArgs>
    appointments_appointments_user_idTouser?: boolean | user$appointments_appointments_user_idTouserArgs<ExtArgs>
    tags_tags_created_byTouser?: boolean | user$tags_tags_created_byTouserArgs<ExtArgs>
    tags_tags_updated_byTouser?: boolean | user$tags_tags_updated_byTouserArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    phone_number?: boolean
    username?: boolean
    auth_key?: boolean
    password_hash?: boolean
    password_reset_token?: boolean
    email?: boolean
    status?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    verification_token?: boolean
    allowed_context?: boolean
    institution_id?: boolean
    last_received_hb_alert_at?: boolean
    last_received_rating_notification_at?: boolean
    language?: boolean
    notifications_enabled?: boolean
    last_login?: boolean
    allow_auto_approved_changes?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "title" | "phone_number" | "username" | "auth_key" | "password_hash" | "password_reset_token" | "email" | "status" | "role" | "created_at" | "updated_at" | "verification_token" | "allowed_context" | "institution_id" | "last_received_hb_alert_at" | "last_received_rating_notification_at" | "language" | "notifications_enabled" | "last_login" | "allow_auto_approved_changes", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments_appointments_creator_idTouser?: boolean | user$appointments_appointments_creator_idTouserArgs<ExtArgs>
    appointments_appointments_user_idTouser?: boolean | user$appointments_appointments_user_idTouserArgs<ExtArgs>
    tags_tags_created_byTouser?: boolean | user$tags_tags_created_byTouserArgs<ExtArgs>
    tags_tags_updated_byTouser?: boolean | user$tags_tags_updated_byTouserArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      appointments_appointments_creator_idTouser: Prisma.$appointmentsPayload<ExtArgs>[]
      appointments_appointments_user_idTouser: Prisma.$appointmentsPayload<ExtArgs>[]
      tags_tags_created_byTouser: Prisma.$tagsPayload<ExtArgs>[]
      tags_tags_updated_byTouser: Prisma.$tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      title: string | null
      phone_number: string | null
      username: string
      auth_key: string
      password_hash: string
      password_reset_token: string | null
      email: string | null
      status: boolean
      role: boolean
      created_at: Date
      updated_at: Date
      verification_token: string | null
      allowed_context: number | null
      institution_id: string | null
      last_received_hb_alert_at: Date
      last_received_rating_notification_at: Date
      language: string | null
      notifications_enabled: boolean | null
      last_login: Date | null
      allow_auto_approved_changes: boolean | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments_appointments_creator_idTouser<T extends user$appointments_appointments_creator_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$appointments_appointments_creator_idTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments_appointments_user_idTouser<T extends user$appointments_appointments_user_idTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$appointments_appointments_user_idTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags_tags_created_byTouser<T extends user$tags_tags_created_byTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$tags_tags_created_byTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags_tags_updated_byTouser<T extends user$tags_tags_updated_byTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$tags_tags_updated_byTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly name: FieldRef<"user", 'String'>
    readonly title: FieldRef<"user", 'String'>
    readonly phone_number: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly auth_key: FieldRef<"user", 'String'>
    readonly password_hash: FieldRef<"user", 'String'>
    readonly password_reset_token: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'Boolean'>
    readonly role: FieldRef<"user", 'Boolean'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly verification_token: FieldRef<"user", 'String'>
    readonly allowed_context: FieldRef<"user", 'Int'>
    readonly institution_id: FieldRef<"user", 'String'>
    readonly last_received_hb_alert_at: FieldRef<"user", 'DateTime'>
    readonly last_received_rating_notification_at: FieldRef<"user", 'DateTime'>
    readonly language: FieldRef<"user", 'String'>
    readonly notifications_enabled: FieldRef<"user", 'Boolean'>
    readonly last_login: FieldRef<"user", 'DateTime'>
    readonly allow_auto_approved_changes: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.appointments_appointments_creator_idTouser
   */
  export type user$appointments_appointments_creator_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * user.appointments_appointments_user_idTouser
   */
  export type user$appointments_appointments_user_idTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * user.tags_tags_created_byTouser
   */
  export type user$tags_tags_created_byTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    cursor?: tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * user.tags_tags_updated_byTouser
   */
  export type user$tags_tags_updated_byTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    cursor?: tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model wallet_accounts
   */

  export type AggregateWallet_accounts = {
    _count: Wallet_accountsCountAggregateOutputType | null
    _avg: Wallet_accountsAvgAggregateOutputType | null
    _sum: Wallet_accountsSumAggregateOutputType | null
    _min: Wallet_accountsMinAggregateOutputType | null
    _max: Wallet_accountsMaxAggregateOutputType | null
  }

  export type Wallet_accountsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    account_type_id: number | null
    balance: number | null
  }

  export type Wallet_accountsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    account_type_id: number | null
    balance: number | null
  }

  export type Wallet_accountsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    account_type_id: number | null
    account_number: string | null
    account_name: string | null
    balance: number | null
    public_key: string | null
    private_key: string | null
    added_at: Date | null
  }

  export type Wallet_accountsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    account_type_id: number | null
    account_number: string | null
    account_name: string | null
    balance: number | null
    public_key: string | null
    private_key: string | null
    added_at: Date | null
  }

  export type Wallet_accountsCountAggregateOutputType = {
    id: number
    user_id: number
    account_type_id: number
    account_number: number
    account_name: number
    balance: number
    public_key: number
    private_key: number
    added_at: number
    _all: number
  }


  export type Wallet_accountsAvgAggregateInputType = {
    id?: true
    user_id?: true
    account_type_id?: true
    balance?: true
  }

  export type Wallet_accountsSumAggregateInputType = {
    id?: true
    user_id?: true
    account_type_id?: true
    balance?: true
  }

  export type Wallet_accountsMinAggregateInputType = {
    id?: true
    user_id?: true
    account_type_id?: true
    account_number?: true
    account_name?: true
    balance?: true
    public_key?: true
    private_key?: true
    added_at?: true
  }

  export type Wallet_accountsMaxAggregateInputType = {
    id?: true
    user_id?: true
    account_type_id?: true
    account_number?: true
    account_name?: true
    balance?: true
    public_key?: true
    private_key?: true
    added_at?: true
  }

  export type Wallet_accountsCountAggregateInputType = {
    id?: true
    user_id?: true
    account_type_id?: true
    account_number?: true
    account_name?: true
    balance?: true
    public_key?: true
    private_key?: true
    added_at?: true
    _all?: true
  }

  export type Wallet_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_accounts to aggregate.
     */
    where?: wallet_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts to fetch.
     */
    orderBy?: wallet_accountsOrderByWithRelationInput | wallet_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_accounts
    **/
    _count?: true | Wallet_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_accountsMaxAggregateInputType
  }

  export type GetWallet_accountsAggregateType<T extends Wallet_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_accounts[P]>
      : GetScalarType<T[P], AggregateWallet_accounts[P]>
  }




  export type wallet_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_accountsWhereInput
    orderBy?: wallet_accountsOrderByWithAggregationInput | wallet_accountsOrderByWithAggregationInput[]
    by: Wallet_accountsScalarFieldEnum[] | Wallet_accountsScalarFieldEnum
    having?: wallet_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_accountsCountAggregateInputType | true
    _avg?: Wallet_accountsAvgAggregateInputType
    _sum?: Wallet_accountsSumAggregateInputType
    _min?: Wallet_accountsMinAggregateInputType
    _max?: Wallet_accountsMaxAggregateInputType
  }

  export type Wallet_accountsGroupByOutputType = {
    id: number
    user_id: number | null
    account_type_id: number | null
    account_number: string | null
    account_name: string | null
    balance: number | null
    public_key: string | null
    private_key: string | null
    added_at: Date
    _count: Wallet_accountsCountAggregateOutputType | null
    _avg: Wallet_accountsAvgAggregateOutputType | null
    _sum: Wallet_accountsSumAggregateOutputType | null
    _min: Wallet_accountsMinAggregateOutputType | null
    _max: Wallet_accountsMaxAggregateOutputType | null
  }

  type GetWallet_accountsGroupByPayload<T extends wallet_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_accountsGroupByOutputType[P]>
        }
      >
    >


  export type wallet_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    account_type_id?: boolean
    account_number?: boolean
    account_name?: boolean
    balance?: boolean
    public_key?: boolean
    private_key?: boolean
    added_at?: boolean
  }, ExtArgs["result"]["wallet_accounts"]>



  export type wallet_accountsSelectScalar = {
    id?: boolean
    user_id?: boolean
    account_type_id?: boolean
    account_number?: boolean
    account_name?: boolean
    balance?: boolean
    public_key?: boolean
    private_key?: boolean
    added_at?: boolean
  }

  export type wallet_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "account_type_id" | "account_number" | "account_name" | "balance" | "public_key" | "private_key" | "added_at", ExtArgs["result"]["wallet_accounts"]>

  export type $wallet_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_accounts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      account_type_id: number | null
      account_number: string | null
      account_name: string | null
      balance: number | null
      public_key: string | null
      private_key: string | null
      added_at: Date
    }, ExtArgs["result"]["wallet_accounts"]>
    composites: {}
  }

  type wallet_accountsGetPayload<S extends boolean | null | undefined | wallet_accountsDefaultArgs> = $Result.GetResult<Prisma.$wallet_accountsPayload, S>

  type wallet_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wallet_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wallet_accountsCountAggregateInputType | true
    }

  export interface wallet_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_accounts'], meta: { name: 'wallet_accounts' } }
    /**
     * Find zero or one Wallet_accounts that matches the filter.
     * @param {wallet_accountsFindUniqueArgs} args - Arguments to find a Wallet_accounts
     * @example
     * // Get one Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_accountsFindUniqueArgs>(args: SelectSubset<T, wallet_accountsFindUniqueArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wallet_accountsFindUniqueOrThrowArgs} args - Arguments to find a Wallet_accounts
     * @example
     * // Get one Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accountsFindFirstArgs} args - Arguments to find a Wallet_accounts
     * @example
     * // Get one Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_accountsFindFirstArgs>(args?: SelectSubset<T, wallet_accountsFindFirstArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accountsFindFirstOrThrowArgs} args - Arguments to find a Wallet_accounts
     * @example
     * // Get one Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallet_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.findMany()
     * 
     * // Get first 10 Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_accountsWithIdOnly = await prisma.wallet_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_accountsFindManyArgs>(args?: SelectSubset<T, wallet_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet_accounts.
     * @param {wallet_accountsCreateArgs} args - Arguments to create a Wallet_accounts.
     * @example
     * // Create one Wallet_accounts
     * const Wallet_accounts = await prisma.wallet_accounts.create({
     *   data: {
     *     // ... data to create a Wallet_accounts
     *   }
     * })
     * 
     */
    create<T extends wallet_accountsCreateArgs>(args: SelectSubset<T, wallet_accountsCreateArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallet_accounts.
     * @param {wallet_accountsCreateManyArgs} args - Arguments to create many Wallet_accounts.
     * @example
     * // Create many Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_accountsCreateManyArgs>(args?: SelectSubset<T, wallet_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_accounts.
     * @param {wallet_accountsDeleteArgs} args - Arguments to delete one Wallet_accounts.
     * @example
     * // Delete one Wallet_accounts
     * const Wallet_accounts = await prisma.wallet_accounts.delete({
     *   where: {
     *     // ... filter to delete one Wallet_accounts
     *   }
     * })
     * 
     */
    delete<T extends wallet_accountsDeleteArgs>(args: SelectSubset<T, wallet_accountsDeleteArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet_accounts.
     * @param {wallet_accountsUpdateArgs} args - Arguments to update one Wallet_accounts.
     * @example
     * // Update one Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_accountsUpdateArgs>(args: SelectSubset<T, wallet_accountsUpdateArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallet_accounts.
     * @param {wallet_accountsDeleteManyArgs} args - Arguments to filter Wallet_accounts to delete.
     * @example
     * // Delete a few Wallet_accounts
     * const { count } = await prisma.wallet_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_accountsDeleteManyArgs>(args?: SelectSubset<T, wallet_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_accountsUpdateManyArgs>(args: SelectSubset<T, wallet_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_accounts.
     * @param {wallet_accountsUpsertArgs} args - Arguments to update or create a Wallet_accounts.
     * @example
     * // Update or create a Wallet_accounts
     * const wallet_accounts = await prisma.wallet_accounts.upsert({
     *   create: {
     *     // ... data to create a Wallet_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_accounts we want to update
     *   }
     * })
     */
    upsert<T extends wallet_accountsUpsertArgs>(args: SelectSubset<T, wallet_accountsUpsertArgs<ExtArgs>>): Prisma__wallet_accountsClient<$Result.GetResult<Prisma.$wallet_accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallet_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accountsCountArgs} args - Arguments to filter Wallet_accounts to count.
     * @example
     * // Count the number of Wallet_accounts
     * const count = await prisma.wallet_accounts.count({
     *   where: {
     *     // ... the filter for the Wallet_accounts we want to count
     *   }
     * })
    **/
    count<T extends wallet_accountsCountArgs>(
      args?: Subset<T, wallet_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_accountsAggregateArgs>(args: Subset<T, Wallet_accountsAggregateArgs>): Prisma.PrismaPromise<GetWallet_accountsAggregateType<T>>

    /**
     * Group by Wallet_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_accountsGroupByArgs['orderBy'] }
        : { orderBy?: wallet_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_accounts model
   */
  readonly fields: wallet_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_accounts model
   */
  interface wallet_accountsFieldRefs {
    readonly id: FieldRef<"wallet_accounts", 'Int'>
    readonly user_id: FieldRef<"wallet_accounts", 'Int'>
    readonly account_type_id: FieldRef<"wallet_accounts", 'Int'>
    readonly account_number: FieldRef<"wallet_accounts", 'String'>
    readonly account_name: FieldRef<"wallet_accounts", 'String'>
    readonly balance: FieldRef<"wallet_accounts", 'Float'>
    readonly public_key: FieldRef<"wallet_accounts", 'String'>
    readonly private_key: FieldRef<"wallet_accounts", 'String'>
    readonly added_at: FieldRef<"wallet_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet_accounts findUnique
   */
  export type wallet_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts to fetch.
     */
    where: wallet_accountsWhereUniqueInput
  }

  /**
   * wallet_accounts findUniqueOrThrow
   */
  export type wallet_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts to fetch.
     */
    where: wallet_accountsWhereUniqueInput
  }

  /**
   * wallet_accounts findFirst
   */
  export type wallet_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts to fetch.
     */
    where?: wallet_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts to fetch.
     */
    orderBy?: wallet_accountsOrderByWithRelationInput | wallet_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_accounts.
     */
    cursor?: wallet_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_accounts.
     */
    distinct?: Wallet_accountsScalarFieldEnum | Wallet_accountsScalarFieldEnum[]
  }

  /**
   * wallet_accounts findFirstOrThrow
   */
  export type wallet_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts to fetch.
     */
    where?: wallet_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts to fetch.
     */
    orderBy?: wallet_accountsOrderByWithRelationInput | wallet_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_accounts.
     */
    cursor?: wallet_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_accounts.
     */
    distinct?: Wallet_accountsScalarFieldEnum | Wallet_accountsScalarFieldEnum[]
  }

  /**
   * wallet_accounts findMany
   */
  export type wallet_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts to fetch.
     */
    where?: wallet_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts to fetch.
     */
    orderBy?: wallet_accountsOrderByWithRelationInput | wallet_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_accounts.
     */
    cursor?: wallet_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts.
     */
    skip?: number
    distinct?: Wallet_accountsScalarFieldEnum | Wallet_accountsScalarFieldEnum[]
  }

  /**
   * wallet_accounts create
   */
  export type wallet_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * The data needed to create a wallet_accounts.
     */
    data?: XOR<wallet_accountsCreateInput, wallet_accountsUncheckedCreateInput>
  }

  /**
   * wallet_accounts createMany
   */
  export type wallet_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_accounts.
     */
    data: wallet_accountsCreateManyInput | wallet_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet_accounts update
   */
  export type wallet_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * The data needed to update a wallet_accounts.
     */
    data: XOR<wallet_accountsUpdateInput, wallet_accountsUncheckedUpdateInput>
    /**
     * Choose, which wallet_accounts to update.
     */
    where: wallet_accountsWhereUniqueInput
  }

  /**
   * wallet_accounts updateMany
   */
  export type wallet_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_accounts.
     */
    data: XOR<wallet_accountsUpdateManyMutationInput, wallet_accountsUncheckedUpdateManyInput>
    /**
     * Filter which wallet_accounts to update
     */
    where?: wallet_accountsWhereInput
    /**
     * Limit how many wallet_accounts to update.
     */
    limit?: number
  }

  /**
   * wallet_accounts upsert
   */
  export type wallet_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * The filter to search for the wallet_accounts to update in case it exists.
     */
    where: wallet_accountsWhereUniqueInput
    /**
     * In case the wallet_accounts found by the `where` argument doesn't exist, create a new wallet_accounts with this data.
     */
    create: XOR<wallet_accountsCreateInput, wallet_accountsUncheckedCreateInput>
    /**
     * In case the wallet_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_accountsUpdateInput, wallet_accountsUncheckedUpdateInput>
  }

  /**
   * wallet_accounts delete
   */
  export type wallet_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
    /**
     * Filter which wallet_accounts to delete.
     */
    where: wallet_accountsWhereUniqueInput
  }

  /**
   * wallet_accounts deleteMany
   */
  export type wallet_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_accounts to delete
     */
    where?: wallet_accountsWhereInput
    /**
     * Limit how many wallet_accounts to delete.
     */
    limit?: number
  }

  /**
   * wallet_accounts without action
   */
  export type wallet_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts
     */
    select?: wallet_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts
     */
    omit?: wallet_accountsOmit<ExtArgs> | null
  }


  /**
   * Model wallet_accounts_types
   */

  export type AggregateWallet_accounts_types = {
    _count: Wallet_accounts_typesCountAggregateOutputType | null
    _avg: Wallet_accounts_typesAvgAggregateOutputType | null
    _sum: Wallet_accounts_typesSumAggregateOutputType | null
    _min: Wallet_accounts_typesMinAggregateOutputType | null
    _max: Wallet_accounts_typesMaxAggregateOutputType | null
  }

  export type Wallet_accounts_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Wallet_accounts_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Wallet_accounts_typesMinAggregateOutputType = {
    id: number | null
    category: string | null
    abbreviation: string | null
    name: string | null
    added_at: Date | null
  }

  export type Wallet_accounts_typesMaxAggregateOutputType = {
    id: number | null
    category: string | null
    abbreviation: string | null
    name: string | null
    added_at: Date | null
  }

  export type Wallet_accounts_typesCountAggregateOutputType = {
    id: number
    category: number
    abbreviation: number
    name: number
    added_at: number
    _all: number
  }


  export type Wallet_accounts_typesAvgAggregateInputType = {
    id?: true
  }

  export type Wallet_accounts_typesSumAggregateInputType = {
    id?: true
  }

  export type Wallet_accounts_typesMinAggregateInputType = {
    id?: true
    category?: true
    abbreviation?: true
    name?: true
    added_at?: true
  }

  export type Wallet_accounts_typesMaxAggregateInputType = {
    id?: true
    category?: true
    abbreviation?: true
    name?: true
    added_at?: true
  }

  export type Wallet_accounts_typesCountAggregateInputType = {
    id?: true
    category?: true
    abbreviation?: true
    name?: true
    added_at?: true
    _all?: true
  }

  export type Wallet_accounts_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_accounts_types to aggregate.
     */
    where?: wallet_accounts_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts_types to fetch.
     */
    orderBy?: wallet_accounts_typesOrderByWithRelationInput | wallet_accounts_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_accounts_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_accounts_types
    **/
    _count?: true | Wallet_accounts_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_accounts_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_accounts_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_accounts_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_accounts_typesMaxAggregateInputType
  }

  export type GetWallet_accounts_typesAggregateType<T extends Wallet_accounts_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_accounts_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_accounts_types[P]>
      : GetScalarType<T[P], AggregateWallet_accounts_types[P]>
  }




  export type wallet_accounts_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_accounts_typesWhereInput
    orderBy?: wallet_accounts_typesOrderByWithAggregationInput | wallet_accounts_typesOrderByWithAggregationInput[]
    by: Wallet_accounts_typesScalarFieldEnum[] | Wallet_accounts_typesScalarFieldEnum
    having?: wallet_accounts_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_accounts_typesCountAggregateInputType | true
    _avg?: Wallet_accounts_typesAvgAggregateInputType
    _sum?: Wallet_accounts_typesSumAggregateInputType
    _min?: Wallet_accounts_typesMinAggregateInputType
    _max?: Wallet_accounts_typesMaxAggregateInputType
  }

  export type Wallet_accounts_typesGroupByOutputType = {
    id: number
    category: string | null
    abbreviation: string | null
    name: string | null
    added_at: Date
    _count: Wallet_accounts_typesCountAggregateOutputType | null
    _avg: Wallet_accounts_typesAvgAggregateOutputType | null
    _sum: Wallet_accounts_typesSumAggregateOutputType | null
    _min: Wallet_accounts_typesMinAggregateOutputType | null
    _max: Wallet_accounts_typesMaxAggregateOutputType | null
  }

  type GetWallet_accounts_typesGroupByPayload<T extends wallet_accounts_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_accounts_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_accounts_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_accounts_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_accounts_typesGroupByOutputType[P]>
        }
      >
    >


  export type wallet_accounts_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    abbreviation?: boolean
    name?: boolean
    added_at?: boolean
  }, ExtArgs["result"]["wallet_accounts_types"]>



  export type wallet_accounts_typesSelectScalar = {
    id?: boolean
    category?: boolean
    abbreviation?: boolean
    name?: boolean
    added_at?: boolean
  }

  export type wallet_accounts_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "abbreviation" | "name" | "added_at", ExtArgs["result"]["wallet_accounts_types"]>

  export type $wallet_accounts_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_accounts_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string | null
      abbreviation: string | null
      name: string | null
      added_at: Date
    }, ExtArgs["result"]["wallet_accounts_types"]>
    composites: {}
  }

  type wallet_accounts_typesGetPayload<S extends boolean | null | undefined | wallet_accounts_typesDefaultArgs> = $Result.GetResult<Prisma.$wallet_accounts_typesPayload, S>

  type wallet_accounts_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wallet_accounts_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wallet_accounts_typesCountAggregateInputType | true
    }

  export interface wallet_accounts_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_accounts_types'], meta: { name: 'wallet_accounts_types' } }
    /**
     * Find zero or one Wallet_accounts_types that matches the filter.
     * @param {wallet_accounts_typesFindUniqueArgs} args - Arguments to find a Wallet_accounts_types
     * @example
     * // Get one Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_accounts_typesFindUniqueArgs>(args: SelectSubset<T, wallet_accounts_typesFindUniqueArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet_accounts_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wallet_accounts_typesFindUniqueOrThrowArgs} args - Arguments to find a Wallet_accounts_types
     * @example
     * // Get one Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_accounts_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_accounts_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_accounts_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accounts_typesFindFirstArgs} args - Arguments to find a Wallet_accounts_types
     * @example
     * // Get one Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_accounts_typesFindFirstArgs>(args?: SelectSubset<T, wallet_accounts_typesFindFirstArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_accounts_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accounts_typesFindFirstOrThrowArgs} args - Arguments to find a Wallet_accounts_types
     * @example
     * // Get one Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_accounts_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_accounts_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallet_accounts_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accounts_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.findMany()
     * 
     * // Get first 10 Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_accounts_typesWithIdOnly = await prisma.wallet_accounts_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_accounts_typesFindManyArgs>(args?: SelectSubset<T, wallet_accounts_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet_accounts_types.
     * @param {wallet_accounts_typesCreateArgs} args - Arguments to create a Wallet_accounts_types.
     * @example
     * // Create one Wallet_accounts_types
     * const Wallet_accounts_types = await prisma.wallet_accounts_types.create({
     *   data: {
     *     // ... data to create a Wallet_accounts_types
     *   }
     * })
     * 
     */
    create<T extends wallet_accounts_typesCreateArgs>(args: SelectSubset<T, wallet_accounts_typesCreateArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallet_accounts_types.
     * @param {wallet_accounts_typesCreateManyArgs} args - Arguments to create many Wallet_accounts_types.
     * @example
     * // Create many Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_accounts_typesCreateManyArgs>(args?: SelectSubset<T, wallet_accounts_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_accounts_types.
     * @param {wallet_accounts_typesDeleteArgs} args - Arguments to delete one Wallet_accounts_types.
     * @example
     * // Delete one Wallet_accounts_types
     * const Wallet_accounts_types = await prisma.wallet_accounts_types.delete({
     *   where: {
     *     // ... filter to delete one Wallet_accounts_types
     *   }
     * })
     * 
     */
    delete<T extends wallet_accounts_typesDeleteArgs>(args: SelectSubset<T, wallet_accounts_typesDeleteArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet_accounts_types.
     * @param {wallet_accounts_typesUpdateArgs} args - Arguments to update one Wallet_accounts_types.
     * @example
     * // Update one Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_accounts_typesUpdateArgs>(args: SelectSubset<T, wallet_accounts_typesUpdateArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallet_accounts_types.
     * @param {wallet_accounts_typesDeleteManyArgs} args - Arguments to filter Wallet_accounts_types to delete.
     * @example
     * // Delete a few Wallet_accounts_types
     * const { count } = await prisma.wallet_accounts_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_accounts_typesDeleteManyArgs>(args?: SelectSubset<T, wallet_accounts_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_accounts_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accounts_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_accounts_typesUpdateManyArgs>(args: SelectSubset<T, wallet_accounts_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_accounts_types.
     * @param {wallet_accounts_typesUpsertArgs} args - Arguments to update or create a Wallet_accounts_types.
     * @example
     * // Update or create a Wallet_accounts_types
     * const wallet_accounts_types = await prisma.wallet_accounts_types.upsert({
     *   create: {
     *     // ... data to create a Wallet_accounts_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_accounts_types we want to update
     *   }
     * })
     */
    upsert<T extends wallet_accounts_typesUpsertArgs>(args: SelectSubset<T, wallet_accounts_typesUpsertArgs<ExtArgs>>): Prisma__wallet_accounts_typesClient<$Result.GetResult<Prisma.$wallet_accounts_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallet_accounts_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accounts_typesCountArgs} args - Arguments to filter Wallet_accounts_types to count.
     * @example
     * // Count the number of Wallet_accounts_types
     * const count = await prisma.wallet_accounts_types.count({
     *   where: {
     *     // ... the filter for the Wallet_accounts_types we want to count
     *   }
     * })
    **/
    count<T extends wallet_accounts_typesCountArgs>(
      args?: Subset<T, wallet_accounts_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_accounts_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_accounts_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_accounts_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_accounts_typesAggregateArgs>(args: Subset<T, Wallet_accounts_typesAggregateArgs>): Prisma.PrismaPromise<GetWallet_accounts_typesAggregateType<T>>

    /**
     * Group by Wallet_accounts_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_accounts_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_accounts_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_accounts_typesGroupByArgs['orderBy'] }
        : { orderBy?: wallet_accounts_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_accounts_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_accounts_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_accounts_types model
   */
  readonly fields: wallet_accounts_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_accounts_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_accounts_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_accounts_types model
   */
  interface wallet_accounts_typesFieldRefs {
    readonly id: FieldRef<"wallet_accounts_types", 'Int'>
    readonly category: FieldRef<"wallet_accounts_types", 'String'>
    readonly abbreviation: FieldRef<"wallet_accounts_types", 'String'>
    readonly name: FieldRef<"wallet_accounts_types", 'String'>
    readonly added_at: FieldRef<"wallet_accounts_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet_accounts_types findUnique
   */
  export type wallet_accounts_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts_types to fetch.
     */
    where: wallet_accounts_typesWhereUniqueInput
  }

  /**
   * wallet_accounts_types findUniqueOrThrow
   */
  export type wallet_accounts_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts_types to fetch.
     */
    where: wallet_accounts_typesWhereUniqueInput
  }

  /**
   * wallet_accounts_types findFirst
   */
  export type wallet_accounts_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts_types to fetch.
     */
    where?: wallet_accounts_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts_types to fetch.
     */
    orderBy?: wallet_accounts_typesOrderByWithRelationInput | wallet_accounts_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_accounts_types.
     */
    cursor?: wallet_accounts_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_accounts_types.
     */
    distinct?: Wallet_accounts_typesScalarFieldEnum | Wallet_accounts_typesScalarFieldEnum[]
  }

  /**
   * wallet_accounts_types findFirstOrThrow
   */
  export type wallet_accounts_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts_types to fetch.
     */
    where?: wallet_accounts_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts_types to fetch.
     */
    orderBy?: wallet_accounts_typesOrderByWithRelationInput | wallet_accounts_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_accounts_types.
     */
    cursor?: wallet_accounts_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_accounts_types.
     */
    distinct?: Wallet_accounts_typesScalarFieldEnum | Wallet_accounts_typesScalarFieldEnum[]
  }

  /**
   * wallet_accounts_types findMany
   */
  export type wallet_accounts_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * Filter, which wallet_accounts_types to fetch.
     */
    where?: wallet_accounts_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_accounts_types to fetch.
     */
    orderBy?: wallet_accounts_typesOrderByWithRelationInput | wallet_accounts_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_accounts_types.
     */
    cursor?: wallet_accounts_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_accounts_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_accounts_types.
     */
    skip?: number
    distinct?: Wallet_accounts_typesScalarFieldEnum | Wallet_accounts_typesScalarFieldEnum[]
  }

  /**
   * wallet_accounts_types create
   */
  export type wallet_accounts_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a wallet_accounts_types.
     */
    data?: XOR<wallet_accounts_typesCreateInput, wallet_accounts_typesUncheckedCreateInput>
  }

  /**
   * wallet_accounts_types createMany
   */
  export type wallet_accounts_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_accounts_types.
     */
    data: wallet_accounts_typesCreateManyInput | wallet_accounts_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet_accounts_types update
   */
  export type wallet_accounts_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a wallet_accounts_types.
     */
    data: XOR<wallet_accounts_typesUpdateInput, wallet_accounts_typesUncheckedUpdateInput>
    /**
     * Choose, which wallet_accounts_types to update.
     */
    where: wallet_accounts_typesWhereUniqueInput
  }

  /**
   * wallet_accounts_types updateMany
   */
  export type wallet_accounts_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_accounts_types.
     */
    data: XOR<wallet_accounts_typesUpdateManyMutationInput, wallet_accounts_typesUncheckedUpdateManyInput>
    /**
     * Filter which wallet_accounts_types to update
     */
    where?: wallet_accounts_typesWhereInput
    /**
     * Limit how many wallet_accounts_types to update.
     */
    limit?: number
  }

  /**
   * wallet_accounts_types upsert
   */
  export type wallet_accounts_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the wallet_accounts_types to update in case it exists.
     */
    where: wallet_accounts_typesWhereUniqueInput
    /**
     * In case the wallet_accounts_types found by the `where` argument doesn't exist, create a new wallet_accounts_types with this data.
     */
    create: XOR<wallet_accounts_typesCreateInput, wallet_accounts_typesUncheckedCreateInput>
    /**
     * In case the wallet_accounts_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_accounts_typesUpdateInput, wallet_accounts_typesUncheckedUpdateInput>
  }

  /**
   * wallet_accounts_types delete
   */
  export type wallet_accounts_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
    /**
     * Filter which wallet_accounts_types to delete.
     */
    where: wallet_accounts_typesWhereUniqueInput
  }

  /**
   * wallet_accounts_types deleteMany
   */
  export type wallet_accounts_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_accounts_types to delete
     */
    where?: wallet_accounts_typesWhereInput
    /**
     * Limit how many wallet_accounts_types to delete.
     */
    limit?: number
  }

  /**
   * wallet_accounts_types without action
   */
  export type wallet_accounts_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_accounts_types
     */
    select?: wallet_accounts_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_accounts_types
     */
    omit?: wallet_accounts_typesOmit<ExtArgs> | null
  }


  /**
   * Model wallet_transfers
   */

  export type AggregateWallet_transfers = {
    _count: Wallet_transfersCountAggregateOutputType | null
    _avg: Wallet_transfersAvgAggregateOutputType | null
    _sum: Wallet_transfersSumAggregateOutputType | null
    _min: Wallet_transfersMinAggregateOutputType | null
    _max: Wallet_transfersMaxAggregateOutputType | null
  }

  export type Wallet_transfersAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    payer_id: number | null
    payer_account_id: number | null
  }

  export type Wallet_transfersSumAggregateOutputType = {
    id: number | null
    amount: number | null
    payer_id: number | null
    payer_account_id: number | null
  }

  export type Wallet_transfersMinAggregateOutputType = {
    id: number | null
    amount: number | null
    currency: string | null
    time: Date | null
    payer_id: number | null
    payer_account_id: number | null
    payee_address: string | null
    payee_name: string | null
    payee_account_type: string | null
    payee_account_number: string | null
    payee_type: string | null
    tx_id: string | null
    fspid: string | null
    ext_trx_id: string | null
    pay_money_ext_res: string | null
    confirm_party_ext_res: string | null
    confirm_quote_ext_res: string | null
    status: string | null
    quote_id: string | null
    note: string | null
    transfer_fees: string | null
  }

  export type Wallet_transfersMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    currency: string | null
    time: Date | null
    payer_id: number | null
    payer_account_id: number | null
    payee_address: string | null
    payee_name: string | null
    payee_account_type: string | null
    payee_account_number: string | null
    payee_type: string | null
    tx_id: string | null
    fspid: string | null
    ext_trx_id: string | null
    pay_money_ext_res: string | null
    confirm_party_ext_res: string | null
    confirm_quote_ext_res: string | null
    status: string | null
    quote_id: string | null
    note: string | null
    transfer_fees: string | null
  }

  export type Wallet_transfersCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    time: number
    payer_id: number
    payer_account_id: number
    payee_address: number
    payee_name: number
    payee_account_type: number
    payee_account_number: number
    payee_type: number
    tx_id: number
    fspid: number
    ext_trx_id: number
    pay_money_ext_res: number
    confirm_party_ext_res: number
    confirm_quote_ext_res: number
    status: number
    quote_id: number
    note: number
    transfer_fees: number
    _all: number
  }


  export type Wallet_transfersAvgAggregateInputType = {
    id?: true
    amount?: true
    payer_id?: true
    payer_account_id?: true
  }

  export type Wallet_transfersSumAggregateInputType = {
    id?: true
    amount?: true
    payer_id?: true
    payer_account_id?: true
  }

  export type Wallet_transfersMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    time?: true
    payer_id?: true
    payer_account_id?: true
    payee_address?: true
    payee_name?: true
    payee_account_type?: true
    payee_account_number?: true
    payee_type?: true
    tx_id?: true
    fspid?: true
    ext_trx_id?: true
    pay_money_ext_res?: true
    confirm_party_ext_res?: true
    confirm_quote_ext_res?: true
    status?: true
    quote_id?: true
    note?: true
    transfer_fees?: true
  }

  export type Wallet_transfersMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    time?: true
    payer_id?: true
    payer_account_id?: true
    payee_address?: true
    payee_name?: true
    payee_account_type?: true
    payee_account_number?: true
    payee_type?: true
    tx_id?: true
    fspid?: true
    ext_trx_id?: true
    pay_money_ext_res?: true
    confirm_party_ext_res?: true
    confirm_quote_ext_res?: true
    status?: true
    quote_id?: true
    note?: true
    transfer_fees?: true
  }

  export type Wallet_transfersCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    time?: true
    payer_id?: true
    payer_account_id?: true
    payee_address?: true
    payee_name?: true
    payee_account_type?: true
    payee_account_number?: true
    payee_type?: true
    tx_id?: true
    fspid?: true
    ext_trx_id?: true
    pay_money_ext_res?: true
    confirm_party_ext_res?: true
    confirm_quote_ext_res?: true
    status?: true
    quote_id?: true
    note?: true
    transfer_fees?: true
    _all?: true
  }

  export type Wallet_transfersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_transfers to aggregate.
     */
    where?: wallet_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transfers to fetch.
     */
    orderBy?: wallet_transfersOrderByWithRelationInput | wallet_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_transfers
    **/
    _count?: true | Wallet_transfersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_transfersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_transfersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_transfersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_transfersMaxAggregateInputType
  }

  export type GetWallet_transfersAggregateType<T extends Wallet_transfersAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_transfers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_transfers[P]>
      : GetScalarType<T[P], AggregateWallet_transfers[P]>
  }




  export type wallet_transfersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_transfersWhereInput
    orderBy?: wallet_transfersOrderByWithAggregationInput | wallet_transfersOrderByWithAggregationInput[]
    by: Wallet_transfersScalarFieldEnum[] | Wallet_transfersScalarFieldEnum
    having?: wallet_transfersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_transfersCountAggregateInputType | true
    _avg?: Wallet_transfersAvgAggregateInputType
    _sum?: Wallet_transfersSumAggregateInputType
    _min?: Wallet_transfersMinAggregateInputType
    _max?: Wallet_transfersMaxAggregateInputType
  }

  export type Wallet_transfersGroupByOutputType = {
    id: number
    amount: number | null
    currency: string | null
    time: Date | null
    payer_id: number | null
    payer_account_id: number | null
    payee_address: string | null
    payee_name: string | null
    payee_account_type: string | null
    payee_account_number: string | null
    payee_type: string | null
    tx_id: string | null
    fspid: string | null
    ext_trx_id: string | null
    pay_money_ext_res: string | null
    confirm_party_ext_res: string | null
    confirm_quote_ext_res: string | null
    status: string | null
    quote_id: string | null
    note: string | null
    transfer_fees: string | null
    _count: Wallet_transfersCountAggregateOutputType | null
    _avg: Wallet_transfersAvgAggregateOutputType | null
    _sum: Wallet_transfersSumAggregateOutputType | null
    _min: Wallet_transfersMinAggregateOutputType | null
    _max: Wallet_transfersMaxAggregateOutputType | null
  }

  type GetWallet_transfersGroupByPayload<T extends wallet_transfersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_transfersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_transfersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_transfersGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_transfersGroupByOutputType[P]>
        }
      >
    >


  export type wallet_transfersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    time?: boolean
    payer_id?: boolean
    payer_account_id?: boolean
    payee_address?: boolean
    payee_name?: boolean
    payee_account_type?: boolean
    payee_account_number?: boolean
    payee_type?: boolean
    tx_id?: boolean
    fspid?: boolean
    ext_trx_id?: boolean
    pay_money_ext_res?: boolean
    confirm_party_ext_res?: boolean
    confirm_quote_ext_res?: boolean
    status?: boolean
    quote_id?: boolean
    note?: boolean
    transfer_fees?: boolean
  }, ExtArgs["result"]["wallet_transfers"]>



  export type wallet_transfersSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    time?: boolean
    payer_id?: boolean
    payer_account_id?: boolean
    payee_address?: boolean
    payee_name?: boolean
    payee_account_type?: boolean
    payee_account_number?: boolean
    payee_type?: boolean
    tx_id?: boolean
    fspid?: boolean
    ext_trx_id?: boolean
    pay_money_ext_res?: boolean
    confirm_party_ext_res?: boolean
    confirm_quote_ext_res?: boolean
    status?: boolean
    quote_id?: boolean
    note?: boolean
    transfer_fees?: boolean
  }

  export type wallet_transfersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "currency" | "time" | "payer_id" | "payer_account_id" | "payee_address" | "payee_name" | "payee_account_type" | "payee_account_number" | "payee_type" | "tx_id" | "fspid" | "ext_trx_id" | "pay_money_ext_res" | "confirm_party_ext_res" | "confirm_quote_ext_res" | "status" | "quote_id" | "note" | "transfer_fees", ExtArgs["result"]["wallet_transfers"]>

  export type $wallet_transfersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_transfers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number | null
      currency: string | null
      time: Date | null
      payer_id: number | null
      payer_account_id: number | null
      payee_address: string | null
      payee_name: string | null
      payee_account_type: string | null
      payee_account_number: string | null
      payee_type: string | null
      tx_id: string | null
      fspid: string | null
      ext_trx_id: string | null
      pay_money_ext_res: string | null
      confirm_party_ext_res: string | null
      confirm_quote_ext_res: string | null
      status: string | null
      quote_id: string | null
      note: string | null
      transfer_fees: string | null
    }, ExtArgs["result"]["wallet_transfers"]>
    composites: {}
  }

  type wallet_transfersGetPayload<S extends boolean | null | undefined | wallet_transfersDefaultArgs> = $Result.GetResult<Prisma.$wallet_transfersPayload, S>

  type wallet_transfersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wallet_transfersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wallet_transfersCountAggregateInputType | true
    }

  export interface wallet_transfersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_transfers'], meta: { name: 'wallet_transfers' } }
    /**
     * Find zero or one Wallet_transfers that matches the filter.
     * @param {wallet_transfersFindUniqueArgs} args - Arguments to find a Wallet_transfers
     * @example
     * // Get one Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_transfersFindUniqueArgs>(args: SelectSubset<T, wallet_transfersFindUniqueArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet_transfers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wallet_transfersFindUniqueOrThrowArgs} args - Arguments to find a Wallet_transfers
     * @example
     * // Get one Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_transfersFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_transfersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transfersFindFirstArgs} args - Arguments to find a Wallet_transfers
     * @example
     * // Get one Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_transfersFindFirstArgs>(args?: SelectSubset<T, wallet_transfersFindFirstArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_transfers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transfersFindFirstOrThrowArgs} args - Arguments to find a Wallet_transfers
     * @example
     * // Get one Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_transfersFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_transfersFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallet_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transfersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.findMany()
     * 
     * // Get first 10 Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_transfersWithIdOnly = await prisma.wallet_transfers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_transfersFindManyArgs>(args?: SelectSubset<T, wallet_transfersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet_transfers.
     * @param {wallet_transfersCreateArgs} args - Arguments to create a Wallet_transfers.
     * @example
     * // Create one Wallet_transfers
     * const Wallet_transfers = await prisma.wallet_transfers.create({
     *   data: {
     *     // ... data to create a Wallet_transfers
     *   }
     * })
     * 
     */
    create<T extends wallet_transfersCreateArgs>(args: SelectSubset<T, wallet_transfersCreateArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallet_transfers.
     * @param {wallet_transfersCreateManyArgs} args - Arguments to create many Wallet_transfers.
     * @example
     * // Create many Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_transfersCreateManyArgs>(args?: SelectSubset<T, wallet_transfersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_transfers.
     * @param {wallet_transfersDeleteArgs} args - Arguments to delete one Wallet_transfers.
     * @example
     * // Delete one Wallet_transfers
     * const Wallet_transfers = await prisma.wallet_transfers.delete({
     *   where: {
     *     // ... filter to delete one Wallet_transfers
     *   }
     * })
     * 
     */
    delete<T extends wallet_transfersDeleteArgs>(args: SelectSubset<T, wallet_transfersDeleteArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet_transfers.
     * @param {wallet_transfersUpdateArgs} args - Arguments to update one Wallet_transfers.
     * @example
     * // Update one Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_transfersUpdateArgs>(args: SelectSubset<T, wallet_transfersUpdateArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallet_transfers.
     * @param {wallet_transfersDeleteManyArgs} args - Arguments to filter Wallet_transfers to delete.
     * @example
     * // Delete a few Wallet_transfers
     * const { count } = await prisma.wallet_transfers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_transfersDeleteManyArgs>(args?: SelectSubset<T, wallet_transfersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transfersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_transfersUpdateManyArgs>(args: SelectSubset<T, wallet_transfersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_transfers.
     * @param {wallet_transfersUpsertArgs} args - Arguments to update or create a Wallet_transfers.
     * @example
     * // Update or create a Wallet_transfers
     * const wallet_transfers = await prisma.wallet_transfers.upsert({
     *   create: {
     *     // ... data to create a Wallet_transfers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_transfers we want to update
     *   }
     * })
     */
    upsert<T extends wallet_transfersUpsertArgs>(args: SelectSubset<T, wallet_transfersUpsertArgs<ExtArgs>>): Prisma__wallet_transfersClient<$Result.GetResult<Prisma.$wallet_transfersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallet_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transfersCountArgs} args - Arguments to filter Wallet_transfers to count.
     * @example
     * // Count the number of Wallet_transfers
     * const count = await prisma.wallet_transfers.count({
     *   where: {
     *     // ... the filter for the Wallet_transfers we want to count
     *   }
     * })
    **/
    count<T extends wallet_transfersCountArgs>(
      args?: Subset<T, wallet_transfersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_transfersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_transfersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_transfersAggregateArgs>(args: Subset<T, Wallet_transfersAggregateArgs>): Prisma.PrismaPromise<GetWallet_transfersAggregateType<T>>

    /**
     * Group by Wallet_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_transfersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_transfersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_transfersGroupByArgs['orderBy'] }
        : { orderBy?: wallet_transfersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_transfersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_transfersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_transfers model
   */
  readonly fields: wallet_transfersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_transfers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_transfersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_transfers model
   */
  interface wallet_transfersFieldRefs {
    readonly id: FieldRef<"wallet_transfers", 'Int'>
    readonly amount: FieldRef<"wallet_transfers", 'Float'>
    readonly currency: FieldRef<"wallet_transfers", 'String'>
    readonly time: FieldRef<"wallet_transfers", 'DateTime'>
    readonly payer_id: FieldRef<"wallet_transfers", 'Int'>
    readonly payer_account_id: FieldRef<"wallet_transfers", 'Int'>
    readonly payee_address: FieldRef<"wallet_transfers", 'String'>
    readonly payee_name: FieldRef<"wallet_transfers", 'String'>
    readonly payee_account_type: FieldRef<"wallet_transfers", 'String'>
    readonly payee_account_number: FieldRef<"wallet_transfers", 'String'>
    readonly payee_type: FieldRef<"wallet_transfers", 'String'>
    readonly tx_id: FieldRef<"wallet_transfers", 'String'>
    readonly fspid: FieldRef<"wallet_transfers", 'String'>
    readonly ext_trx_id: FieldRef<"wallet_transfers", 'String'>
    readonly pay_money_ext_res: FieldRef<"wallet_transfers", 'String'>
    readonly confirm_party_ext_res: FieldRef<"wallet_transfers", 'String'>
    readonly confirm_quote_ext_res: FieldRef<"wallet_transfers", 'String'>
    readonly status: FieldRef<"wallet_transfers", 'String'>
    readonly quote_id: FieldRef<"wallet_transfers", 'String'>
    readonly note: FieldRef<"wallet_transfers", 'String'>
    readonly transfer_fees: FieldRef<"wallet_transfers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * wallet_transfers findUnique
   */
  export type wallet_transfersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_transfers to fetch.
     */
    where: wallet_transfersWhereUniqueInput
  }

  /**
   * wallet_transfers findUniqueOrThrow
   */
  export type wallet_transfersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_transfers to fetch.
     */
    where: wallet_transfersWhereUniqueInput
  }

  /**
   * wallet_transfers findFirst
   */
  export type wallet_transfersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_transfers to fetch.
     */
    where?: wallet_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transfers to fetch.
     */
    orderBy?: wallet_transfersOrderByWithRelationInput | wallet_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_transfers.
     */
    cursor?: wallet_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_transfers.
     */
    distinct?: Wallet_transfersScalarFieldEnum | Wallet_transfersScalarFieldEnum[]
  }

  /**
   * wallet_transfers findFirstOrThrow
   */
  export type wallet_transfersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_transfers to fetch.
     */
    where?: wallet_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transfers to fetch.
     */
    orderBy?: wallet_transfersOrderByWithRelationInput | wallet_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_transfers.
     */
    cursor?: wallet_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_transfers.
     */
    distinct?: Wallet_transfersScalarFieldEnum | Wallet_transfersScalarFieldEnum[]
  }

  /**
   * wallet_transfers findMany
   */
  export type wallet_transfersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_transfers to fetch.
     */
    where?: wallet_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_transfers to fetch.
     */
    orderBy?: wallet_transfersOrderByWithRelationInput | wallet_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_transfers.
     */
    cursor?: wallet_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_transfers.
     */
    skip?: number
    distinct?: Wallet_transfersScalarFieldEnum | Wallet_transfersScalarFieldEnum[]
  }

  /**
   * wallet_transfers create
   */
  export type wallet_transfersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * The data needed to create a wallet_transfers.
     */
    data?: XOR<wallet_transfersCreateInput, wallet_transfersUncheckedCreateInput>
  }

  /**
   * wallet_transfers createMany
   */
  export type wallet_transfersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_transfers.
     */
    data: wallet_transfersCreateManyInput | wallet_transfersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet_transfers update
   */
  export type wallet_transfersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * The data needed to update a wallet_transfers.
     */
    data: XOR<wallet_transfersUpdateInput, wallet_transfersUncheckedUpdateInput>
    /**
     * Choose, which wallet_transfers to update.
     */
    where: wallet_transfersWhereUniqueInput
  }

  /**
   * wallet_transfers updateMany
   */
  export type wallet_transfersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_transfers.
     */
    data: XOR<wallet_transfersUpdateManyMutationInput, wallet_transfersUncheckedUpdateManyInput>
    /**
     * Filter which wallet_transfers to update
     */
    where?: wallet_transfersWhereInput
    /**
     * Limit how many wallet_transfers to update.
     */
    limit?: number
  }

  /**
   * wallet_transfers upsert
   */
  export type wallet_transfersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * The filter to search for the wallet_transfers to update in case it exists.
     */
    where: wallet_transfersWhereUniqueInput
    /**
     * In case the wallet_transfers found by the `where` argument doesn't exist, create a new wallet_transfers with this data.
     */
    create: XOR<wallet_transfersCreateInput, wallet_transfersUncheckedCreateInput>
    /**
     * In case the wallet_transfers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_transfersUpdateInput, wallet_transfersUncheckedUpdateInput>
  }

  /**
   * wallet_transfers delete
   */
  export type wallet_transfersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
    /**
     * Filter which wallet_transfers to delete.
     */
    where: wallet_transfersWhereUniqueInput
  }

  /**
   * wallet_transfers deleteMany
   */
  export type wallet_transfersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_transfers to delete
     */
    where?: wallet_transfersWhereInput
    /**
     * Limit how many wallet_transfers to delete.
     */
    limit?: number
  }

  /**
   * wallet_transfers without action
   */
  export type wallet_transfersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_transfers
     */
    select?: wallet_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_transfers
     */
    omit?: wallet_transfersOmit<ExtArgs> | null
  }


  /**
   * Model wallet_users
   */

  export type AggregateWallet_users = {
    _count: Wallet_usersCountAggregateOutputType | null
    _avg: Wallet_usersAvgAggregateOutputType | null
    _sum: Wallet_usersSumAggregateOutputType | null
    _min: Wallet_usersMinAggregateOutputType | null
    _max: Wallet_usersMaxAggregateOutputType | null
  }

  export type Wallet_usersAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type Wallet_usersSumAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type Wallet_usersMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    fullname: string | null
    email: string | null
    private_key: string | null
    public_key: string | null
    initiated_at: Date | null
  }

  export type Wallet_usersMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    fullname: string | null
    email: string | null
    private_key: string | null
    public_key: string | null
    initiated_at: Date | null
  }

  export type Wallet_usersCountAggregateOutputType = {
    id: number
    device_id: number
    fullname: number
    email: number
    private_key: number
    public_key: number
    initiated_at: number
    _all: number
  }


  export type Wallet_usersAvgAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type Wallet_usersSumAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type Wallet_usersMinAggregateInputType = {
    id?: true
    device_id?: true
    fullname?: true
    email?: true
    private_key?: true
    public_key?: true
    initiated_at?: true
  }

  export type Wallet_usersMaxAggregateInputType = {
    id?: true
    device_id?: true
    fullname?: true
    email?: true
    private_key?: true
    public_key?: true
    initiated_at?: true
  }

  export type Wallet_usersCountAggregateInputType = {
    id?: true
    device_id?: true
    fullname?: true
    email?: true
    private_key?: true
    public_key?: true
    initiated_at?: true
    _all?: true
  }

  export type Wallet_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_users to aggregate.
     */
    where?: wallet_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_usersOrderByWithRelationInput | wallet_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_users
    **/
    _count?: true | Wallet_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_usersMaxAggregateInputType
  }

  export type GetWallet_usersAggregateType<T extends Wallet_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_users[P]>
      : GetScalarType<T[P], AggregateWallet_users[P]>
  }




  export type wallet_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_usersWhereInput
    orderBy?: wallet_usersOrderByWithAggregationInput | wallet_usersOrderByWithAggregationInput[]
    by: Wallet_usersScalarFieldEnum[] | Wallet_usersScalarFieldEnum
    having?: wallet_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_usersCountAggregateInputType | true
    _avg?: Wallet_usersAvgAggregateInputType
    _sum?: Wallet_usersSumAggregateInputType
    _min?: Wallet_usersMinAggregateInputType
    _max?: Wallet_usersMaxAggregateInputType
  }

  export type Wallet_usersGroupByOutputType = {
    id: number
    device_id: number | null
    fullname: string | null
    email: string | null
    private_key: string | null
    public_key: string | null
    initiated_at: Date
    _count: Wallet_usersCountAggregateOutputType | null
    _avg: Wallet_usersAvgAggregateOutputType | null
    _sum: Wallet_usersSumAggregateOutputType | null
    _min: Wallet_usersMinAggregateOutputType | null
    _max: Wallet_usersMaxAggregateOutputType | null
  }

  type GetWallet_usersGroupByPayload<T extends wallet_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_usersGroupByOutputType[P]>
        }
      >
    >


  export type wallet_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    fullname?: boolean
    email?: boolean
    private_key?: boolean
    public_key?: boolean
    initiated_at?: boolean
  }, ExtArgs["result"]["wallet_users"]>



  export type wallet_usersSelectScalar = {
    id?: boolean
    device_id?: boolean
    fullname?: boolean
    email?: boolean
    private_key?: boolean
    public_key?: boolean
    initiated_at?: boolean
  }

  export type wallet_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "fullname" | "email" | "private_key" | "public_key" | "initiated_at", ExtArgs["result"]["wallet_users"]>

  export type $wallet_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number | null
      fullname: string | null
      email: string | null
      private_key: string | null
      public_key: string | null
      initiated_at: Date
    }, ExtArgs["result"]["wallet_users"]>
    composites: {}
  }

  type wallet_usersGetPayload<S extends boolean | null | undefined | wallet_usersDefaultArgs> = $Result.GetResult<Prisma.$wallet_usersPayload, S>

  type wallet_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<wallet_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wallet_usersCountAggregateInputType | true
    }

  export interface wallet_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_users'], meta: { name: 'wallet_users' } }
    /**
     * Find zero or one Wallet_users that matches the filter.
     * @param {wallet_usersFindUniqueArgs} args - Arguments to find a Wallet_users
     * @example
     * // Get one Wallet_users
     * const wallet_users = await prisma.wallet_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_usersFindUniqueArgs>(args: SelectSubset<T, wallet_usersFindUniqueArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {wallet_usersFindUniqueOrThrowArgs} args - Arguments to find a Wallet_users
     * @example
     * // Get one Wallet_users
     * const wallet_users = await prisma.wallet_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_usersFindFirstArgs} args - Arguments to find a Wallet_users
     * @example
     * // Get one Wallet_users
     * const wallet_users = await prisma.wallet_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_usersFindFirstArgs>(args?: SelectSubset<T, wallet_usersFindFirstArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_usersFindFirstOrThrowArgs} args - Arguments to find a Wallet_users
     * @example
     * // Get one Wallet_users
     * const wallet_users = await prisma.wallet_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallet_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_users
     * const wallet_users = await prisma.wallet_users.findMany()
     * 
     * // Get first 10 Wallet_users
     * const wallet_users = await prisma.wallet_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_usersWithIdOnly = await prisma.wallet_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_usersFindManyArgs>(args?: SelectSubset<T, wallet_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet_users.
     * @param {wallet_usersCreateArgs} args - Arguments to create a Wallet_users.
     * @example
     * // Create one Wallet_users
     * const Wallet_users = await prisma.wallet_users.create({
     *   data: {
     *     // ... data to create a Wallet_users
     *   }
     * })
     * 
     */
    create<T extends wallet_usersCreateArgs>(args: SelectSubset<T, wallet_usersCreateArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallet_users.
     * @param {wallet_usersCreateManyArgs} args - Arguments to create many Wallet_users.
     * @example
     * // Create many Wallet_users
     * const wallet_users = await prisma.wallet_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_usersCreateManyArgs>(args?: SelectSubset<T, wallet_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_users.
     * @param {wallet_usersDeleteArgs} args - Arguments to delete one Wallet_users.
     * @example
     * // Delete one Wallet_users
     * const Wallet_users = await prisma.wallet_users.delete({
     *   where: {
     *     // ... filter to delete one Wallet_users
     *   }
     * })
     * 
     */
    delete<T extends wallet_usersDeleteArgs>(args: SelectSubset<T, wallet_usersDeleteArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet_users.
     * @param {wallet_usersUpdateArgs} args - Arguments to update one Wallet_users.
     * @example
     * // Update one Wallet_users
     * const wallet_users = await prisma.wallet_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_usersUpdateArgs>(args: SelectSubset<T, wallet_usersUpdateArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallet_users.
     * @param {wallet_usersDeleteManyArgs} args - Arguments to filter Wallet_users to delete.
     * @example
     * // Delete a few Wallet_users
     * const { count } = await prisma.wallet_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_usersDeleteManyArgs>(args?: SelectSubset<T, wallet_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_users
     * const wallet_users = await prisma.wallet_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_usersUpdateManyArgs>(args: SelectSubset<T, wallet_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_users.
     * @param {wallet_usersUpsertArgs} args - Arguments to update or create a Wallet_users.
     * @example
     * // Update or create a Wallet_users
     * const wallet_users = await prisma.wallet_users.upsert({
     *   create: {
     *     // ... data to create a Wallet_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_users we want to update
     *   }
     * })
     */
    upsert<T extends wallet_usersUpsertArgs>(args: SelectSubset<T, wallet_usersUpsertArgs<ExtArgs>>): Prisma__wallet_usersClient<$Result.GetResult<Prisma.$wallet_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallet_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_usersCountArgs} args - Arguments to filter Wallet_users to count.
     * @example
     * // Count the number of Wallet_users
     * const count = await prisma.wallet_users.count({
     *   where: {
     *     // ... the filter for the Wallet_users we want to count
     *   }
     * })
    **/
    count<T extends wallet_usersCountArgs>(
      args?: Subset<T, wallet_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_usersAggregateArgs>(args: Subset<T, Wallet_usersAggregateArgs>): Prisma.PrismaPromise<GetWallet_usersAggregateType<T>>

    /**
     * Group by Wallet_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_usersGroupByArgs['orderBy'] }
        : { orderBy?: wallet_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_users model
   */
  readonly fields: wallet_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_users model
   */
  interface wallet_usersFieldRefs {
    readonly id: FieldRef<"wallet_users", 'Int'>
    readonly device_id: FieldRef<"wallet_users", 'Int'>
    readonly fullname: FieldRef<"wallet_users", 'String'>
    readonly email: FieldRef<"wallet_users", 'String'>
    readonly private_key: FieldRef<"wallet_users", 'String'>
    readonly public_key: FieldRef<"wallet_users", 'String'>
    readonly initiated_at: FieldRef<"wallet_users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet_users findUnique
   */
  export type wallet_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_users to fetch.
     */
    where: wallet_usersWhereUniqueInput
  }

  /**
   * wallet_users findUniqueOrThrow
   */
  export type wallet_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_users to fetch.
     */
    where: wallet_usersWhereUniqueInput
  }

  /**
   * wallet_users findFirst
   */
  export type wallet_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_users to fetch.
     */
    where?: wallet_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_usersOrderByWithRelationInput | wallet_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_users.
     */
    cursor?: wallet_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_users.
     */
    distinct?: Wallet_usersScalarFieldEnum | Wallet_usersScalarFieldEnum[]
  }

  /**
   * wallet_users findFirstOrThrow
   */
  export type wallet_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_users to fetch.
     */
    where?: wallet_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_usersOrderByWithRelationInput | wallet_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_users.
     */
    cursor?: wallet_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_users.
     */
    distinct?: Wallet_usersScalarFieldEnum | Wallet_usersScalarFieldEnum[]
  }

  /**
   * wallet_users findMany
   */
  export type wallet_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * Filter, which wallet_users to fetch.
     */
    where?: wallet_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_usersOrderByWithRelationInput | wallet_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_users.
     */
    cursor?: wallet_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    distinct?: Wallet_usersScalarFieldEnum | Wallet_usersScalarFieldEnum[]
  }

  /**
   * wallet_users create
   */
  export type wallet_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * The data needed to create a wallet_users.
     */
    data?: XOR<wallet_usersCreateInput, wallet_usersUncheckedCreateInput>
  }

  /**
   * wallet_users createMany
   */
  export type wallet_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_users.
     */
    data: wallet_usersCreateManyInput | wallet_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet_users update
   */
  export type wallet_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * The data needed to update a wallet_users.
     */
    data: XOR<wallet_usersUpdateInput, wallet_usersUncheckedUpdateInput>
    /**
     * Choose, which wallet_users to update.
     */
    where: wallet_usersWhereUniqueInput
  }

  /**
   * wallet_users updateMany
   */
  export type wallet_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_users.
     */
    data: XOR<wallet_usersUpdateManyMutationInput, wallet_usersUncheckedUpdateManyInput>
    /**
     * Filter which wallet_users to update
     */
    where?: wallet_usersWhereInput
    /**
     * Limit how many wallet_users to update.
     */
    limit?: number
  }

  /**
   * wallet_users upsert
   */
  export type wallet_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * The filter to search for the wallet_users to update in case it exists.
     */
    where: wallet_usersWhereUniqueInput
    /**
     * In case the wallet_users found by the `where` argument doesn't exist, create a new wallet_users with this data.
     */
    create: XOR<wallet_usersCreateInput, wallet_usersUncheckedCreateInput>
    /**
     * In case the wallet_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_usersUpdateInput, wallet_usersUncheckedUpdateInput>
  }

  /**
   * wallet_users delete
   */
  export type wallet_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
    /**
     * Filter which wallet_users to delete.
     */
    where: wallet_usersWhereUniqueInput
  }

  /**
   * wallet_users deleteMany
   */
  export type wallet_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_users to delete
     */
    where?: wallet_usersWhereInput
    /**
     * Limit how many wallet_users to delete.
     */
    limit?: number
  }

  /**
   * wallet_users without action
   */
  export type wallet_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_users
     */
    select?: wallet_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet_users
     */
    omit?: wallet_usersOmit<ExtArgs> | null
  }


  /**
   * Model images
   */

  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    user_id: number | null
    review_id: number | null
  }

  export type ImagesSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    user_id: number | null
    review_id: number | null
  }

  export type ImagesMinAggregateOutputType = {
    id: number | null
    institution_id: number | null
    user_id: number | null
    type: string | null
    image_url: string | null
    caption: string | null
    uploaded_at: Date | null
    review_id: number | null
  }

  export type ImagesMaxAggregateOutputType = {
    id: number | null
    institution_id: number | null
    user_id: number | null
    type: string | null
    image_url: string | null
    caption: string | null
    uploaded_at: Date | null
    review_id: number | null
  }

  export type ImagesCountAggregateOutputType = {
    id: number
    institution_id: number
    user_id: number
    type: number
    image_url: number
    caption: number
    uploaded_at: number
    review_id: number
    _all: number
  }


  export type ImagesAvgAggregateInputType = {
    id?: true
    institution_id?: true
    user_id?: true
    review_id?: true
  }

  export type ImagesSumAggregateInputType = {
    id?: true
    institution_id?: true
    user_id?: true
    review_id?: true
  }

  export type ImagesMinAggregateInputType = {
    id?: true
    institution_id?: true
    user_id?: true
    type?: true
    image_url?: true
    caption?: true
    uploaded_at?: true
    review_id?: true
  }

  export type ImagesMaxAggregateInputType = {
    id?: true
    institution_id?: true
    user_id?: true
    type?: true
    image_url?: true
    caption?: true
    uploaded_at?: true
    review_id?: true
  }

  export type ImagesCountAggregateInputType = {
    id?: true
    institution_id?: true
    user_id?: true
    type?: true
    image_url?: true
    caption?: true
    uploaded_at?: true
    review_id?: true
    _all?: true
  }

  export type ImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to aggregate.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithAggregationInput | imagesOrderByWithAggregationInput[]
    by: ImagesScalarFieldEnum[] | ImagesScalarFieldEnum
    having?: imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _avg?: ImagesAvgAggregateInputType
    _sum?: ImagesSumAggregateInputType
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }

  export type ImagesGroupByOutputType = {
    id: number
    institution_id: number | null
    user_id: number | null
    type: string | null
    image_url: string | null
    caption: string | null
    uploaded_at: Date
    review_id: number | null
    _count: ImagesCountAggregateOutputType | null
    _avg: ImagesAvgAggregateOutputType | null
    _sum: ImagesSumAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution_id?: boolean
    user_id?: boolean
    type?: boolean
    image_url?: boolean
    caption?: boolean
    uploaded_at?: boolean
    review_id?: boolean
    institution?: boolean | images$institutionArgs<ExtArgs>
    reviews?: boolean | images$reviewsArgs<ExtArgs>
    users_profile?: boolean | images$users_profileArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>



  export type imagesSelectScalar = {
    id?: boolean
    institution_id?: boolean
    user_id?: boolean
    type?: boolean
    image_url?: boolean
    caption?: boolean
    uploaded_at?: boolean
    review_id?: boolean
  }

  export type imagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution_id" | "user_id" | "type" | "image_url" | "caption" | "uploaded_at" | "review_id", ExtArgs["result"]["images"]>
  export type imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | images$institutionArgs<ExtArgs>
    reviews?: boolean | images$reviewsArgs<ExtArgs>
    users_profile?: boolean | images$users_profileArgs<ExtArgs>
  }

  export type $imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "images"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs> | null
      reviews: Prisma.$reviewsPayload<ExtArgs> | null
      users_profile: Prisma.$users_profilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institution_id: number | null
      user_id: number | null
      type: string | null
      image_url: string | null
      caption: string | null
      uploaded_at: Date
      review_id: number | null
    }, ExtArgs["result"]["images"]>
    composites: {}
  }

  type imagesGetPayload<S extends boolean | null | undefined | imagesDefaultArgs> = $Result.GetResult<Prisma.$imagesPayload, S>

  type imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<imagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['images'], meta: { name: 'images' } }
    /**
     * Find zero or one Images that matches the filter.
     * @param {imagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends imagesFindUniqueArgs>(args: SelectSubset<T, imagesFindUniqueArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {imagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends imagesFindFirstArgs>(args?: SelectSubset<T, imagesFindFirstArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagesWithIdOnly = await prisma.images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends imagesFindManyArgs>(args?: SelectSubset<T, imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Images.
     * @param {imagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
     */
    create<T extends imagesCreateArgs>(args: SelectSubset<T, imagesCreateArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {imagesCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends imagesCreateManyArgs>(args?: SelectSubset<T, imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Images.
     * @param {imagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
     */
    delete<T extends imagesDeleteArgs>(args: SelectSubset<T, imagesDeleteArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Images.
     * @param {imagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends imagesUpdateArgs>(args: SelectSubset<T, imagesUpdateArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {imagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends imagesDeleteManyArgs>(args?: SelectSubset<T, imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends imagesUpdateManyArgs>(args: SelectSubset<T, imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Images.
     * @param {imagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
     */
    upsert<T extends imagesUpsertArgs>(args: SelectSubset<T, imagesUpsertArgs<ExtArgs>>): Prisma__imagesClient<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends imagesCountArgs>(
      args?: Subset<T, imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: imagesGroupByArgs['orderBy'] }
        : { orderBy?: imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the images model
   */
  readonly fields: imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends images$institutionArgs<ExtArgs> = {}>(args?: Subset<T, images$institutionArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends images$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, images$reviewsArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_profile<T extends images$users_profileArgs<ExtArgs> = {}>(args?: Subset<T, images$users_profileArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the images model
   */
  interface imagesFieldRefs {
    readonly id: FieldRef<"images", 'Int'>
    readonly institution_id: FieldRef<"images", 'Int'>
    readonly user_id: FieldRef<"images", 'Int'>
    readonly type: FieldRef<"images", 'String'>
    readonly image_url: FieldRef<"images", 'String'>
    readonly caption: FieldRef<"images", 'String'>
    readonly uploaded_at: FieldRef<"images", 'DateTime'>
    readonly review_id: FieldRef<"images", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * images findUnique
   */
  export type imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findUniqueOrThrow
   */
  export type imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findFirst
   */
  export type imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images findFirstOrThrow
   */
  export type imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images findMany
   */
  export type imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * images create
   */
  export type imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a images.
     */
    data?: XOR<imagesCreateInput, imagesUncheckedCreateInput>
  }

  /**
   * images createMany
   */
  export type imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many images.
     */
    data: imagesCreateManyInput | imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * images update
   */
  export type imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a images.
     */
    data: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
    /**
     * Choose, which images to update.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images updateMany
   */
  export type imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update images.
     */
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to update.
     */
    limit?: number
  }

  /**
   * images upsert
   */
  export type imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the images to update in case it exists.
     */
    where: imagesWhereUniqueInput
    /**
     * In case the images found by the `where` argument doesn't exist, create a new images with this data.
     */
    create: XOR<imagesCreateInput, imagesUncheckedCreateInput>
    /**
     * In case the images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
  }

  /**
   * images delete
   */
  export type imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    /**
     * Filter which images to delete.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images deleteMany
   */
  export type imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which images to delete
     */
    where?: imagesWhereInput
    /**
     * Limit how many images to delete.
     */
    limit?: number
  }

  /**
   * images.institution
   */
  export type images$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
  }

  /**
   * images.reviews
   */
  export type images$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
  }

  /**
   * images.users_profile
   */
  export type images$users_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    where?: users_profileWhereInput
  }

  /**
   * images without action
   */
  export type imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
  }


  /**
   * Model sectors
   */

  export type AggregateSectors = {
    _count: SectorsCountAggregateOutputType | null
    _avg: SectorsAvgAggregateOutputType | null
    _sum: SectorsSumAggregateOutputType | null
    _min: SectorsMinAggregateOutputType | null
    _max: SectorsMaxAggregateOutputType | null
  }

  export type SectorsAvgAggregateOutputType = {
    id: number | null
  }

  export type SectorsSumAggregateOutputType = {
    id: number | null
  }

  export type SectorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SectorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SectorsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type SectorsAvgAggregateInputType = {
    id?: true
  }

  export type SectorsSumAggregateInputType = {
    id?: true
  }

  export type SectorsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SectorsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SectorsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SectorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sectors to aggregate.
     */
    where?: sectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sectors to fetch.
     */
    orderBy?: sectorsOrderByWithRelationInput | sectorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sectors
    **/
    _count?: true | SectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectorsMaxAggregateInputType
  }

  export type GetSectorsAggregateType<T extends SectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectors[P]>
      : GetScalarType<T[P], AggregateSectors[P]>
  }




  export type sectorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sectorsWhereInput
    orderBy?: sectorsOrderByWithAggregationInput | sectorsOrderByWithAggregationInput[]
    by: SectorsScalarFieldEnum[] | SectorsScalarFieldEnum
    having?: sectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectorsCountAggregateInputType | true
    _avg?: SectorsAvgAggregateInputType
    _sum?: SectorsSumAggregateInputType
    _min?: SectorsMinAggregateInputType
    _max?: SectorsMaxAggregateInputType
  }

  export type SectorsGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    _count: SectorsCountAggregateOutputType | null
    _avg: SectorsAvgAggregateOutputType | null
    _sum: SectorsSumAggregateOutputType | null
    _min: SectorsMinAggregateOutputType | null
    _max: SectorsMaxAggregateOutputType | null
  }

  type GetSectorsGroupByPayload<T extends sectorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectorsGroupByOutputType[P]>
            : GetScalarType<T[P], SectorsGroupByOutputType[P]>
        }
      >
    >


  export type sectorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    categories?: boolean | sectors$categoriesArgs<ExtArgs>
    _count?: boolean | SectorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectors"]>



  export type sectorsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type sectorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["sectors"]>
  export type sectorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | sectors$categoriesArgs<ExtArgs>
    _count?: boolean | SectorsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sectorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sectors"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      description: string | null
    }, ExtArgs["result"]["sectors"]>
    composites: {}
  }

  type sectorsGetPayload<S extends boolean | null | undefined | sectorsDefaultArgs> = $Result.GetResult<Prisma.$sectorsPayload, S>

  type sectorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sectorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectorsCountAggregateInputType | true
    }

  export interface sectorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sectors'], meta: { name: 'sectors' } }
    /**
     * Find zero or one Sectors that matches the filter.
     * @param {sectorsFindUniqueArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sectorsFindUniqueArgs>(args: SelectSubset<T, sectorsFindUniqueArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sectors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sectorsFindUniqueOrThrowArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sectorsFindUniqueOrThrowArgs>(args: SelectSubset<T, sectorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectorsFindFirstArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sectorsFindFirstArgs>(args?: SelectSubset<T, sectorsFindFirstArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sectors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectorsFindFirstOrThrowArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sectorsFindFirstOrThrowArgs>(args?: SelectSubset<T, sectorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sectors
     * const sectors = await prisma.sectors.findMany()
     * 
     * // Get first 10 Sectors
     * const sectors = await prisma.sectors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorsWithIdOnly = await prisma.sectors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sectorsFindManyArgs>(args?: SelectSubset<T, sectorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sectors.
     * @param {sectorsCreateArgs} args - Arguments to create a Sectors.
     * @example
     * // Create one Sectors
     * const Sectors = await prisma.sectors.create({
     *   data: {
     *     // ... data to create a Sectors
     *   }
     * })
     * 
     */
    create<T extends sectorsCreateArgs>(args: SelectSubset<T, sectorsCreateArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sectors.
     * @param {sectorsCreateManyArgs} args - Arguments to create many Sectors.
     * @example
     * // Create many Sectors
     * const sectors = await prisma.sectors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sectorsCreateManyArgs>(args?: SelectSubset<T, sectorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sectors.
     * @param {sectorsDeleteArgs} args - Arguments to delete one Sectors.
     * @example
     * // Delete one Sectors
     * const Sectors = await prisma.sectors.delete({
     *   where: {
     *     // ... filter to delete one Sectors
     *   }
     * })
     * 
     */
    delete<T extends sectorsDeleteArgs>(args: SelectSubset<T, sectorsDeleteArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sectors.
     * @param {sectorsUpdateArgs} args - Arguments to update one Sectors.
     * @example
     * // Update one Sectors
     * const sectors = await prisma.sectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sectorsUpdateArgs>(args: SelectSubset<T, sectorsUpdateArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sectors.
     * @param {sectorsDeleteManyArgs} args - Arguments to filter Sectors to delete.
     * @example
     * // Delete a few Sectors
     * const { count } = await prisma.sectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sectorsDeleteManyArgs>(args?: SelectSubset<T, sectorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sectors
     * const sectors = await prisma.sectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sectorsUpdateManyArgs>(args: SelectSubset<T, sectorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sectors.
     * @param {sectorsUpsertArgs} args - Arguments to update or create a Sectors.
     * @example
     * // Update or create a Sectors
     * const sectors = await prisma.sectors.upsert({
     *   create: {
     *     // ... data to create a Sectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sectors we want to update
     *   }
     * })
     */
    upsert<T extends sectorsUpsertArgs>(args: SelectSubset<T, sectorsUpsertArgs<ExtArgs>>): Prisma__sectorsClient<$Result.GetResult<Prisma.$sectorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectorsCountArgs} args - Arguments to filter Sectors to count.
     * @example
     * // Count the number of Sectors
     * const count = await prisma.sectors.count({
     *   where: {
     *     // ... the filter for the Sectors we want to count
     *   }
     * })
    **/
    count<T extends sectorsCountArgs>(
      args?: Subset<T, sectorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorsAggregateArgs>(args: Subset<T, SectorsAggregateArgs>): Prisma.PrismaPromise<GetSectorsAggregateType<T>>

    /**
     * Group by Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sectorsGroupByArgs['orderBy'] }
        : { orderBy?: sectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sectors model
   */
  readonly fields: sectorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sectorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends sectors$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, sectors$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sectors model
   */
  interface sectorsFieldRefs {
    readonly id: FieldRef<"sectors", 'Int'>
    readonly name: FieldRef<"sectors", 'String'>
    readonly description: FieldRef<"sectors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sectors findUnique
   */
  export type sectorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * Filter, which sectors to fetch.
     */
    where: sectorsWhereUniqueInput
  }

  /**
   * sectors findUniqueOrThrow
   */
  export type sectorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * Filter, which sectors to fetch.
     */
    where: sectorsWhereUniqueInput
  }

  /**
   * sectors findFirst
   */
  export type sectorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * Filter, which sectors to fetch.
     */
    where?: sectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sectors to fetch.
     */
    orderBy?: sectorsOrderByWithRelationInput | sectorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sectors.
     */
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sectors.
     */
    distinct?: SectorsScalarFieldEnum | SectorsScalarFieldEnum[]
  }

  /**
   * sectors findFirstOrThrow
   */
  export type sectorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * Filter, which sectors to fetch.
     */
    where?: sectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sectors to fetch.
     */
    orderBy?: sectorsOrderByWithRelationInput | sectorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sectors.
     */
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sectors.
     */
    distinct?: SectorsScalarFieldEnum | SectorsScalarFieldEnum[]
  }

  /**
   * sectors findMany
   */
  export type sectorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * Filter, which sectors to fetch.
     */
    where?: sectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sectors to fetch.
     */
    orderBy?: sectorsOrderByWithRelationInput | sectorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sectors.
     */
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
     */
    skip?: number
    distinct?: SectorsScalarFieldEnum | SectorsScalarFieldEnum[]
  }

  /**
   * sectors create
   */
  export type sectorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * The data needed to create a sectors.
     */
    data?: XOR<sectorsCreateInput, sectorsUncheckedCreateInput>
  }

  /**
   * sectors createMany
   */
  export type sectorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sectors.
     */
    data: sectorsCreateManyInput | sectorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sectors update
   */
  export type sectorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * The data needed to update a sectors.
     */
    data: XOR<sectorsUpdateInput, sectorsUncheckedUpdateInput>
    /**
     * Choose, which sectors to update.
     */
    where: sectorsWhereUniqueInput
  }

  /**
   * sectors updateMany
   */
  export type sectorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sectors.
     */
    data: XOR<sectorsUpdateManyMutationInput, sectorsUncheckedUpdateManyInput>
    /**
     * Filter which sectors to update
     */
    where?: sectorsWhereInput
    /**
     * Limit how many sectors to update.
     */
    limit?: number
  }

  /**
   * sectors upsert
   */
  export type sectorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * The filter to search for the sectors to update in case it exists.
     */
    where: sectorsWhereUniqueInput
    /**
     * In case the sectors found by the `where` argument doesn't exist, create a new sectors with this data.
     */
    create: XOR<sectorsCreateInput, sectorsUncheckedCreateInput>
    /**
     * In case the sectors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sectorsUpdateInput, sectorsUncheckedUpdateInput>
  }

  /**
   * sectors delete
   */
  export type sectorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
    /**
     * Filter which sectors to delete.
     */
    where: sectorsWhereUniqueInput
  }

  /**
   * sectors deleteMany
   */
  export type sectorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sectors to delete
     */
    where?: sectorsWhereInput
    /**
     * Limit how many sectors to delete.
     */
    limit?: number
  }

  /**
   * sectors.categories
   */
  export type sectors$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * sectors without action
   */
  export type sectorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sectors
     */
    select?: sectorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sectors
     */
    omit?: sectorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectorsInclude<ExtArgs> | null
  }


  /**
   * Model users_profile
   */

  export type AggregateUsers_profile = {
    _count: Users_profileCountAggregateOutputType | null
    _avg: Users_profileAvgAggregateOutputType | null
    _sum: Users_profileSumAggregateOutputType | null
    _min: Users_profileMinAggregateOutputType | null
    _max: Users_profileMaxAggregateOutputType | null
  }

  export type Users_profileAvgAggregateOutputType = {
    id: number | null
  }

  export type Users_profileSumAggregateOutputType = {
    id: number | null
  }

  export type Users_profileMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone_number: string | null
    age_group: string | null
    gender: string | null
    address: string | null
    added_at: Date | null
    isVerified: boolean | null
    verifyToken: string | null
  }

  export type Users_profileMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    phone_number: string | null
    age_group: string | null
    gender: string | null
    address: string | null
    added_at: Date | null
    isVerified: boolean | null
    verifyToken: string | null
  }

  export type Users_profileCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    phone_number: number
    age_group: number
    gender: number
    address: number
    added_at: number
    isVerified: number
    verifyToken: number
    _all: number
  }


  export type Users_profileAvgAggregateInputType = {
    id?: true
  }

  export type Users_profileSumAggregateInputType = {
    id?: true
  }

  export type Users_profileMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone_number?: true
    age_group?: true
    gender?: true
    address?: true
    added_at?: true
    isVerified?: true
    verifyToken?: true
  }

  export type Users_profileMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone_number?: true
    age_group?: true
    gender?: true
    address?: true
    added_at?: true
    isVerified?: true
    verifyToken?: true
  }

  export type Users_profileCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    phone_number?: true
    age_group?: true
    gender?: true
    address?: true
    added_at?: true
    isVerified?: true
    verifyToken?: true
    _all?: true
  }

  export type Users_profileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_profile to aggregate.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_profiles
    **/
    _count?: true | Users_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_profileMaxAggregateInputType
  }

  export type GetUsers_profileAggregateType<T extends Users_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_profile[P]>
      : GetScalarType<T[P], AggregateUsers_profile[P]>
  }




  export type users_profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_profileWhereInput
    orderBy?: users_profileOrderByWithAggregationInput | users_profileOrderByWithAggregationInput[]
    by: Users_profileScalarFieldEnum[] | Users_profileScalarFieldEnum
    having?: users_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_profileCountAggregateInputType | true
    _avg?: Users_profileAvgAggregateInputType
    _sum?: Users_profileSumAggregateInputType
    _min?: Users_profileMinAggregateInputType
    _max?: Users_profileMaxAggregateInputType
  }

  export type Users_profileGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number: string | null
    age_group: string | null
    gender: string | null
    address: string | null
    added_at: Date
    isVerified: boolean | null
    verifyToken: string | null
    _count: Users_profileCountAggregateOutputType | null
    _avg: Users_profileAvgAggregateOutputType | null
    _sum: Users_profileSumAggregateOutputType | null
    _min: Users_profileMinAggregateOutputType | null
    _max: Users_profileMaxAggregateOutputType | null
  }

  type GetUsers_profileGroupByPayload<T extends users_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Users_profileGroupByOutputType[P]>
        }
      >
    >


  export type users_profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    age_group?: boolean
    gender?: boolean
    address?: boolean
    added_at?: boolean
    isVerified?: boolean
    verifyToken?: boolean
    images?: boolean | users_profile$imagesArgs<ExtArgs>
    reviews?: boolean | users_profile$reviewsArgs<ExtArgs>
    serviceReview?: boolean | users_profile$serviceReviewArgs<ExtArgs>
    _count?: boolean | Users_profileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_profile"]>



  export type users_profileSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    age_group?: boolean
    gender?: boolean
    address?: boolean
    added_at?: boolean
    isVerified?: boolean
    verifyToken?: boolean
  }

  export type users_profileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "phone_number" | "age_group" | "gender" | "address" | "added_at" | "isVerified" | "verifyToken", ExtArgs["result"]["users_profile"]>
  export type users_profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | users_profile$imagesArgs<ExtArgs>
    reviews?: boolean | users_profile$reviewsArgs<ExtArgs>
    serviceReview?: boolean | users_profile$serviceReviewArgs<ExtArgs>
    _count?: boolean | Users_profileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $users_profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_profile"
    objects: {
      images: Prisma.$imagesPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
      serviceReview: Prisma.$serviceReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      phone_number: string | null
      age_group: string | null
      gender: string | null
      address: string | null
      added_at: Date
      isVerified: boolean | null
      verifyToken: string | null
    }, ExtArgs["result"]["users_profile"]>
    composites: {}
  }

  type users_profileGetPayload<S extends boolean | null | undefined | users_profileDefaultArgs> = $Result.GetResult<Prisma.$users_profilePayload, S>

  type users_profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users_profileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users_profileCountAggregateInputType | true
    }

  export interface users_profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_profile'], meta: { name: 'users_profile' } }
    /**
     * Find zero or one Users_profile that matches the filter.
     * @param {users_profileFindUniqueArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users_profileFindUniqueArgs>(args: SelectSubset<T, users_profileFindUniqueArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users_profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users_profileFindUniqueOrThrowArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users_profileFindUniqueOrThrowArgs>(args: SelectSubset<T, users_profileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileFindFirstArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users_profileFindFirstArgs>(args?: SelectSubset<T, users_profileFindFirstArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileFindFirstOrThrowArgs} args - Arguments to find a Users_profile
     * @example
     * // Get one Users_profile
     * const users_profile = await prisma.users_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users_profileFindFirstOrThrowArgs>(args?: SelectSubset<T, users_profileFindFirstOrThrowArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_profiles
     * const users_profiles = await prisma.users_profile.findMany()
     * 
     * // Get first 10 Users_profiles
     * const users_profiles = await prisma.users_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_profileWithIdOnly = await prisma.users_profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users_profileFindManyArgs>(args?: SelectSubset<T, users_profileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users_profile.
     * @param {users_profileCreateArgs} args - Arguments to create a Users_profile.
     * @example
     * // Create one Users_profile
     * const Users_profile = await prisma.users_profile.create({
     *   data: {
     *     // ... data to create a Users_profile
     *   }
     * })
     * 
     */
    create<T extends users_profileCreateArgs>(args: SelectSubset<T, users_profileCreateArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users_profiles.
     * @param {users_profileCreateManyArgs} args - Arguments to create many Users_profiles.
     * @example
     * // Create many Users_profiles
     * const users_profile = await prisma.users_profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users_profileCreateManyArgs>(args?: SelectSubset<T, users_profileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_profile.
     * @param {users_profileDeleteArgs} args - Arguments to delete one Users_profile.
     * @example
     * // Delete one Users_profile
     * const Users_profile = await prisma.users_profile.delete({
     *   where: {
     *     // ... filter to delete one Users_profile
     *   }
     * })
     * 
     */
    delete<T extends users_profileDeleteArgs>(args: SelectSubset<T, users_profileDeleteArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users_profile.
     * @param {users_profileUpdateArgs} args - Arguments to update one Users_profile.
     * @example
     * // Update one Users_profile
     * const users_profile = await prisma.users_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users_profileUpdateArgs>(args: SelectSubset<T, users_profileUpdateArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users_profiles.
     * @param {users_profileDeleteManyArgs} args - Arguments to filter Users_profiles to delete.
     * @example
     * // Delete a few Users_profiles
     * const { count } = await prisma.users_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users_profileDeleteManyArgs>(args?: SelectSubset<T, users_profileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_profiles
     * const users_profile = await prisma.users_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users_profileUpdateManyArgs>(args: SelectSubset<T, users_profileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_profile.
     * @param {users_profileUpsertArgs} args - Arguments to update or create a Users_profile.
     * @example
     * // Update or create a Users_profile
     * const users_profile = await prisma.users_profile.upsert({
     *   create: {
     *     // ... data to create a Users_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_profile we want to update
     *   }
     * })
     */
    upsert<T extends users_profileUpsertArgs>(args: SelectSubset<T, users_profileUpsertArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileCountArgs} args - Arguments to filter Users_profiles to count.
     * @example
     * // Count the number of Users_profiles
     * const count = await prisma.users_profile.count({
     *   where: {
     *     // ... the filter for the Users_profiles we want to count
     *   }
     * })
    **/
    count<T extends users_profileCountArgs>(
      args?: Subset<T, users_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_profileAggregateArgs>(args: Subset<T, Users_profileAggregateArgs>): Prisma.PrismaPromise<GetUsers_profileAggregateType<T>>

    /**
     * Group by Users_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_profileGroupByArgs['orderBy'] }
        : { orderBy?: users_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_profile model
   */
  readonly fields: users_profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends users_profile$imagesArgs<ExtArgs> = {}>(args?: Subset<T, users_profile$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends users_profile$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, users_profile$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceReview<T extends users_profile$serviceReviewArgs<ExtArgs> = {}>(args?: Subset<T, users_profile$serviceReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users_profile model
   */
  interface users_profileFieldRefs {
    readonly id: FieldRef<"users_profile", 'Int'>
    readonly first_name: FieldRef<"users_profile", 'String'>
    readonly last_name: FieldRef<"users_profile", 'String'>
    readonly email: FieldRef<"users_profile", 'String'>
    readonly password: FieldRef<"users_profile", 'String'>
    readonly phone_number: FieldRef<"users_profile", 'String'>
    readonly age_group: FieldRef<"users_profile", 'String'>
    readonly gender: FieldRef<"users_profile", 'String'>
    readonly address: FieldRef<"users_profile", 'String'>
    readonly added_at: FieldRef<"users_profile", 'DateTime'>
    readonly isVerified: FieldRef<"users_profile", 'Boolean'>
    readonly verifyToken: FieldRef<"users_profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users_profile findUnique
   */
  export type users_profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where: users_profileWhereUniqueInput
  }

  /**
   * users_profile findUniqueOrThrow
   */
  export type users_profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where: users_profileWhereUniqueInput
  }

  /**
   * users_profile findFirst
   */
  export type users_profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_profiles.
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_profiles.
     */
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }

  /**
   * users_profile findFirstOrThrow
   */
  export type users_profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profile to fetch.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_profiles.
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_profiles.
     */
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }

  /**
   * users_profile findMany
   */
  export type users_profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter, which users_profiles to fetch.
     */
    where?: users_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_profiles to fetch.
     */
    orderBy?: users_profileOrderByWithRelationInput | users_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_profiles.
     */
    cursor?: users_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_profiles.
     */
    skip?: number
    distinct?: Users_profileScalarFieldEnum | Users_profileScalarFieldEnum[]
  }

  /**
   * users_profile create
   */
  export type users_profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * The data needed to create a users_profile.
     */
    data: XOR<users_profileCreateInput, users_profileUncheckedCreateInput>
  }

  /**
   * users_profile createMany
   */
  export type users_profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_profiles.
     */
    data: users_profileCreateManyInput | users_profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_profile update
   */
  export type users_profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * The data needed to update a users_profile.
     */
    data: XOR<users_profileUpdateInput, users_profileUncheckedUpdateInput>
    /**
     * Choose, which users_profile to update.
     */
    where: users_profileWhereUniqueInput
  }

  /**
   * users_profile updateMany
   */
  export type users_profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_profiles.
     */
    data: XOR<users_profileUpdateManyMutationInput, users_profileUncheckedUpdateManyInput>
    /**
     * Filter which users_profiles to update
     */
    where?: users_profileWhereInput
    /**
     * Limit how many users_profiles to update.
     */
    limit?: number
  }

  /**
   * users_profile upsert
   */
  export type users_profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * The filter to search for the users_profile to update in case it exists.
     */
    where: users_profileWhereUniqueInput
    /**
     * In case the users_profile found by the `where` argument doesn't exist, create a new users_profile with this data.
     */
    create: XOR<users_profileCreateInput, users_profileUncheckedCreateInput>
    /**
     * In case the users_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_profileUpdateInput, users_profileUncheckedUpdateInput>
  }

  /**
   * users_profile delete
   */
  export type users_profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    /**
     * Filter which users_profile to delete.
     */
    where: users_profileWhereUniqueInput
  }

  /**
   * users_profile deleteMany
   */
  export type users_profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_profiles to delete
     */
    where?: users_profileWhereInput
    /**
     * Limit how many users_profiles to delete.
     */
    limit?: number
  }

  /**
   * users_profile.images
   */
  export type users_profile$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * users_profile.reviews
   */
  export type users_profile$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * users_profile.serviceReview
   */
  export type users_profile$serviceReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    where?: serviceReviewWhereInput
    orderBy?: serviceReviewOrderByWithRelationInput | serviceReviewOrderByWithRelationInput[]
    cursor?: serviceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceReviewScalarFieldEnum | ServiceReviewScalarFieldEnum[]
  }

  /**
   * users_profile without action
   */
  export type users_profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
  }


  /**
   * Model reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: number | null
    rating: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: number | null
    rating: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: number | null
    rating: number | null
    review: string | null
    created_at: Date | null
    is_approved: boolean | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: number | null
    rating: number | null
    review: string | null
    created_at: Date | null
    is_approved: boolean | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    user_id: number
    institution_id: number
    rating: number
    review: number
    created_at: number
    is_approved: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    rating?: true
    review?: true
    created_at?: true
    is_approved?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    rating?: true
    review?: true
    created_at?: true
    is_approved?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    rating?: true
    review?: true
    created_at?: true
    is_approved?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to aggregate.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithAggregationInput | reviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: number
    user_id: number
    institution_id: number
    rating: number
    review: string | null
    created_at: Date
    is_approved: boolean | null
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution_id?: boolean
    rating?: boolean
    review?: boolean
    created_at?: boolean
    is_approved?: boolean
    images?: boolean | reviews$imagesArgs<ExtArgs>
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    users_profile?: boolean | users_profileDefaultArgs<ExtArgs>
    _count?: boolean | ReviewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>



  export type reviewsSelectScalar = {
    id?: boolean
    user_id?: boolean
    institution_id?: boolean
    rating?: boolean
    review?: boolean
    created_at?: boolean
    is_approved?: boolean
  }

  export type reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "institution_id" | "rating" | "review" | "created_at" | "is_approved", ExtArgs["result"]["reviews"]>
  export type reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | reviews$imagesArgs<ExtArgs>
    institution?: boolean | institutionDefaultArgs<ExtArgs>
    users_profile?: boolean | users_profileDefaultArgs<ExtArgs>
    _count?: boolean | ReviewsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews"
    objects: {
      images: Prisma.$imagesPayload<ExtArgs>[]
      institution: Prisma.$institutionPayload<ExtArgs>
      users_profile: Prisma.$users_profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      institution_id: number
      rating: number
      review: string | null
      created_at: Date
      is_approved: boolean | null
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type reviewsGetPayload<S extends boolean | null | undefined | reviewsDefaultArgs> = $Result.GetResult<Prisma.$reviewsPayload, S>

  type reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews'], meta: { name: 'reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {reviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsFindUniqueArgs>(args: SelectSubset<T, reviewsFindUniqueArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsFindFirstArgs>(args?: SelectSubset<T, reviewsFindFirstArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsFindManyArgs>(args?: SelectSubset<T, reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {reviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends reviewsCreateArgs>(args: SelectSubset<T, reviewsCreateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCreateManyArgs>(args?: SelectSubset<T, reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reviews.
     * @param {reviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends reviewsDeleteArgs>(args: SelectSubset<T, reviewsDeleteArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {reviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsUpdateArgs>(args: SelectSubset<T, reviewsUpdateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsDeleteManyArgs>(args?: SelectSubset<T, reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsUpdateManyArgs>(args: SelectSubset<T, reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reviews.
     * @param {reviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends reviewsUpsertArgs>(args: SelectSubset<T, reviewsUpsertArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewsCountArgs>(
      args?: Subset<T, reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsGroupByArgs['orderBy'] }
        : { orderBy?: reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews model
   */
  readonly fields: reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends reviews$imagesArgs<ExtArgs> = {}>(args?: Subset<T, reviews$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_profile<T extends users_profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, users_profileDefaultArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviews model
   */
  interface reviewsFieldRefs {
    readonly id: FieldRef<"reviews", 'Int'>
    readonly user_id: FieldRef<"reviews", 'Int'>
    readonly institution_id: FieldRef<"reviews", 'Int'>
    readonly rating: FieldRef<"reviews", 'Int'>
    readonly review: FieldRef<"reviews", 'String'>
    readonly created_at: FieldRef<"reviews", 'DateTime'>
    readonly is_approved: FieldRef<"reviews", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * reviews findUnique
   */
  export type reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findUniqueOrThrow
   */
  export type reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findFirst
   */
  export type reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findFirstOrThrow
   */
  export type reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findMany
   */
  export type reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews create
   */
  export type reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a reviews.
     */
    data: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
  }

  /**
   * reviews createMany
   */
  export type reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews update
   */
  export type reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a reviews.
     */
    data: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
    /**
     * Choose, which reviews to update.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews updateMany
   */
  export type reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * reviews upsert
   */
  export type reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the reviews to update in case it exists.
     */
    where: reviewsWhereUniqueInput
    /**
     * In case the reviews found by the `where` argument doesn't exist, create a new reviews with this data.
     */
    create: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
    /**
     * In case the reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
  }

  /**
   * reviews delete
   */
  export type reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter which reviews to delete.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews deleteMany
   */
  export type reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * reviews.images
   */
  export type reviews$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the images
     */
    omit?: imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imagesInclude<ExtArgs> | null
    where?: imagesWhereInput
    orderBy?: imagesOrderByWithRelationInput | imagesOrderByWithRelationInput[]
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * reviews without action
   */
  export type reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
  }


  /**
   * Model workingHour
   */

  export type AggregateWorkingHour = {
    _count: WorkingHourCountAggregateOutputType | null
    _avg: WorkingHourAvgAggregateOutputType | null
    _sum: WorkingHourSumAggregateOutputType | null
    _min: WorkingHourMinAggregateOutputType | null
    _max: WorkingHourMaxAggregateOutputType | null
  }

  export type WorkingHourAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
  }

  export type WorkingHourSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
  }

  export type WorkingHourMinAggregateOutputType = {
    id: number | null
    institution_id: number | null
    day_of_week: string | null
    open_time: Date | null
    close_time: Date | null
  }

  export type WorkingHourMaxAggregateOutputType = {
    id: number | null
    institution_id: number | null
    day_of_week: string | null
    open_time: Date | null
    close_time: Date | null
  }

  export type WorkingHourCountAggregateOutputType = {
    id: number
    institution_id: number
    day_of_week: number
    open_time: number
    close_time: number
    _all: number
  }


  export type WorkingHourAvgAggregateInputType = {
    id?: true
    institution_id?: true
  }

  export type WorkingHourSumAggregateInputType = {
    id?: true
    institution_id?: true
  }

  export type WorkingHourMinAggregateInputType = {
    id?: true
    institution_id?: true
    day_of_week?: true
    open_time?: true
    close_time?: true
  }

  export type WorkingHourMaxAggregateInputType = {
    id?: true
    institution_id?: true
    day_of_week?: true
    open_time?: true
    close_time?: true
  }

  export type WorkingHourCountAggregateInputType = {
    id?: true
    institution_id?: true
    day_of_week?: true
    open_time?: true
    close_time?: true
    _all?: true
  }

  export type WorkingHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workingHour to aggregate.
     */
    where?: workingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workingHours to fetch.
     */
    orderBy?: workingHourOrderByWithRelationInput | workingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: workingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workingHours
    **/
    _count?: true | WorkingHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkingHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkingHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkingHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkingHourMaxAggregateInputType
  }

  export type GetWorkingHourAggregateType<T extends WorkingHourAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkingHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingHour[P]>
      : GetScalarType<T[P], AggregateWorkingHour[P]>
  }




  export type workingHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workingHourWhereInput
    orderBy?: workingHourOrderByWithAggregationInput | workingHourOrderByWithAggregationInput[]
    by: WorkingHourScalarFieldEnum[] | WorkingHourScalarFieldEnum
    having?: workingHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkingHourCountAggregateInputType | true
    _avg?: WorkingHourAvgAggregateInputType
    _sum?: WorkingHourSumAggregateInputType
    _min?: WorkingHourMinAggregateInputType
    _max?: WorkingHourMaxAggregateInputType
  }

  export type WorkingHourGroupByOutputType = {
    id: number
    institution_id: number
    day_of_week: string
    open_time: Date | null
    close_time: Date | null
    _count: WorkingHourCountAggregateOutputType | null
    _avg: WorkingHourAvgAggregateOutputType | null
    _sum: WorkingHourSumAggregateOutputType | null
    _min: WorkingHourMinAggregateOutputType | null
    _max: WorkingHourMaxAggregateOutputType | null
  }

  type GetWorkingHourGroupByPayload<T extends workingHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkingHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkingHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkingHourGroupByOutputType[P]>
            : GetScalarType<T[P], WorkingHourGroupByOutputType[P]>
        }
      >
    >


  export type workingHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution_id?: boolean
    day_of_week?: boolean
    open_time?: boolean
    close_time?: boolean
    institution?: boolean | institutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingHour"]>



  export type workingHourSelectScalar = {
    id?: boolean
    institution_id?: boolean
    day_of_week?: boolean
    open_time?: boolean
    close_time?: boolean
  }

  export type workingHourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution_id" | "day_of_week" | "open_time" | "close_time", ExtArgs["result"]["workingHour"]>
  export type workingHourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionDefaultArgs<ExtArgs>
  }

  export type $workingHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "workingHour"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institution_id: number
      day_of_week: string
      open_time: Date | null
      close_time: Date | null
    }, ExtArgs["result"]["workingHour"]>
    composites: {}
  }

  type workingHourGetPayload<S extends boolean | null | undefined | workingHourDefaultArgs> = $Result.GetResult<Prisma.$workingHourPayload, S>

  type workingHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<workingHourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkingHourCountAggregateInputType | true
    }

  export interface workingHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['workingHour'], meta: { name: 'workingHour' } }
    /**
     * Find zero or one WorkingHour that matches the filter.
     * @param {workingHourFindUniqueArgs} args - Arguments to find a WorkingHour
     * @example
     * // Get one WorkingHour
     * const workingHour = await prisma.workingHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends workingHourFindUniqueArgs>(args: SelectSubset<T, workingHourFindUniqueArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkingHour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {workingHourFindUniqueOrThrowArgs} args - Arguments to find a WorkingHour
     * @example
     * // Get one WorkingHour
     * const workingHour = await prisma.workingHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends workingHourFindUniqueOrThrowArgs>(args: SelectSubset<T, workingHourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workingHourFindFirstArgs} args - Arguments to find a WorkingHour
     * @example
     * // Get one WorkingHour
     * const workingHour = await prisma.workingHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends workingHourFindFirstArgs>(args?: SelectSubset<T, workingHourFindFirstArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workingHourFindFirstOrThrowArgs} args - Arguments to find a WorkingHour
     * @example
     * // Get one WorkingHour
     * const workingHour = await prisma.workingHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends workingHourFindFirstOrThrowArgs>(args?: SelectSubset<T, workingHourFindFirstOrThrowArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workingHourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingHours
     * const workingHours = await prisma.workingHour.findMany()
     * 
     * // Get first 10 WorkingHours
     * const workingHours = await prisma.workingHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingHourWithIdOnly = await prisma.workingHour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends workingHourFindManyArgs>(args?: SelectSubset<T, workingHourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkingHour.
     * @param {workingHourCreateArgs} args - Arguments to create a WorkingHour.
     * @example
     * // Create one WorkingHour
     * const WorkingHour = await prisma.workingHour.create({
     *   data: {
     *     // ... data to create a WorkingHour
     *   }
     * })
     * 
     */
    create<T extends workingHourCreateArgs>(args: SelectSubset<T, workingHourCreateArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkingHours.
     * @param {workingHourCreateManyArgs} args - Arguments to create many WorkingHours.
     * @example
     * // Create many WorkingHours
     * const workingHour = await prisma.workingHour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends workingHourCreateManyArgs>(args?: SelectSubset<T, workingHourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkingHour.
     * @param {workingHourDeleteArgs} args - Arguments to delete one WorkingHour.
     * @example
     * // Delete one WorkingHour
     * const WorkingHour = await prisma.workingHour.delete({
     *   where: {
     *     // ... filter to delete one WorkingHour
     *   }
     * })
     * 
     */
    delete<T extends workingHourDeleteArgs>(args: SelectSubset<T, workingHourDeleteArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkingHour.
     * @param {workingHourUpdateArgs} args - Arguments to update one WorkingHour.
     * @example
     * // Update one WorkingHour
     * const workingHour = await prisma.workingHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends workingHourUpdateArgs>(args: SelectSubset<T, workingHourUpdateArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkingHours.
     * @param {workingHourDeleteManyArgs} args - Arguments to filter WorkingHours to delete.
     * @example
     * // Delete a few WorkingHours
     * const { count } = await prisma.workingHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends workingHourDeleteManyArgs>(args?: SelectSubset<T, workingHourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workingHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingHours
     * const workingHour = await prisma.workingHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends workingHourUpdateManyArgs>(args: SelectSubset<T, workingHourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkingHour.
     * @param {workingHourUpsertArgs} args - Arguments to update or create a WorkingHour.
     * @example
     * // Update or create a WorkingHour
     * const workingHour = await prisma.workingHour.upsert({
     *   create: {
     *     // ... data to create a WorkingHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingHour we want to update
     *   }
     * })
     */
    upsert<T extends workingHourUpsertArgs>(args: SelectSubset<T, workingHourUpsertArgs<ExtArgs>>): Prisma__workingHourClient<$Result.GetResult<Prisma.$workingHourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workingHourCountArgs} args - Arguments to filter WorkingHours to count.
     * @example
     * // Count the number of WorkingHours
     * const count = await prisma.workingHour.count({
     *   where: {
     *     // ... the filter for the WorkingHours we want to count
     *   }
     * })
    **/
    count<T extends workingHourCountArgs>(
      args?: Subset<T, workingHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingHourAggregateArgs>(args: Subset<T, WorkingHourAggregateArgs>): Prisma.PrismaPromise<GetWorkingHourAggregateType<T>>

    /**
     * Group by WorkingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workingHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends workingHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: workingHourGroupByArgs['orderBy'] }
        : { orderBy?: workingHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, workingHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the workingHour model
   */
  readonly fields: workingHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for workingHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__workingHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the workingHour model
   */
  interface workingHourFieldRefs {
    readonly id: FieldRef<"workingHour", 'Int'>
    readonly institution_id: FieldRef<"workingHour", 'Int'>
    readonly day_of_week: FieldRef<"workingHour", 'String'>
    readonly open_time: FieldRef<"workingHour", 'DateTime'>
    readonly close_time: FieldRef<"workingHour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * workingHour findUnique
   */
  export type workingHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * Filter, which workingHour to fetch.
     */
    where: workingHourWhereUniqueInput
  }

  /**
   * workingHour findUniqueOrThrow
   */
  export type workingHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * Filter, which workingHour to fetch.
     */
    where: workingHourWhereUniqueInput
  }

  /**
   * workingHour findFirst
   */
  export type workingHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * Filter, which workingHour to fetch.
     */
    where?: workingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workingHours to fetch.
     */
    orderBy?: workingHourOrderByWithRelationInput | workingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workingHours.
     */
    cursor?: workingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workingHours.
     */
    distinct?: WorkingHourScalarFieldEnum | WorkingHourScalarFieldEnum[]
  }

  /**
   * workingHour findFirstOrThrow
   */
  export type workingHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * Filter, which workingHour to fetch.
     */
    where?: workingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workingHours to fetch.
     */
    orderBy?: workingHourOrderByWithRelationInput | workingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workingHours.
     */
    cursor?: workingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workingHours.
     */
    distinct?: WorkingHourScalarFieldEnum | WorkingHourScalarFieldEnum[]
  }

  /**
   * workingHour findMany
   */
  export type workingHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * Filter, which workingHours to fetch.
     */
    where?: workingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workingHours to fetch.
     */
    orderBy?: workingHourOrderByWithRelationInput | workingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workingHours.
     */
    cursor?: workingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workingHours.
     */
    skip?: number
    distinct?: WorkingHourScalarFieldEnum | WorkingHourScalarFieldEnum[]
  }

  /**
   * workingHour create
   */
  export type workingHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * The data needed to create a workingHour.
     */
    data: XOR<workingHourCreateInput, workingHourUncheckedCreateInput>
  }

  /**
   * workingHour createMany
   */
  export type workingHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many workingHours.
     */
    data: workingHourCreateManyInput | workingHourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * workingHour update
   */
  export type workingHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * The data needed to update a workingHour.
     */
    data: XOR<workingHourUpdateInput, workingHourUncheckedUpdateInput>
    /**
     * Choose, which workingHour to update.
     */
    where: workingHourWhereUniqueInput
  }

  /**
   * workingHour updateMany
   */
  export type workingHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update workingHours.
     */
    data: XOR<workingHourUpdateManyMutationInput, workingHourUncheckedUpdateManyInput>
    /**
     * Filter which workingHours to update
     */
    where?: workingHourWhereInput
    /**
     * Limit how many workingHours to update.
     */
    limit?: number
  }

  /**
   * workingHour upsert
   */
  export type workingHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * The filter to search for the workingHour to update in case it exists.
     */
    where: workingHourWhereUniqueInput
    /**
     * In case the workingHour found by the `where` argument doesn't exist, create a new workingHour with this data.
     */
    create: XOR<workingHourCreateInput, workingHourUncheckedCreateInput>
    /**
     * In case the workingHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<workingHourUpdateInput, workingHourUncheckedUpdateInput>
  }

  /**
   * workingHour delete
   */
  export type workingHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
    /**
     * Filter which workingHour to delete.
     */
    where: workingHourWhereUniqueInput
  }

  /**
   * workingHour deleteMany
   */
  export type workingHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workingHours to delete
     */
    where?: workingHourWhereInput
    /**
     * Limit how many workingHours to delete.
     */
    limit?: number
  }

  /**
   * workingHour without action
   */
  export type workingHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workingHour
     */
    select?: workingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workingHour
     */
    omit?: workingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workingHourInclude<ExtArgs> | null
  }


  /**
   * Model amenities
   */

  export type AggregateAmenities = {
    _count: AmenitiesCountAggregateOutputType | null
    _avg: AmenitiesAvgAggregateOutputType | null
    _sum: AmenitiesSumAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  export type AmenitiesAvgAggregateOutputType = {
    id: number | null
  }

  export type AmenitiesSumAggregateOutputType = {
    id: number | null
  }

  export type AmenitiesMinAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    added_at: Date | null
  }

  export type AmenitiesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    added_at: Date | null
  }

  export type AmenitiesCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    added_at: number
    _all: number
  }


  export type AmenitiesAvgAggregateInputType = {
    id?: true
  }

  export type AmenitiesSumAggregateInputType = {
    id?: true
  }

  export type AmenitiesMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    added_at?: true
  }

  export type AmenitiesMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    added_at?: true
  }

  export type AmenitiesCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    added_at?: true
    _all?: true
  }

  export type AmenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which amenities to aggregate.
     */
    where?: amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amenities to fetch.
     */
    orderBy?: amenitiesOrderByWithRelationInput | amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned amenities
    **/
    _count?: true | AmenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenitiesMaxAggregateInputType
  }

  export type GetAmenitiesAggregateType<T extends AmenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenities[P]>
      : GetScalarType<T[P], AggregateAmenities[P]>
  }




  export type amenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: amenitiesWhereInput
    orderBy?: amenitiesOrderByWithAggregationInput | amenitiesOrderByWithAggregationInput[]
    by: AmenitiesScalarFieldEnum[] | AmenitiesScalarFieldEnum
    having?: amenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenitiesCountAggregateInputType | true
    _avg?: AmenitiesAvgAggregateInputType
    _sum?: AmenitiesSumAggregateInputType
    _min?: AmenitiesMinAggregateInputType
    _max?: AmenitiesMaxAggregateInputType
  }

  export type AmenitiesGroupByOutputType = {
    id: number
    name: string
    icon: string | null
    added_at: Date | null
    _count: AmenitiesCountAggregateOutputType | null
    _avg: AmenitiesAvgAggregateOutputType | null
    _sum: AmenitiesSumAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  type GetAmenitiesGroupByPayload<T extends amenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
        }
      >
    >


  export type amenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    added_at?: boolean
    business_amenities?: boolean | amenities$business_amenitiesArgs<ExtArgs>
    _count?: boolean | AmenitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenities"]>



  export type amenitiesSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    added_at?: boolean
  }

  export type amenitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "added_at", ExtArgs["result"]["amenities"]>
  export type amenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business_amenities?: boolean | amenities$business_amenitiesArgs<ExtArgs>
    _count?: boolean | AmenitiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $amenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "amenities"
    objects: {
      business_amenities: Prisma.$business_amenitiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      icon: string | null
      added_at: Date | null
    }, ExtArgs["result"]["amenities"]>
    composites: {}
  }

  type amenitiesGetPayload<S extends boolean | null | undefined | amenitiesDefaultArgs> = $Result.GetResult<Prisma.$amenitiesPayload, S>

  type amenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<amenitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenitiesCountAggregateInputType | true
    }

  export interface amenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['amenities'], meta: { name: 'amenities' } }
    /**
     * Find zero or one Amenities that matches the filter.
     * @param {amenitiesFindUniqueArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends amenitiesFindUniqueArgs>(args: SelectSubset<T, amenitiesFindUniqueArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {amenitiesFindUniqueOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends amenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, amenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amenitiesFindFirstArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends amenitiesFindFirstArgs>(args?: SelectSubset<T, amenitiesFindFirstArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amenitiesFindFirstOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends amenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, amenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenities.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends amenitiesFindManyArgs>(args?: SelectSubset<T, amenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenities.
     * @param {amenitiesCreateArgs} args - Arguments to create a Amenities.
     * @example
     * // Create one Amenities
     * const Amenities = await prisma.amenities.create({
     *   data: {
     *     // ... data to create a Amenities
     *   }
     * })
     * 
     */
    create<T extends amenitiesCreateArgs>(args: SelectSubset<T, amenitiesCreateArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {amenitiesCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends amenitiesCreateManyArgs>(args?: SelectSubset<T, amenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Amenities.
     * @param {amenitiesDeleteArgs} args - Arguments to delete one Amenities.
     * @example
     * // Delete one Amenities
     * const Amenities = await prisma.amenities.delete({
     *   where: {
     *     // ... filter to delete one Amenities
     *   }
     * })
     * 
     */
    delete<T extends amenitiesDeleteArgs>(args: SelectSubset<T, amenitiesDeleteArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenities.
     * @param {amenitiesUpdateArgs} args - Arguments to update one Amenities.
     * @example
     * // Update one Amenities
     * const amenities = await prisma.amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends amenitiesUpdateArgs>(args: SelectSubset<T, amenitiesUpdateArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {amenitiesDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends amenitiesDeleteManyArgs>(args?: SelectSubset<T, amenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends amenitiesUpdateManyArgs>(args: SelectSubset<T, amenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenities.
     * @param {amenitiesUpsertArgs} args - Arguments to update or create a Amenities.
     * @example
     * // Update or create a Amenities
     * const amenities = await prisma.amenities.upsert({
     *   create: {
     *     // ... data to create a Amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenities we want to update
     *   }
     * })
     */
    upsert<T extends amenitiesUpsertArgs>(args: SelectSubset<T, amenitiesUpsertArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amenitiesCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenities.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends amenitiesCountArgs>(
      args?: Subset<T, amenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenitiesAggregateArgs>(args: Subset<T, AmenitiesAggregateArgs>): Prisma.PrismaPromise<GetAmenitiesAggregateType<T>>

    /**
     * Group by Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {amenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends amenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: amenitiesGroupByArgs['orderBy'] }
        : { orderBy?: amenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, amenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the amenities model
   */
  readonly fields: amenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__amenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business_amenities<T extends amenities$business_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, amenities$business_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the amenities model
   */
  interface amenitiesFieldRefs {
    readonly id: FieldRef<"amenities", 'Int'>
    readonly name: FieldRef<"amenities", 'String'>
    readonly icon: FieldRef<"amenities", 'String'>
    readonly added_at: FieldRef<"amenities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * amenities findUnique
   */
  export type amenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which amenities to fetch.
     */
    where: amenitiesWhereUniqueInput
  }

  /**
   * amenities findUniqueOrThrow
   */
  export type amenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which amenities to fetch.
     */
    where: amenitiesWhereUniqueInput
  }

  /**
   * amenities findFirst
   */
  export type amenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which amenities to fetch.
     */
    where?: amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amenities to fetch.
     */
    orderBy?: amenitiesOrderByWithRelationInput | amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for amenities.
     */
    cursor?: amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * amenities findFirstOrThrow
   */
  export type amenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which amenities to fetch.
     */
    where?: amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amenities to fetch.
     */
    orderBy?: amenitiesOrderByWithRelationInput | amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for amenities.
     */
    cursor?: amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * amenities findMany
   */
  export type amenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which amenities to fetch.
     */
    where?: amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of amenities to fetch.
     */
    orderBy?: amenitiesOrderByWithRelationInput | amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing amenities.
     */
    cursor?: amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` amenities.
     */
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * amenities create
   */
  export type amenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a amenities.
     */
    data: XOR<amenitiesCreateInput, amenitiesUncheckedCreateInput>
  }

  /**
   * amenities createMany
   */
  export type amenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many amenities.
     */
    data: amenitiesCreateManyInput | amenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * amenities update
   */
  export type amenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a amenities.
     */
    data: XOR<amenitiesUpdateInput, amenitiesUncheckedUpdateInput>
    /**
     * Choose, which amenities to update.
     */
    where: amenitiesWhereUniqueInput
  }

  /**
   * amenities updateMany
   */
  export type amenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update amenities.
     */
    data: XOR<amenitiesUpdateManyMutationInput, amenitiesUncheckedUpdateManyInput>
    /**
     * Filter which amenities to update
     */
    where?: amenitiesWhereInput
    /**
     * Limit how many amenities to update.
     */
    limit?: number
  }

  /**
   * amenities upsert
   */
  export type amenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the amenities to update in case it exists.
     */
    where: amenitiesWhereUniqueInput
    /**
     * In case the amenities found by the `where` argument doesn't exist, create a new amenities with this data.
     */
    create: XOR<amenitiesCreateInput, amenitiesUncheckedCreateInput>
    /**
     * In case the amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<amenitiesUpdateInput, amenitiesUncheckedUpdateInput>
  }

  /**
   * amenities delete
   */
  export type amenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    /**
     * Filter which amenities to delete.
     */
    where: amenitiesWhereUniqueInput
  }

  /**
   * amenities deleteMany
   */
  export type amenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which amenities to delete
     */
    where?: amenitiesWhereInput
    /**
     * Limit how many amenities to delete.
     */
    limit?: number
  }

  /**
   * amenities.business_amenities
   */
  export type amenities$business_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    where?: business_amenitiesWhereInput
    orderBy?: business_amenitiesOrderByWithRelationInput | business_amenitiesOrderByWithRelationInput[]
    cursor?: business_amenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Business_amenitiesScalarFieldEnum | Business_amenitiesScalarFieldEnum[]
  }

  /**
   * amenities without action
   */
  export type amenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
  }


  /**
   * Model business_amenities
   */

  export type AggregateBusiness_amenities = {
    _count: Business_amenitiesCountAggregateOutputType | null
    _avg: Business_amenitiesAvgAggregateOutputType | null
    _sum: Business_amenitiesSumAggregateOutputType | null
    _min: Business_amenitiesMinAggregateOutputType | null
    _max: Business_amenitiesMaxAggregateOutputType | null
  }

  export type Business_amenitiesAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    amenitY_id: number | null
  }

  export type Business_amenitiesSumAggregateOutputType = {
    id: number | null
    institution_id: number | null
    amenitY_id: number | null
  }

  export type Business_amenitiesMinAggregateOutputType = {
    id: number | null
    institution_id: number | null
    amenitY_id: number | null
  }

  export type Business_amenitiesMaxAggregateOutputType = {
    id: number | null
    institution_id: number | null
    amenitY_id: number | null
  }

  export type Business_amenitiesCountAggregateOutputType = {
    id: number
    institution_id: number
    amenitY_id: number
    _all: number
  }


  export type Business_amenitiesAvgAggregateInputType = {
    id?: true
    institution_id?: true
    amenitY_id?: true
  }

  export type Business_amenitiesSumAggregateInputType = {
    id?: true
    institution_id?: true
    amenitY_id?: true
  }

  export type Business_amenitiesMinAggregateInputType = {
    id?: true
    institution_id?: true
    amenitY_id?: true
  }

  export type Business_amenitiesMaxAggregateInputType = {
    id?: true
    institution_id?: true
    amenitY_id?: true
  }

  export type Business_amenitiesCountAggregateInputType = {
    id?: true
    institution_id?: true
    amenitY_id?: true
    _all?: true
  }

  export type Business_amenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which business_amenities to aggregate.
     */
    where?: business_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_amenities to fetch.
     */
    orderBy?: business_amenitiesOrderByWithRelationInput | business_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: business_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned business_amenities
    **/
    _count?: true | Business_amenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Business_amenitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Business_amenitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Business_amenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Business_amenitiesMaxAggregateInputType
  }

  export type GetBusiness_amenitiesAggregateType<T extends Business_amenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness_amenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness_amenities[P]>
      : GetScalarType<T[P], AggregateBusiness_amenities[P]>
  }




  export type business_amenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: business_amenitiesWhereInput
    orderBy?: business_amenitiesOrderByWithAggregationInput | business_amenitiesOrderByWithAggregationInput[]
    by: Business_amenitiesScalarFieldEnum[] | Business_amenitiesScalarFieldEnum
    having?: business_amenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Business_amenitiesCountAggregateInputType | true
    _avg?: Business_amenitiesAvgAggregateInputType
    _sum?: Business_amenitiesSumAggregateInputType
    _min?: Business_amenitiesMinAggregateInputType
    _max?: Business_amenitiesMaxAggregateInputType
  }

  export type Business_amenitiesGroupByOutputType = {
    id: number
    institution_id: number | null
    amenitY_id: number | null
    _count: Business_amenitiesCountAggregateOutputType | null
    _avg: Business_amenitiesAvgAggregateOutputType | null
    _sum: Business_amenitiesSumAggregateOutputType | null
    _min: Business_amenitiesMinAggregateOutputType | null
    _max: Business_amenitiesMaxAggregateOutputType | null
  }

  type GetBusiness_amenitiesGroupByPayload<T extends business_amenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Business_amenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Business_amenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Business_amenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Business_amenitiesGroupByOutputType[P]>
        }
      >
    >


  export type business_amenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institution_id?: boolean
    amenitY_id?: boolean
    amenities?: boolean | business_amenities$amenitiesArgs<ExtArgs>
    institution?: boolean | business_amenities$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["business_amenities"]>



  export type business_amenitiesSelectScalar = {
    id?: boolean
    institution_id?: boolean
    amenitY_id?: boolean
  }

  export type business_amenitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institution_id" | "amenitY_id", ExtArgs["result"]["business_amenities"]>
  export type business_amenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amenities?: boolean | business_amenities$amenitiesArgs<ExtArgs>
    institution?: boolean | business_amenities$institutionArgs<ExtArgs>
  }

  export type $business_amenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "business_amenities"
    objects: {
      amenities: Prisma.$amenitiesPayload<ExtArgs> | null
      institution: Prisma.$institutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      institution_id: number | null
      amenitY_id: number | null
    }, ExtArgs["result"]["business_amenities"]>
    composites: {}
  }

  type business_amenitiesGetPayload<S extends boolean | null | undefined | business_amenitiesDefaultArgs> = $Result.GetResult<Prisma.$business_amenitiesPayload, S>

  type business_amenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<business_amenitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Business_amenitiesCountAggregateInputType | true
    }

  export interface business_amenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['business_amenities'], meta: { name: 'business_amenities' } }
    /**
     * Find zero or one Business_amenities that matches the filter.
     * @param {business_amenitiesFindUniqueArgs} args - Arguments to find a Business_amenities
     * @example
     * // Get one Business_amenities
     * const business_amenities = await prisma.business_amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends business_amenitiesFindUniqueArgs>(args: SelectSubset<T, business_amenitiesFindUniqueArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Business_amenities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {business_amenitiesFindUniqueOrThrowArgs} args - Arguments to find a Business_amenities
     * @example
     * // Get one Business_amenities
     * const business_amenities = await prisma.business_amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends business_amenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, business_amenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business_amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_amenitiesFindFirstArgs} args - Arguments to find a Business_amenities
     * @example
     * // Get one Business_amenities
     * const business_amenities = await prisma.business_amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends business_amenitiesFindFirstArgs>(args?: SelectSubset<T, business_amenitiesFindFirstArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business_amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_amenitiesFindFirstOrThrowArgs} args - Arguments to find a Business_amenities
     * @example
     * // Get one Business_amenities
     * const business_amenities = await prisma.business_amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends business_amenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, business_amenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Business_amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_amenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Business_amenities
     * const business_amenities = await prisma.business_amenities.findMany()
     * 
     * // Get first 10 Business_amenities
     * const business_amenities = await prisma.business_amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const business_amenitiesWithIdOnly = await prisma.business_amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends business_amenitiesFindManyArgs>(args?: SelectSubset<T, business_amenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Business_amenities.
     * @param {business_amenitiesCreateArgs} args - Arguments to create a Business_amenities.
     * @example
     * // Create one Business_amenities
     * const Business_amenities = await prisma.business_amenities.create({
     *   data: {
     *     // ... data to create a Business_amenities
     *   }
     * })
     * 
     */
    create<T extends business_amenitiesCreateArgs>(args: SelectSubset<T, business_amenitiesCreateArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Business_amenities.
     * @param {business_amenitiesCreateManyArgs} args - Arguments to create many Business_amenities.
     * @example
     * // Create many Business_amenities
     * const business_amenities = await prisma.business_amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends business_amenitiesCreateManyArgs>(args?: SelectSubset<T, business_amenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Business_amenities.
     * @param {business_amenitiesDeleteArgs} args - Arguments to delete one Business_amenities.
     * @example
     * // Delete one Business_amenities
     * const Business_amenities = await prisma.business_amenities.delete({
     *   where: {
     *     // ... filter to delete one Business_amenities
     *   }
     * })
     * 
     */
    delete<T extends business_amenitiesDeleteArgs>(args: SelectSubset<T, business_amenitiesDeleteArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Business_amenities.
     * @param {business_amenitiesUpdateArgs} args - Arguments to update one Business_amenities.
     * @example
     * // Update one Business_amenities
     * const business_amenities = await prisma.business_amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends business_amenitiesUpdateArgs>(args: SelectSubset<T, business_amenitiesUpdateArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Business_amenities.
     * @param {business_amenitiesDeleteManyArgs} args - Arguments to filter Business_amenities to delete.
     * @example
     * // Delete a few Business_amenities
     * const { count } = await prisma.business_amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends business_amenitiesDeleteManyArgs>(args?: SelectSubset<T, business_amenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Business_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_amenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Business_amenities
     * const business_amenities = await prisma.business_amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends business_amenitiesUpdateManyArgs>(args: SelectSubset<T, business_amenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Business_amenities.
     * @param {business_amenitiesUpsertArgs} args - Arguments to update or create a Business_amenities.
     * @example
     * // Update or create a Business_amenities
     * const business_amenities = await prisma.business_amenities.upsert({
     *   create: {
     *     // ... data to create a Business_amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business_amenities we want to update
     *   }
     * })
     */
    upsert<T extends business_amenitiesUpsertArgs>(args: SelectSubset<T, business_amenitiesUpsertArgs<ExtArgs>>): Prisma__business_amenitiesClient<$Result.GetResult<Prisma.$business_amenitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Business_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_amenitiesCountArgs} args - Arguments to filter Business_amenities to count.
     * @example
     * // Count the number of Business_amenities
     * const count = await prisma.business_amenities.count({
     *   where: {
     *     // ... the filter for the Business_amenities we want to count
     *   }
     * })
    **/
    count<T extends business_amenitiesCountArgs>(
      args?: Subset<T, business_amenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Business_amenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Business_amenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Business_amenitiesAggregateArgs>(args: Subset<T, Business_amenitiesAggregateArgs>): Prisma.PrismaPromise<GetBusiness_amenitiesAggregateType<T>>

    /**
     * Group by Business_amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_amenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends business_amenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: business_amenitiesGroupByArgs['orderBy'] }
        : { orderBy?: business_amenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, business_amenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusiness_amenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the business_amenities model
   */
  readonly fields: business_amenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for business_amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__business_amenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    amenities<T extends business_amenities$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, business_amenities$amenitiesArgs<ExtArgs>>): Prisma__amenitiesClient<$Result.GetResult<Prisma.$amenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    institution<T extends business_amenities$institutionArgs<ExtArgs> = {}>(args?: Subset<T, business_amenities$institutionArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the business_amenities model
   */
  interface business_amenitiesFieldRefs {
    readonly id: FieldRef<"business_amenities", 'Int'>
    readonly institution_id: FieldRef<"business_amenities", 'Int'>
    readonly amenitY_id: FieldRef<"business_amenities", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * business_amenities findUnique
   */
  export type business_amenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which business_amenities to fetch.
     */
    where: business_amenitiesWhereUniqueInput
  }

  /**
   * business_amenities findUniqueOrThrow
   */
  export type business_amenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which business_amenities to fetch.
     */
    where: business_amenitiesWhereUniqueInput
  }

  /**
   * business_amenities findFirst
   */
  export type business_amenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which business_amenities to fetch.
     */
    where?: business_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_amenities to fetch.
     */
    orderBy?: business_amenitiesOrderByWithRelationInput | business_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for business_amenities.
     */
    cursor?: business_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of business_amenities.
     */
    distinct?: Business_amenitiesScalarFieldEnum | Business_amenitiesScalarFieldEnum[]
  }

  /**
   * business_amenities findFirstOrThrow
   */
  export type business_amenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which business_amenities to fetch.
     */
    where?: business_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_amenities to fetch.
     */
    orderBy?: business_amenitiesOrderByWithRelationInput | business_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for business_amenities.
     */
    cursor?: business_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of business_amenities.
     */
    distinct?: Business_amenitiesScalarFieldEnum | Business_amenitiesScalarFieldEnum[]
  }

  /**
   * business_amenities findMany
   */
  export type business_amenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * Filter, which business_amenities to fetch.
     */
    where?: business_amenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_amenities to fetch.
     */
    orderBy?: business_amenitiesOrderByWithRelationInput | business_amenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing business_amenities.
     */
    cursor?: business_amenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_amenities.
     */
    skip?: number
    distinct?: Business_amenitiesScalarFieldEnum | Business_amenitiesScalarFieldEnum[]
  }

  /**
   * business_amenities create
   */
  export type business_amenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a business_amenities.
     */
    data?: XOR<business_amenitiesCreateInput, business_amenitiesUncheckedCreateInput>
  }

  /**
   * business_amenities createMany
   */
  export type business_amenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many business_amenities.
     */
    data: business_amenitiesCreateManyInput | business_amenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * business_amenities update
   */
  export type business_amenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a business_amenities.
     */
    data: XOR<business_amenitiesUpdateInput, business_amenitiesUncheckedUpdateInput>
    /**
     * Choose, which business_amenities to update.
     */
    where: business_amenitiesWhereUniqueInput
  }

  /**
   * business_amenities updateMany
   */
  export type business_amenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update business_amenities.
     */
    data: XOR<business_amenitiesUpdateManyMutationInput, business_amenitiesUncheckedUpdateManyInput>
    /**
     * Filter which business_amenities to update
     */
    where?: business_amenitiesWhereInput
    /**
     * Limit how many business_amenities to update.
     */
    limit?: number
  }

  /**
   * business_amenities upsert
   */
  export type business_amenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the business_amenities to update in case it exists.
     */
    where: business_amenitiesWhereUniqueInput
    /**
     * In case the business_amenities found by the `where` argument doesn't exist, create a new business_amenities with this data.
     */
    create: XOR<business_amenitiesCreateInput, business_amenitiesUncheckedCreateInput>
    /**
     * In case the business_amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<business_amenitiesUpdateInput, business_amenitiesUncheckedUpdateInput>
  }

  /**
   * business_amenities delete
   */
  export type business_amenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
    /**
     * Filter which business_amenities to delete.
     */
    where: business_amenitiesWhereUniqueInput
  }

  /**
   * business_amenities deleteMany
   */
  export type business_amenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which business_amenities to delete
     */
    where?: business_amenitiesWhereInput
    /**
     * Limit how many business_amenities to delete.
     */
    limit?: number
  }

  /**
   * business_amenities.amenities
   */
  export type business_amenities$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the amenities
     */
    select?: amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the amenities
     */
    omit?: amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: amenitiesInclude<ExtArgs> | null
    where?: amenitiesWhereInput
  }

  /**
   * business_amenities.institution
   */
  export type business_amenities$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institution
     */
    select?: institutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institution
     */
    omit?: institutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionInclude<ExtArgs> | null
    where?: institutionWhereInput
  }

  /**
   * business_amenities without action
   */
  export type business_amenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_amenities
     */
    select?: business_amenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_amenities
     */
    omit?: business_amenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_amenitiesInclude<ExtArgs> | null
  }


  /**
   * Model price_ranges
   */

  export type AggregatePrice_ranges = {
    _count: Price_rangesCountAggregateOutputType | null
    _avg: Price_rangesAvgAggregateOutputType | null
    _sum: Price_rangesSumAggregateOutputType | null
    _min: Price_rangesMinAggregateOutputType | null
    _max: Price_rangesMaxAggregateOutputType | null
  }

  export type Price_rangesAvgAggregateOutputType = {
    id: number | null
    max_value: number | null
    min_value: number | null
    institution_id: number | null
  }

  export type Price_rangesSumAggregateOutputType = {
    id: number | null
    max_value: number | null
    min_value: number | null
    institution_id: number | null
  }

  export type Price_rangesMinAggregateOutputType = {
    id: number | null
    max_value: number | null
    min_value: number | null
    institution_id: number | null
    label: string | null
  }

  export type Price_rangesMaxAggregateOutputType = {
    id: number | null
    max_value: number | null
    min_value: number | null
    institution_id: number | null
    label: string | null
  }

  export type Price_rangesCountAggregateOutputType = {
    id: number
    max_value: number
    min_value: number
    institution_id: number
    label: number
    _all: number
  }


  export type Price_rangesAvgAggregateInputType = {
    id?: true
    max_value?: true
    min_value?: true
    institution_id?: true
  }

  export type Price_rangesSumAggregateInputType = {
    id?: true
    max_value?: true
    min_value?: true
    institution_id?: true
  }

  export type Price_rangesMinAggregateInputType = {
    id?: true
    max_value?: true
    min_value?: true
    institution_id?: true
    label?: true
  }

  export type Price_rangesMaxAggregateInputType = {
    id?: true
    max_value?: true
    min_value?: true
    institution_id?: true
    label?: true
  }

  export type Price_rangesCountAggregateInputType = {
    id?: true
    max_value?: true
    min_value?: true
    institution_id?: true
    label?: true
    _all?: true
  }

  export type Price_rangesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which price_ranges to aggregate.
     */
    where?: price_rangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_ranges to fetch.
     */
    orderBy?: price_rangesOrderByWithRelationInput | price_rangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: price_rangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_ranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned price_ranges
    **/
    _count?: true | Price_rangesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Price_rangesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Price_rangesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Price_rangesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Price_rangesMaxAggregateInputType
  }

  export type GetPrice_rangesAggregateType<T extends Price_rangesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice_ranges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice_ranges[P]>
      : GetScalarType<T[P], AggregatePrice_ranges[P]>
  }




  export type price_rangesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: price_rangesWhereInput
    orderBy?: price_rangesOrderByWithAggregationInput | price_rangesOrderByWithAggregationInput[]
    by: Price_rangesScalarFieldEnum[] | Price_rangesScalarFieldEnum
    having?: price_rangesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Price_rangesCountAggregateInputType | true
    _avg?: Price_rangesAvgAggregateInputType
    _sum?: Price_rangesSumAggregateInputType
    _min?: Price_rangesMinAggregateInputType
    _max?: Price_rangesMaxAggregateInputType
  }

  export type Price_rangesGroupByOutputType = {
    id: number
    max_value: number
    min_value: number
    institution_id: number
    label: string | null
    _count: Price_rangesCountAggregateOutputType | null
    _avg: Price_rangesAvgAggregateOutputType | null
    _sum: Price_rangesSumAggregateOutputType | null
    _min: Price_rangesMinAggregateOutputType | null
    _max: Price_rangesMaxAggregateOutputType | null
  }

  type GetPrice_rangesGroupByPayload<T extends price_rangesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Price_rangesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Price_rangesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Price_rangesGroupByOutputType[P]>
            : GetScalarType<T[P], Price_rangesGroupByOutputType[P]>
        }
      >
    >


  export type price_rangesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max_value?: boolean
    min_value?: boolean
    institution_id?: boolean
    label?: boolean
    institution?: boolean | institutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["price_ranges"]>



  export type price_rangesSelectScalar = {
    id?: boolean
    max_value?: boolean
    min_value?: boolean
    institution_id?: boolean
    label?: boolean
  }

  export type price_rangesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "max_value" | "min_value" | "institution_id" | "label", ExtArgs["result"]["price_ranges"]>
  export type price_rangesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionDefaultArgs<ExtArgs>
  }

  export type $price_rangesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "price_ranges"
    objects: {
      institution: Prisma.$institutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      max_value: number
      min_value: number
      institution_id: number
      label: string | null
    }, ExtArgs["result"]["price_ranges"]>
    composites: {}
  }

  type price_rangesGetPayload<S extends boolean | null | undefined | price_rangesDefaultArgs> = $Result.GetResult<Prisma.$price_rangesPayload, S>

  type price_rangesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<price_rangesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Price_rangesCountAggregateInputType | true
    }

  export interface price_rangesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['price_ranges'], meta: { name: 'price_ranges' } }
    /**
     * Find zero or one Price_ranges that matches the filter.
     * @param {price_rangesFindUniqueArgs} args - Arguments to find a Price_ranges
     * @example
     * // Get one Price_ranges
     * const price_ranges = await prisma.price_ranges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends price_rangesFindUniqueArgs>(args: SelectSubset<T, price_rangesFindUniqueArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Price_ranges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {price_rangesFindUniqueOrThrowArgs} args - Arguments to find a Price_ranges
     * @example
     * // Get one Price_ranges
     * const price_ranges = await prisma.price_ranges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends price_rangesFindUniqueOrThrowArgs>(args: SelectSubset<T, price_rangesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Price_ranges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_rangesFindFirstArgs} args - Arguments to find a Price_ranges
     * @example
     * // Get one Price_ranges
     * const price_ranges = await prisma.price_ranges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends price_rangesFindFirstArgs>(args?: SelectSubset<T, price_rangesFindFirstArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Price_ranges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_rangesFindFirstOrThrowArgs} args - Arguments to find a Price_ranges
     * @example
     * // Get one Price_ranges
     * const price_ranges = await prisma.price_ranges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends price_rangesFindFirstOrThrowArgs>(args?: SelectSubset<T, price_rangesFindFirstOrThrowArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Price_ranges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_rangesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Price_ranges
     * const price_ranges = await prisma.price_ranges.findMany()
     * 
     * // Get first 10 Price_ranges
     * const price_ranges = await prisma.price_ranges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const price_rangesWithIdOnly = await prisma.price_ranges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends price_rangesFindManyArgs>(args?: SelectSubset<T, price_rangesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Price_ranges.
     * @param {price_rangesCreateArgs} args - Arguments to create a Price_ranges.
     * @example
     * // Create one Price_ranges
     * const Price_ranges = await prisma.price_ranges.create({
     *   data: {
     *     // ... data to create a Price_ranges
     *   }
     * })
     * 
     */
    create<T extends price_rangesCreateArgs>(args: SelectSubset<T, price_rangesCreateArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Price_ranges.
     * @param {price_rangesCreateManyArgs} args - Arguments to create many Price_ranges.
     * @example
     * // Create many Price_ranges
     * const price_ranges = await prisma.price_ranges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends price_rangesCreateManyArgs>(args?: SelectSubset<T, price_rangesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Price_ranges.
     * @param {price_rangesDeleteArgs} args - Arguments to delete one Price_ranges.
     * @example
     * // Delete one Price_ranges
     * const Price_ranges = await prisma.price_ranges.delete({
     *   where: {
     *     // ... filter to delete one Price_ranges
     *   }
     * })
     * 
     */
    delete<T extends price_rangesDeleteArgs>(args: SelectSubset<T, price_rangesDeleteArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Price_ranges.
     * @param {price_rangesUpdateArgs} args - Arguments to update one Price_ranges.
     * @example
     * // Update one Price_ranges
     * const price_ranges = await prisma.price_ranges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends price_rangesUpdateArgs>(args: SelectSubset<T, price_rangesUpdateArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Price_ranges.
     * @param {price_rangesDeleteManyArgs} args - Arguments to filter Price_ranges to delete.
     * @example
     * // Delete a few Price_ranges
     * const { count } = await prisma.price_ranges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends price_rangesDeleteManyArgs>(args?: SelectSubset<T, price_rangesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Price_ranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_rangesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Price_ranges
     * const price_ranges = await prisma.price_ranges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends price_rangesUpdateManyArgs>(args: SelectSubset<T, price_rangesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Price_ranges.
     * @param {price_rangesUpsertArgs} args - Arguments to update or create a Price_ranges.
     * @example
     * // Update or create a Price_ranges
     * const price_ranges = await prisma.price_ranges.upsert({
     *   create: {
     *     // ... data to create a Price_ranges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price_ranges we want to update
     *   }
     * })
     */
    upsert<T extends price_rangesUpsertArgs>(args: SelectSubset<T, price_rangesUpsertArgs<ExtArgs>>): Prisma__price_rangesClient<$Result.GetResult<Prisma.$price_rangesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Price_ranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_rangesCountArgs} args - Arguments to filter Price_ranges to count.
     * @example
     * // Count the number of Price_ranges
     * const count = await prisma.price_ranges.count({
     *   where: {
     *     // ... the filter for the Price_ranges we want to count
     *   }
     * })
    **/
    count<T extends price_rangesCountArgs>(
      args?: Subset<T, price_rangesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Price_rangesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price_ranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Price_rangesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Price_rangesAggregateArgs>(args: Subset<T, Price_rangesAggregateArgs>): Prisma.PrismaPromise<GetPrice_rangesAggregateType<T>>

    /**
     * Group by Price_ranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_rangesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends price_rangesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: price_rangesGroupByArgs['orderBy'] }
        : { orderBy?: price_rangesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, price_rangesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrice_rangesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the price_ranges model
   */
  readonly fields: price_rangesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for price_ranges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__price_rangesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionDefaultArgs<ExtArgs>>): Prisma__institutionClient<$Result.GetResult<Prisma.$institutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the price_ranges model
   */
  interface price_rangesFieldRefs {
    readonly id: FieldRef<"price_ranges", 'Int'>
    readonly max_value: FieldRef<"price_ranges", 'Int'>
    readonly min_value: FieldRef<"price_ranges", 'Int'>
    readonly institution_id: FieldRef<"price_ranges", 'Int'>
    readonly label: FieldRef<"price_ranges", 'String'>
  }
    

  // Custom InputTypes
  /**
   * price_ranges findUnique
   */
  export type price_rangesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * Filter, which price_ranges to fetch.
     */
    where: price_rangesWhereUniqueInput
  }

  /**
   * price_ranges findUniqueOrThrow
   */
  export type price_rangesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * Filter, which price_ranges to fetch.
     */
    where: price_rangesWhereUniqueInput
  }

  /**
   * price_ranges findFirst
   */
  export type price_rangesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * Filter, which price_ranges to fetch.
     */
    where?: price_rangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_ranges to fetch.
     */
    orderBy?: price_rangesOrderByWithRelationInput | price_rangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for price_ranges.
     */
    cursor?: price_rangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_ranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of price_ranges.
     */
    distinct?: Price_rangesScalarFieldEnum | Price_rangesScalarFieldEnum[]
  }

  /**
   * price_ranges findFirstOrThrow
   */
  export type price_rangesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * Filter, which price_ranges to fetch.
     */
    where?: price_rangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_ranges to fetch.
     */
    orderBy?: price_rangesOrderByWithRelationInput | price_rangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for price_ranges.
     */
    cursor?: price_rangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_ranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of price_ranges.
     */
    distinct?: Price_rangesScalarFieldEnum | Price_rangesScalarFieldEnum[]
  }

  /**
   * price_ranges findMany
   */
  export type price_rangesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * Filter, which price_ranges to fetch.
     */
    where?: price_rangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_ranges to fetch.
     */
    orderBy?: price_rangesOrderByWithRelationInput | price_rangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing price_ranges.
     */
    cursor?: price_rangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_ranges.
     */
    skip?: number
    distinct?: Price_rangesScalarFieldEnum | Price_rangesScalarFieldEnum[]
  }

  /**
   * price_ranges create
   */
  export type price_rangesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * The data needed to create a price_ranges.
     */
    data: XOR<price_rangesCreateInput, price_rangesUncheckedCreateInput>
  }

  /**
   * price_ranges createMany
   */
  export type price_rangesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many price_ranges.
     */
    data: price_rangesCreateManyInput | price_rangesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * price_ranges update
   */
  export type price_rangesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * The data needed to update a price_ranges.
     */
    data: XOR<price_rangesUpdateInput, price_rangesUncheckedUpdateInput>
    /**
     * Choose, which price_ranges to update.
     */
    where: price_rangesWhereUniqueInput
  }

  /**
   * price_ranges updateMany
   */
  export type price_rangesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update price_ranges.
     */
    data: XOR<price_rangesUpdateManyMutationInput, price_rangesUncheckedUpdateManyInput>
    /**
     * Filter which price_ranges to update
     */
    where?: price_rangesWhereInput
    /**
     * Limit how many price_ranges to update.
     */
    limit?: number
  }

  /**
   * price_ranges upsert
   */
  export type price_rangesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * The filter to search for the price_ranges to update in case it exists.
     */
    where: price_rangesWhereUniqueInput
    /**
     * In case the price_ranges found by the `where` argument doesn't exist, create a new price_ranges with this data.
     */
    create: XOR<price_rangesCreateInput, price_rangesUncheckedCreateInput>
    /**
     * In case the price_ranges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<price_rangesUpdateInput, price_rangesUncheckedUpdateInput>
  }

  /**
   * price_ranges delete
   */
  export type price_rangesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
    /**
     * Filter which price_ranges to delete.
     */
    where: price_rangesWhereUniqueInput
  }

  /**
   * price_ranges deleteMany
   */
  export type price_rangesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which price_ranges to delete
     */
    where?: price_rangesWhereInput
    /**
     * Limit how many price_ranges to delete.
     */
    limit?: number
  }

  /**
   * price_ranges without action
   */
  export type price_rangesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the price_ranges
     */
    select?: price_rangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the price_ranges
     */
    omit?: price_rangesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: price_rangesInclude<ExtArgs> | null
  }


  /**
   * Model surveyAnswers
   */

  export type AggregateSurveyAnswers = {
    _count: SurveyAnswersCountAggregateOutputType | null
    _avg: SurveyAnswersAvgAggregateOutputType | null
    _sum: SurveyAnswersSumAggregateOutputType | null
    _min: SurveyAnswersMinAggregateOutputType | null
    _max: SurveyAnswersMaxAggregateOutputType | null
  }

  export type SurveyAnswersAvgAggregateOutputType = {
    id: number | null
    question_id: number | null
    user_id: number | null
    scale_rating: number | null
  }

  export type SurveyAnswersSumAggregateOutputType = {
    id: number | null
    question_id: number | null
    user_id: number | null
    scale_rating: number | null
  }

  export type SurveyAnswersMinAggregateOutputType = {
    id: number | null
    question_id: number | null
    user_id: number | null
    answer: string | null
    scale_rating: number | null
    added_at: Date | null
  }

  export type SurveyAnswersMaxAggregateOutputType = {
    id: number | null
    question_id: number | null
    user_id: number | null
    answer: string | null
    scale_rating: number | null
    added_at: Date | null
  }

  export type SurveyAnswersCountAggregateOutputType = {
    id: number
    question_id: number
    user_id: number
    answer: number
    scale_rating: number
    added_at: number
    _all: number
  }


  export type SurveyAnswersAvgAggregateInputType = {
    id?: true
    question_id?: true
    user_id?: true
    scale_rating?: true
  }

  export type SurveyAnswersSumAggregateInputType = {
    id?: true
    question_id?: true
    user_id?: true
    scale_rating?: true
  }

  export type SurveyAnswersMinAggregateInputType = {
    id?: true
    question_id?: true
    user_id?: true
    answer?: true
    scale_rating?: true
    added_at?: true
  }

  export type SurveyAnswersMaxAggregateInputType = {
    id?: true
    question_id?: true
    user_id?: true
    answer?: true
    scale_rating?: true
    added_at?: true
  }

  export type SurveyAnswersCountAggregateInputType = {
    id?: true
    question_id?: true
    user_id?: true
    answer?: true
    scale_rating?: true
    added_at?: true
    _all?: true
  }

  export type SurveyAnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveyAnswers to aggregate.
     */
    where?: surveyAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyAnswers to fetch.
     */
    orderBy?: surveyAnswersOrderByWithRelationInput | surveyAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surveyAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surveyAnswers
    **/
    _count?: true | SurveyAnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyAnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyAnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyAnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyAnswersMaxAggregateInputType
  }

  export type GetSurveyAnswersAggregateType<T extends SurveyAnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyAnswers[P]>
      : GetScalarType<T[P], AggregateSurveyAnswers[P]>
  }




  export type surveyAnswersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyAnswersWhereInput
    orderBy?: surveyAnswersOrderByWithAggregationInput | surveyAnswersOrderByWithAggregationInput[]
    by: SurveyAnswersScalarFieldEnum[] | SurveyAnswersScalarFieldEnum
    having?: surveyAnswersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyAnswersCountAggregateInputType | true
    _avg?: SurveyAnswersAvgAggregateInputType
    _sum?: SurveyAnswersSumAggregateInputType
    _min?: SurveyAnswersMinAggregateInputType
    _max?: SurveyAnswersMaxAggregateInputType
  }

  export type SurveyAnswersGroupByOutputType = {
    id: number
    question_id: number
    user_id: number | null
    answer: string | null
    scale_rating: number | null
    added_at: Date
    _count: SurveyAnswersCountAggregateOutputType | null
    _avg: SurveyAnswersAvgAggregateOutputType | null
    _sum: SurveyAnswersSumAggregateOutputType | null
    _min: SurveyAnswersMinAggregateOutputType | null
    _max: SurveyAnswersMaxAggregateOutputType | null
  }

  type GetSurveyAnswersGroupByPayload<T extends surveyAnswersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyAnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyAnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyAnswersGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyAnswersGroupByOutputType[P]>
        }
      >
    >


  export type surveyAnswersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question_id?: boolean
    user_id?: boolean
    answer?: boolean
    scale_rating?: boolean
    added_at?: boolean
    surveyQuestions?: boolean | surveyQuestionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyAnswers"]>



  export type surveyAnswersSelectScalar = {
    id?: boolean
    question_id?: boolean
    user_id?: boolean
    answer?: boolean
    scale_rating?: boolean
    added_at?: boolean
  }

  export type surveyAnswersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question_id" | "user_id" | "answer" | "scale_rating" | "added_at", ExtArgs["result"]["surveyAnswers"]>
  export type surveyAnswersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyQuestions?: boolean | surveyQuestionsDefaultArgs<ExtArgs>
  }

  export type $surveyAnswersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surveyAnswers"
    objects: {
      surveyQuestions: Prisma.$surveyQuestionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question_id: number
      user_id: number | null
      answer: string | null
      scale_rating: number | null
      added_at: Date
    }, ExtArgs["result"]["surveyAnswers"]>
    composites: {}
  }

  type surveyAnswersGetPayload<S extends boolean | null | undefined | surveyAnswersDefaultArgs> = $Result.GetResult<Prisma.$surveyAnswersPayload, S>

  type surveyAnswersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surveyAnswersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyAnswersCountAggregateInputType | true
    }

  export interface surveyAnswersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surveyAnswers'], meta: { name: 'surveyAnswers' } }
    /**
     * Find zero or one SurveyAnswers that matches the filter.
     * @param {surveyAnswersFindUniqueArgs} args - Arguments to find a SurveyAnswers
     * @example
     * // Get one SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surveyAnswersFindUniqueArgs>(args: SelectSubset<T, surveyAnswersFindUniqueArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyAnswers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surveyAnswersFindUniqueOrThrowArgs} args - Arguments to find a SurveyAnswers
     * @example
     * // Get one SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surveyAnswersFindUniqueOrThrowArgs>(args: SelectSubset<T, surveyAnswersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyAnswersFindFirstArgs} args - Arguments to find a SurveyAnswers
     * @example
     * // Get one SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surveyAnswersFindFirstArgs>(args?: SelectSubset<T, surveyAnswersFindFirstArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyAnswers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyAnswersFindFirstOrThrowArgs} args - Arguments to find a SurveyAnswers
     * @example
     * // Get one SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surveyAnswersFindFirstOrThrowArgs>(args?: SelectSubset<T, surveyAnswersFindFirstOrThrowArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyAnswersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.findMany()
     * 
     * // Get first 10 SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyAnswersWithIdOnly = await prisma.surveyAnswers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends surveyAnswersFindManyArgs>(args?: SelectSubset<T, surveyAnswersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyAnswers.
     * @param {surveyAnswersCreateArgs} args - Arguments to create a SurveyAnswers.
     * @example
     * // Create one SurveyAnswers
     * const SurveyAnswers = await prisma.surveyAnswers.create({
     *   data: {
     *     // ... data to create a SurveyAnswers
     *   }
     * })
     * 
     */
    create<T extends surveyAnswersCreateArgs>(args: SelectSubset<T, surveyAnswersCreateArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyAnswers.
     * @param {surveyAnswersCreateManyArgs} args - Arguments to create many SurveyAnswers.
     * @example
     * // Create many SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surveyAnswersCreateManyArgs>(args?: SelectSubset<T, surveyAnswersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyAnswers.
     * @param {surveyAnswersDeleteArgs} args - Arguments to delete one SurveyAnswers.
     * @example
     * // Delete one SurveyAnswers
     * const SurveyAnswers = await prisma.surveyAnswers.delete({
     *   where: {
     *     // ... filter to delete one SurveyAnswers
     *   }
     * })
     * 
     */
    delete<T extends surveyAnswersDeleteArgs>(args: SelectSubset<T, surveyAnswersDeleteArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyAnswers.
     * @param {surveyAnswersUpdateArgs} args - Arguments to update one SurveyAnswers.
     * @example
     * // Update one SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surveyAnswersUpdateArgs>(args: SelectSubset<T, surveyAnswersUpdateArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyAnswers.
     * @param {surveyAnswersDeleteManyArgs} args - Arguments to filter SurveyAnswers to delete.
     * @example
     * // Delete a few SurveyAnswers
     * const { count } = await prisma.surveyAnswers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surveyAnswersDeleteManyArgs>(args?: SelectSubset<T, surveyAnswersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyAnswersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surveyAnswersUpdateManyArgs>(args: SelectSubset<T, surveyAnswersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyAnswers.
     * @param {surveyAnswersUpsertArgs} args - Arguments to update or create a SurveyAnswers.
     * @example
     * // Update or create a SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswers.upsert({
     *   create: {
     *     // ... data to create a SurveyAnswers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyAnswers we want to update
     *   }
     * })
     */
    upsert<T extends surveyAnswersUpsertArgs>(args: SelectSubset<T, surveyAnswersUpsertArgs<ExtArgs>>): Prisma__surveyAnswersClient<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyAnswersCountArgs} args - Arguments to filter SurveyAnswers to count.
     * @example
     * // Count the number of SurveyAnswers
     * const count = await prisma.surveyAnswers.count({
     *   where: {
     *     // ... the filter for the SurveyAnswers we want to count
     *   }
     * })
    **/
    count<T extends surveyAnswersCountArgs>(
      args?: Subset<T, surveyAnswersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyAnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAnswersAggregateArgs>(args: Subset<T, SurveyAnswersAggregateArgs>): Prisma.PrismaPromise<GetSurveyAnswersAggregateType<T>>

    /**
     * Group by SurveyAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyAnswersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surveyAnswersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surveyAnswersGroupByArgs['orderBy'] }
        : { orderBy?: surveyAnswersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surveyAnswersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surveyAnswers model
   */
  readonly fields: surveyAnswersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surveyAnswers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surveyAnswersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyQuestions<T extends surveyQuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, surveyQuestionsDefaultArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the surveyAnswers model
   */
  interface surveyAnswersFieldRefs {
    readonly id: FieldRef<"surveyAnswers", 'Int'>
    readonly question_id: FieldRef<"surveyAnswers", 'Int'>
    readonly user_id: FieldRef<"surveyAnswers", 'Int'>
    readonly answer: FieldRef<"surveyAnswers", 'String'>
    readonly scale_rating: FieldRef<"surveyAnswers", 'Int'>
    readonly added_at: FieldRef<"surveyAnswers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * surveyAnswers findUnique
   */
  export type surveyAnswersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * Filter, which surveyAnswers to fetch.
     */
    where: surveyAnswersWhereUniqueInput
  }

  /**
   * surveyAnswers findUniqueOrThrow
   */
  export type surveyAnswersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * Filter, which surveyAnswers to fetch.
     */
    where: surveyAnswersWhereUniqueInput
  }

  /**
   * surveyAnswers findFirst
   */
  export type surveyAnswersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * Filter, which surveyAnswers to fetch.
     */
    where?: surveyAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyAnswers to fetch.
     */
    orderBy?: surveyAnswersOrderByWithRelationInput | surveyAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveyAnswers.
     */
    cursor?: surveyAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveyAnswers.
     */
    distinct?: SurveyAnswersScalarFieldEnum | SurveyAnswersScalarFieldEnum[]
  }

  /**
   * surveyAnswers findFirstOrThrow
   */
  export type surveyAnswersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * Filter, which surveyAnswers to fetch.
     */
    where?: surveyAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyAnswers to fetch.
     */
    orderBy?: surveyAnswersOrderByWithRelationInput | surveyAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveyAnswers.
     */
    cursor?: surveyAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveyAnswers.
     */
    distinct?: SurveyAnswersScalarFieldEnum | SurveyAnswersScalarFieldEnum[]
  }

  /**
   * surveyAnswers findMany
   */
  export type surveyAnswersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * Filter, which surveyAnswers to fetch.
     */
    where?: surveyAnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyAnswers to fetch.
     */
    orderBy?: surveyAnswersOrderByWithRelationInput | surveyAnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surveyAnswers.
     */
    cursor?: surveyAnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyAnswers.
     */
    skip?: number
    distinct?: SurveyAnswersScalarFieldEnum | SurveyAnswersScalarFieldEnum[]
  }

  /**
   * surveyAnswers create
   */
  export type surveyAnswersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * The data needed to create a surveyAnswers.
     */
    data: XOR<surveyAnswersCreateInput, surveyAnswersUncheckedCreateInput>
  }

  /**
   * surveyAnswers createMany
   */
  export type surveyAnswersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surveyAnswers.
     */
    data: surveyAnswersCreateManyInput | surveyAnswersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surveyAnswers update
   */
  export type surveyAnswersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * The data needed to update a surveyAnswers.
     */
    data: XOR<surveyAnswersUpdateInput, surveyAnswersUncheckedUpdateInput>
    /**
     * Choose, which surveyAnswers to update.
     */
    where: surveyAnswersWhereUniqueInput
  }

  /**
   * surveyAnswers updateMany
   */
  export type surveyAnswersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surveyAnswers.
     */
    data: XOR<surveyAnswersUpdateManyMutationInput, surveyAnswersUncheckedUpdateManyInput>
    /**
     * Filter which surveyAnswers to update
     */
    where?: surveyAnswersWhereInput
    /**
     * Limit how many surveyAnswers to update.
     */
    limit?: number
  }

  /**
   * surveyAnswers upsert
   */
  export type surveyAnswersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * The filter to search for the surveyAnswers to update in case it exists.
     */
    where: surveyAnswersWhereUniqueInput
    /**
     * In case the surveyAnswers found by the `where` argument doesn't exist, create a new surveyAnswers with this data.
     */
    create: XOR<surveyAnswersCreateInput, surveyAnswersUncheckedCreateInput>
    /**
     * In case the surveyAnswers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surveyAnswersUpdateInput, surveyAnswersUncheckedUpdateInput>
  }

  /**
   * surveyAnswers delete
   */
  export type surveyAnswersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    /**
     * Filter which surveyAnswers to delete.
     */
    where: surveyAnswersWhereUniqueInput
  }

  /**
   * surveyAnswers deleteMany
   */
  export type surveyAnswersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveyAnswers to delete
     */
    where?: surveyAnswersWhereInput
    /**
     * Limit how many surveyAnswers to delete.
     */
    limit?: number
  }

  /**
   * surveyAnswers without action
   */
  export type surveyAnswersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
  }


  /**
   * Model surveyQuestions
   */

  export type AggregateSurveyQuestions = {
    _count: SurveyQuestionsCountAggregateOutputType | null
    _avg: SurveyQuestionsAvgAggregateOutputType | null
    _sum: SurveyQuestionsSumAggregateOutputType | null
    _min: SurveyQuestionsMinAggregateOutputType | null
    _max: SurveyQuestionsMaxAggregateOutputType | null
  }

  export type SurveyQuestionsAvgAggregateOutputType = {
    id: number | null
    service_id: number | null
  }

  export type SurveyQuestionsSumAggregateOutputType = {
    id: number | null
    service_id: number | null
  }

  export type SurveyQuestionsMinAggregateOutputType = {
    id: number | null
    service_id: number | null
    question: string | null
    choices: string | null
    added_at: Date | null
  }

  export type SurveyQuestionsMaxAggregateOutputType = {
    id: number | null
    service_id: number | null
    question: string | null
    choices: string | null
    added_at: Date | null
  }

  export type SurveyQuestionsCountAggregateOutputType = {
    id: number
    service_id: number
    question: number
    choices: number
    added_at: number
    _all: number
  }


  export type SurveyQuestionsAvgAggregateInputType = {
    id?: true
    service_id?: true
  }

  export type SurveyQuestionsSumAggregateInputType = {
    id?: true
    service_id?: true
  }

  export type SurveyQuestionsMinAggregateInputType = {
    id?: true
    service_id?: true
    question?: true
    choices?: true
    added_at?: true
  }

  export type SurveyQuestionsMaxAggregateInputType = {
    id?: true
    service_id?: true
    question?: true
    choices?: true
    added_at?: true
  }

  export type SurveyQuestionsCountAggregateInputType = {
    id?: true
    service_id?: true
    question?: true
    choices?: true
    added_at?: true
    _all?: true
  }

  export type SurveyQuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveyQuestions to aggregate.
     */
    where?: surveyQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyQuestions to fetch.
     */
    orderBy?: surveyQuestionsOrderByWithRelationInput | surveyQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surveyQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surveyQuestions
    **/
    _count?: true | SurveyQuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionsMaxAggregateInputType
  }

  export type GetSurveyQuestionsAggregateType<T extends SurveyQuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestions[P]>
      : GetScalarType<T[P], AggregateSurveyQuestions[P]>
  }




  export type surveyQuestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveyQuestionsWhereInput
    orderBy?: surveyQuestionsOrderByWithAggregationInput | surveyQuestionsOrderByWithAggregationInput[]
    by: SurveyQuestionsScalarFieldEnum[] | SurveyQuestionsScalarFieldEnum
    having?: surveyQuestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionsCountAggregateInputType | true
    _avg?: SurveyQuestionsAvgAggregateInputType
    _sum?: SurveyQuestionsSumAggregateInputType
    _min?: SurveyQuestionsMinAggregateInputType
    _max?: SurveyQuestionsMaxAggregateInputType
  }

  export type SurveyQuestionsGroupByOutputType = {
    id: number
    service_id: number
    question: string | null
    choices: string | null
    added_at: Date
    _count: SurveyQuestionsCountAggregateOutputType | null
    _avg: SurveyQuestionsAvgAggregateOutputType | null
    _sum: SurveyQuestionsSumAggregateOutputType | null
    _min: SurveyQuestionsMinAggregateOutputType | null
    _max: SurveyQuestionsMaxAggregateOutputType | null
  }

  type GetSurveyQuestionsGroupByPayload<T extends surveyQuestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyQuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionsGroupByOutputType[P]>
        }
      >
    >


  export type surveyQuestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    question?: boolean
    choices?: boolean
    added_at?: boolean
    surveyAnswers?: boolean | surveyQuestions$surveyAnswersArgs<ExtArgs>
    service_group?: boolean | service_groupDefaultArgs<ExtArgs>
    _count?: boolean | SurveyQuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestions"]>



  export type surveyQuestionsSelectScalar = {
    id?: boolean
    service_id?: boolean
    question?: boolean
    choices?: boolean
    added_at?: boolean
  }

  export type surveyQuestionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "question" | "choices" | "added_at", ExtArgs["result"]["surveyQuestions"]>
  export type surveyQuestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyAnswers?: boolean | surveyQuestions$surveyAnswersArgs<ExtArgs>
    service_group?: boolean | service_groupDefaultArgs<ExtArgs>
    _count?: boolean | SurveyQuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $surveyQuestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surveyQuestions"
    objects: {
      surveyAnswers: Prisma.$surveyAnswersPayload<ExtArgs>[]
      service_group: Prisma.$service_groupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      service_id: number
      question: string | null
      choices: string | null
      added_at: Date
    }, ExtArgs["result"]["surveyQuestions"]>
    composites: {}
  }

  type surveyQuestionsGetPayload<S extends boolean | null | undefined | surveyQuestionsDefaultArgs> = $Result.GetResult<Prisma.$surveyQuestionsPayload, S>

  type surveyQuestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surveyQuestionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyQuestionsCountAggregateInputType | true
    }

  export interface surveyQuestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surveyQuestions'], meta: { name: 'surveyQuestions' } }
    /**
     * Find zero or one SurveyQuestions that matches the filter.
     * @param {surveyQuestionsFindUniqueArgs} args - Arguments to find a SurveyQuestions
     * @example
     * // Get one SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surveyQuestionsFindUniqueArgs>(args: SelectSubset<T, surveyQuestionsFindUniqueArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyQuestions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surveyQuestionsFindUniqueOrThrowArgs} args - Arguments to find a SurveyQuestions
     * @example
     * // Get one SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surveyQuestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, surveyQuestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyQuestionsFindFirstArgs} args - Arguments to find a SurveyQuestions
     * @example
     * // Get one SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surveyQuestionsFindFirstArgs>(args?: SelectSubset<T, surveyQuestionsFindFirstArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyQuestionsFindFirstOrThrowArgs} args - Arguments to find a SurveyQuestions
     * @example
     * // Get one SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surveyQuestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, surveyQuestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyQuestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.findMany()
     * 
     * // Get first 10 SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionsWithIdOnly = await prisma.surveyQuestions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends surveyQuestionsFindManyArgs>(args?: SelectSubset<T, surveyQuestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyQuestions.
     * @param {surveyQuestionsCreateArgs} args - Arguments to create a SurveyQuestions.
     * @example
     * // Create one SurveyQuestions
     * const SurveyQuestions = await prisma.surveyQuestions.create({
     *   data: {
     *     // ... data to create a SurveyQuestions
     *   }
     * })
     * 
     */
    create<T extends surveyQuestionsCreateArgs>(args: SelectSubset<T, surveyQuestionsCreateArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyQuestions.
     * @param {surveyQuestionsCreateManyArgs} args - Arguments to create many SurveyQuestions.
     * @example
     * // Create many SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surveyQuestionsCreateManyArgs>(args?: SelectSubset<T, surveyQuestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyQuestions.
     * @param {surveyQuestionsDeleteArgs} args - Arguments to delete one SurveyQuestions.
     * @example
     * // Delete one SurveyQuestions
     * const SurveyQuestions = await prisma.surveyQuestions.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestions
     *   }
     * })
     * 
     */
    delete<T extends surveyQuestionsDeleteArgs>(args: SelectSubset<T, surveyQuestionsDeleteArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyQuestions.
     * @param {surveyQuestionsUpdateArgs} args - Arguments to update one SurveyQuestions.
     * @example
     * // Update one SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surveyQuestionsUpdateArgs>(args: SelectSubset<T, surveyQuestionsUpdateArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyQuestions.
     * @param {surveyQuestionsDeleteManyArgs} args - Arguments to filter SurveyQuestions to delete.
     * @example
     * // Delete a few SurveyQuestions
     * const { count } = await prisma.surveyQuestions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surveyQuestionsDeleteManyArgs>(args?: SelectSubset<T, surveyQuestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyQuestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surveyQuestionsUpdateManyArgs>(args: SelectSubset<T, surveyQuestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyQuestions.
     * @param {surveyQuestionsUpsertArgs} args - Arguments to update or create a SurveyQuestions.
     * @example
     * // Update or create a SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestions.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestions we want to update
     *   }
     * })
     */
    upsert<T extends surveyQuestionsUpsertArgs>(args: SelectSubset<T, surveyQuestionsUpsertArgs<ExtArgs>>): Prisma__surveyQuestionsClient<$Result.GetResult<Prisma.$surveyQuestionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyQuestionsCountArgs} args - Arguments to filter SurveyQuestions to count.
     * @example
     * // Count the number of SurveyQuestions
     * const count = await prisma.surveyQuestions.count({
     *   where: {
     *     // ... the filter for the SurveyQuestions we want to count
     *   }
     * })
    **/
    count<T extends surveyQuestionsCountArgs>(
      args?: Subset<T, surveyQuestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionsAggregateArgs>(args: Subset<T, SurveyQuestionsAggregateArgs>): Prisma.PrismaPromise<GetSurveyQuestionsAggregateType<T>>

    /**
     * Group by SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveyQuestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surveyQuestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surveyQuestionsGroupByArgs['orderBy'] }
        : { orderBy?: surveyQuestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surveyQuestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surveyQuestions model
   */
  readonly fields: surveyQuestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surveyQuestions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surveyQuestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyAnswers<T extends surveyQuestions$surveyAnswersArgs<ExtArgs> = {}>(args?: Subset<T, surveyQuestions$surveyAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveyAnswersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_group<T extends service_groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, service_groupDefaultArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the surveyQuestions model
   */
  interface surveyQuestionsFieldRefs {
    readonly id: FieldRef<"surveyQuestions", 'Int'>
    readonly service_id: FieldRef<"surveyQuestions", 'Int'>
    readonly question: FieldRef<"surveyQuestions", 'String'>
    readonly choices: FieldRef<"surveyQuestions", 'String'>
    readonly added_at: FieldRef<"surveyQuestions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * surveyQuestions findUnique
   */
  export type surveyQuestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which surveyQuestions to fetch.
     */
    where: surveyQuestionsWhereUniqueInput
  }

  /**
   * surveyQuestions findUniqueOrThrow
   */
  export type surveyQuestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which surveyQuestions to fetch.
     */
    where: surveyQuestionsWhereUniqueInput
  }

  /**
   * surveyQuestions findFirst
   */
  export type surveyQuestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which surveyQuestions to fetch.
     */
    where?: surveyQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyQuestions to fetch.
     */
    orderBy?: surveyQuestionsOrderByWithRelationInput | surveyQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveyQuestions.
     */
    cursor?: surveyQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveyQuestions.
     */
    distinct?: SurveyQuestionsScalarFieldEnum | SurveyQuestionsScalarFieldEnum[]
  }

  /**
   * surveyQuestions findFirstOrThrow
   */
  export type surveyQuestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which surveyQuestions to fetch.
     */
    where?: surveyQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyQuestions to fetch.
     */
    orderBy?: surveyQuestionsOrderByWithRelationInput | surveyQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveyQuestions.
     */
    cursor?: surveyQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveyQuestions.
     */
    distinct?: SurveyQuestionsScalarFieldEnum | SurveyQuestionsScalarFieldEnum[]
  }

  /**
   * surveyQuestions findMany
   */
  export type surveyQuestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which surveyQuestions to fetch.
     */
    where?: surveyQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveyQuestions to fetch.
     */
    orderBy?: surveyQuestionsOrderByWithRelationInput | surveyQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surveyQuestions.
     */
    cursor?: surveyQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveyQuestions.
     */
    skip?: number
    distinct?: SurveyQuestionsScalarFieldEnum | SurveyQuestionsScalarFieldEnum[]
  }

  /**
   * surveyQuestions create
   */
  export type surveyQuestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a surveyQuestions.
     */
    data: XOR<surveyQuestionsCreateInput, surveyQuestionsUncheckedCreateInput>
  }

  /**
   * surveyQuestions createMany
   */
  export type surveyQuestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surveyQuestions.
     */
    data: surveyQuestionsCreateManyInput | surveyQuestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surveyQuestions update
   */
  export type surveyQuestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a surveyQuestions.
     */
    data: XOR<surveyQuestionsUpdateInput, surveyQuestionsUncheckedUpdateInput>
    /**
     * Choose, which surveyQuestions to update.
     */
    where: surveyQuestionsWhereUniqueInput
  }

  /**
   * surveyQuestions updateMany
   */
  export type surveyQuestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surveyQuestions.
     */
    data: XOR<surveyQuestionsUpdateManyMutationInput, surveyQuestionsUncheckedUpdateManyInput>
    /**
     * Filter which surveyQuestions to update
     */
    where?: surveyQuestionsWhereInput
    /**
     * Limit how many surveyQuestions to update.
     */
    limit?: number
  }

  /**
   * surveyQuestions upsert
   */
  export type surveyQuestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the surveyQuestions to update in case it exists.
     */
    where: surveyQuestionsWhereUniqueInput
    /**
     * In case the surveyQuestions found by the `where` argument doesn't exist, create a new surveyQuestions with this data.
     */
    create: XOR<surveyQuestionsCreateInput, surveyQuestionsUncheckedCreateInput>
    /**
     * In case the surveyQuestions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surveyQuestionsUpdateInput, surveyQuestionsUncheckedUpdateInput>
  }

  /**
   * surveyQuestions delete
   */
  export type surveyQuestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
    /**
     * Filter which surveyQuestions to delete.
     */
    where: surveyQuestionsWhereUniqueInput
  }

  /**
   * surveyQuestions deleteMany
   */
  export type surveyQuestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveyQuestions to delete
     */
    where?: surveyQuestionsWhereInput
    /**
     * Limit how many surveyQuestions to delete.
     */
    limit?: number
  }

  /**
   * surveyQuestions.surveyAnswers
   */
  export type surveyQuestions$surveyAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyAnswers
     */
    select?: surveyAnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyAnswers
     */
    omit?: surveyAnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyAnswersInclude<ExtArgs> | null
    where?: surveyAnswersWhereInput
    orderBy?: surveyAnswersOrderByWithRelationInput | surveyAnswersOrderByWithRelationInput[]
    cursor?: surveyAnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyAnswersScalarFieldEnum | SurveyAnswersScalarFieldEnum[]
  }

  /**
   * surveyQuestions without action
   */
  export type surveyQuestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveyQuestions
     */
    select?: surveyQuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surveyQuestions
     */
    omit?: surveyQuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveyQuestionsInclude<ExtArgs> | null
  }


  /**
   * Model serviceReview
   */

  export type AggregateServiceReview = {
    _count: ServiceReviewCountAggregateOutputType | null
    _avg: ServiceReviewAvgAggregateOutputType | null
    _sum: ServiceReviewSumAggregateOutputType | null
    _min: ServiceReviewMinAggregateOutputType | null
    _max: ServiceReviewMaxAggregateOutputType | null
  }

  export type ServiceReviewAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    service_id: number | null
    rating: number | null
  }

  export type ServiceReviewSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    service_id: number | null
    rating: number | null
  }

  export type ServiceReviewMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    service_id: number | null
    rating: number | null
    emoRating: string | null
    added_at: Date | null
  }

  export type ServiceReviewMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    service_id: number | null
    rating: number | null
    emoRating: string | null
    added_at: Date | null
  }

  export type ServiceReviewCountAggregateOutputType = {
    id: number
    user_id: number
    service_id: number
    rating: number
    emoRating: number
    added_at: number
    _all: number
  }


  export type ServiceReviewAvgAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    rating?: true
  }

  export type ServiceReviewSumAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    rating?: true
  }

  export type ServiceReviewMinAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    rating?: true
    emoRating?: true
    added_at?: true
  }

  export type ServiceReviewMaxAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    rating?: true
    emoRating?: true
    added_at?: true
  }

  export type ServiceReviewCountAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    rating?: true
    emoRating?: true
    added_at?: true
    _all?: true
  }

  export type ServiceReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceReview to aggregate.
     */
    where?: serviceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceReviews to fetch.
     */
    orderBy?: serviceReviewOrderByWithRelationInput | serviceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceReviews
    **/
    _count?: true | ServiceReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceReviewMaxAggregateInputType
  }

  export type GetServiceReviewAggregateType<T extends ServiceReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceReview[P]>
      : GetScalarType<T[P], AggregateServiceReview[P]>
  }




  export type serviceReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceReviewWhereInput
    orderBy?: serviceReviewOrderByWithAggregationInput | serviceReviewOrderByWithAggregationInput[]
    by: ServiceReviewScalarFieldEnum[] | ServiceReviewScalarFieldEnum
    having?: serviceReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceReviewCountAggregateInputType | true
    _avg?: ServiceReviewAvgAggregateInputType
    _sum?: ServiceReviewSumAggregateInputType
    _min?: ServiceReviewMinAggregateInputType
    _max?: ServiceReviewMaxAggregateInputType
  }

  export type ServiceReviewGroupByOutputType = {
    id: number
    user_id: number | null
    service_id: number | null
    rating: number | null
    emoRating: string
    added_at: Date | null
    _count: ServiceReviewCountAggregateOutputType | null
    _avg: ServiceReviewAvgAggregateOutputType | null
    _sum: ServiceReviewSumAggregateOutputType | null
    _min: ServiceReviewMinAggregateOutputType | null
    _max: ServiceReviewMaxAggregateOutputType | null
  }

  type GetServiceReviewGroupByPayload<T extends serviceReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceReviewGroupByOutputType[P]>
        }
      >
    >


  export type serviceReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    service_id?: boolean
    rating?: boolean
    emoRating?: boolean
    added_at?: boolean
    service_group?: boolean | serviceReview$service_groupArgs<ExtArgs>
    users_profile?: boolean | serviceReview$users_profileArgs<ExtArgs>
  }, ExtArgs["result"]["serviceReview"]>



  export type serviceReviewSelectScalar = {
    id?: boolean
    user_id?: boolean
    service_id?: boolean
    rating?: boolean
    emoRating?: boolean
    added_at?: boolean
  }

  export type serviceReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "service_id" | "rating" | "emoRating" | "added_at", ExtArgs["result"]["serviceReview"]>
  export type serviceReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_group?: boolean | serviceReview$service_groupArgs<ExtArgs>
    users_profile?: boolean | serviceReview$users_profileArgs<ExtArgs>
  }

  export type $serviceReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceReview"
    objects: {
      service_group: Prisma.$service_groupPayload<ExtArgs> | null
      users_profile: Prisma.$users_profilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      service_id: number | null
      rating: number | null
      emoRating: string
      added_at: Date | null
    }, ExtArgs["result"]["serviceReview"]>
    composites: {}
  }

  type serviceReviewGetPayload<S extends boolean | null | undefined | serviceReviewDefaultArgs> = $Result.GetResult<Prisma.$serviceReviewPayload, S>

  type serviceReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceReviewCountAggregateInputType | true
    }

  export interface serviceReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceReview'], meta: { name: 'serviceReview' } }
    /**
     * Find zero or one ServiceReview that matches the filter.
     * @param {serviceReviewFindUniqueArgs} args - Arguments to find a ServiceReview
     * @example
     * // Get one ServiceReview
     * const serviceReview = await prisma.serviceReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceReviewFindUniqueArgs>(args: SelectSubset<T, serviceReviewFindUniqueArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceReviewFindUniqueOrThrowArgs} args - Arguments to find a ServiceReview
     * @example
     * // Get one ServiceReview
     * const serviceReview = await prisma.serviceReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceReviewFindFirstArgs} args - Arguments to find a ServiceReview
     * @example
     * // Get one ServiceReview
     * const serviceReview = await prisma.serviceReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceReviewFindFirstArgs>(args?: SelectSubset<T, serviceReviewFindFirstArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceReviewFindFirstOrThrowArgs} args - Arguments to find a ServiceReview
     * @example
     * // Get one ServiceReview
     * const serviceReview = await prisma.serviceReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceReviews
     * const serviceReviews = await prisma.serviceReview.findMany()
     * 
     * // Get first 10 ServiceReviews
     * const serviceReviews = await prisma.serviceReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceReviewWithIdOnly = await prisma.serviceReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serviceReviewFindManyArgs>(args?: SelectSubset<T, serviceReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceReview.
     * @param {serviceReviewCreateArgs} args - Arguments to create a ServiceReview.
     * @example
     * // Create one ServiceReview
     * const ServiceReview = await prisma.serviceReview.create({
     *   data: {
     *     // ... data to create a ServiceReview
     *   }
     * })
     * 
     */
    create<T extends serviceReviewCreateArgs>(args: SelectSubset<T, serviceReviewCreateArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceReviews.
     * @param {serviceReviewCreateManyArgs} args - Arguments to create many ServiceReviews.
     * @example
     * // Create many ServiceReviews
     * const serviceReview = await prisma.serviceReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceReviewCreateManyArgs>(args?: SelectSubset<T, serviceReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceReview.
     * @param {serviceReviewDeleteArgs} args - Arguments to delete one ServiceReview.
     * @example
     * // Delete one ServiceReview
     * const ServiceReview = await prisma.serviceReview.delete({
     *   where: {
     *     // ... filter to delete one ServiceReview
     *   }
     * })
     * 
     */
    delete<T extends serviceReviewDeleteArgs>(args: SelectSubset<T, serviceReviewDeleteArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceReview.
     * @param {serviceReviewUpdateArgs} args - Arguments to update one ServiceReview.
     * @example
     * // Update one ServiceReview
     * const serviceReview = await prisma.serviceReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceReviewUpdateArgs>(args: SelectSubset<T, serviceReviewUpdateArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceReviews.
     * @param {serviceReviewDeleteManyArgs} args - Arguments to filter ServiceReviews to delete.
     * @example
     * // Delete a few ServiceReviews
     * const { count } = await prisma.serviceReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceReviewDeleteManyArgs>(args?: SelectSubset<T, serviceReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceReviews
     * const serviceReview = await prisma.serviceReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceReviewUpdateManyArgs>(args: SelectSubset<T, serviceReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceReview.
     * @param {serviceReviewUpsertArgs} args - Arguments to update or create a ServiceReview.
     * @example
     * // Update or create a ServiceReview
     * const serviceReview = await prisma.serviceReview.upsert({
     *   create: {
     *     // ... data to create a ServiceReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceReview we want to update
     *   }
     * })
     */
    upsert<T extends serviceReviewUpsertArgs>(args: SelectSubset<T, serviceReviewUpsertArgs<ExtArgs>>): Prisma__serviceReviewClient<$Result.GetResult<Prisma.$serviceReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceReviewCountArgs} args - Arguments to filter ServiceReviews to count.
     * @example
     * // Count the number of ServiceReviews
     * const count = await prisma.serviceReview.count({
     *   where: {
     *     // ... the filter for the ServiceReviews we want to count
     *   }
     * })
    **/
    count<T extends serviceReviewCountArgs>(
      args?: Subset<T, serviceReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceReviewAggregateArgs>(args: Subset<T, ServiceReviewAggregateArgs>): Prisma.PrismaPromise<GetServiceReviewAggregateType<T>>

    /**
     * Group by ServiceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceReviewGroupByArgs['orderBy'] }
        : { orderBy?: serviceReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceReview model
   */
  readonly fields: serviceReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service_group<T extends serviceReview$service_groupArgs<ExtArgs> = {}>(args?: Subset<T, serviceReview$service_groupArgs<ExtArgs>>): Prisma__service_groupClient<$Result.GetResult<Prisma.$service_groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_profile<T extends serviceReview$users_profileArgs<ExtArgs> = {}>(args?: Subset<T, serviceReview$users_profileArgs<ExtArgs>>): Prisma__users_profileClient<$Result.GetResult<Prisma.$users_profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceReview model
   */
  interface serviceReviewFieldRefs {
    readonly id: FieldRef<"serviceReview", 'Int'>
    readonly user_id: FieldRef<"serviceReview", 'Int'>
    readonly service_id: FieldRef<"serviceReview", 'Int'>
    readonly rating: FieldRef<"serviceReview", 'Int'>
    readonly emoRating: FieldRef<"serviceReview", 'String'>
    readonly added_at: FieldRef<"serviceReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * serviceReview findUnique
   */
  export type serviceReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * Filter, which serviceReview to fetch.
     */
    where: serviceReviewWhereUniqueInput
  }

  /**
   * serviceReview findUniqueOrThrow
   */
  export type serviceReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * Filter, which serviceReview to fetch.
     */
    where: serviceReviewWhereUniqueInput
  }

  /**
   * serviceReview findFirst
   */
  export type serviceReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * Filter, which serviceReview to fetch.
     */
    where?: serviceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceReviews to fetch.
     */
    orderBy?: serviceReviewOrderByWithRelationInput | serviceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceReviews.
     */
    cursor?: serviceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceReviews.
     */
    distinct?: ServiceReviewScalarFieldEnum | ServiceReviewScalarFieldEnum[]
  }

  /**
   * serviceReview findFirstOrThrow
   */
  export type serviceReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * Filter, which serviceReview to fetch.
     */
    where?: serviceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceReviews to fetch.
     */
    orderBy?: serviceReviewOrderByWithRelationInput | serviceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceReviews.
     */
    cursor?: serviceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceReviews.
     */
    distinct?: ServiceReviewScalarFieldEnum | ServiceReviewScalarFieldEnum[]
  }

  /**
   * serviceReview findMany
   */
  export type serviceReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * Filter, which serviceReviews to fetch.
     */
    where?: serviceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceReviews to fetch.
     */
    orderBy?: serviceReviewOrderByWithRelationInput | serviceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceReviews.
     */
    cursor?: serviceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceReviews.
     */
    skip?: number
    distinct?: ServiceReviewScalarFieldEnum | ServiceReviewScalarFieldEnum[]
  }

  /**
   * serviceReview create
   */
  export type serviceReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a serviceReview.
     */
    data: XOR<serviceReviewCreateInput, serviceReviewUncheckedCreateInput>
  }

  /**
   * serviceReview createMany
   */
  export type serviceReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceReviews.
     */
    data: serviceReviewCreateManyInput | serviceReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceReview update
   */
  export type serviceReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a serviceReview.
     */
    data: XOR<serviceReviewUpdateInput, serviceReviewUncheckedUpdateInput>
    /**
     * Choose, which serviceReview to update.
     */
    where: serviceReviewWhereUniqueInput
  }

  /**
   * serviceReview updateMany
   */
  export type serviceReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceReviews.
     */
    data: XOR<serviceReviewUpdateManyMutationInput, serviceReviewUncheckedUpdateManyInput>
    /**
     * Filter which serviceReviews to update
     */
    where?: serviceReviewWhereInput
    /**
     * Limit how many serviceReviews to update.
     */
    limit?: number
  }

  /**
   * serviceReview upsert
   */
  export type serviceReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the serviceReview to update in case it exists.
     */
    where: serviceReviewWhereUniqueInput
    /**
     * In case the serviceReview found by the `where` argument doesn't exist, create a new serviceReview with this data.
     */
    create: XOR<serviceReviewCreateInput, serviceReviewUncheckedCreateInput>
    /**
     * In case the serviceReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceReviewUpdateInput, serviceReviewUncheckedUpdateInput>
  }

  /**
   * serviceReview delete
   */
  export type serviceReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
    /**
     * Filter which serviceReview to delete.
     */
    where: serviceReviewWhereUniqueInput
  }

  /**
   * serviceReview deleteMany
   */
  export type serviceReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceReviews to delete
     */
    where?: serviceReviewWhereInput
    /**
     * Limit how many serviceReviews to delete.
     */
    limit?: number
  }

  /**
   * serviceReview.service_group
   */
  export type serviceReview$service_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_group
     */
    select?: service_groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_group
     */
    omit?: service_groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_groupInclude<ExtArgs> | null
    where?: service_groupWhereInput
  }

  /**
   * serviceReview.users_profile
   */
  export type serviceReview$users_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_profile
     */
    select?: users_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_profile
     */
    omit?: users_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_profileInclude<ExtArgs> | null
    where?: users_profileWhereInput
  }

  /**
   * serviceReview without action
   */
  export type serviceReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceReview
     */
    select?: serviceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the serviceReview
     */
    omit?: serviceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceReviewInclude<ExtArgs> | null
  }


  /**
   * Model category_search_terms
   */

  export type AggregateCategory_search_terms = {
    _count: Category_search_termsCountAggregateOutputType | null
    _avg: Category_search_termsAvgAggregateOutputType | null
    _sum: Category_search_termsSumAggregateOutputType | null
    _min: Category_search_termsMinAggregateOutputType | null
    _max: Category_search_termsMaxAggregateOutputType | null
  }

  export type Category_search_termsAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type Category_search_termsSumAggregateOutputType = {
    id: number | null
    category_id: number | null
  }

  export type Category_search_termsMinAggregateOutputType = {
    id: number | null
    category_id: number | null
    term: string | null
  }

  export type Category_search_termsMaxAggregateOutputType = {
    id: number | null
    category_id: number | null
    term: string | null
  }

  export type Category_search_termsCountAggregateOutputType = {
    id: number
    category_id: number
    term: number
    _all: number
  }


  export type Category_search_termsAvgAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type Category_search_termsSumAggregateInputType = {
    id?: true
    category_id?: true
  }

  export type Category_search_termsMinAggregateInputType = {
    id?: true
    category_id?: true
    term?: true
  }

  export type Category_search_termsMaxAggregateInputType = {
    id?: true
    category_id?: true
    term?: true
  }

  export type Category_search_termsCountAggregateInputType = {
    id?: true
    category_id?: true
    term?: true
    _all?: true
  }

  export type Category_search_termsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_search_terms to aggregate.
     */
    where?: category_search_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_search_terms to fetch.
     */
    orderBy?: category_search_termsOrderByWithRelationInput | category_search_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: category_search_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_search_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_search_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned category_search_terms
    **/
    _count?: true | Category_search_termsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Category_search_termsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Category_search_termsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Category_search_termsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Category_search_termsMaxAggregateInputType
  }

  export type GetCategory_search_termsAggregateType<T extends Category_search_termsAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory_search_terms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory_search_terms[P]>
      : GetScalarType<T[P], AggregateCategory_search_terms[P]>
  }




  export type category_search_termsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_search_termsWhereInput
    orderBy?: category_search_termsOrderByWithAggregationInput | category_search_termsOrderByWithAggregationInput[]
    by: Category_search_termsScalarFieldEnum[] | Category_search_termsScalarFieldEnum
    having?: category_search_termsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Category_search_termsCountAggregateInputType | true
    _avg?: Category_search_termsAvgAggregateInputType
    _sum?: Category_search_termsSumAggregateInputType
    _min?: Category_search_termsMinAggregateInputType
    _max?: Category_search_termsMaxAggregateInputType
  }

  export type Category_search_termsGroupByOutputType = {
    id: number
    category_id: number
    term: string
    _count: Category_search_termsCountAggregateOutputType | null
    _avg: Category_search_termsAvgAggregateOutputType | null
    _sum: Category_search_termsSumAggregateOutputType | null
    _min: Category_search_termsMinAggregateOutputType | null
    _max: Category_search_termsMaxAggregateOutputType | null
  }

  type GetCategory_search_termsGroupByPayload<T extends category_search_termsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Category_search_termsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Category_search_termsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Category_search_termsGroupByOutputType[P]>
            : GetScalarType<T[P], Category_search_termsGroupByOutputType[P]>
        }
      >
    >


  export type category_search_termsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    term?: boolean
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category_search_terms"]>



  export type category_search_termsSelectScalar = {
    id?: boolean
    category_id?: boolean
    term?: boolean
  }

  export type category_search_termsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_id" | "term", ExtArgs["result"]["category_search_terms"]>
  export type category_search_termsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
  }

  export type $category_search_termsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category_search_terms"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category_id: number
      term: string
    }, ExtArgs["result"]["category_search_terms"]>
    composites: {}
  }

  type category_search_termsGetPayload<S extends boolean | null | undefined | category_search_termsDefaultArgs> = $Result.GetResult<Prisma.$category_search_termsPayload, S>

  type category_search_termsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<category_search_termsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Category_search_termsCountAggregateInputType | true
    }

  export interface category_search_termsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category_search_terms'], meta: { name: 'category_search_terms' } }
    /**
     * Find zero or one Category_search_terms that matches the filter.
     * @param {category_search_termsFindUniqueArgs} args - Arguments to find a Category_search_terms
     * @example
     * // Get one Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends category_search_termsFindUniqueArgs>(args: SelectSubset<T, category_search_termsFindUniqueArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category_search_terms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {category_search_termsFindUniqueOrThrowArgs} args - Arguments to find a Category_search_terms
     * @example
     * // Get one Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends category_search_termsFindUniqueOrThrowArgs>(args: SelectSubset<T, category_search_termsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category_search_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_search_termsFindFirstArgs} args - Arguments to find a Category_search_terms
     * @example
     * // Get one Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends category_search_termsFindFirstArgs>(args?: SelectSubset<T, category_search_termsFindFirstArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category_search_terms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_search_termsFindFirstOrThrowArgs} args - Arguments to find a Category_search_terms
     * @example
     * // Get one Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends category_search_termsFindFirstOrThrowArgs>(args?: SelectSubset<T, category_search_termsFindFirstOrThrowArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Category_search_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_search_termsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.findMany()
     * 
     * // Get first 10 Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const category_search_termsWithIdOnly = await prisma.category_search_terms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends category_search_termsFindManyArgs>(args?: SelectSubset<T, category_search_termsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category_search_terms.
     * @param {category_search_termsCreateArgs} args - Arguments to create a Category_search_terms.
     * @example
     * // Create one Category_search_terms
     * const Category_search_terms = await prisma.category_search_terms.create({
     *   data: {
     *     // ... data to create a Category_search_terms
     *   }
     * })
     * 
     */
    create<T extends category_search_termsCreateArgs>(args: SelectSubset<T, category_search_termsCreateArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Category_search_terms.
     * @param {category_search_termsCreateManyArgs} args - Arguments to create many Category_search_terms.
     * @example
     * // Create many Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends category_search_termsCreateManyArgs>(args?: SelectSubset<T, category_search_termsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category_search_terms.
     * @param {category_search_termsDeleteArgs} args - Arguments to delete one Category_search_terms.
     * @example
     * // Delete one Category_search_terms
     * const Category_search_terms = await prisma.category_search_terms.delete({
     *   where: {
     *     // ... filter to delete one Category_search_terms
     *   }
     * })
     * 
     */
    delete<T extends category_search_termsDeleteArgs>(args: SelectSubset<T, category_search_termsDeleteArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category_search_terms.
     * @param {category_search_termsUpdateArgs} args - Arguments to update one Category_search_terms.
     * @example
     * // Update one Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends category_search_termsUpdateArgs>(args: SelectSubset<T, category_search_termsUpdateArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Category_search_terms.
     * @param {category_search_termsDeleteManyArgs} args - Arguments to filter Category_search_terms to delete.
     * @example
     * // Delete a few Category_search_terms
     * const { count } = await prisma.category_search_terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends category_search_termsDeleteManyArgs>(args?: SelectSubset<T, category_search_termsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_search_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_search_termsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends category_search_termsUpdateManyArgs>(args: SelectSubset<T, category_search_termsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category_search_terms.
     * @param {category_search_termsUpsertArgs} args - Arguments to update or create a Category_search_terms.
     * @example
     * // Update or create a Category_search_terms
     * const category_search_terms = await prisma.category_search_terms.upsert({
     *   create: {
     *     // ... data to create a Category_search_terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category_search_terms we want to update
     *   }
     * })
     */
    upsert<T extends category_search_termsUpsertArgs>(args: SelectSubset<T, category_search_termsUpsertArgs<ExtArgs>>): Prisma__category_search_termsClient<$Result.GetResult<Prisma.$category_search_termsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Category_search_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_search_termsCountArgs} args - Arguments to filter Category_search_terms to count.
     * @example
     * // Count the number of Category_search_terms
     * const count = await prisma.category_search_terms.count({
     *   where: {
     *     // ... the filter for the Category_search_terms we want to count
     *   }
     * })
    **/
    count<T extends category_search_termsCountArgs>(
      args?: Subset<T, category_search_termsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Category_search_termsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category_search_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_search_termsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Category_search_termsAggregateArgs>(args: Subset<T, Category_search_termsAggregateArgs>): Prisma.PrismaPromise<GetCategory_search_termsAggregateType<T>>

    /**
     * Group by Category_search_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_search_termsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends category_search_termsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: category_search_termsGroupByArgs['orderBy'] }
        : { orderBy?: category_search_termsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, category_search_termsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategory_search_termsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category_search_terms model
   */
  readonly fields: category_search_termsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category_search_terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__category_search_termsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriesDefaultArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category_search_terms model
   */
  interface category_search_termsFieldRefs {
    readonly id: FieldRef<"category_search_terms", 'Int'>
    readonly category_id: FieldRef<"category_search_terms", 'Int'>
    readonly term: FieldRef<"category_search_terms", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category_search_terms findUnique
   */
  export type category_search_termsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * Filter, which category_search_terms to fetch.
     */
    where: category_search_termsWhereUniqueInput
  }

  /**
   * category_search_terms findUniqueOrThrow
   */
  export type category_search_termsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * Filter, which category_search_terms to fetch.
     */
    where: category_search_termsWhereUniqueInput
  }

  /**
   * category_search_terms findFirst
   */
  export type category_search_termsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * Filter, which category_search_terms to fetch.
     */
    where?: category_search_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_search_terms to fetch.
     */
    orderBy?: category_search_termsOrderByWithRelationInput | category_search_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_search_terms.
     */
    cursor?: category_search_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_search_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_search_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_search_terms.
     */
    distinct?: Category_search_termsScalarFieldEnum | Category_search_termsScalarFieldEnum[]
  }

  /**
   * category_search_terms findFirstOrThrow
   */
  export type category_search_termsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * Filter, which category_search_terms to fetch.
     */
    where?: category_search_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_search_terms to fetch.
     */
    orderBy?: category_search_termsOrderByWithRelationInput | category_search_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_search_terms.
     */
    cursor?: category_search_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_search_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_search_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_search_terms.
     */
    distinct?: Category_search_termsScalarFieldEnum | Category_search_termsScalarFieldEnum[]
  }

  /**
   * category_search_terms findMany
   */
  export type category_search_termsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * Filter, which category_search_terms to fetch.
     */
    where?: category_search_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_search_terms to fetch.
     */
    orderBy?: category_search_termsOrderByWithRelationInput | category_search_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing category_search_terms.
     */
    cursor?: category_search_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_search_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_search_terms.
     */
    skip?: number
    distinct?: Category_search_termsScalarFieldEnum | Category_search_termsScalarFieldEnum[]
  }

  /**
   * category_search_terms create
   */
  export type category_search_termsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * The data needed to create a category_search_terms.
     */
    data: XOR<category_search_termsCreateInput, category_search_termsUncheckedCreateInput>
  }

  /**
   * category_search_terms createMany
   */
  export type category_search_termsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many category_search_terms.
     */
    data: category_search_termsCreateManyInput | category_search_termsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category_search_terms update
   */
  export type category_search_termsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * The data needed to update a category_search_terms.
     */
    data: XOR<category_search_termsUpdateInput, category_search_termsUncheckedUpdateInput>
    /**
     * Choose, which category_search_terms to update.
     */
    where: category_search_termsWhereUniqueInput
  }

  /**
   * category_search_terms updateMany
   */
  export type category_search_termsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update category_search_terms.
     */
    data: XOR<category_search_termsUpdateManyMutationInput, category_search_termsUncheckedUpdateManyInput>
    /**
     * Filter which category_search_terms to update
     */
    where?: category_search_termsWhereInput
    /**
     * Limit how many category_search_terms to update.
     */
    limit?: number
  }

  /**
   * category_search_terms upsert
   */
  export type category_search_termsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * The filter to search for the category_search_terms to update in case it exists.
     */
    where: category_search_termsWhereUniqueInput
    /**
     * In case the category_search_terms found by the `where` argument doesn't exist, create a new category_search_terms with this data.
     */
    create: XOR<category_search_termsCreateInput, category_search_termsUncheckedCreateInput>
    /**
     * In case the category_search_terms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<category_search_termsUpdateInput, category_search_termsUncheckedUpdateInput>
  }

  /**
   * category_search_terms delete
   */
  export type category_search_termsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
    /**
     * Filter which category_search_terms to delete.
     */
    where: category_search_termsWhereUniqueInput
  }

  /**
   * category_search_terms deleteMany
   */
  export type category_search_termsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_search_terms to delete
     */
    where?: category_search_termsWhereInput
    /**
     * Limit how many category_search_terms to delete.
     */
    limit?: number
  }

  /**
   * category_search_terms without action
   */
  export type category_search_termsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_search_terms
     */
    select?: category_search_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the category_search_terms
     */
    omit?: category_search_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_search_termsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const App_releasesScalarFieldEnum: {
    id: 'id',
    release_version: 'release_version',
    app_name: 'app_name',
    platform: 'platform',
    release_note: 'release_note',
    release_url: 'release_url',
    minimum_version: 'minimum_version',
    added_at: 'added_at'
  };

  export type App_releasesScalarFieldEnum = (typeof App_releasesScalarFieldEnum)[keyof typeof App_releasesScalarFieldEnum]


  export const AppointmentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    registry_type: 'registry_type',
    institution_id: 'institution_id',
    service_id: 'service_id',
    operator_id: 'operator_id',
    user_id: 'user_id',
    reason: 'reason',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    location: 'location',
    additional_note: 'additional_note',
    creator_id: 'creator_id',
    recurring: 'recurring',
    notification_status: 'notification_status',
    ticket_created: 'ticket_created',
    appointment_cancelled: 'appointment_cancelled',
    created_at: 'created_at',
    cancellation_reason: 'cancellation_reason'
  };

  export type AppointmentsScalarFieldEnum = (typeof AppointmentsScalarFieldEnum)[keyof typeof AppointmentsScalarFieldEnum]


  export const AppsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    institution_id: 'institution_id',
    secret_key: 'secret_key',
    access_key: 'access_key',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AppsScalarFieldEnum = (typeof AppsScalarFieldEnum)[keyof typeof AppsScalarFieldEnum]


  export const Audit_trailScalarFieldEnum: {
    id: 'id',
    old_value: 'old_value',
    new_value: 'new_value',
    action: 'action',
    model: 'model',
    field: 'field',
    user_id: 'user_id',
    ip: 'ip',
    user_agent: 'user_agent',
    model_id: 'model_id',
    display_name: 'display_name',
    time: 'time',
    status: 'status',
    reviewed_by: 'reviewed_by'
  };

  export type Audit_trailScalarFieldEnum = (typeof Audit_trailScalarFieldEnum)[keyof typeof Audit_trailScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sector_id: 'sector_id'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const Change_requestScalarFieldEnum: {
    id: 'id',
    old_value: 'old_value',
    new_value: 'new_value',
    action: 'action',
    model: 'model',
    model_id: 'model_id',
    user_id: 'user_id',
    ip: 'ip',
    user_agent: 'user_agent',
    display_name: 'display_name',
    status: 'status',
    reviewed_by: 'reviewed_by',
    time: 'time',
    institution_id: 'institution_id'
  };

  export type Change_requestScalarFieldEnum = (typeof Change_requestScalarFieldEnum)[keyof typeof Change_requestScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    notification_token: 'notification_token',
    affiliate_id: 'affiliate_id',
    service_id: 'service_id',
    serial_number: 'serial_number',
    status: 'status',
    created_at: 'created_at',
    device_type: 'device_type',
    gender: 'gender',
    age_range: 'age_range',
    language: 'language',
    notification_enabled: 'notification_enabled',
    apiKey: 'apiKey',
    nonce: 'nonce',
    linkShortCode: 'linkShortCode',
    linkShortCodeExp: 'linkShortCodeExp',
    phone_number: 'phone_number',
    latest_hb: 'latest_hb',
    latest_hb_version: 'latest_hb_version',
    updated_at: 'updated_at'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const Device_heartbeatScalarFieldEnum: {
    id: 'id',
    time: 'time',
    device_id: 'device_id',
    operator_id: 'operator_id',
    version: 'version'
  };

  export type Device_heartbeatScalarFieldEnum = (typeof Device_heartbeatScalarFieldEnum)[keyof typeof Device_heartbeatScalarFieldEnum]


  export const InstitutionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    search_term: 'search_term',
    email: 'email',
    address: 'address',
    phone_number: 'phone_number',
    url: 'url',
    status: 'status',
    created_at: 'created_at',
    plan: 'plan',
    type: 'type',
    level: 'level',
    parent_id: 'parent_id',
    good_ratings: 'good_ratings',
    bad_ratings: 'bad_ratings',
    excellent_ratings: 'excellent_ratings',
    nps: 'nps',
    csat: 'csat',
    queue_autocreation: 'queue_autocreation',
    queue_manual_creation: 'queue_manual_creation',
    working_hours: 'working_hours',
    qms_message: 'qms_message',
    priority_list: 'priority_list',
    logo: 'logo',
    app_name: 'app_name',
    allowed_context: 'allowed_context',
    host_name: 'host_name',
    membership_type: 'membership_type',
    category_id: 'category_id',
    latest_membership_renew_time: 'latest_membership_renew_time',
    description: 'description',
    latitude: 'latitude',
    longitude: 'longitude',
    button_one: 'button_one',
    button_two: 'button_two',
    amenities: 'amenities'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const Institution_invoicesScalarFieldEnum: {
    id: 'id',
    invoice_number: 'invoice_number',
    institution_id: 'institution_id',
    institution_name: 'institution_name',
    period_start: 'period_start',
    period_end: 'period_end',
    generated_at: 'generated_at',
    expiry: 'expiry',
    payment_reference_number: 'payment_reference_number',
    ext_payment_reference_number: 'ext_payment_reference_number',
    payment_status: 'payment_status',
    payment_status_desc: 'payment_status_desc',
    payment_method: 'payment_method',
    payment_retries: 'payment_retries',
    status: 'status',
    total_amount: 'total_amount'
  };

  export type Institution_invoicesScalarFieldEnum = (typeof Institution_invoicesScalarFieldEnum)[keyof typeof Institution_invoicesScalarFieldEnum]


  export const Institution_service_trackingScalarFieldEnum: {
    id: 'id',
    institution_id: 'institution_id',
    branch_id: 'branch_id',
    service_id: 'service_id',
    branch_name: 'branch_name',
    service_group_name: 'service_group_name',
    time: 'time',
    action: 'action',
    status: 'status',
    invoice_number: 'invoice_number'
  };

  export type Institution_service_trackingScalarFieldEnum = (typeof Institution_service_trackingScalarFieldEnum)[keyof typeof Institution_service_trackingScalarFieldEnum]


  export const Login_historyScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    ip: 'ip',
    user_agent: 'user_agent',
    time: 'time'
  };

  export type Login_historyScalarFieldEnum = (typeof Login_historyScalarFieldEnum)[keyof typeof Login_historyScalarFieldEnum]


  export const MigrationScalarFieldEnum: {
    version: 'version',
    apply_time: 'apply_time'
  };

  export type MigrationScalarFieldEnum = (typeof MigrationScalarFieldEnum)[keyof typeof MigrationScalarFieldEnum]


  export const Mms_fileScalarFieldEnum: {
    id: 'id',
    device_uuid: 'device_uuid',
    institution_id: 'institution_id',
    path: 'path',
    comment: 'comment',
    type: 'type',
    longitude: 'longitude',
    latitude: 'latitude',
    height: 'height',
    width: 'width',
    first_view_time: 'first_view_time',
    last_view_time: 'last_view_time',
    created_at: 'created_at'
  };

  export type Mms_fileScalarFieldEnum = (typeof Mms_fileScalarFieldEnum)[keyof typeof Mms_fileScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    link: 'link',
    seen: 'seen',
    time_sent: 'time_sent',
    time_seen: 'time_seen'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const Notification_recipientScalarFieldEnum: {
    id: 'id',
    id_notification: 'id_notification',
    id_user: 'id_user',
    seen: 'seen',
    ticket: 'ticket',
    reference_id: 'reference_id'
  };

  export type Notification_recipientScalarFieldEnum = (typeof Notification_recipientScalarFieldEnum)[keyof typeof Notification_recipientScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    parent_id: 'parent_id',
    created_at: 'created_at'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const Popup_questionsScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    name_fr: 'name_fr',
    name_rw: 'name_rw',
    name_sw: 'name_sw',
    service_id: 'service_id',
    description_en: 'description_en',
    description_fr: 'description_fr',
    description_rw: 'description_rw',
    description_sw: 'description_sw',
    applies_to_bad: 'applies_to_bad',
    applies_to_good: 'applies_to_good',
    applies_to_excellent: 'applies_to_excellent',
    institution_id: 'institution_id',
    status: 'status',
    type: 'type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Popup_questionsScalarFieldEnum = (typeof Popup_questionsScalarFieldEnum)[keyof typeof Popup_questionsScalarFieldEnum]


  export const Popup_questions_answersScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    rating_id: 'rating_id',
    ticket_id: 'ticket_id',
    answer_id: 'answer_id',
    answered_at: 'answered_at'
  };

  export type Popup_questions_answersScalarFieldEnum = (typeof Popup_questions_answersScalarFieldEnum)[keyof typeof Popup_questions_answersScalarFieldEnum]


  export const Popup_questions_possible_answersScalarFieldEnum: {
    id: 'id',
    popup_question_id: 'popup_question_id',
    answer_en: 'answer_en',
    answer_fr: 'answer_fr',
    answer_rw: 'answer_rw',
    answer_sw: 'answer_sw',
    created_at: 'created_at',
    updated_at: 'updated_at',
    priority: 'priority'
  };

  export type Popup_questions_possible_answersScalarFieldEnum = (typeof Popup_questions_possible_answersScalarFieldEnum)[keyof typeof Popup_questions_possible_answersScalarFieldEnum]


  export const Qms_branch_operatorScalarFieldEnum: {
    id: 'id',
    operator_id: 'operator_id',
    institution_id: 'institution_id',
    service_id: 'service_id',
    linked_at: 'linked_at',
    status: 'status'
  };

  export type Qms_branch_operatorScalarFieldEnum = (typeof Qms_branch_operatorScalarFieldEnum)[keyof typeof Qms_branch_operatorScalarFieldEnum]


  export const Qms_branch_transactionsScalarFieldEnum: {
    id: 'id',
    affiliate_id: 'affiliate_id',
    date: 'date',
    note: 'note',
    created_at: 'created_at',
    last_updated: 'last_updated'
  };

  export type Qms_branch_transactionsScalarFieldEnum = (typeof Qms_branch_transactionsScalarFieldEnum)[keyof typeof Qms_branch_transactionsScalarFieldEnum]


  export const Qms_counterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Qms_counterScalarFieldEnum = (typeof Qms_counterScalarFieldEnum)[keyof typeof Qms_counterScalarFieldEnum]


  export const Qms_customerScalarFieldEnum: {
    id: 'id',
    customer_uuid: 'customer_uuid',
    device_id: 'device_id',
    name: 'name',
    phone_number: 'phone_number',
    email: 'email',
    has_priority_service: 'has_priority_service',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Qms_customerScalarFieldEnum = (typeof Qms_customerScalarFieldEnum)[keyof typeof Qms_customerScalarFieldEnum]


  export const Qms_operatorScalarFieldEnum: {
    id: 'id',
    operator_uuid: 'operator_uuid',
    institution_id: 'institution_id',
    name: 'name',
    username: 'username',
    password_hash: 'password_hash',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email_address: 'email_address',
    phone_number: 'phone_number',
    terminal: 'terminal'
  };

  export type Qms_operatorScalarFieldEnum = (typeof Qms_operatorScalarFieldEnum)[keyof typeof Qms_operatorScalarFieldEnum]


  export const Qms_operator_transactionsScalarFieldEnum: {
    id: 'id',
    branch_transaction_id: 'branch_transaction_id',
    operator_id: 'operator_id',
    transaction: 'transaction',
    created_at: 'created_at',
    last_updated: 'last_updated'
  };

  export type Qms_operator_transactionsScalarFieldEnum = (typeof Qms_operator_transactionsScalarFieldEnum)[keyof typeof Qms_operator_transactionsScalarFieldEnum]


  export const Qms_queueScalarFieldEnum: {
    id: 'id',
    queue_uuid: 'queue_uuid',
    service_id: 'service_id',
    queue_date: 'queue_date',
    start_time: 'start_time',
    end_time: 'end_time',
    status: 'status',
    avg_service_time: 'avg_service_time',
    created_at: 'created_at',
    updated_at: 'updated_at',
    closure_notification: 'closure_notification',
    inter_arrival_time: 'inter_arrival_time'
  };

  export type Qms_queueScalarFieldEnum = (typeof Qms_queueScalarFieldEnum)[keyof typeof Qms_queueScalarFieldEnum]


  export const Qms_queue_operator_lnkScalarFieldEnum: {
    id: 'id',
    queue_id: 'queue_id',
    operator_id: 'operator_id',
    operator_uuid: 'operator_uuid',
    counter_id: 'counter_id',
    first_login: 'first_login',
    last_logout: 'last_logout',
    api_key: 'api_key'
  };

  export type Qms_queue_operator_lnkScalarFieldEnum = (typeof Qms_queue_operator_lnkScalarFieldEnum)[keyof typeof Qms_queue_operator_lnkScalarFieldEnum]


  export const Qms_ticketScalarFieldEnum: {
    id: 'id',
    ticket_uuid: 'ticket_uuid',
    queue_id: 'queue_id',
    customer_id: 'customer_id',
    ticket_number: 'ticket_number',
    full_ticket_number: 'full_ticket_number',
    pin: 'pin',
    status: 'status',
    service_time: 'service_time',
    estimated_waiting_time: 'estimated_waiting_time',
    created_at: 'created_at',
    waiting_ended_on: 'waiting_ended_on',
    skipped_at: 'skipped_at',
    cancelled_at: 'cancelled_at',
    on_hold_from: 'on_hold_from',
    skips_count: 'skips_count',
    prioritized: 'prioritized',
    reason_id: 'reason_id',
    prioritized_at: 'prioritized_at',
    is_next: 'is_next',
    prev_ticket_id: 'prev_ticket_id',
    rating_notification_sent: 'rating_notification_sent',
    source: 'source'
  };

  export type Qms_ticketScalarFieldEnum = (typeof Qms_ticketScalarFieldEnum)[keyof typeof Qms_ticketScalarFieldEnum]


  export const Qms_ticket_assignmentScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    queue_id: 'queue_id',
    operator_id: 'operator_id',
    counter_id: 'counter_id',
    status: 'status',
    started_at: 'started_at',
    completed_at: 'completed_at',
    assigned_at: 'assigned_at',
    state: 'state',
    comment: 'comment'
  };

  export type Qms_ticket_assignmentScalarFieldEnum = (typeof Qms_ticket_assignmentScalarFieldEnum)[keyof typeof Qms_ticket_assignmentScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    state: 'state',
    time: 'time',
    service_id: 'service_id',
    comment: 'comment',
    gender: 'gender',
    age_range: 'age_range',
    location: 'location',
    device_id: 'device_id',
    nps_score: 'nps_score',
    ticket_id: 'ticket_id',
    finger_print: 'finger_print'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const Rating_assetsScalarFieldEnum: {
    rating_assets_id: 'rating_assets_id',
    rating_assets_image: 'rating_assets_image',
    rating_assets_video: 'rating_assets_video',
    rating_id: 'rating_id'
  };

  export type Rating_assetsScalarFieldEnum = (typeof Rating_assetsScalarFieldEnum)[keyof typeof Rating_assetsScalarFieldEnum]


  export const Rating_qr_code_sessionsScalarFieldEnum: {
    id: 'id',
    institution_uuid: 'institution_uuid',
    service_uuid: 'service_uuid',
    user_agent: 'user_agent',
    finger_print: 'finger_print',
    ip_address: 'ip_address',
    session_token: 'session_token',
    session_expiration: 'session_expiration',
    status: 'status',
    created_at: 'created_at'
  };

  export type Rating_qr_code_sessionsScalarFieldEnum = (typeof Rating_qr_code_sessionsScalarFieldEnum)[keyof typeof Rating_qr_code_sessionsScalarFieldEnum]


  export const Rating_replyScalarFieldEnum: {
    id: 'id',
    specific: 'specific',
    rating_id: 'rating_id',
    time: 'time',
    reply: 'reply'
  };

  export type Rating_replyScalarFieldEnum = (typeof Rating_replyScalarFieldEnum)[keyof typeof Rating_replyScalarFieldEnum]


  export const ReportsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    institution_id: 'institution_id',
    service_ids: 'service_ids',
    start_date: 'start_date',
    end_date: 'end_date',
    report_created_by: 'report_created_by',
    report_institution_id: 'report_institution_id',
    report_recipient: 'report_recipient',
    report_queue_uuid: 'report_queue_uuid',
    report_content_key: 'report_content_key',
    status: 'status',
    created_at: 'created_at'
  };

  export type ReportsScalarFieldEnum = (typeof ReportsScalarFieldEnum)[keyof typeof ReportsScalarFieldEnum]


  export const Request_institutionScalarFieldEnum: {
    id: 'id',
    owner_name: 'owner_name',
    address: 'address',
    phone_number: 'phone_number',
    email: 'email',
    name: 'name',
    category: 'category',
    location: 'location',
    type: 'type',
    business_certificate: 'business_certificate',
    product_type: 'product_type',
    approval_status: 'approval_status'
  };

  export type Request_institutionScalarFieldEnum = (typeof Request_institutionScalarFieldEnum)[keyof typeof Request_institutionScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    institution_id: 'institution_id',
    status: 'status',
    created_at: 'created_at',
    bad_rating_threshold: 'bad_rating_threshold',
    group: 'group',
    good_ratings: 'good_ratings',
    bad_ratings: 'bad_ratings',
    excellent_ratings: 'excellent_ratings',
    nps: 'nps',
    csat: 'csat',
    mean_service_time: 'mean_service_time',
    avg_service_time: 'avg_service_time',
    uuid: 'uuid',
    inter_arrival_time: 'inter_arrival_time',
    estimated_time: 'estimated_time'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const Service_groupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_rw: 'name_rw',
    name_fr: 'name_fr',
    name_sw: 'name_sw',
    search_term: 'search_term',
    institution_id: 'institution_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    uuid: 'uuid',
    status: 'status',
    good_ratings: 'good_ratings',
    bad_ratings: 'bad_ratings',
    excellent_ratings: 'excellent_ratings',
    nps: 'nps',
    csat: 'csat',
    mean_service_time: 'mean_service_time',
    ticket_prefix: 'ticket_prefix',
    bad_rating_threshold: 'bad_rating_threshold'
  };

  export type Service_groupScalarFieldEnum = (typeof Service_groupScalarFieldEnum)[keyof typeof Service_groupScalarFieldEnum]


  export const SurveyScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    type: 'type',
    name: 'name',
    description: 'description',
    url: 'url',
    survey_data: 'survey_data',
    institution_id: 'institution_id',
    service_id: 'service_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    access_key: 'access_key'
  };

  export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


  export const Survey_resultScalarFieldEnum: {
    id: 'id',
    survey_id: 'survey_id',
    rating_id: 'rating_id',
    service_id: 'service_id',
    device_id: 'device_id',
    agent: 'agent',
    result_data: 'result_data',
    replied_at: 'replied_at'
  };

  export type Survey_resultScalarFieldEnum = (typeof Survey_resultScalarFieldEnum)[keyof typeof Survey_resultScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    services: 'services',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_by: 'updated_by',
    status: 'status'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const TipScalarFieldEnum: {
    id: 'id',
    collection_reference_id: 'collection_reference_id',
    disbursement_reference_id: 'disbursement_reference_id',
    device_id: 'device_id',
    rating_id: 'rating_id',
    payee: 'payee',
    payer: 'payer',
    amount: 'amount',
    tip_amount: 'tip_amount',
    collection_status: 'collection_status',
    collection_status_details: 'collection_status_details',
    closed_at: 'closed_at',
    disbursed_at: 'disbursed_at',
    disbursement_status: 'disbursement_status',
    disbursement_status_details: 'disbursement_status_details',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TipScalarFieldEnum = (typeof TipScalarFieldEnum)[keyof typeof TipScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    phone_number: 'phone_number',
    username: 'username',
    auth_key: 'auth_key',
    password_hash: 'password_hash',
    password_reset_token: 'password_reset_token',
    email: 'email',
    status: 'status',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at',
    verification_token: 'verification_token',
    allowed_context: 'allowed_context',
    institution_id: 'institution_id',
    last_received_hb_alert_at: 'last_received_hb_alert_at',
    last_received_rating_notification_at: 'last_received_rating_notification_at',
    language: 'language',
    notifications_enabled: 'notifications_enabled',
    last_login: 'last_login',
    allow_auto_approved_changes: 'allow_auto_approved_changes'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Wallet_accountsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    account_type_id: 'account_type_id',
    account_number: 'account_number',
    account_name: 'account_name',
    balance: 'balance',
    public_key: 'public_key',
    private_key: 'private_key',
    added_at: 'added_at'
  };

  export type Wallet_accountsScalarFieldEnum = (typeof Wallet_accountsScalarFieldEnum)[keyof typeof Wallet_accountsScalarFieldEnum]


  export const Wallet_accounts_typesScalarFieldEnum: {
    id: 'id',
    category: 'category',
    abbreviation: 'abbreviation',
    name: 'name',
    added_at: 'added_at'
  };

  export type Wallet_accounts_typesScalarFieldEnum = (typeof Wallet_accounts_typesScalarFieldEnum)[keyof typeof Wallet_accounts_typesScalarFieldEnum]


  export const Wallet_transfersScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    time: 'time',
    payer_id: 'payer_id',
    payer_account_id: 'payer_account_id',
    payee_address: 'payee_address',
    payee_name: 'payee_name',
    payee_account_type: 'payee_account_type',
    payee_account_number: 'payee_account_number',
    payee_type: 'payee_type',
    tx_id: 'tx_id',
    fspid: 'fspid',
    ext_trx_id: 'ext_trx_id',
    pay_money_ext_res: 'pay_money_ext_res',
    confirm_party_ext_res: 'confirm_party_ext_res',
    confirm_quote_ext_res: 'confirm_quote_ext_res',
    status: 'status',
    quote_id: 'quote_id',
    note: 'note',
    transfer_fees: 'transfer_fees'
  };

  export type Wallet_transfersScalarFieldEnum = (typeof Wallet_transfersScalarFieldEnum)[keyof typeof Wallet_transfersScalarFieldEnum]


  export const Wallet_usersScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    fullname: 'fullname',
    email: 'email',
    private_key: 'private_key',
    public_key: 'public_key',
    initiated_at: 'initiated_at'
  };

  export type Wallet_usersScalarFieldEnum = (typeof Wallet_usersScalarFieldEnum)[keyof typeof Wallet_usersScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    id: 'id',
    institution_id: 'institution_id',
    user_id: 'user_id',
    type: 'type',
    image_url: 'image_url',
    caption: 'caption',
    uploaded_at: 'uploaded_at',
    review_id: 'review_id'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const SectorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type SectorsScalarFieldEnum = (typeof SectorsScalarFieldEnum)[keyof typeof SectorsScalarFieldEnum]


  export const Users_profileScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone_number: 'phone_number',
    age_group: 'age_group',
    gender: 'gender',
    address: 'address',
    added_at: 'added_at',
    isVerified: 'isVerified',
    verifyToken: 'verifyToken'
  };

  export type Users_profileScalarFieldEnum = (typeof Users_profileScalarFieldEnum)[keyof typeof Users_profileScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    institution_id: 'institution_id',
    rating: 'rating',
    review: 'review',
    created_at: 'created_at',
    is_approved: 'is_approved'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const WorkingHourScalarFieldEnum: {
    id: 'id',
    institution_id: 'institution_id',
    day_of_week: 'day_of_week',
    open_time: 'open_time',
    close_time: 'close_time'
  };

  export type WorkingHourScalarFieldEnum = (typeof WorkingHourScalarFieldEnum)[keyof typeof WorkingHourScalarFieldEnum]


  export const AmenitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    added_at: 'added_at'
  };

  export type AmenitiesScalarFieldEnum = (typeof AmenitiesScalarFieldEnum)[keyof typeof AmenitiesScalarFieldEnum]


  export const Business_amenitiesScalarFieldEnum: {
    id: 'id',
    institution_id: 'institution_id',
    amenitY_id: 'amenitY_id'
  };

  export type Business_amenitiesScalarFieldEnum = (typeof Business_amenitiesScalarFieldEnum)[keyof typeof Business_amenitiesScalarFieldEnum]


  export const Price_rangesScalarFieldEnum: {
    id: 'id',
    max_value: 'max_value',
    min_value: 'min_value',
    institution_id: 'institution_id',
    label: 'label'
  };

  export type Price_rangesScalarFieldEnum = (typeof Price_rangesScalarFieldEnum)[keyof typeof Price_rangesScalarFieldEnum]


  export const SurveyAnswersScalarFieldEnum: {
    id: 'id',
    question_id: 'question_id',
    user_id: 'user_id',
    answer: 'answer',
    scale_rating: 'scale_rating',
    added_at: 'added_at'
  };

  export type SurveyAnswersScalarFieldEnum = (typeof SurveyAnswersScalarFieldEnum)[keyof typeof SurveyAnswersScalarFieldEnum]


  export const SurveyQuestionsScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    question: 'question',
    choices: 'choices',
    added_at: 'added_at'
  };

  export type SurveyQuestionsScalarFieldEnum = (typeof SurveyQuestionsScalarFieldEnum)[keyof typeof SurveyQuestionsScalarFieldEnum]


  export const ServiceReviewScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    service_id: 'service_id',
    rating: 'rating',
    emoRating: 'emoRating',
    added_at: 'added_at'
  };

  export type ServiceReviewScalarFieldEnum = (typeof ServiceReviewScalarFieldEnum)[keyof typeof ServiceReviewScalarFieldEnum]


  export const Category_search_termsScalarFieldEnum: {
    id: 'id',
    category_id: 'category_id',
    term: 'term'
  };

  export type Category_search_termsScalarFieldEnum = (typeof Category_search_termsScalarFieldEnum)[keyof typeof Category_search_termsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const app_releasesOrderByRelevanceFieldEnum: {
    release_version: 'release_version',
    release_note: 'release_note',
    release_url: 'release_url',
    minimum_version: 'minimum_version'
  };

  export type app_releasesOrderByRelevanceFieldEnum = (typeof app_releasesOrderByRelevanceFieldEnum)[keyof typeof app_releasesOrderByRelevanceFieldEnum]


  export const appointmentsOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    phone: 'phone',
    reason: 'reason',
    location: 'location',
    additional_note: 'additional_note',
    cancellation_reason: 'cancellation_reason'
  };

  export type appointmentsOrderByRelevanceFieldEnum = (typeof appointmentsOrderByRelevanceFieldEnum)[keyof typeof appointmentsOrderByRelevanceFieldEnum]


  export const appsOrderByRelevanceFieldEnum: {
    name: 'name',
    secret_key: 'secret_key',
    access_key: 'access_key'
  };

  export type appsOrderByRelevanceFieldEnum = (typeof appsOrderByRelevanceFieldEnum)[keyof typeof appsOrderByRelevanceFieldEnum]


  export const audit_trailOrderByRelevanceFieldEnum: {
    old_value: 'old_value',
    new_value: 'new_value',
    action: 'action',
    model: 'model',
    field: 'field',
    ip: 'ip',
    user_agent: 'user_agent',
    model_id: 'model_id',
    display_name: 'display_name'
  };

  export type audit_trailOrderByRelevanceFieldEnum = (typeof audit_trailOrderByRelevanceFieldEnum)[keyof typeof audit_trailOrderByRelevanceFieldEnum]


  export const categoriesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type categoriesOrderByRelevanceFieldEnum = (typeof categoriesOrderByRelevanceFieldEnum)[keyof typeof categoriesOrderByRelevanceFieldEnum]


  export const change_requestOrderByRelevanceFieldEnum: {
    old_value: 'old_value',
    new_value: 'new_value',
    action: 'action',
    model: 'model',
    ip: 'ip',
    user_agent: 'user_agent',
    display_name: 'display_name'
  };

  export type change_requestOrderByRelevanceFieldEnum = (typeof change_requestOrderByRelevanceFieldEnum)[keyof typeof change_requestOrderByRelevanceFieldEnum]


  export const deviceOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    notification_token: 'notification_token',
    service_id: 'service_id',
    serial_number: 'serial_number',
    apiKey: 'apiKey',
    linkShortCode: 'linkShortCode',
    phone_number: 'phone_number',
    latest_hb_version: 'latest_hb_version'
  };

  export type deviceOrderByRelevanceFieldEnum = (typeof deviceOrderByRelevanceFieldEnum)[keyof typeof deviceOrderByRelevanceFieldEnum]


  export const device_heartbeatOrderByRelevanceFieldEnum: {
    version: 'version'
  };

  export type device_heartbeatOrderByRelevanceFieldEnum = (typeof device_heartbeatOrderByRelevanceFieldEnum)[keyof typeof device_heartbeatOrderByRelevanceFieldEnum]


  export const institutionOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    name: 'name',
    search_term: 'search_term',
    email: 'email',
    address: 'address',
    phone_number: 'phone_number',
    url: 'url',
    working_hours: 'working_hours',
    qms_message: 'qms_message',
    priority_list: 'priority_list',
    logo: 'logo',
    app_name: 'app_name',
    host_name: 'host_name',
    description: 'description',
    latitude: 'latitude',
    longitude: 'longitude',
    button_one: 'button_one',
    button_two: 'button_two',
    amenities: 'amenities'
  };

  export type institutionOrderByRelevanceFieldEnum = (typeof institutionOrderByRelevanceFieldEnum)[keyof typeof institutionOrderByRelevanceFieldEnum]


  export const institution_invoicesOrderByRelevanceFieldEnum: {
    invoice_number: 'invoice_number',
    institution_name: 'institution_name',
    payment_reference_number: 'payment_reference_number',
    ext_payment_reference_number: 'ext_payment_reference_number',
    payment_status_desc: 'payment_status_desc',
    payment_method: 'payment_method'
  };

  export type institution_invoicesOrderByRelevanceFieldEnum = (typeof institution_invoicesOrderByRelevanceFieldEnum)[keyof typeof institution_invoicesOrderByRelevanceFieldEnum]


  export const institution_service_trackingOrderByRelevanceFieldEnum: {
    branch_name: 'branch_name',
    service_group_name: 'service_group_name',
    invoice_number: 'invoice_number'
  };

  export type institution_service_trackingOrderByRelevanceFieldEnum = (typeof institution_service_trackingOrderByRelevanceFieldEnum)[keyof typeof institution_service_trackingOrderByRelevanceFieldEnum]


  export const login_historyOrderByRelevanceFieldEnum: {
    ip: 'ip',
    user_agent: 'user_agent'
  };

  export type login_historyOrderByRelevanceFieldEnum = (typeof login_historyOrderByRelevanceFieldEnum)[keyof typeof login_historyOrderByRelevanceFieldEnum]


  export const migrationOrderByRelevanceFieldEnum: {
    version: 'version'
  };

  export type migrationOrderByRelevanceFieldEnum = (typeof migrationOrderByRelevanceFieldEnum)[keyof typeof migrationOrderByRelevanceFieldEnum]


  export const mms_fileOrderByRelevanceFieldEnum: {
    device_uuid: 'device_uuid',
    path: 'path',
    comment: 'comment'
  };

  export type mms_fileOrderByRelevanceFieldEnum = (typeof mms_fileOrderByRelevanceFieldEnum)[keyof typeof mms_fileOrderByRelevanceFieldEnum]


  export const notificationOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content',
    link: 'link'
  };

  export type notificationOrderByRelevanceFieldEnum = (typeof notificationOrderByRelevanceFieldEnum)[keyof typeof notificationOrderByRelevanceFieldEnum]


  export const optionOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type optionOrderByRelevanceFieldEnum = (typeof optionOrderByRelevanceFieldEnum)[keyof typeof optionOrderByRelevanceFieldEnum]


  export const popup_questionsOrderByRelevanceFieldEnum: {
    name_en: 'name_en',
    name_fr: 'name_fr',
    name_rw: 'name_rw',
    name_sw: 'name_sw',
    service_id: 'service_id',
    description_en: 'description_en',
    description_fr: 'description_fr',
    description_rw: 'description_rw',
    description_sw: 'description_sw'
  };

  export type popup_questionsOrderByRelevanceFieldEnum = (typeof popup_questionsOrderByRelevanceFieldEnum)[keyof typeof popup_questionsOrderByRelevanceFieldEnum]


  export const popup_questions_possible_answersOrderByRelevanceFieldEnum: {
    answer_en: 'answer_en',
    answer_fr: 'answer_fr',
    answer_rw: 'answer_rw',
    answer_sw: 'answer_sw'
  };

  export type popup_questions_possible_answersOrderByRelevanceFieldEnum = (typeof popup_questions_possible_answersOrderByRelevanceFieldEnum)[keyof typeof popup_questions_possible_answersOrderByRelevanceFieldEnum]


  export const qms_branch_operatorOrderByRelevanceFieldEnum: {
    service_id: 'service_id'
  };

  export type qms_branch_operatorOrderByRelevanceFieldEnum = (typeof qms_branch_operatorOrderByRelevanceFieldEnum)[keyof typeof qms_branch_operatorOrderByRelevanceFieldEnum]


  export const qms_branch_transactionsOrderByRelevanceFieldEnum: {
    note: 'note'
  };

  export type qms_branch_transactionsOrderByRelevanceFieldEnum = (typeof qms_branch_transactionsOrderByRelevanceFieldEnum)[keyof typeof qms_branch_transactionsOrderByRelevanceFieldEnum]


  export const qms_counterOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type qms_counterOrderByRelevanceFieldEnum = (typeof qms_counterOrderByRelevanceFieldEnum)[keyof typeof qms_counterOrderByRelevanceFieldEnum]


  export const qms_customerOrderByRelevanceFieldEnum: {
    customer_uuid: 'customer_uuid',
    name: 'name',
    phone_number: 'phone_number',
    email: 'email'
  };

  export type qms_customerOrderByRelevanceFieldEnum = (typeof qms_customerOrderByRelevanceFieldEnum)[keyof typeof qms_customerOrderByRelevanceFieldEnum]


  export const qms_operatorOrderByRelevanceFieldEnum: {
    operator_uuid: 'operator_uuid',
    name: 'name',
    username: 'username',
    password_hash: 'password_hash',
    email_address: 'email_address',
    phone_number: 'phone_number'
  };

  export type qms_operatorOrderByRelevanceFieldEnum = (typeof qms_operatorOrderByRelevanceFieldEnum)[keyof typeof qms_operatorOrderByRelevanceFieldEnum]


  export const qms_queueOrderByRelevanceFieldEnum: {
    queue_uuid: 'queue_uuid'
  };

  export type qms_queueOrderByRelevanceFieldEnum = (typeof qms_queueOrderByRelevanceFieldEnum)[keyof typeof qms_queueOrderByRelevanceFieldEnum]


  export const qms_queue_operator_lnkOrderByRelevanceFieldEnum: {
    operator_uuid: 'operator_uuid',
    api_key: 'api_key'
  };

  export type qms_queue_operator_lnkOrderByRelevanceFieldEnum = (typeof qms_queue_operator_lnkOrderByRelevanceFieldEnum)[keyof typeof qms_queue_operator_lnkOrderByRelevanceFieldEnum]


  export const qms_ticketOrderByRelevanceFieldEnum: {
    ticket_uuid: 'ticket_uuid',
    ticket_number: 'ticket_number',
    full_ticket_number: 'full_ticket_number'
  };

  export type qms_ticketOrderByRelevanceFieldEnum = (typeof qms_ticketOrderByRelevanceFieldEnum)[keyof typeof qms_ticketOrderByRelevanceFieldEnum]


  export const qms_ticket_assignmentOrderByRelevanceFieldEnum: {
    comment: 'comment'
  };

  export type qms_ticket_assignmentOrderByRelevanceFieldEnum = (typeof qms_ticket_assignmentOrderByRelevanceFieldEnum)[keyof typeof qms_ticket_assignmentOrderByRelevanceFieldEnum]


  export const ratingOrderByRelevanceFieldEnum: {
    comment: 'comment',
    finger_print: 'finger_print'
  };

  export type ratingOrderByRelevanceFieldEnum = (typeof ratingOrderByRelevanceFieldEnum)[keyof typeof ratingOrderByRelevanceFieldEnum]


  export const rating_assetsOrderByRelevanceFieldEnum: {
    rating_assets_image: 'rating_assets_image',
    rating_assets_video: 'rating_assets_video'
  };

  export type rating_assetsOrderByRelevanceFieldEnum = (typeof rating_assetsOrderByRelevanceFieldEnum)[keyof typeof rating_assetsOrderByRelevanceFieldEnum]


  export const rating_qr_code_sessionsOrderByRelevanceFieldEnum: {
    institution_uuid: 'institution_uuid',
    service_uuid: 'service_uuid',
    user_agent: 'user_agent',
    finger_print: 'finger_print',
    ip_address: 'ip_address',
    session_token: 'session_token'
  };

  export type rating_qr_code_sessionsOrderByRelevanceFieldEnum = (typeof rating_qr_code_sessionsOrderByRelevanceFieldEnum)[keyof typeof rating_qr_code_sessionsOrderByRelevanceFieldEnum]


  export const rating_replyOrderByRelevanceFieldEnum: {
    reply: 'reply'
  };

  export type rating_replyOrderByRelevanceFieldEnum = (typeof rating_replyOrderByRelevanceFieldEnum)[keyof typeof rating_replyOrderByRelevanceFieldEnum]


  export const reportsOrderByRelevanceFieldEnum: {
    title: 'title',
    type: 'type',
    service_ids: 'service_ids',
    report_institution_id: 'report_institution_id',
    report_recipient: 'report_recipient',
    report_queue_uuid: 'report_queue_uuid',
    report_content_key: 'report_content_key'
  };

  export type reportsOrderByRelevanceFieldEnum = (typeof reportsOrderByRelevanceFieldEnum)[keyof typeof reportsOrderByRelevanceFieldEnum]


  export const request_institutionOrderByRelevanceFieldEnum: {
    owner_name: 'owner_name',
    address: 'address',
    phone_number: 'phone_number',
    email: 'email',
    name: 'name',
    category: 'category',
    location: 'location',
    type: 'type',
    business_certificate: 'business_certificate',
    product_type: 'product_type'
  };

  export type request_institutionOrderByRelevanceFieldEnum = (typeof request_institutionOrderByRelevanceFieldEnum)[keyof typeof request_institutionOrderByRelevanceFieldEnum]


  export const serviceOrderByRelevanceFieldEnum: {
    uuid: 'uuid'
  };

  export type serviceOrderByRelevanceFieldEnum = (typeof serviceOrderByRelevanceFieldEnum)[keyof typeof serviceOrderByRelevanceFieldEnum]


  export const service_groupOrderByRelevanceFieldEnum: {
    name: 'name',
    name_rw: 'name_rw',
    name_fr: 'name_fr',
    name_sw: 'name_sw',
    search_term: 'search_term',
    uuid: 'uuid',
    ticket_prefix: 'ticket_prefix'
  };

  export type service_groupOrderByRelevanceFieldEnum = (typeof service_groupOrderByRelevanceFieldEnum)[keyof typeof service_groupOrderByRelevanceFieldEnum]


  export const surveyOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    url: 'url',
    survey_data: 'survey_data',
    service_id: 'service_id',
    access_key: 'access_key'
  };

  export type surveyOrderByRelevanceFieldEnum = (typeof surveyOrderByRelevanceFieldEnum)[keyof typeof surveyOrderByRelevanceFieldEnum]


  export const survey_resultOrderByRelevanceFieldEnum: {
    agent: 'agent',
    result_data: 'result_data'
  };

  export type survey_resultOrderByRelevanceFieldEnum = (typeof survey_resultOrderByRelevanceFieldEnum)[keyof typeof survey_resultOrderByRelevanceFieldEnum]


  export const tagsOrderByRelevanceFieldEnum: {
    name: 'name',
    services: 'services'
  };

  export type tagsOrderByRelevanceFieldEnum = (typeof tagsOrderByRelevanceFieldEnum)[keyof typeof tagsOrderByRelevanceFieldEnum]


  export const tipOrderByRelevanceFieldEnum: {
    collection_reference_id: 'collection_reference_id',
    disbursement_reference_id: 'disbursement_reference_id',
    payee: 'payee',
    payer: 'payer',
    collection_status: 'collection_status',
    collection_status_details: 'collection_status_details',
    disbursement_status: 'disbursement_status',
    disbursement_status_details: 'disbursement_status_details'
  };

  export type tipOrderByRelevanceFieldEnum = (typeof tipOrderByRelevanceFieldEnum)[keyof typeof tipOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    name: 'name',
    title: 'title',
    phone_number: 'phone_number',
    username: 'username',
    auth_key: 'auth_key',
    password_hash: 'password_hash',
    password_reset_token: 'password_reset_token',
    email: 'email',
    verification_token: 'verification_token',
    institution_id: 'institution_id',
    language: 'language'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const wallet_accountsOrderByRelevanceFieldEnum: {
    account_number: 'account_number',
    account_name: 'account_name',
    public_key: 'public_key',
    private_key: 'private_key'
  };

  export type wallet_accountsOrderByRelevanceFieldEnum = (typeof wallet_accountsOrderByRelevanceFieldEnum)[keyof typeof wallet_accountsOrderByRelevanceFieldEnum]


  export const wallet_accounts_typesOrderByRelevanceFieldEnum: {
    category: 'category',
    abbreviation: 'abbreviation',
    name: 'name'
  };

  export type wallet_accounts_typesOrderByRelevanceFieldEnum = (typeof wallet_accounts_typesOrderByRelevanceFieldEnum)[keyof typeof wallet_accounts_typesOrderByRelevanceFieldEnum]


  export const wallet_transfersOrderByRelevanceFieldEnum: {
    currency: 'currency',
    payee_address: 'payee_address',
    payee_name: 'payee_name',
    payee_account_type: 'payee_account_type',
    payee_account_number: 'payee_account_number',
    payee_type: 'payee_type',
    tx_id: 'tx_id',
    fspid: 'fspid',
    ext_trx_id: 'ext_trx_id',
    pay_money_ext_res: 'pay_money_ext_res',
    confirm_party_ext_res: 'confirm_party_ext_res',
    confirm_quote_ext_res: 'confirm_quote_ext_res',
    status: 'status',
    quote_id: 'quote_id',
    note: 'note',
    transfer_fees: 'transfer_fees'
  };

  export type wallet_transfersOrderByRelevanceFieldEnum = (typeof wallet_transfersOrderByRelevanceFieldEnum)[keyof typeof wallet_transfersOrderByRelevanceFieldEnum]


  export const wallet_usersOrderByRelevanceFieldEnum: {
    fullname: 'fullname',
    email: 'email',
    private_key: 'private_key',
    public_key: 'public_key'
  };

  export type wallet_usersOrderByRelevanceFieldEnum = (typeof wallet_usersOrderByRelevanceFieldEnum)[keyof typeof wallet_usersOrderByRelevanceFieldEnum]


  export const imagesOrderByRelevanceFieldEnum: {
    type: 'type',
    image_url: 'image_url',
    caption: 'caption'
  };

  export type imagesOrderByRelevanceFieldEnum = (typeof imagesOrderByRelevanceFieldEnum)[keyof typeof imagesOrderByRelevanceFieldEnum]


  export const sectorsOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type sectorsOrderByRelevanceFieldEnum = (typeof sectorsOrderByRelevanceFieldEnum)[keyof typeof sectorsOrderByRelevanceFieldEnum]


  export const users_profileOrderByRelevanceFieldEnum: {
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    phone_number: 'phone_number',
    age_group: 'age_group',
    gender: 'gender',
    address: 'address',
    verifyToken: 'verifyToken'
  };

  export type users_profileOrderByRelevanceFieldEnum = (typeof users_profileOrderByRelevanceFieldEnum)[keyof typeof users_profileOrderByRelevanceFieldEnum]


  export const reviewsOrderByRelevanceFieldEnum: {
    review: 'review'
  };

  export type reviewsOrderByRelevanceFieldEnum = (typeof reviewsOrderByRelevanceFieldEnum)[keyof typeof reviewsOrderByRelevanceFieldEnum]


  export const workingHourOrderByRelevanceFieldEnum: {
    day_of_week: 'day_of_week'
  };

  export type workingHourOrderByRelevanceFieldEnum = (typeof workingHourOrderByRelevanceFieldEnum)[keyof typeof workingHourOrderByRelevanceFieldEnum]


  export const amenitiesOrderByRelevanceFieldEnum: {
    name: 'name',
    icon: 'icon'
  };

  export type amenitiesOrderByRelevanceFieldEnum = (typeof amenitiesOrderByRelevanceFieldEnum)[keyof typeof amenitiesOrderByRelevanceFieldEnum]


  export const price_rangesOrderByRelevanceFieldEnum: {
    label: 'label'
  };

  export type price_rangesOrderByRelevanceFieldEnum = (typeof price_rangesOrderByRelevanceFieldEnum)[keyof typeof price_rangesOrderByRelevanceFieldEnum]


  export const surveyAnswersOrderByRelevanceFieldEnum: {
    answer: 'answer'
  };

  export type surveyAnswersOrderByRelevanceFieldEnum = (typeof surveyAnswersOrderByRelevanceFieldEnum)[keyof typeof surveyAnswersOrderByRelevanceFieldEnum]


  export const surveyQuestionsOrderByRelevanceFieldEnum: {
    question: 'question',
    choices: 'choices'
  };

  export type surveyQuestionsOrderByRelevanceFieldEnum = (typeof surveyQuestionsOrderByRelevanceFieldEnum)[keyof typeof surveyQuestionsOrderByRelevanceFieldEnum]


  export const serviceReviewOrderByRelevanceFieldEnum: {
    emoRating: 'emoRating'
  };

  export type serviceReviewOrderByRelevanceFieldEnum = (typeof serviceReviewOrderByRelevanceFieldEnum)[keyof typeof serviceReviewOrderByRelevanceFieldEnum]


  export const category_search_termsOrderByRelevanceFieldEnum: {
    term: 'term'
  };

  export type category_search_termsOrderByRelevanceFieldEnum = (typeof category_search_termsOrderByRelevanceFieldEnum)[keyof typeof category_search_termsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'app_releases_app_name'
   */
  export type Enumapp_releases_app_nameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'app_releases_app_name'>
    


  /**
   * Reference to a field of type 'app_releases_platform'
   */
  export type Enumapp_releases_platformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'app_releases_platform'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'audit_trail_status'
   */
  export type Enumaudit_trail_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'audit_trail_status'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'institution_invoices_payment_status'
   */
  export type Enuminstitution_invoices_payment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'institution_invoices_payment_status'>
    


  /**
   * Reference to a field of type 'institution_invoices_status'
   */
  export type Enuminstitution_invoices_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'institution_invoices_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'qms_queue_status'
   */
  export type Enumqms_queue_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'qms_queue_status'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'rating_qr_code_sessions_status'
   */
  export type Enumrating_qr_code_sessions_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rating_qr_code_sessions_status'>
    
  /**
   * Deep Input Types
   */


  export type app_releasesWhereInput = {
    AND?: app_releasesWhereInput | app_releasesWhereInput[]
    OR?: app_releasesWhereInput[]
    NOT?: app_releasesWhereInput | app_releasesWhereInput[]
    id?: IntFilter<"app_releases"> | number
    release_version?: StringFilter<"app_releases"> | string
    app_name?: Enumapp_releases_app_nameFilter<"app_releases"> | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformFilter<"app_releases"> | $Enums.app_releases_platform
    release_note?: StringNullableFilter<"app_releases"> | string | null
    release_url?: StringFilter<"app_releases"> | string
    minimum_version?: StringFilter<"app_releases"> | string
    added_at?: DateTimeFilter<"app_releases"> | Date | string
  }

  export type app_releasesOrderByWithRelationInput = {
    id?: SortOrder
    release_version?: SortOrder
    app_name?: SortOrder
    platform?: SortOrder
    release_note?: SortOrderInput | SortOrder
    release_url?: SortOrder
    minimum_version?: SortOrder
    added_at?: SortOrder
    _relevance?: app_releasesOrderByRelevanceInput
  }

  export type app_releasesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: app_releasesWhereInput | app_releasesWhereInput[]
    OR?: app_releasesWhereInput[]
    NOT?: app_releasesWhereInput | app_releasesWhereInput[]
    release_version?: StringFilter<"app_releases"> | string
    app_name?: Enumapp_releases_app_nameFilter<"app_releases"> | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformFilter<"app_releases"> | $Enums.app_releases_platform
    release_note?: StringNullableFilter<"app_releases"> | string | null
    release_url?: StringFilter<"app_releases"> | string
    minimum_version?: StringFilter<"app_releases"> | string
    added_at?: DateTimeFilter<"app_releases"> | Date | string
  }, "id">

  export type app_releasesOrderByWithAggregationInput = {
    id?: SortOrder
    release_version?: SortOrder
    app_name?: SortOrder
    platform?: SortOrder
    release_note?: SortOrderInput | SortOrder
    release_url?: SortOrder
    minimum_version?: SortOrder
    added_at?: SortOrder
    _count?: app_releasesCountOrderByAggregateInput
    _avg?: app_releasesAvgOrderByAggregateInput
    _max?: app_releasesMaxOrderByAggregateInput
    _min?: app_releasesMinOrderByAggregateInput
    _sum?: app_releasesSumOrderByAggregateInput
  }

  export type app_releasesScalarWhereWithAggregatesInput = {
    AND?: app_releasesScalarWhereWithAggregatesInput | app_releasesScalarWhereWithAggregatesInput[]
    OR?: app_releasesScalarWhereWithAggregatesInput[]
    NOT?: app_releasesScalarWhereWithAggregatesInput | app_releasesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_releases"> | number
    release_version?: StringWithAggregatesFilter<"app_releases"> | string
    app_name?: Enumapp_releases_app_nameWithAggregatesFilter<"app_releases"> | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformWithAggregatesFilter<"app_releases"> | $Enums.app_releases_platform
    release_note?: StringNullableWithAggregatesFilter<"app_releases"> | string | null
    release_url?: StringWithAggregatesFilter<"app_releases"> | string
    minimum_version?: StringWithAggregatesFilter<"app_releases"> | string
    added_at?: DateTimeWithAggregatesFilter<"app_releases"> | Date | string
  }

  export type appointmentsWhereInput = {
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    id?: IntFilter<"appointments"> | number
    name?: StringNullableFilter<"appointments"> | string | null
    email?: StringNullableFilter<"appointments"> | string | null
    phone?: StringFilter<"appointments"> | string
    registry_type?: IntFilter<"appointments"> | number
    institution_id?: IntNullableFilter<"appointments"> | number | null
    service_id?: IntNullableFilter<"appointments"> | number | null
    operator_id?: IntNullableFilter<"appointments"> | number | null
    user_id?: IntNullableFilter<"appointments"> | number | null
    reason?: StringFilter<"appointments"> | string
    date?: DateTimeFilter<"appointments"> | Date | string
    start_time?: DateTimeFilter<"appointments"> | Date | string
    end_time?: DateTimeFilter<"appointments"> | Date | string
    location?: StringFilter<"appointments"> | string
    additional_note?: StringFilter<"appointments"> | string
    creator_id?: IntFilter<"appointments"> | number
    recurring?: IntNullableFilter<"appointments"> | number | null
    notification_status?: IntNullableFilter<"appointments"> | number | null
    ticket_created?: IntNullableFilter<"appointments"> | number | null
    appointment_cancelled?: IntNullableFilter<"appointments"> | number | null
    created_at?: DateTimeNullableFilter<"appointments"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"appointments"> | string | null
    user_appointments_creator_idTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    qms_operator?: XOR<Qms_operatorNullableScalarRelationFilter, qms_operatorWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
    user_appointments_user_idTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type appointmentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    reason?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    location?: SortOrder
    additional_note?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrderInput | SortOrder
    notification_status?: SortOrderInput | SortOrder
    ticket_created?: SortOrderInput | SortOrder
    appointment_cancelled?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    user_appointments_creator_idTouser?: userOrderByWithRelationInput
    institution?: institutionOrderByWithRelationInput
    qms_operator?: qms_operatorOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
    user_appointments_user_idTouser?: userOrderByWithRelationInput
    _relevance?: appointmentsOrderByRelevanceInput
  }

  export type appointmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    name?: StringNullableFilter<"appointments"> | string | null
    email?: StringNullableFilter<"appointments"> | string | null
    phone?: StringFilter<"appointments"> | string
    registry_type?: IntFilter<"appointments"> | number
    institution_id?: IntNullableFilter<"appointments"> | number | null
    service_id?: IntNullableFilter<"appointments"> | number | null
    operator_id?: IntNullableFilter<"appointments"> | number | null
    user_id?: IntNullableFilter<"appointments"> | number | null
    reason?: StringFilter<"appointments"> | string
    date?: DateTimeFilter<"appointments"> | Date | string
    start_time?: DateTimeFilter<"appointments"> | Date | string
    end_time?: DateTimeFilter<"appointments"> | Date | string
    location?: StringFilter<"appointments"> | string
    additional_note?: StringFilter<"appointments"> | string
    creator_id?: IntFilter<"appointments"> | number
    recurring?: IntNullableFilter<"appointments"> | number | null
    notification_status?: IntNullableFilter<"appointments"> | number | null
    ticket_created?: IntNullableFilter<"appointments"> | number | null
    appointment_cancelled?: IntNullableFilter<"appointments"> | number | null
    created_at?: DateTimeNullableFilter<"appointments"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"appointments"> | string | null
    user_appointments_creator_idTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    qms_operator?: XOR<Qms_operatorNullableScalarRelationFilter, qms_operatorWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
    user_appointments_user_idTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type appointmentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    reason?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    location?: SortOrder
    additional_note?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrderInput | SortOrder
    notification_status?: SortOrderInput | SortOrder
    ticket_created?: SortOrderInput | SortOrder
    appointment_cancelled?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    _count?: appointmentsCountOrderByAggregateInput
    _avg?: appointmentsAvgOrderByAggregateInput
    _max?: appointmentsMaxOrderByAggregateInput
    _min?: appointmentsMinOrderByAggregateInput
    _sum?: appointmentsSumOrderByAggregateInput
  }

  export type appointmentsScalarWhereWithAggregatesInput = {
    AND?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    OR?: appointmentsScalarWhereWithAggregatesInput[]
    NOT?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"appointments"> | number
    name?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    email?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    phone?: StringWithAggregatesFilter<"appointments"> | string
    registry_type?: IntWithAggregatesFilter<"appointments"> | number
    institution_id?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    service_id?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    operator_id?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    reason?: StringWithAggregatesFilter<"appointments"> | string
    date?: DateTimeWithAggregatesFilter<"appointments"> | Date | string
    start_time?: DateTimeWithAggregatesFilter<"appointments"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"appointments"> | Date | string
    location?: StringWithAggregatesFilter<"appointments"> | string
    additional_note?: StringWithAggregatesFilter<"appointments"> | string
    creator_id?: IntWithAggregatesFilter<"appointments"> | number
    recurring?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    notification_status?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    ticket_created?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    appointment_cancelled?: IntNullableWithAggregatesFilter<"appointments"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"appointments"> | Date | string | null
    cancellation_reason?: StringNullableWithAggregatesFilter<"appointments"> | string | null
  }

  export type appsWhereInput = {
    AND?: appsWhereInput | appsWhereInput[]
    OR?: appsWhereInput[]
    NOT?: appsWhereInput | appsWhereInput[]
    id?: IntFilter<"apps"> | number
    name?: StringFilter<"apps"> | string
    status?: IntFilter<"apps"> | number
    institution_id?: IntFilter<"apps"> | number
    secret_key?: StringNullableFilter<"apps"> | string | null
    access_key?: StringNullableFilter<"apps"> | string | null
    created_at?: DateTimeNullableFilter<"apps"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"apps"> | Date | string | null
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
  }

  export type appsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
    secret_key?: SortOrderInput | SortOrder
    access_key?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    institution?: institutionOrderByWithRelationInput
    _relevance?: appsOrderByRelevanceInput
  }

  export type appsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: appsWhereInput | appsWhereInput[]
    OR?: appsWhereInput[]
    NOT?: appsWhereInput | appsWhereInput[]
    name?: StringFilter<"apps"> | string
    status?: IntFilter<"apps"> | number
    institution_id?: IntFilter<"apps"> | number
    secret_key?: StringNullableFilter<"apps"> | string | null
    access_key?: StringNullableFilter<"apps"> | string | null
    created_at?: DateTimeNullableFilter<"apps"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"apps"> | Date | string | null
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
  }, "id">

  export type appsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
    secret_key?: SortOrderInput | SortOrder
    access_key?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: appsCountOrderByAggregateInput
    _avg?: appsAvgOrderByAggregateInput
    _max?: appsMaxOrderByAggregateInput
    _min?: appsMinOrderByAggregateInput
    _sum?: appsSumOrderByAggregateInput
  }

  export type appsScalarWhereWithAggregatesInput = {
    AND?: appsScalarWhereWithAggregatesInput | appsScalarWhereWithAggregatesInput[]
    OR?: appsScalarWhereWithAggregatesInput[]
    NOT?: appsScalarWhereWithAggregatesInput | appsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"apps"> | number
    name?: StringWithAggregatesFilter<"apps"> | string
    status?: IntWithAggregatesFilter<"apps"> | number
    institution_id?: IntWithAggregatesFilter<"apps"> | number
    secret_key?: StringNullableWithAggregatesFilter<"apps"> | string | null
    access_key?: StringNullableWithAggregatesFilter<"apps"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"apps"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"apps"> | Date | string | null
  }

  export type audit_trailWhereInput = {
    AND?: audit_trailWhereInput | audit_trailWhereInput[]
    OR?: audit_trailWhereInput[]
    NOT?: audit_trailWhereInput | audit_trailWhereInput[]
    id?: IntFilter<"audit_trail"> | number
    old_value?: StringNullableFilter<"audit_trail"> | string | null
    new_value?: StringNullableFilter<"audit_trail"> | string | null
    action?: StringFilter<"audit_trail"> | string
    model?: StringFilter<"audit_trail"> | string
    field?: StringNullableFilter<"audit_trail"> | string | null
    user_id?: IntNullableFilter<"audit_trail"> | number | null
    ip?: StringNullableFilter<"audit_trail"> | string | null
    user_agent?: StringNullableFilter<"audit_trail"> | string | null
    model_id?: StringFilter<"audit_trail"> | string
    display_name?: StringNullableFilter<"audit_trail"> | string | null
    time?: DateTimeFilter<"audit_trail"> | Date | string
    status?: Enumaudit_trail_statusNullableFilter<"audit_trail"> | $Enums.audit_trail_status | null
    reviewed_by?: IntNullableFilter<"audit_trail"> | number | null
  }

  export type audit_trailOrderByWithRelationInput = {
    id?: SortOrder
    old_value?: SortOrderInput | SortOrder
    new_value?: SortOrderInput | SortOrder
    action?: SortOrder
    model?: SortOrder
    field?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    model_id?: SortOrder
    display_name?: SortOrderInput | SortOrder
    time?: SortOrder
    status?: SortOrderInput | SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    _relevance?: audit_trailOrderByRelevanceInput
  }

  export type audit_trailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: audit_trailWhereInput | audit_trailWhereInput[]
    OR?: audit_trailWhereInput[]
    NOT?: audit_trailWhereInput | audit_trailWhereInput[]
    old_value?: StringNullableFilter<"audit_trail"> | string | null
    new_value?: StringNullableFilter<"audit_trail"> | string | null
    action?: StringFilter<"audit_trail"> | string
    model?: StringFilter<"audit_trail"> | string
    field?: StringNullableFilter<"audit_trail"> | string | null
    user_id?: IntNullableFilter<"audit_trail"> | number | null
    ip?: StringNullableFilter<"audit_trail"> | string | null
    user_agent?: StringNullableFilter<"audit_trail"> | string | null
    model_id?: StringFilter<"audit_trail"> | string
    display_name?: StringNullableFilter<"audit_trail"> | string | null
    time?: DateTimeFilter<"audit_trail"> | Date | string
    status?: Enumaudit_trail_statusNullableFilter<"audit_trail"> | $Enums.audit_trail_status | null
    reviewed_by?: IntNullableFilter<"audit_trail"> | number | null
  }, "id">

  export type audit_trailOrderByWithAggregationInput = {
    id?: SortOrder
    old_value?: SortOrderInput | SortOrder
    new_value?: SortOrderInput | SortOrder
    action?: SortOrder
    model?: SortOrder
    field?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    model_id?: SortOrder
    display_name?: SortOrderInput | SortOrder
    time?: SortOrder
    status?: SortOrderInput | SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    _count?: audit_trailCountOrderByAggregateInput
    _avg?: audit_trailAvgOrderByAggregateInput
    _max?: audit_trailMaxOrderByAggregateInput
    _min?: audit_trailMinOrderByAggregateInput
    _sum?: audit_trailSumOrderByAggregateInput
  }

  export type audit_trailScalarWhereWithAggregatesInput = {
    AND?: audit_trailScalarWhereWithAggregatesInput | audit_trailScalarWhereWithAggregatesInput[]
    OR?: audit_trailScalarWhereWithAggregatesInput[]
    NOT?: audit_trailScalarWhereWithAggregatesInput | audit_trailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"audit_trail"> | number
    old_value?: StringNullableWithAggregatesFilter<"audit_trail"> | string | null
    new_value?: StringNullableWithAggregatesFilter<"audit_trail"> | string | null
    action?: StringWithAggregatesFilter<"audit_trail"> | string
    model?: StringWithAggregatesFilter<"audit_trail"> | string
    field?: StringNullableWithAggregatesFilter<"audit_trail"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"audit_trail"> | number | null
    ip?: StringNullableWithAggregatesFilter<"audit_trail"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"audit_trail"> | string | null
    model_id?: StringWithAggregatesFilter<"audit_trail"> | string
    display_name?: StringNullableWithAggregatesFilter<"audit_trail"> | string | null
    time?: DateTimeWithAggregatesFilter<"audit_trail"> | Date | string
    status?: Enumaudit_trail_statusNullableWithAggregatesFilter<"audit_trail"> | $Enums.audit_trail_status | null
    reviewed_by?: IntNullableWithAggregatesFilter<"audit_trail"> | number | null
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: IntFilter<"categories"> | number
    name?: StringFilter<"categories"> | string
    sector_id?: IntNullableFilter<"categories"> | number | null
    sectors?: XOR<SectorsNullableScalarRelationFilter, sectorsWhereInput> | null
    category_search_terms?: Category_search_termsListRelationFilter
    institution?: InstitutionListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sector_id?: SortOrderInput | SortOrder
    sectors?: sectorsOrderByWithRelationInput
    category_search_terms?: category_search_termsOrderByRelationAggregateInput
    institution?: institutionOrderByRelationAggregateInput
    _relevance?: categoriesOrderByRelevanceInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    name?: StringFilter<"categories"> | string
    sector_id?: IntNullableFilter<"categories"> | number | null
    sectors?: XOR<SectorsNullableScalarRelationFilter, sectorsWhereInput> | null
    category_search_terms?: Category_search_termsListRelationFilter
    institution?: InstitutionListRelationFilter
  }, "id">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sector_id?: SortOrderInput | SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"categories"> | number
    name?: StringWithAggregatesFilter<"categories"> | string
    sector_id?: IntNullableWithAggregatesFilter<"categories"> | number | null
  }

  export type change_requestWhereInput = {
    AND?: change_requestWhereInput | change_requestWhereInput[]
    OR?: change_requestWhereInput[]
    NOT?: change_requestWhereInput | change_requestWhereInput[]
    id?: IntFilter<"change_request"> | number
    old_value?: StringNullableFilter<"change_request"> | string | null
    new_value?: StringNullableFilter<"change_request"> | string | null
    action?: StringFilter<"change_request"> | string
    model?: StringFilter<"change_request"> | string
    model_id?: IntNullableFilter<"change_request"> | number | null
    user_id?: IntFilter<"change_request"> | number
    ip?: StringNullableFilter<"change_request"> | string | null
    user_agent?: StringNullableFilter<"change_request"> | string | null
    display_name?: StringNullableFilter<"change_request"> | string | null
    status?: BoolNullableFilter<"change_request"> | boolean | null
    reviewed_by?: IntNullableFilter<"change_request"> | number | null
    time?: DateTimeFilter<"change_request"> | Date | string
    institution_id?: IntNullableFilter<"change_request"> | number | null
  }

  export type change_requestOrderByWithRelationInput = {
    id?: SortOrder
    old_value?: SortOrderInput | SortOrder
    new_value?: SortOrderInput | SortOrder
    action?: SortOrder
    model?: SortOrder
    model_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    ip?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    display_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    time?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    _relevance?: change_requestOrderByRelevanceInput
  }

  export type change_requestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: change_requestWhereInput | change_requestWhereInput[]
    OR?: change_requestWhereInput[]
    NOT?: change_requestWhereInput | change_requestWhereInput[]
    old_value?: StringNullableFilter<"change_request"> | string | null
    new_value?: StringNullableFilter<"change_request"> | string | null
    action?: StringFilter<"change_request"> | string
    model?: StringFilter<"change_request"> | string
    model_id?: IntNullableFilter<"change_request"> | number | null
    user_id?: IntFilter<"change_request"> | number
    ip?: StringNullableFilter<"change_request"> | string | null
    user_agent?: StringNullableFilter<"change_request"> | string | null
    display_name?: StringNullableFilter<"change_request"> | string | null
    status?: BoolNullableFilter<"change_request"> | boolean | null
    reviewed_by?: IntNullableFilter<"change_request"> | number | null
    time?: DateTimeFilter<"change_request"> | Date | string
    institution_id?: IntNullableFilter<"change_request"> | number | null
  }, "id">

  export type change_requestOrderByWithAggregationInput = {
    id?: SortOrder
    old_value?: SortOrderInput | SortOrder
    new_value?: SortOrderInput | SortOrder
    action?: SortOrder
    model?: SortOrder
    model_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    ip?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    display_name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    time?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    _count?: change_requestCountOrderByAggregateInput
    _avg?: change_requestAvgOrderByAggregateInput
    _max?: change_requestMaxOrderByAggregateInput
    _min?: change_requestMinOrderByAggregateInput
    _sum?: change_requestSumOrderByAggregateInput
  }

  export type change_requestScalarWhereWithAggregatesInput = {
    AND?: change_requestScalarWhereWithAggregatesInput | change_requestScalarWhereWithAggregatesInput[]
    OR?: change_requestScalarWhereWithAggregatesInput[]
    NOT?: change_requestScalarWhereWithAggregatesInput | change_requestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"change_request"> | number
    old_value?: StringNullableWithAggregatesFilter<"change_request"> | string | null
    new_value?: StringNullableWithAggregatesFilter<"change_request"> | string | null
    action?: StringWithAggregatesFilter<"change_request"> | string
    model?: StringWithAggregatesFilter<"change_request"> | string
    model_id?: IntNullableWithAggregatesFilter<"change_request"> | number | null
    user_id?: IntWithAggregatesFilter<"change_request"> | number
    ip?: StringNullableWithAggregatesFilter<"change_request"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"change_request"> | string | null
    display_name?: StringNullableWithAggregatesFilter<"change_request"> | string | null
    status?: BoolNullableWithAggregatesFilter<"change_request"> | boolean | null
    reviewed_by?: IntNullableWithAggregatesFilter<"change_request"> | number | null
    time?: DateTimeWithAggregatesFilter<"change_request"> | Date | string
    institution_id?: IntNullableWithAggregatesFilter<"change_request"> | number | null
  }

  export type deviceWhereInput = {
    AND?: deviceWhereInput | deviceWhereInput[]
    OR?: deviceWhereInput[]
    NOT?: deviceWhereInput | deviceWhereInput[]
    id?: IntFilter<"device"> | number
    uuid?: StringNullableFilter<"device"> | string | null
    notification_token?: StringNullableFilter<"device"> | string | null
    affiliate_id?: IntNullableFilter<"device"> | number | null
    service_id?: StringNullableFilter<"device"> | string | null
    serial_number?: StringNullableFilter<"device"> | string | null
    status?: IntFilter<"device"> | number
    created_at?: DateTimeFilter<"device"> | Date | string
    device_type?: IntFilter<"device"> | number
    gender?: IntNullableFilter<"device"> | number | null
    age_range?: IntNullableFilter<"device"> | number | null
    language?: IntNullableFilter<"device"> | number | null
    notification_enabled?: BoolNullableFilter<"device"> | boolean | null
    apiKey?: StringNullableFilter<"device"> | string | null
    nonce?: IntNullableFilter<"device"> | number | null
    linkShortCode?: StringNullableFilter<"device"> | string | null
    linkShortCodeExp?: DateTimeNullableFilter<"device"> | Date | string | null
    phone_number?: StringNullableFilter<"device"> | string | null
    latest_hb?: DateTimeNullableFilter<"device"> | Date | string | null
    latest_hb_version?: StringNullableFilter<"device"> | string | null
    updated_at?: DateTimeFilter<"device"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    qms_customer?: Qms_customerListRelationFilter
    rating?: RatingListRelationFilter
    tip?: TipListRelationFilter
  }

  export type deviceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    notification_token?: SortOrderInput | SortOrder
    affiliate_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    serial_number?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    device_type?: SortOrder
    gender?: SortOrderInput | SortOrder
    age_range?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    notification_enabled?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    linkShortCode?: SortOrderInput | SortOrder
    linkShortCodeExp?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    latest_hb?: SortOrderInput | SortOrder
    latest_hb_version?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    institution?: institutionOrderByWithRelationInput
    qms_customer?: qms_customerOrderByRelationAggregateInput
    rating?: ratingOrderByRelationAggregateInput
    tip?: tipOrderByRelationAggregateInput
    _relevance?: deviceOrderByRelevanceInput
  }

  export type deviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: deviceWhereInput | deviceWhereInput[]
    OR?: deviceWhereInput[]
    NOT?: deviceWhereInput | deviceWhereInput[]
    notification_token?: StringNullableFilter<"device"> | string | null
    affiliate_id?: IntNullableFilter<"device"> | number | null
    service_id?: StringNullableFilter<"device"> | string | null
    serial_number?: StringNullableFilter<"device"> | string | null
    status?: IntFilter<"device"> | number
    created_at?: DateTimeFilter<"device"> | Date | string
    device_type?: IntFilter<"device"> | number
    gender?: IntNullableFilter<"device"> | number | null
    age_range?: IntNullableFilter<"device"> | number | null
    language?: IntNullableFilter<"device"> | number | null
    notification_enabled?: BoolNullableFilter<"device"> | boolean | null
    apiKey?: StringNullableFilter<"device"> | string | null
    nonce?: IntNullableFilter<"device"> | number | null
    linkShortCode?: StringNullableFilter<"device"> | string | null
    linkShortCodeExp?: DateTimeNullableFilter<"device"> | Date | string | null
    phone_number?: StringNullableFilter<"device"> | string | null
    latest_hb?: DateTimeNullableFilter<"device"> | Date | string | null
    latest_hb_version?: StringNullableFilter<"device"> | string | null
    updated_at?: DateTimeFilter<"device"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    qms_customer?: Qms_customerListRelationFilter
    rating?: RatingListRelationFilter
    tip?: TipListRelationFilter
  }, "id" | "uuid">

  export type deviceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    notification_token?: SortOrderInput | SortOrder
    affiliate_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    serial_number?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    device_type?: SortOrder
    gender?: SortOrderInput | SortOrder
    age_range?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    notification_enabled?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    nonce?: SortOrderInput | SortOrder
    linkShortCode?: SortOrderInput | SortOrder
    linkShortCodeExp?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    latest_hb?: SortOrderInput | SortOrder
    latest_hb_version?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    _count?: deviceCountOrderByAggregateInput
    _avg?: deviceAvgOrderByAggregateInput
    _max?: deviceMaxOrderByAggregateInput
    _min?: deviceMinOrderByAggregateInput
    _sum?: deviceSumOrderByAggregateInput
  }

  export type deviceScalarWhereWithAggregatesInput = {
    AND?: deviceScalarWhereWithAggregatesInput | deviceScalarWhereWithAggregatesInput[]
    OR?: deviceScalarWhereWithAggregatesInput[]
    NOT?: deviceScalarWhereWithAggregatesInput | deviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"device"> | number
    uuid?: StringNullableWithAggregatesFilter<"device"> | string | null
    notification_token?: StringNullableWithAggregatesFilter<"device"> | string | null
    affiliate_id?: IntNullableWithAggregatesFilter<"device"> | number | null
    service_id?: StringNullableWithAggregatesFilter<"device"> | string | null
    serial_number?: StringNullableWithAggregatesFilter<"device"> | string | null
    status?: IntWithAggregatesFilter<"device"> | number
    created_at?: DateTimeWithAggregatesFilter<"device"> | Date | string
    device_type?: IntWithAggregatesFilter<"device"> | number
    gender?: IntNullableWithAggregatesFilter<"device"> | number | null
    age_range?: IntNullableWithAggregatesFilter<"device"> | number | null
    language?: IntNullableWithAggregatesFilter<"device"> | number | null
    notification_enabled?: BoolNullableWithAggregatesFilter<"device"> | boolean | null
    apiKey?: StringNullableWithAggregatesFilter<"device"> | string | null
    nonce?: IntNullableWithAggregatesFilter<"device"> | number | null
    linkShortCode?: StringNullableWithAggregatesFilter<"device"> | string | null
    linkShortCodeExp?: DateTimeNullableWithAggregatesFilter<"device"> | Date | string | null
    phone_number?: StringNullableWithAggregatesFilter<"device"> | string | null
    latest_hb?: DateTimeNullableWithAggregatesFilter<"device"> | Date | string | null
    latest_hb_version?: StringNullableWithAggregatesFilter<"device"> | string | null
    updated_at?: DateTimeWithAggregatesFilter<"device"> | Date | string
  }

  export type device_heartbeatWhereInput = {
    AND?: device_heartbeatWhereInput | device_heartbeatWhereInput[]
    OR?: device_heartbeatWhereInput[]
    NOT?: device_heartbeatWhereInput | device_heartbeatWhereInput[]
    id?: IntFilter<"device_heartbeat"> | number
    time?: DateTimeFilter<"device_heartbeat"> | Date | string
    device_id?: IntNullableFilter<"device_heartbeat"> | number | null
    operator_id?: IntNullableFilter<"device_heartbeat"> | number | null
    version?: StringNullableFilter<"device_heartbeat"> | string | null
  }

  export type device_heartbeatOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    device_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _relevance?: device_heartbeatOrderByRelevanceInput
  }

  export type device_heartbeatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: device_heartbeatWhereInput | device_heartbeatWhereInput[]
    OR?: device_heartbeatWhereInput[]
    NOT?: device_heartbeatWhereInput | device_heartbeatWhereInput[]
    time?: DateTimeFilter<"device_heartbeat"> | Date | string
    device_id?: IntNullableFilter<"device_heartbeat"> | number | null
    operator_id?: IntNullableFilter<"device_heartbeat"> | number | null
    version?: StringNullableFilter<"device_heartbeat"> | string | null
  }, "id">

  export type device_heartbeatOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    device_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: device_heartbeatCountOrderByAggregateInput
    _avg?: device_heartbeatAvgOrderByAggregateInput
    _max?: device_heartbeatMaxOrderByAggregateInput
    _min?: device_heartbeatMinOrderByAggregateInput
    _sum?: device_heartbeatSumOrderByAggregateInput
  }

  export type device_heartbeatScalarWhereWithAggregatesInput = {
    AND?: device_heartbeatScalarWhereWithAggregatesInput | device_heartbeatScalarWhereWithAggregatesInput[]
    OR?: device_heartbeatScalarWhereWithAggregatesInput[]
    NOT?: device_heartbeatScalarWhereWithAggregatesInput | device_heartbeatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"device_heartbeat"> | number
    time?: DateTimeWithAggregatesFilter<"device_heartbeat"> | Date | string
    device_id?: IntNullableWithAggregatesFilter<"device_heartbeat"> | number | null
    operator_id?: IntNullableWithAggregatesFilter<"device_heartbeat"> | number | null
    version?: StringNullableWithAggregatesFilter<"device_heartbeat"> | string | null
  }

  export type institutionWhereInput = {
    AND?: institutionWhereInput | institutionWhereInput[]
    OR?: institutionWhereInput[]
    NOT?: institutionWhereInput | institutionWhereInput[]
    id?: IntFilter<"institution"> | number
    uuid?: StringNullableFilter<"institution"> | string | null
    name?: StringFilter<"institution"> | string
    search_term?: StringNullableFilter<"institution"> | string | null
    email?: StringNullableFilter<"institution"> | string | null
    address?: StringNullableFilter<"institution"> | string | null
    phone_number?: StringNullableFilter<"institution"> | string | null
    url?: StringNullableFilter<"institution"> | string | null
    status?: IntNullableFilter<"institution"> | number | null
    created_at?: DateTimeFilter<"institution"> | Date | string
    plan?: IntNullableFilter<"institution"> | number | null
    type?: IntNullableFilter<"institution"> | number | null
    level?: IntNullableFilter<"institution"> | number | null
    parent_id?: IntNullableFilter<"institution"> | number | null
    good_ratings?: IntNullableFilter<"institution"> | number | null
    bad_ratings?: IntNullableFilter<"institution"> | number | null
    excellent_ratings?: IntNullableFilter<"institution"> | number | null
    nps?: IntNullableFilter<"institution"> | number | null
    csat?: IntNullableFilter<"institution"> | number | null
    queue_autocreation?: IntNullableFilter<"institution"> | number | null
    queue_manual_creation?: IntNullableFilter<"institution"> | number | null
    working_hours?: StringNullableFilter<"institution"> | string | null
    qms_message?: StringNullableFilter<"institution"> | string | null
    priority_list?: StringNullableFilter<"institution"> | string | null
    logo?: StringNullableFilter<"institution"> | string | null
    app_name?: StringNullableFilter<"institution"> | string | null
    allowed_context?: IntNullableFilter<"institution"> | number | null
    host_name?: StringNullableFilter<"institution"> | string | null
    membership_type?: IntFilter<"institution"> | number
    category_id?: IntNullableFilter<"institution"> | number | null
    latest_membership_renew_time?: DateTimeNullableFilter<"institution"> | Date | string | null
    description?: StringNullableFilter<"institution"> | string | null
    latitude?: StringNullableFilter<"institution"> | string | null
    longitude?: StringNullableFilter<"institution"> | string | null
    button_one?: StringNullableFilter<"institution"> | string | null
    button_two?: StringNullableFilter<"institution"> | string | null
    amenities?: StringNullableFilter<"institution"> | string | null
    appointments?: AppointmentsListRelationFilter
    apps?: AppsListRelationFilter
    business_amenities?: Business_amenitiesListRelationFilter
    device?: DeviceListRelationFilter
    images?: ImagesListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    popup_questions?: Popup_questionsListRelationFilter
    price_ranges?: Price_rangesListRelationFilter
    qms_branch_operator?: Qms_branch_operatorListRelationFilter
    qms_branch_transactions?: Qms_branch_transactionsListRelationFilter
    qms_operator?: Qms_operatorListRelationFilter
    reviews?: ReviewsListRelationFilter
    service?: ServiceListRelationFilter
    service_group?: Service_groupListRelationFilter
    workingHour?: WorkingHourListRelationFilter
  }

  export type institutionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    search_term?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    plan?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    good_ratings?: SortOrderInput | SortOrder
    bad_ratings?: SortOrderInput | SortOrder
    excellent_ratings?: SortOrderInput | SortOrder
    nps?: SortOrderInput | SortOrder
    csat?: SortOrderInput | SortOrder
    queue_autocreation?: SortOrderInput | SortOrder
    queue_manual_creation?: SortOrderInput | SortOrder
    working_hours?: SortOrderInput | SortOrder
    qms_message?: SortOrderInput | SortOrder
    priority_list?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    app_name?: SortOrderInput | SortOrder
    allowed_context?: SortOrderInput | SortOrder
    host_name?: SortOrderInput | SortOrder
    membership_type?: SortOrder
    category_id?: SortOrderInput | SortOrder
    latest_membership_renew_time?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    button_one?: SortOrderInput | SortOrder
    button_two?: SortOrderInput | SortOrder
    amenities?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    apps?: appsOrderByRelationAggregateInput
    business_amenities?: business_amenitiesOrderByRelationAggregateInput
    device?: deviceOrderByRelationAggregateInput
    images?: imagesOrderByRelationAggregateInput
    categories?: categoriesOrderByWithRelationInput
    popup_questions?: popup_questionsOrderByRelationAggregateInput
    price_ranges?: price_rangesOrderByRelationAggregateInput
    qms_branch_operator?: qms_branch_operatorOrderByRelationAggregateInput
    qms_branch_transactions?: qms_branch_transactionsOrderByRelationAggregateInput
    qms_operator?: qms_operatorOrderByRelationAggregateInput
    reviews?: reviewsOrderByRelationAggregateInput
    service?: serviceOrderByRelationAggregateInput
    service_group?: service_groupOrderByRelationAggregateInput
    workingHour?: workingHourOrderByRelationAggregateInput
    _relevance?: institutionOrderByRelevanceInput
  }

  export type institutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: institutionWhereInput | institutionWhereInput[]
    OR?: institutionWhereInput[]
    NOT?: institutionWhereInput | institutionWhereInput[]
    name?: StringFilter<"institution"> | string
    search_term?: StringNullableFilter<"institution"> | string | null
    email?: StringNullableFilter<"institution"> | string | null
    address?: StringNullableFilter<"institution"> | string | null
    phone_number?: StringNullableFilter<"institution"> | string | null
    url?: StringNullableFilter<"institution"> | string | null
    status?: IntNullableFilter<"institution"> | number | null
    created_at?: DateTimeFilter<"institution"> | Date | string
    plan?: IntNullableFilter<"institution"> | number | null
    type?: IntNullableFilter<"institution"> | number | null
    level?: IntNullableFilter<"institution"> | number | null
    parent_id?: IntNullableFilter<"institution"> | number | null
    good_ratings?: IntNullableFilter<"institution"> | number | null
    bad_ratings?: IntNullableFilter<"institution"> | number | null
    excellent_ratings?: IntNullableFilter<"institution"> | number | null
    nps?: IntNullableFilter<"institution"> | number | null
    csat?: IntNullableFilter<"institution"> | number | null
    queue_autocreation?: IntNullableFilter<"institution"> | number | null
    queue_manual_creation?: IntNullableFilter<"institution"> | number | null
    working_hours?: StringNullableFilter<"institution"> | string | null
    qms_message?: StringNullableFilter<"institution"> | string | null
    priority_list?: StringNullableFilter<"institution"> | string | null
    logo?: StringNullableFilter<"institution"> | string | null
    app_name?: StringNullableFilter<"institution"> | string | null
    allowed_context?: IntNullableFilter<"institution"> | number | null
    host_name?: StringNullableFilter<"institution"> | string | null
    membership_type?: IntFilter<"institution"> | number
    category_id?: IntNullableFilter<"institution"> | number | null
    latest_membership_renew_time?: DateTimeNullableFilter<"institution"> | Date | string | null
    description?: StringNullableFilter<"institution"> | string | null
    latitude?: StringNullableFilter<"institution"> | string | null
    longitude?: StringNullableFilter<"institution"> | string | null
    button_one?: StringNullableFilter<"institution"> | string | null
    button_two?: StringNullableFilter<"institution"> | string | null
    amenities?: StringNullableFilter<"institution"> | string | null
    appointments?: AppointmentsListRelationFilter
    apps?: AppsListRelationFilter
    business_amenities?: Business_amenitiesListRelationFilter
    device?: DeviceListRelationFilter
    images?: ImagesListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    popup_questions?: Popup_questionsListRelationFilter
    price_ranges?: Price_rangesListRelationFilter
    qms_branch_operator?: Qms_branch_operatorListRelationFilter
    qms_branch_transactions?: Qms_branch_transactionsListRelationFilter
    qms_operator?: Qms_operatorListRelationFilter
    reviews?: ReviewsListRelationFilter
    service?: ServiceListRelationFilter
    service_group?: Service_groupListRelationFilter
    workingHour?: WorkingHourListRelationFilter
  }, "id" | "uuid">

  export type institutionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    name?: SortOrder
    search_term?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    plan?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    good_ratings?: SortOrderInput | SortOrder
    bad_ratings?: SortOrderInput | SortOrder
    excellent_ratings?: SortOrderInput | SortOrder
    nps?: SortOrderInput | SortOrder
    csat?: SortOrderInput | SortOrder
    queue_autocreation?: SortOrderInput | SortOrder
    queue_manual_creation?: SortOrderInput | SortOrder
    working_hours?: SortOrderInput | SortOrder
    qms_message?: SortOrderInput | SortOrder
    priority_list?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    app_name?: SortOrderInput | SortOrder
    allowed_context?: SortOrderInput | SortOrder
    host_name?: SortOrderInput | SortOrder
    membership_type?: SortOrder
    category_id?: SortOrderInput | SortOrder
    latest_membership_renew_time?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    button_one?: SortOrderInput | SortOrder
    button_two?: SortOrderInput | SortOrder
    amenities?: SortOrderInput | SortOrder
    _count?: institutionCountOrderByAggregateInput
    _avg?: institutionAvgOrderByAggregateInput
    _max?: institutionMaxOrderByAggregateInput
    _min?: institutionMinOrderByAggregateInput
    _sum?: institutionSumOrderByAggregateInput
  }

  export type institutionScalarWhereWithAggregatesInput = {
    AND?: institutionScalarWhereWithAggregatesInput | institutionScalarWhereWithAggregatesInput[]
    OR?: institutionScalarWhereWithAggregatesInput[]
    NOT?: institutionScalarWhereWithAggregatesInput | institutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"institution"> | number
    uuid?: StringNullableWithAggregatesFilter<"institution"> | string | null
    name?: StringWithAggregatesFilter<"institution"> | string
    search_term?: StringNullableWithAggregatesFilter<"institution"> | string | null
    email?: StringNullableWithAggregatesFilter<"institution"> | string | null
    address?: StringNullableWithAggregatesFilter<"institution"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"institution"> | string | null
    url?: StringNullableWithAggregatesFilter<"institution"> | string | null
    status?: IntNullableWithAggregatesFilter<"institution"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"institution"> | Date | string
    plan?: IntNullableWithAggregatesFilter<"institution"> | number | null
    type?: IntNullableWithAggregatesFilter<"institution"> | number | null
    level?: IntNullableWithAggregatesFilter<"institution"> | number | null
    parent_id?: IntNullableWithAggregatesFilter<"institution"> | number | null
    good_ratings?: IntNullableWithAggregatesFilter<"institution"> | number | null
    bad_ratings?: IntNullableWithAggregatesFilter<"institution"> | number | null
    excellent_ratings?: IntNullableWithAggregatesFilter<"institution"> | number | null
    nps?: IntNullableWithAggregatesFilter<"institution"> | number | null
    csat?: IntNullableWithAggregatesFilter<"institution"> | number | null
    queue_autocreation?: IntNullableWithAggregatesFilter<"institution"> | number | null
    queue_manual_creation?: IntNullableWithAggregatesFilter<"institution"> | number | null
    working_hours?: StringNullableWithAggregatesFilter<"institution"> | string | null
    qms_message?: StringNullableWithAggregatesFilter<"institution"> | string | null
    priority_list?: StringNullableWithAggregatesFilter<"institution"> | string | null
    logo?: StringNullableWithAggregatesFilter<"institution"> | string | null
    app_name?: StringNullableWithAggregatesFilter<"institution"> | string | null
    allowed_context?: IntNullableWithAggregatesFilter<"institution"> | number | null
    host_name?: StringNullableWithAggregatesFilter<"institution"> | string | null
    membership_type?: IntWithAggregatesFilter<"institution"> | number
    category_id?: IntNullableWithAggregatesFilter<"institution"> | number | null
    latest_membership_renew_time?: DateTimeNullableWithAggregatesFilter<"institution"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"institution"> | string | null
    latitude?: StringNullableWithAggregatesFilter<"institution"> | string | null
    longitude?: StringNullableWithAggregatesFilter<"institution"> | string | null
    button_one?: StringNullableWithAggregatesFilter<"institution"> | string | null
    button_two?: StringNullableWithAggregatesFilter<"institution"> | string | null
    amenities?: StringNullableWithAggregatesFilter<"institution"> | string | null
  }

  export type institution_invoicesWhereInput = {
    AND?: institution_invoicesWhereInput | institution_invoicesWhereInput[]
    OR?: institution_invoicesWhereInput[]
    NOT?: institution_invoicesWhereInput | institution_invoicesWhereInput[]
    id?: IntFilter<"institution_invoices"> | number
    invoice_number?: StringFilter<"institution_invoices"> | string
    institution_id?: IntFilter<"institution_invoices"> | number
    institution_name?: StringFilter<"institution_invoices"> | string
    period_start?: DateTimeFilter<"institution_invoices"> | Date | string
    period_end?: DateTimeFilter<"institution_invoices"> | Date | string
    generated_at?: DateTimeFilter<"institution_invoices"> | Date | string
    expiry?: DateTimeFilter<"institution_invoices"> | Date | string
    payment_reference_number?: StringFilter<"institution_invoices"> | string
    ext_payment_reference_number?: StringNullableFilter<"institution_invoices"> | string | null
    payment_status?: Enuminstitution_invoices_payment_statusFilter<"institution_invoices"> | $Enums.institution_invoices_payment_status
    payment_status_desc?: StringNullableFilter<"institution_invoices"> | string | null
    payment_method?: StringNullableFilter<"institution_invoices"> | string | null
    payment_retries?: IntNullableFilter<"institution_invoices"> | number | null
    status?: Enuminstitution_invoices_statusFilter<"institution_invoices"> | $Enums.institution_invoices_status
    total_amount?: FloatNullableFilter<"institution_invoices"> | number | null
  }

  export type institution_invoicesOrderByWithRelationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    generated_at?: SortOrder
    expiry?: SortOrder
    payment_reference_number?: SortOrder
    ext_payment_reference_number?: SortOrderInput | SortOrder
    payment_status?: SortOrder
    payment_status_desc?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_retries?: SortOrderInput | SortOrder
    status?: SortOrder
    total_amount?: SortOrderInput | SortOrder
    _relevance?: institution_invoicesOrderByRelevanceInput
  }

  export type institution_invoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: institution_invoicesWhereInput | institution_invoicesWhereInput[]
    OR?: institution_invoicesWhereInput[]
    NOT?: institution_invoicesWhereInput | institution_invoicesWhereInput[]
    invoice_number?: StringFilter<"institution_invoices"> | string
    institution_id?: IntFilter<"institution_invoices"> | number
    institution_name?: StringFilter<"institution_invoices"> | string
    period_start?: DateTimeFilter<"institution_invoices"> | Date | string
    period_end?: DateTimeFilter<"institution_invoices"> | Date | string
    generated_at?: DateTimeFilter<"institution_invoices"> | Date | string
    expiry?: DateTimeFilter<"institution_invoices"> | Date | string
    payment_reference_number?: StringFilter<"institution_invoices"> | string
    ext_payment_reference_number?: StringNullableFilter<"institution_invoices"> | string | null
    payment_status?: Enuminstitution_invoices_payment_statusFilter<"institution_invoices"> | $Enums.institution_invoices_payment_status
    payment_status_desc?: StringNullableFilter<"institution_invoices"> | string | null
    payment_method?: StringNullableFilter<"institution_invoices"> | string | null
    payment_retries?: IntNullableFilter<"institution_invoices"> | number | null
    status?: Enuminstitution_invoices_statusFilter<"institution_invoices"> | $Enums.institution_invoices_status
    total_amount?: FloatNullableFilter<"institution_invoices"> | number | null
  }, "id">

  export type institution_invoicesOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    generated_at?: SortOrder
    expiry?: SortOrder
    payment_reference_number?: SortOrder
    ext_payment_reference_number?: SortOrderInput | SortOrder
    payment_status?: SortOrder
    payment_status_desc?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_retries?: SortOrderInput | SortOrder
    status?: SortOrder
    total_amount?: SortOrderInput | SortOrder
    _count?: institution_invoicesCountOrderByAggregateInput
    _avg?: institution_invoicesAvgOrderByAggregateInput
    _max?: institution_invoicesMaxOrderByAggregateInput
    _min?: institution_invoicesMinOrderByAggregateInput
    _sum?: institution_invoicesSumOrderByAggregateInput
  }

  export type institution_invoicesScalarWhereWithAggregatesInput = {
    AND?: institution_invoicesScalarWhereWithAggregatesInput | institution_invoicesScalarWhereWithAggregatesInput[]
    OR?: institution_invoicesScalarWhereWithAggregatesInput[]
    NOT?: institution_invoicesScalarWhereWithAggregatesInput | institution_invoicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"institution_invoices"> | number
    invoice_number?: StringWithAggregatesFilter<"institution_invoices"> | string
    institution_id?: IntWithAggregatesFilter<"institution_invoices"> | number
    institution_name?: StringWithAggregatesFilter<"institution_invoices"> | string
    period_start?: DateTimeWithAggregatesFilter<"institution_invoices"> | Date | string
    period_end?: DateTimeWithAggregatesFilter<"institution_invoices"> | Date | string
    generated_at?: DateTimeWithAggregatesFilter<"institution_invoices"> | Date | string
    expiry?: DateTimeWithAggregatesFilter<"institution_invoices"> | Date | string
    payment_reference_number?: StringWithAggregatesFilter<"institution_invoices"> | string
    ext_payment_reference_number?: StringNullableWithAggregatesFilter<"institution_invoices"> | string | null
    payment_status?: Enuminstitution_invoices_payment_statusWithAggregatesFilter<"institution_invoices"> | $Enums.institution_invoices_payment_status
    payment_status_desc?: StringNullableWithAggregatesFilter<"institution_invoices"> | string | null
    payment_method?: StringNullableWithAggregatesFilter<"institution_invoices"> | string | null
    payment_retries?: IntNullableWithAggregatesFilter<"institution_invoices"> | number | null
    status?: Enuminstitution_invoices_statusWithAggregatesFilter<"institution_invoices"> | $Enums.institution_invoices_status
    total_amount?: FloatNullableWithAggregatesFilter<"institution_invoices"> | number | null
  }

  export type institution_service_trackingWhereInput = {
    AND?: institution_service_trackingWhereInput | institution_service_trackingWhereInput[]
    OR?: institution_service_trackingWhereInput[]
    NOT?: institution_service_trackingWhereInput | institution_service_trackingWhereInput[]
    id?: IntFilter<"institution_service_tracking"> | number
    institution_id?: IntNullableFilter<"institution_service_tracking"> | number | null
    branch_id?: IntNullableFilter<"institution_service_tracking"> | number | null
    service_id?: IntNullableFilter<"institution_service_tracking"> | number | null
    branch_name?: StringNullableFilter<"institution_service_tracking"> | string | null
    service_group_name?: StringNullableFilter<"institution_service_tracking"> | string | null
    time?: DateTimeFilter<"institution_service_tracking"> | Date | string
    action?: BoolNullableFilter<"institution_service_tracking"> | boolean | null
    status?: BoolNullableFilter<"institution_service_tracking"> | boolean | null
    invoice_number?: StringNullableFilter<"institution_service_tracking"> | string | null
  }

  export type institution_service_trackingOrderByWithRelationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    branch_name?: SortOrderInput | SortOrder
    service_group_name?: SortOrderInput | SortOrder
    time?: SortOrder
    action?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    invoice_number?: SortOrderInput | SortOrder
    _relevance?: institution_service_trackingOrderByRelevanceInput
  }

  export type institution_service_trackingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: institution_service_trackingWhereInput | institution_service_trackingWhereInput[]
    OR?: institution_service_trackingWhereInput[]
    NOT?: institution_service_trackingWhereInput | institution_service_trackingWhereInput[]
    institution_id?: IntNullableFilter<"institution_service_tracking"> | number | null
    branch_id?: IntNullableFilter<"institution_service_tracking"> | number | null
    service_id?: IntNullableFilter<"institution_service_tracking"> | number | null
    branch_name?: StringNullableFilter<"institution_service_tracking"> | string | null
    service_group_name?: StringNullableFilter<"institution_service_tracking"> | string | null
    time?: DateTimeFilter<"institution_service_tracking"> | Date | string
    action?: BoolNullableFilter<"institution_service_tracking"> | boolean | null
    status?: BoolNullableFilter<"institution_service_tracking"> | boolean | null
    invoice_number?: StringNullableFilter<"institution_service_tracking"> | string | null
  }, "id">

  export type institution_service_trackingOrderByWithAggregationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    branch_name?: SortOrderInput | SortOrder
    service_group_name?: SortOrderInput | SortOrder
    time?: SortOrder
    action?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    invoice_number?: SortOrderInput | SortOrder
    _count?: institution_service_trackingCountOrderByAggregateInput
    _avg?: institution_service_trackingAvgOrderByAggregateInput
    _max?: institution_service_trackingMaxOrderByAggregateInput
    _min?: institution_service_trackingMinOrderByAggregateInput
    _sum?: institution_service_trackingSumOrderByAggregateInput
  }

  export type institution_service_trackingScalarWhereWithAggregatesInput = {
    AND?: institution_service_trackingScalarWhereWithAggregatesInput | institution_service_trackingScalarWhereWithAggregatesInput[]
    OR?: institution_service_trackingScalarWhereWithAggregatesInput[]
    NOT?: institution_service_trackingScalarWhereWithAggregatesInput | institution_service_trackingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"institution_service_tracking"> | number
    institution_id?: IntNullableWithAggregatesFilter<"institution_service_tracking"> | number | null
    branch_id?: IntNullableWithAggregatesFilter<"institution_service_tracking"> | number | null
    service_id?: IntNullableWithAggregatesFilter<"institution_service_tracking"> | number | null
    branch_name?: StringNullableWithAggregatesFilter<"institution_service_tracking"> | string | null
    service_group_name?: StringNullableWithAggregatesFilter<"institution_service_tracking"> | string | null
    time?: DateTimeWithAggregatesFilter<"institution_service_tracking"> | Date | string
    action?: BoolNullableWithAggregatesFilter<"institution_service_tracking"> | boolean | null
    status?: BoolNullableWithAggregatesFilter<"institution_service_tracking"> | boolean | null
    invoice_number?: StringNullableWithAggregatesFilter<"institution_service_tracking"> | string | null
  }

  export type login_historyWhereInput = {
    AND?: login_historyWhereInput | login_historyWhereInput[]
    OR?: login_historyWhereInput[]
    NOT?: login_historyWhereInput | login_historyWhereInput[]
    id?: IntFilter<"login_history"> | number
    user_id?: IntNullableFilter<"login_history"> | number | null
    ip?: StringNullableFilter<"login_history"> | string | null
    user_agent?: StringNullableFilter<"login_history"> | string | null
    time?: DateTimeFilter<"login_history"> | Date | string
  }

  export type login_historyOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    time?: SortOrder
    _relevance?: login_historyOrderByRelevanceInput
  }

  export type login_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: login_historyWhereInput | login_historyWhereInput[]
    OR?: login_historyWhereInput[]
    NOT?: login_historyWhereInput | login_historyWhereInput[]
    user_id?: IntNullableFilter<"login_history"> | number | null
    ip?: StringNullableFilter<"login_history"> | string | null
    user_agent?: StringNullableFilter<"login_history"> | string | null
    time?: DateTimeFilter<"login_history"> | Date | string
  }, "id">

  export type login_historyOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    time?: SortOrder
    _count?: login_historyCountOrderByAggregateInput
    _avg?: login_historyAvgOrderByAggregateInput
    _max?: login_historyMaxOrderByAggregateInput
    _min?: login_historyMinOrderByAggregateInput
    _sum?: login_historySumOrderByAggregateInput
  }

  export type login_historyScalarWhereWithAggregatesInput = {
    AND?: login_historyScalarWhereWithAggregatesInput | login_historyScalarWhereWithAggregatesInput[]
    OR?: login_historyScalarWhereWithAggregatesInput[]
    NOT?: login_historyScalarWhereWithAggregatesInput | login_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"login_history"> | number
    user_id?: IntNullableWithAggregatesFilter<"login_history"> | number | null
    ip?: StringNullableWithAggregatesFilter<"login_history"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"login_history"> | string | null
    time?: DateTimeWithAggregatesFilter<"login_history"> | Date | string
  }

  export type migrationWhereInput = {
    AND?: migrationWhereInput | migrationWhereInput[]
    OR?: migrationWhereInput[]
    NOT?: migrationWhereInput | migrationWhereInput[]
    version?: StringFilter<"migration"> | string
    apply_time?: IntNullableFilter<"migration"> | number | null
  }

  export type migrationOrderByWithRelationInput = {
    version?: SortOrder
    apply_time?: SortOrderInput | SortOrder
    _relevance?: migrationOrderByRelevanceInput
  }

  export type migrationWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: migrationWhereInput | migrationWhereInput[]
    OR?: migrationWhereInput[]
    NOT?: migrationWhereInput | migrationWhereInput[]
    apply_time?: IntNullableFilter<"migration"> | number | null
  }, "version">

  export type migrationOrderByWithAggregationInput = {
    version?: SortOrder
    apply_time?: SortOrderInput | SortOrder
    _count?: migrationCountOrderByAggregateInput
    _avg?: migrationAvgOrderByAggregateInput
    _max?: migrationMaxOrderByAggregateInput
    _min?: migrationMinOrderByAggregateInput
    _sum?: migrationSumOrderByAggregateInput
  }

  export type migrationScalarWhereWithAggregatesInput = {
    AND?: migrationScalarWhereWithAggregatesInput | migrationScalarWhereWithAggregatesInput[]
    OR?: migrationScalarWhereWithAggregatesInput[]
    NOT?: migrationScalarWhereWithAggregatesInput | migrationScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"migration"> | string
    apply_time?: IntNullableWithAggregatesFilter<"migration"> | number | null
  }

  export type mms_fileWhereInput = {
    AND?: mms_fileWhereInput | mms_fileWhereInput[]
    OR?: mms_fileWhereInput[]
    NOT?: mms_fileWhereInput | mms_fileWhereInput[]
    id?: IntFilter<"mms_file"> | number
    device_uuid?: StringFilter<"mms_file"> | string
    institution_id?: IntFilter<"mms_file"> | number
    path?: StringFilter<"mms_file"> | string
    comment?: StringNullableFilter<"mms_file"> | string | null
    type?: IntFilter<"mms_file"> | number
    longitude?: FloatNullableFilter<"mms_file"> | number | null
    latitude?: FloatNullableFilter<"mms_file"> | number | null
    height?: IntNullableFilter<"mms_file"> | number | null
    width?: IntNullableFilter<"mms_file"> | number | null
    first_view_time?: DateTimeNullableFilter<"mms_file"> | Date | string | null
    last_view_time?: DateTimeNullableFilter<"mms_file"> | Date | string | null
    created_at?: DateTimeNullableFilter<"mms_file"> | Date | string | null
  }

  export type mms_fileOrderByWithRelationInput = {
    id?: SortOrder
    device_uuid?: SortOrder
    institution_id?: SortOrder
    path?: SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrder
    longitude?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    first_view_time?: SortOrderInput | SortOrder
    last_view_time?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: mms_fileOrderByRelevanceInput
  }

  export type mms_fileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: mms_fileWhereInput | mms_fileWhereInput[]
    OR?: mms_fileWhereInput[]
    NOT?: mms_fileWhereInput | mms_fileWhereInput[]
    device_uuid?: StringFilter<"mms_file"> | string
    institution_id?: IntFilter<"mms_file"> | number
    path?: StringFilter<"mms_file"> | string
    comment?: StringNullableFilter<"mms_file"> | string | null
    type?: IntFilter<"mms_file"> | number
    longitude?: FloatNullableFilter<"mms_file"> | number | null
    latitude?: FloatNullableFilter<"mms_file"> | number | null
    height?: IntNullableFilter<"mms_file"> | number | null
    width?: IntNullableFilter<"mms_file"> | number | null
    first_view_time?: DateTimeNullableFilter<"mms_file"> | Date | string | null
    last_view_time?: DateTimeNullableFilter<"mms_file"> | Date | string | null
    created_at?: DateTimeNullableFilter<"mms_file"> | Date | string | null
  }, "id">

  export type mms_fileOrderByWithAggregationInput = {
    id?: SortOrder
    device_uuid?: SortOrder
    institution_id?: SortOrder
    path?: SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrder
    longitude?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    first_view_time?: SortOrderInput | SortOrder
    last_view_time?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: mms_fileCountOrderByAggregateInput
    _avg?: mms_fileAvgOrderByAggregateInput
    _max?: mms_fileMaxOrderByAggregateInput
    _min?: mms_fileMinOrderByAggregateInput
    _sum?: mms_fileSumOrderByAggregateInput
  }

  export type mms_fileScalarWhereWithAggregatesInput = {
    AND?: mms_fileScalarWhereWithAggregatesInput | mms_fileScalarWhereWithAggregatesInput[]
    OR?: mms_fileScalarWhereWithAggregatesInput[]
    NOT?: mms_fileScalarWhereWithAggregatesInput | mms_fileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mms_file"> | number
    device_uuid?: StringWithAggregatesFilter<"mms_file"> | string
    institution_id?: IntWithAggregatesFilter<"mms_file"> | number
    path?: StringWithAggregatesFilter<"mms_file"> | string
    comment?: StringNullableWithAggregatesFilter<"mms_file"> | string | null
    type?: IntWithAggregatesFilter<"mms_file"> | number
    longitude?: FloatNullableWithAggregatesFilter<"mms_file"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"mms_file"> | number | null
    height?: IntNullableWithAggregatesFilter<"mms_file"> | number | null
    width?: IntNullableWithAggregatesFilter<"mms_file"> | number | null
    first_view_time?: DateTimeNullableWithAggregatesFilter<"mms_file"> | Date | string | null
    last_view_time?: DateTimeNullableWithAggregatesFilter<"mms_file"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"mms_file"> | Date | string | null
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: IntFilter<"notification"> | number
    title?: StringNullableFilter<"notification"> | string | null
    content?: StringFilter<"notification"> | string
    link?: StringNullableFilter<"notification"> | string | null
    seen?: BoolNullableFilter<"notification"> | boolean | null
    time_sent?: DateTimeNullableFilter<"notification"> | Date | string | null
    time_seen?: DateTimeNullableFilter<"notification"> | Date | string | null
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    link?: SortOrderInput | SortOrder
    seen?: SortOrderInput | SortOrder
    time_sent?: SortOrderInput | SortOrder
    time_seen?: SortOrderInput | SortOrder
    _relevance?: notificationOrderByRelevanceInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    title?: StringNullableFilter<"notification"> | string | null
    content?: StringFilter<"notification"> | string
    link?: StringNullableFilter<"notification"> | string | null
    seen?: BoolNullableFilter<"notification"> | boolean | null
    time_sent?: DateTimeNullableFilter<"notification"> | Date | string | null
    time_seen?: DateTimeNullableFilter<"notification"> | Date | string | null
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    link?: SortOrderInput | SortOrder
    seen?: SortOrderInput | SortOrder
    time_sent?: SortOrderInput | SortOrder
    time_seen?: SortOrderInput | SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notification"> | number
    title?: StringNullableWithAggregatesFilter<"notification"> | string | null
    content?: StringWithAggregatesFilter<"notification"> | string
    link?: StringNullableWithAggregatesFilter<"notification"> | string | null
    seen?: BoolNullableWithAggregatesFilter<"notification"> | boolean | null
    time_sent?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
    time_seen?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
  }

  export type notification_recipientWhereInput = {
    AND?: notification_recipientWhereInput | notification_recipientWhereInput[]
    OR?: notification_recipientWhereInput[]
    NOT?: notification_recipientWhereInput | notification_recipientWhereInput[]
    id?: IntFilter<"notification_recipient"> | number
    id_notification?: IntFilter<"notification_recipient"> | number
    id_user?: IntNullableFilter<"notification_recipient"> | number | null
    seen?: IntNullableFilter<"notification_recipient"> | number | null
    ticket?: IntNullableFilter<"notification_recipient"> | number | null
    reference_id?: IntNullableFilter<"notification_recipient"> | number | null
  }

  export type notification_recipientOrderByWithRelationInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrderInput | SortOrder
    seen?: SortOrderInput | SortOrder
    ticket?: SortOrderInput | SortOrder
    reference_id?: SortOrderInput | SortOrder
  }

  export type notification_recipientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notification_recipientWhereInput | notification_recipientWhereInput[]
    OR?: notification_recipientWhereInput[]
    NOT?: notification_recipientWhereInput | notification_recipientWhereInput[]
    id_notification?: IntFilter<"notification_recipient"> | number
    id_user?: IntNullableFilter<"notification_recipient"> | number | null
    seen?: IntNullableFilter<"notification_recipient"> | number | null
    ticket?: IntNullableFilter<"notification_recipient"> | number | null
    reference_id?: IntNullableFilter<"notification_recipient"> | number | null
  }, "id">

  export type notification_recipientOrderByWithAggregationInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrderInput | SortOrder
    seen?: SortOrderInput | SortOrder
    ticket?: SortOrderInput | SortOrder
    reference_id?: SortOrderInput | SortOrder
    _count?: notification_recipientCountOrderByAggregateInput
    _avg?: notification_recipientAvgOrderByAggregateInput
    _max?: notification_recipientMaxOrderByAggregateInput
    _min?: notification_recipientMinOrderByAggregateInput
    _sum?: notification_recipientSumOrderByAggregateInput
  }

  export type notification_recipientScalarWhereWithAggregatesInput = {
    AND?: notification_recipientScalarWhereWithAggregatesInput | notification_recipientScalarWhereWithAggregatesInput[]
    OR?: notification_recipientScalarWhereWithAggregatesInput[]
    NOT?: notification_recipientScalarWhereWithAggregatesInput | notification_recipientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notification_recipient"> | number
    id_notification?: IntWithAggregatesFilter<"notification_recipient"> | number
    id_user?: IntNullableWithAggregatesFilter<"notification_recipient"> | number | null
    seen?: IntNullableWithAggregatesFilter<"notification_recipient"> | number | null
    ticket?: IntNullableWithAggregatesFilter<"notification_recipient"> | number | null
    reference_id?: IntNullableWithAggregatesFilter<"notification_recipient"> | number | null
  }

  export type optionWhereInput = {
    AND?: optionWhereInput | optionWhereInput[]
    OR?: optionWhereInput[]
    NOT?: optionWhereInput | optionWhereInput[]
    id?: IntFilter<"option"> | number
    name?: StringNullableFilter<"option"> | string | null
    description?: StringNullableFilter<"option"> | string | null
    type?: IntNullableFilter<"option"> | number | null
    parent_id?: IntNullableFilter<"option"> | number | null
    created_at?: DateTimeFilter<"option"> | Date | string
    qms_ticket?: Qms_ticketListRelationFilter
  }

  export type optionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    qms_ticket?: qms_ticketOrderByRelationAggregateInput
    _relevance?: optionOrderByRelevanceInput
  }

  export type optionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: optionWhereInput | optionWhereInput[]
    OR?: optionWhereInput[]
    NOT?: optionWhereInput | optionWhereInput[]
    description?: StringNullableFilter<"option"> | string | null
    type?: IntNullableFilter<"option"> | number | null
    parent_id?: IntNullableFilter<"option"> | number | null
    created_at?: DateTimeFilter<"option"> | Date | string
    qms_ticket?: Qms_ticketListRelationFilter
  }, "id" | "name">

  export type optionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: optionCountOrderByAggregateInput
    _avg?: optionAvgOrderByAggregateInput
    _max?: optionMaxOrderByAggregateInput
    _min?: optionMinOrderByAggregateInput
    _sum?: optionSumOrderByAggregateInput
  }

  export type optionScalarWhereWithAggregatesInput = {
    AND?: optionScalarWhereWithAggregatesInput | optionScalarWhereWithAggregatesInput[]
    OR?: optionScalarWhereWithAggregatesInput[]
    NOT?: optionScalarWhereWithAggregatesInput | optionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"option"> | number
    name?: StringNullableWithAggregatesFilter<"option"> | string | null
    description?: StringNullableWithAggregatesFilter<"option"> | string | null
    type?: IntNullableWithAggregatesFilter<"option"> | number | null
    parent_id?: IntNullableWithAggregatesFilter<"option"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"option"> | Date | string
  }

  export type popup_questionsWhereInput = {
    AND?: popup_questionsWhereInput | popup_questionsWhereInput[]
    OR?: popup_questionsWhereInput[]
    NOT?: popup_questionsWhereInput | popup_questionsWhereInput[]
    id?: IntFilter<"popup_questions"> | number
    name_en?: StringFilter<"popup_questions"> | string
    name_fr?: StringNullableFilter<"popup_questions"> | string | null
    name_rw?: StringNullableFilter<"popup_questions"> | string | null
    name_sw?: StringNullableFilter<"popup_questions"> | string | null
    service_id?: StringFilter<"popup_questions"> | string
    description_en?: StringFilter<"popup_questions"> | string
    description_fr?: StringNullableFilter<"popup_questions"> | string | null
    description_rw?: StringNullableFilter<"popup_questions"> | string | null
    description_sw?: StringNullableFilter<"popup_questions"> | string | null
    applies_to_bad?: BoolFilter<"popup_questions"> | boolean
    applies_to_good?: BoolFilter<"popup_questions"> | boolean
    applies_to_excellent?: BoolFilter<"popup_questions"> | boolean
    institution_id?: IntFilter<"popup_questions"> | number
    status?: BoolNullableFilter<"popup_questions"> | boolean | null
    type?: IntNullableFilter<"popup_questions"> | number | null
    created_at?: DateTimeFilter<"popup_questions"> | Date | string
    updated_at?: DateTimeFilter<"popup_questions"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    popup_questions_possible_answers?: Popup_questions_possible_answersListRelationFilter
  }

  export type popup_questionsOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_fr?: SortOrderInput | SortOrder
    name_rw?: SortOrderInput | SortOrder
    name_sw?: SortOrderInput | SortOrder
    service_id?: SortOrder
    description_en?: SortOrder
    description_fr?: SortOrderInput | SortOrder
    description_rw?: SortOrderInput | SortOrder
    description_sw?: SortOrderInput | SortOrder
    applies_to_bad?: SortOrder
    applies_to_good?: SortOrder
    applies_to_excellent?: SortOrder
    institution_id?: SortOrder
    status?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    institution?: institutionOrderByWithRelationInput
    popup_questions_possible_answers?: popup_questions_possible_answersOrderByRelationAggregateInput
    _relevance?: popup_questionsOrderByRelevanceInput
  }

  export type popup_questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: popup_questionsWhereInput | popup_questionsWhereInput[]
    OR?: popup_questionsWhereInput[]
    NOT?: popup_questionsWhereInput | popup_questionsWhereInput[]
    name_en?: StringFilter<"popup_questions"> | string
    name_fr?: StringNullableFilter<"popup_questions"> | string | null
    name_rw?: StringNullableFilter<"popup_questions"> | string | null
    name_sw?: StringNullableFilter<"popup_questions"> | string | null
    service_id?: StringFilter<"popup_questions"> | string
    description_en?: StringFilter<"popup_questions"> | string
    description_fr?: StringNullableFilter<"popup_questions"> | string | null
    description_rw?: StringNullableFilter<"popup_questions"> | string | null
    description_sw?: StringNullableFilter<"popup_questions"> | string | null
    applies_to_bad?: BoolFilter<"popup_questions"> | boolean
    applies_to_good?: BoolFilter<"popup_questions"> | boolean
    applies_to_excellent?: BoolFilter<"popup_questions"> | boolean
    institution_id?: IntFilter<"popup_questions"> | number
    status?: BoolNullableFilter<"popup_questions"> | boolean | null
    type?: IntNullableFilter<"popup_questions"> | number | null
    created_at?: DateTimeFilter<"popup_questions"> | Date | string
    updated_at?: DateTimeFilter<"popup_questions"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    popup_questions_possible_answers?: Popup_questions_possible_answersListRelationFilter
  }, "id">

  export type popup_questionsOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_fr?: SortOrderInput | SortOrder
    name_rw?: SortOrderInput | SortOrder
    name_sw?: SortOrderInput | SortOrder
    service_id?: SortOrder
    description_en?: SortOrder
    description_fr?: SortOrderInput | SortOrder
    description_rw?: SortOrderInput | SortOrder
    description_sw?: SortOrderInput | SortOrder
    applies_to_bad?: SortOrder
    applies_to_good?: SortOrder
    applies_to_excellent?: SortOrder
    institution_id?: SortOrder
    status?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: popup_questionsCountOrderByAggregateInput
    _avg?: popup_questionsAvgOrderByAggregateInput
    _max?: popup_questionsMaxOrderByAggregateInput
    _min?: popup_questionsMinOrderByAggregateInput
    _sum?: popup_questionsSumOrderByAggregateInput
  }

  export type popup_questionsScalarWhereWithAggregatesInput = {
    AND?: popup_questionsScalarWhereWithAggregatesInput | popup_questionsScalarWhereWithAggregatesInput[]
    OR?: popup_questionsScalarWhereWithAggregatesInput[]
    NOT?: popup_questionsScalarWhereWithAggregatesInput | popup_questionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"popup_questions"> | number
    name_en?: StringWithAggregatesFilter<"popup_questions"> | string
    name_fr?: StringNullableWithAggregatesFilter<"popup_questions"> | string | null
    name_rw?: StringNullableWithAggregatesFilter<"popup_questions"> | string | null
    name_sw?: StringNullableWithAggregatesFilter<"popup_questions"> | string | null
    service_id?: StringWithAggregatesFilter<"popup_questions"> | string
    description_en?: StringWithAggregatesFilter<"popup_questions"> | string
    description_fr?: StringNullableWithAggregatesFilter<"popup_questions"> | string | null
    description_rw?: StringNullableWithAggregatesFilter<"popup_questions"> | string | null
    description_sw?: StringNullableWithAggregatesFilter<"popup_questions"> | string | null
    applies_to_bad?: BoolWithAggregatesFilter<"popup_questions"> | boolean
    applies_to_good?: BoolWithAggregatesFilter<"popup_questions"> | boolean
    applies_to_excellent?: BoolWithAggregatesFilter<"popup_questions"> | boolean
    institution_id?: IntWithAggregatesFilter<"popup_questions"> | number
    status?: BoolNullableWithAggregatesFilter<"popup_questions"> | boolean | null
    type?: IntNullableWithAggregatesFilter<"popup_questions"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"popup_questions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"popup_questions"> | Date | string
  }

  export type popup_questions_answersWhereInput = {
    AND?: popup_questions_answersWhereInput | popup_questions_answersWhereInput[]
    OR?: popup_questions_answersWhereInput[]
    NOT?: popup_questions_answersWhereInput | popup_questions_answersWhereInput[]
    id?: IntFilter<"popup_questions_answers"> | number
    device_id?: IntFilter<"popup_questions_answers"> | number
    rating_id?: IntNullableFilter<"popup_questions_answers"> | number | null
    ticket_id?: IntNullableFilter<"popup_questions_answers"> | number | null
    answer_id?: IntFilter<"popup_questions_answers"> | number
    answered_at?: DateTimeFilter<"popup_questions_answers"> | Date | string
    popup_questions_possible_answers?: XOR<Popup_questions_possible_answersScalarRelationFilter, popup_questions_possible_answersWhereInput>
  }

  export type popup_questions_answersOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrderInput | SortOrder
    ticket_id?: SortOrderInput | SortOrder
    answer_id?: SortOrder
    answered_at?: SortOrder
    popup_questions_possible_answers?: popup_questions_possible_answersOrderByWithRelationInput
  }

  export type popup_questions_answersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: popup_questions_answersWhereInput | popup_questions_answersWhereInput[]
    OR?: popup_questions_answersWhereInput[]
    NOT?: popup_questions_answersWhereInput | popup_questions_answersWhereInput[]
    device_id?: IntFilter<"popup_questions_answers"> | number
    rating_id?: IntNullableFilter<"popup_questions_answers"> | number | null
    ticket_id?: IntNullableFilter<"popup_questions_answers"> | number | null
    answer_id?: IntFilter<"popup_questions_answers"> | number
    answered_at?: DateTimeFilter<"popup_questions_answers"> | Date | string
    popup_questions_possible_answers?: XOR<Popup_questions_possible_answersScalarRelationFilter, popup_questions_possible_answersWhereInput>
  }, "id">

  export type popup_questions_answersOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrderInput | SortOrder
    ticket_id?: SortOrderInput | SortOrder
    answer_id?: SortOrder
    answered_at?: SortOrder
    _count?: popup_questions_answersCountOrderByAggregateInput
    _avg?: popup_questions_answersAvgOrderByAggregateInput
    _max?: popup_questions_answersMaxOrderByAggregateInput
    _min?: popup_questions_answersMinOrderByAggregateInput
    _sum?: popup_questions_answersSumOrderByAggregateInput
  }

  export type popup_questions_answersScalarWhereWithAggregatesInput = {
    AND?: popup_questions_answersScalarWhereWithAggregatesInput | popup_questions_answersScalarWhereWithAggregatesInput[]
    OR?: popup_questions_answersScalarWhereWithAggregatesInput[]
    NOT?: popup_questions_answersScalarWhereWithAggregatesInput | popup_questions_answersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"popup_questions_answers"> | number
    device_id?: IntWithAggregatesFilter<"popup_questions_answers"> | number
    rating_id?: IntNullableWithAggregatesFilter<"popup_questions_answers"> | number | null
    ticket_id?: IntNullableWithAggregatesFilter<"popup_questions_answers"> | number | null
    answer_id?: IntWithAggregatesFilter<"popup_questions_answers"> | number
    answered_at?: DateTimeWithAggregatesFilter<"popup_questions_answers"> | Date | string
  }

  export type popup_questions_possible_answersWhereInput = {
    AND?: popup_questions_possible_answersWhereInput | popup_questions_possible_answersWhereInput[]
    OR?: popup_questions_possible_answersWhereInput[]
    NOT?: popup_questions_possible_answersWhereInput | popup_questions_possible_answersWhereInput[]
    id?: IntFilter<"popup_questions_possible_answers"> | number
    popup_question_id?: IntFilter<"popup_questions_possible_answers"> | number
    answer_en?: StringFilter<"popup_questions_possible_answers"> | string
    answer_fr?: StringFilter<"popup_questions_possible_answers"> | string
    answer_rw?: StringFilter<"popup_questions_possible_answers"> | string
    answer_sw?: StringFilter<"popup_questions_possible_answers"> | string
    created_at?: DateTimeFilter<"popup_questions_possible_answers"> | Date | string
    updated_at?: DateTimeFilter<"popup_questions_possible_answers"> | Date | string
    priority?: IntNullableFilter<"popup_questions_possible_answers"> | number | null
    popup_questions_answers?: Popup_questions_answersListRelationFilter
    popup_questions?: XOR<Popup_questionsScalarRelationFilter, popup_questionsWhereInput>
  }

  export type popup_questions_possible_answersOrderByWithRelationInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    answer_en?: SortOrder
    answer_fr?: SortOrder
    answer_rw?: SortOrder
    answer_sw?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    priority?: SortOrderInput | SortOrder
    popup_questions_answers?: popup_questions_answersOrderByRelationAggregateInput
    popup_questions?: popup_questionsOrderByWithRelationInput
    _relevance?: popup_questions_possible_answersOrderByRelevanceInput
  }

  export type popup_questions_possible_answersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: popup_questions_possible_answersWhereInput | popup_questions_possible_answersWhereInput[]
    OR?: popup_questions_possible_answersWhereInput[]
    NOT?: popup_questions_possible_answersWhereInput | popup_questions_possible_answersWhereInput[]
    popup_question_id?: IntFilter<"popup_questions_possible_answers"> | number
    answer_en?: StringFilter<"popup_questions_possible_answers"> | string
    answer_fr?: StringFilter<"popup_questions_possible_answers"> | string
    answer_rw?: StringFilter<"popup_questions_possible_answers"> | string
    answer_sw?: StringFilter<"popup_questions_possible_answers"> | string
    created_at?: DateTimeFilter<"popup_questions_possible_answers"> | Date | string
    updated_at?: DateTimeFilter<"popup_questions_possible_answers"> | Date | string
    priority?: IntNullableFilter<"popup_questions_possible_answers"> | number | null
    popup_questions_answers?: Popup_questions_answersListRelationFilter
    popup_questions?: XOR<Popup_questionsScalarRelationFilter, popup_questionsWhereInput>
  }, "id">

  export type popup_questions_possible_answersOrderByWithAggregationInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    answer_en?: SortOrder
    answer_fr?: SortOrder
    answer_rw?: SortOrder
    answer_sw?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    priority?: SortOrderInput | SortOrder
    _count?: popup_questions_possible_answersCountOrderByAggregateInput
    _avg?: popup_questions_possible_answersAvgOrderByAggregateInput
    _max?: popup_questions_possible_answersMaxOrderByAggregateInput
    _min?: popup_questions_possible_answersMinOrderByAggregateInput
    _sum?: popup_questions_possible_answersSumOrderByAggregateInput
  }

  export type popup_questions_possible_answersScalarWhereWithAggregatesInput = {
    AND?: popup_questions_possible_answersScalarWhereWithAggregatesInput | popup_questions_possible_answersScalarWhereWithAggregatesInput[]
    OR?: popup_questions_possible_answersScalarWhereWithAggregatesInput[]
    NOT?: popup_questions_possible_answersScalarWhereWithAggregatesInput | popup_questions_possible_answersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"popup_questions_possible_answers"> | number
    popup_question_id?: IntWithAggregatesFilter<"popup_questions_possible_answers"> | number
    answer_en?: StringWithAggregatesFilter<"popup_questions_possible_answers"> | string
    answer_fr?: StringWithAggregatesFilter<"popup_questions_possible_answers"> | string
    answer_rw?: StringWithAggregatesFilter<"popup_questions_possible_answers"> | string
    answer_sw?: StringWithAggregatesFilter<"popup_questions_possible_answers"> | string
    created_at?: DateTimeWithAggregatesFilter<"popup_questions_possible_answers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"popup_questions_possible_answers"> | Date | string
    priority?: IntNullableWithAggregatesFilter<"popup_questions_possible_answers"> | number | null
  }

  export type qms_branch_operatorWhereInput = {
    AND?: qms_branch_operatorWhereInput | qms_branch_operatorWhereInput[]
    OR?: qms_branch_operatorWhereInput[]
    NOT?: qms_branch_operatorWhereInput | qms_branch_operatorWhereInput[]
    id?: IntFilter<"qms_branch_operator"> | number
    operator_id?: IntFilter<"qms_branch_operator"> | number
    institution_id?: IntFilter<"qms_branch_operator"> | number
    service_id?: StringFilter<"qms_branch_operator"> | string
    linked_at?: DateTimeFilter<"qms_branch_operator"> | Date | string
    status?: IntFilter<"qms_branch_operator"> | number
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    qms_operator?: XOR<Qms_operatorScalarRelationFilter, qms_operatorWhereInput>
  }

  export type qms_branch_operatorOrderByWithRelationInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    linked_at?: SortOrder
    status?: SortOrder
    institution?: institutionOrderByWithRelationInput
    qms_operator?: qms_operatorOrderByWithRelationInput
    _relevance?: qms_branch_operatorOrderByRelevanceInput
  }

  export type qms_branch_operatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_branch_operatorWhereInput | qms_branch_operatorWhereInput[]
    OR?: qms_branch_operatorWhereInput[]
    NOT?: qms_branch_operatorWhereInput | qms_branch_operatorWhereInput[]
    operator_id?: IntFilter<"qms_branch_operator"> | number
    institution_id?: IntFilter<"qms_branch_operator"> | number
    service_id?: StringFilter<"qms_branch_operator"> | string
    linked_at?: DateTimeFilter<"qms_branch_operator"> | Date | string
    status?: IntFilter<"qms_branch_operator"> | number
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    qms_operator?: XOR<Qms_operatorScalarRelationFilter, qms_operatorWhereInput>
  }, "id">

  export type qms_branch_operatorOrderByWithAggregationInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    linked_at?: SortOrder
    status?: SortOrder
    _count?: qms_branch_operatorCountOrderByAggregateInput
    _avg?: qms_branch_operatorAvgOrderByAggregateInput
    _max?: qms_branch_operatorMaxOrderByAggregateInput
    _min?: qms_branch_operatorMinOrderByAggregateInput
    _sum?: qms_branch_operatorSumOrderByAggregateInput
  }

  export type qms_branch_operatorScalarWhereWithAggregatesInput = {
    AND?: qms_branch_operatorScalarWhereWithAggregatesInput | qms_branch_operatorScalarWhereWithAggregatesInput[]
    OR?: qms_branch_operatorScalarWhereWithAggregatesInput[]
    NOT?: qms_branch_operatorScalarWhereWithAggregatesInput | qms_branch_operatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_branch_operator"> | number
    operator_id?: IntWithAggregatesFilter<"qms_branch_operator"> | number
    institution_id?: IntWithAggregatesFilter<"qms_branch_operator"> | number
    service_id?: StringWithAggregatesFilter<"qms_branch_operator"> | string
    linked_at?: DateTimeWithAggregatesFilter<"qms_branch_operator"> | Date | string
    status?: IntWithAggregatesFilter<"qms_branch_operator"> | number
  }

  export type qms_branch_transactionsWhereInput = {
    AND?: qms_branch_transactionsWhereInput | qms_branch_transactionsWhereInput[]
    OR?: qms_branch_transactionsWhereInput[]
    NOT?: qms_branch_transactionsWhereInput | qms_branch_transactionsWhereInput[]
    id?: IntFilter<"qms_branch_transactions"> | number
    affiliate_id?: IntFilter<"qms_branch_transactions"> | number
    date?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    note?: StringNullableFilter<"qms_branch_transactions"> | string | null
    created_at?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    last_updated?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    qms_operator_transactions?: Qms_operator_transactionsListRelationFilter
  }

  export type qms_branch_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    date?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
    institution?: institutionOrderByWithRelationInput
    qms_operator_transactions?: qms_operator_transactionsOrderByRelationAggregateInput
    _relevance?: qms_branch_transactionsOrderByRelevanceInput
  }

  export type qms_branch_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    affiliate_id_date?: qms_branch_transactionsAffiliate_idDateCompoundUniqueInput
    AND?: qms_branch_transactionsWhereInput | qms_branch_transactionsWhereInput[]
    OR?: qms_branch_transactionsWhereInput[]
    NOT?: qms_branch_transactionsWhereInput | qms_branch_transactionsWhereInput[]
    affiliate_id?: IntFilter<"qms_branch_transactions"> | number
    date?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    note?: StringNullableFilter<"qms_branch_transactions"> | string | null
    created_at?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    last_updated?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    qms_operator_transactions?: Qms_operator_transactionsListRelationFilter
  }, "id" | "affiliate_id_date">

  export type qms_branch_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    date?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
    _count?: qms_branch_transactionsCountOrderByAggregateInput
    _avg?: qms_branch_transactionsAvgOrderByAggregateInput
    _max?: qms_branch_transactionsMaxOrderByAggregateInput
    _min?: qms_branch_transactionsMinOrderByAggregateInput
    _sum?: qms_branch_transactionsSumOrderByAggregateInput
  }

  export type qms_branch_transactionsScalarWhereWithAggregatesInput = {
    AND?: qms_branch_transactionsScalarWhereWithAggregatesInput | qms_branch_transactionsScalarWhereWithAggregatesInput[]
    OR?: qms_branch_transactionsScalarWhereWithAggregatesInput[]
    NOT?: qms_branch_transactionsScalarWhereWithAggregatesInput | qms_branch_transactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_branch_transactions"> | number
    affiliate_id?: IntWithAggregatesFilter<"qms_branch_transactions"> | number
    date?: DateTimeWithAggregatesFilter<"qms_branch_transactions"> | Date | string
    note?: StringNullableWithAggregatesFilter<"qms_branch_transactions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"qms_branch_transactions"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"qms_branch_transactions"> | Date | string
  }

  export type qms_counterWhereInput = {
    AND?: qms_counterWhereInput | qms_counterWhereInput[]
    OR?: qms_counterWhereInput[]
    NOT?: qms_counterWhereInput | qms_counterWhereInput[]
    id?: IntFilter<"qms_counter"> | number
    name?: StringFilter<"qms_counter"> | string
    description?: StringNullableFilter<"qms_counter"> | string | null
    service_id?: IntNullableFilter<"qms_counter"> | number | null
    created_at?: DateTimeFilter<"qms_counter"> | Date | string
    updated_at?: DateTimeFilter<"qms_counter"> | Date | string
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }

  export type qms_counterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    service?: serviceOrderByWithRelationInput
    _relevance?: qms_counterOrderByRelevanceInput
  }

  export type qms_counterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_counterWhereInput | qms_counterWhereInput[]
    OR?: qms_counterWhereInput[]
    NOT?: qms_counterWhereInput | qms_counterWhereInput[]
    name?: StringFilter<"qms_counter"> | string
    description?: StringNullableFilter<"qms_counter"> | string | null
    service_id?: IntNullableFilter<"qms_counter"> | number | null
    created_at?: DateTimeFilter<"qms_counter"> | Date | string
    updated_at?: DateTimeFilter<"qms_counter"> | Date | string
    service?: XOR<ServiceNullableScalarRelationFilter, serviceWhereInput> | null
  }, "id">

  export type qms_counterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: qms_counterCountOrderByAggregateInput
    _avg?: qms_counterAvgOrderByAggregateInput
    _max?: qms_counterMaxOrderByAggregateInput
    _min?: qms_counterMinOrderByAggregateInput
    _sum?: qms_counterSumOrderByAggregateInput
  }

  export type qms_counterScalarWhereWithAggregatesInput = {
    AND?: qms_counterScalarWhereWithAggregatesInput | qms_counterScalarWhereWithAggregatesInput[]
    OR?: qms_counterScalarWhereWithAggregatesInput[]
    NOT?: qms_counterScalarWhereWithAggregatesInput | qms_counterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_counter"> | number
    name?: StringWithAggregatesFilter<"qms_counter"> | string
    description?: StringNullableWithAggregatesFilter<"qms_counter"> | string | null
    service_id?: IntNullableWithAggregatesFilter<"qms_counter"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"qms_counter"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"qms_counter"> | Date | string
  }

  export type qms_customerWhereInput = {
    AND?: qms_customerWhereInput | qms_customerWhereInput[]
    OR?: qms_customerWhereInput[]
    NOT?: qms_customerWhereInput | qms_customerWhereInput[]
    id?: IntFilter<"qms_customer"> | number
    customer_uuid?: StringFilter<"qms_customer"> | string
    device_id?: IntNullableFilter<"qms_customer"> | number | null
    name?: StringFilter<"qms_customer"> | string
    phone_number?: StringNullableFilter<"qms_customer"> | string | null
    email?: StringNullableFilter<"qms_customer"> | string | null
    has_priority_service?: BoolNullableFilter<"qms_customer"> | boolean | null
    created_at?: DateTimeFilter<"qms_customer"> | Date | string
    updated_at?: DateTimeFilter<"qms_customer"> | Date | string
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    qms_ticket?: Qms_ticketListRelationFilter
  }

  export type qms_customerOrderByWithRelationInput = {
    id?: SortOrder
    customer_uuid?: SortOrder
    device_id?: SortOrderInput | SortOrder
    name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    has_priority_service?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    device?: deviceOrderByWithRelationInput
    qms_ticket?: qms_ticketOrderByRelationAggregateInput
    _relevance?: qms_customerOrderByRelevanceInput
  }

  export type qms_customerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_customerWhereInput | qms_customerWhereInput[]
    OR?: qms_customerWhereInput[]
    NOT?: qms_customerWhereInput | qms_customerWhereInput[]
    customer_uuid?: StringFilter<"qms_customer"> | string
    device_id?: IntNullableFilter<"qms_customer"> | number | null
    name?: StringFilter<"qms_customer"> | string
    phone_number?: StringNullableFilter<"qms_customer"> | string | null
    email?: StringNullableFilter<"qms_customer"> | string | null
    has_priority_service?: BoolNullableFilter<"qms_customer"> | boolean | null
    created_at?: DateTimeFilter<"qms_customer"> | Date | string
    updated_at?: DateTimeFilter<"qms_customer"> | Date | string
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    qms_ticket?: Qms_ticketListRelationFilter
  }, "id">

  export type qms_customerOrderByWithAggregationInput = {
    id?: SortOrder
    customer_uuid?: SortOrder
    device_id?: SortOrderInput | SortOrder
    name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    has_priority_service?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: qms_customerCountOrderByAggregateInput
    _avg?: qms_customerAvgOrderByAggregateInput
    _max?: qms_customerMaxOrderByAggregateInput
    _min?: qms_customerMinOrderByAggregateInput
    _sum?: qms_customerSumOrderByAggregateInput
  }

  export type qms_customerScalarWhereWithAggregatesInput = {
    AND?: qms_customerScalarWhereWithAggregatesInput | qms_customerScalarWhereWithAggregatesInput[]
    OR?: qms_customerScalarWhereWithAggregatesInput[]
    NOT?: qms_customerScalarWhereWithAggregatesInput | qms_customerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_customer"> | number
    customer_uuid?: StringWithAggregatesFilter<"qms_customer"> | string
    device_id?: IntNullableWithAggregatesFilter<"qms_customer"> | number | null
    name?: StringWithAggregatesFilter<"qms_customer"> | string
    phone_number?: StringNullableWithAggregatesFilter<"qms_customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"qms_customer"> | string | null
    has_priority_service?: BoolNullableWithAggregatesFilter<"qms_customer"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"qms_customer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"qms_customer"> | Date | string
  }

  export type qms_operatorWhereInput = {
    AND?: qms_operatorWhereInput | qms_operatorWhereInput[]
    OR?: qms_operatorWhereInput[]
    NOT?: qms_operatorWhereInput | qms_operatorWhereInput[]
    id?: IntFilter<"qms_operator"> | number
    operator_uuid?: StringFilter<"qms_operator"> | string
    institution_id?: IntNullableFilter<"qms_operator"> | number | null
    name?: StringFilter<"qms_operator"> | string
    username?: StringFilter<"qms_operator"> | string
    password_hash?: StringNullableFilter<"qms_operator"> | string | null
    is_active?: BoolFilter<"qms_operator"> | boolean
    created_at?: DateTimeFilter<"qms_operator"> | Date | string
    updated_at?: DateTimeFilter<"qms_operator"> | Date | string
    email_address?: StringFilter<"qms_operator"> | string
    phone_number?: StringNullableFilter<"qms_operator"> | string | null
    terminal?: BoolNullableFilter<"qms_operator"> | boolean | null
    appointments?: AppointmentsListRelationFilter
    qms_branch_operator?: Qms_branch_operatorListRelationFilter
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    qms_operator_transactions?: Qms_operator_transactionsListRelationFilter
    qms_queue_operator_lnk?: Qms_queue_operator_lnkListRelationFilter
    qms_ticket_assignment?: Qms_ticket_assignmentListRelationFilter
  }

  export type qms_operatorOrderByWithRelationInput = {
    id?: SortOrder
    operator_uuid?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    name?: SortOrder
    username?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_address?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    terminal?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    qms_branch_operator?: qms_branch_operatorOrderByRelationAggregateInput
    institution?: institutionOrderByWithRelationInput
    qms_operator_transactions?: qms_operator_transactionsOrderByRelationAggregateInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkOrderByRelationAggregateInput
    qms_ticket_assignment?: qms_ticket_assignmentOrderByRelationAggregateInput
    _relevance?: qms_operatorOrderByRelevanceInput
  }

  export type qms_operatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_operatorWhereInput | qms_operatorWhereInput[]
    OR?: qms_operatorWhereInput[]
    NOT?: qms_operatorWhereInput | qms_operatorWhereInput[]
    operator_uuid?: StringFilter<"qms_operator"> | string
    institution_id?: IntNullableFilter<"qms_operator"> | number | null
    name?: StringFilter<"qms_operator"> | string
    username?: StringFilter<"qms_operator"> | string
    password_hash?: StringNullableFilter<"qms_operator"> | string | null
    is_active?: BoolFilter<"qms_operator"> | boolean
    created_at?: DateTimeFilter<"qms_operator"> | Date | string
    updated_at?: DateTimeFilter<"qms_operator"> | Date | string
    email_address?: StringFilter<"qms_operator"> | string
    phone_number?: StringNullableFilter<"qms_operator"> | string | null
    terminal?: BoolNullableFilter<"qms_operator"> | boolean | null
    appointments?: AppointmentsListRelationFilter
    qms_branch_operator?: Qms_branch_operatorListRelationFilter
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    qms_operator_transactions?: Qms_operator_transactionsListRelationFilter
    qms_queue_operator_lnk?: Qms_queue_operator_lnkListRelationFilter
    qms_ticket_assignment?: Qms_ticket_assignmentListRelationFilter
  }, "id">

  export type qms_operatorOrderByWithAggregationInput = {
    id?: SortOrder
    operator_uuid?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    name?: SortOrder
    username?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_address?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    terminal?: SortOrderInput | SortOrder
    _count?: qms_operatorCountOrderByAggregateInput
    _avg?: qms_operatorAvgOrderByAggregateInput
    _max?: qms_operatorMaxOrderByAggregateInput
    _min?: qms_operatorMinOrderByAggregateInput
    _sum?: qms_operatorSumOrderByAggregateInput
  }

  export type qms_operatorScalarWhereWithAggregatesInput = {
    AND?: qms_operatorScalarWhereWithAggregatesInput | qms_operatorScalarWhereWithAggregatesInput[]
    OR?: qms_operatorScalarWhereWithAggregatesInput[]
    NOT?: qms_operatorScalarWhereWithAggregatesInput | qms_operatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_operator"> | number
    operator_uuid?: StringWithAggregatesFilter<"qms_operator"> | string
    institution_id?: IntNullableWithAggregatesFilter<"qms_operator"> | number | null
    name?: StringWithAggregatesFilter<"qms_operator"> | string
    username?: StringWithAggregatesFilter<"qms_operator"> | string
    password_hash?: StringNullableWithAggregatesFilter<"qms_operator"> | string | null
    is_active?: BoolWithAggregatesFilter<"qms_operator"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"qms_operator"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"qms_operator"> | Date | string
    email_address?: StringWithAggregatesFilter<"qms_operator"> | string
    phone_number?: StringNullableWithAggregatesFilter<"qms_operator"> | string | null
    terminal?: BoolNullableWithAggregatesFilter<"qms_operator"> | boolean | null
  }

  export type qms_operator_transactionsWhereInput = {
    AND?: qms_operator_transactionsWhereInput | qms_operator_transactionsWhereInput[]
    OR?: qms_operator_transactionsWhereInput[]
    NOT?: qms_operator_transactionsWhereInput | qms_operator_transactionsWhereInput[]
    id?: IntFilter<"qms_operator_transactions"> | number
    branch_transaction_id?: IntFilter<"qms_operator_transactions"> | number
    operator_id?: IntFilter<"qms_operator_transactions"> | number
    transaction?: IntFilter<"qms_operator_transactions"> | number
    created_at?: DateTimeFilter<"qms_operator_transactions"> | Date | string
    last_updated?: DateTimeFilter<"qms_operator_transactions"> | Date | string
    qms_branch_transactions?: XOR<Qms_branch_transactionsScalarRelationFilter, qms_branch_transactionsWhereInput>
    qms_operator?: XOR<Qms_operatorScalarRelationFilter, qms_operatorWhereInput>
  }

  export type qms_operator_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
    qms_branch_transactions?: qms_branch_transactionsOrderByWithRelationInput
    qms_operator?: qms_operatorOrderByWithRelationInput
  }

  export type qms_operator_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_operator_transactionsWhereInput | qms_operator_transactionsWhereInput[]
    OR?: qms_operator_transactionsWhereInput[]
    NOT?: qms_operator_transactionsWhereInput | qms_operator_transactionsWhereInput[]
    branch_transaction_id?: IntFilter<"qms_operator_transactions"> | number
    operator_id?: IntFilter<"qms_operator_transactions"> | number
    transaction?: IntFilter<"qms_operator_transactions"> | number
    created_at?: DateTimeFilter<"qms_operator_transactions"> | Date | string
    last_updated?: DateTimeFilter<"qms_operator_transactions"> | Date | string
    qms_branch_transactions?: XOR<Qms_branch_transactionsScalarRelationFilter, qms_branch_transactionsWhereInput>
    qms_operator?: XOR<Qms_operatorScalarRelationFilter, qms_operatorWhereInput>
  }, "id">

  export type qms_operator_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
    _count?: qms_operator_transactionsCountOrderByAggregateInput
    _avg?: qms_operator_transactionsAvgOrderByAggregateInput
    _max?: qms_operator_transactionsMaxOrderByAggregateInput
    _min?: qms_operator_transactionsMinOrderByAggregateInput
    _sum?: qms_operator_transactionsSumOrderByAggregateInput
  }

  export type qms_operator_transactionsScalarWhereWithAggregatesInput = {
    AND?: qms_operator_transactionsScalarWhereWithAggregatesInput | qms_operator_transactionsScalarWhereWithAggregatesInput[]
    OR?: qms_operator_transactionsScalarWhereWithAggregatesInput[]
    NOT?: qms_operator_transactionsScalarWhereWithAggregatesInput | qms_operator_transactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_operator_transactions"> | number
    branch_transaction_id?: IntWithAggregatesFilter<"qms_operator_transactions"> | number
    operator_id?: IntWithAggregatesFilter<"qms_operator_transactions"> | number
    transaction?: IntWithAggregatesFilter<"qms_operator_transactions"> | number
    created_at?: DateTimeWithAggregatesFilter<"qms_operator_transactions"> | Date | string
    last_updated?: DateTimeWithAggregatesFilter<"qms_operator_transactions"> | Date | string
  }

  export type qms_queueWhereInput = {
    AND?: qms_queueWhereInput | qms_queueWhereInput[]
    OR?: qms_queueWhereInput[]
    NOT?: qms_queueWhereInput | qms_queueWhereInput[]
    id?: IntFilter<"qms_queue"> | number
    queue_uuid?: StringFilter<"qms_queue"> | string
    service_id?: IntFilter<"qms_queue"> | number
    queue_date?: DateTimeFilter<"qms_queue"> | Date | string
    start_time?: DateTimeFilter<"qms_queue"> | Date | string
    end_time?: DateTimeFilter<"qms_queue"> | Date | string
    status?: Enumqms_queue_statusFilter<"qms_queue"> | $Enums.qms_queue_status
    avg_service_time?: FloatNullableFilter<"qms_queue"> | number | null
    created_at?: DateTimeFilter<"qms_queue"> | Date | string
    updated_at?: DateTimeFilter<"qms_queue"> | Date | string
    closure_notification?: IntFilter<"qms_queue"> | number
    inter_arrival_time?: FloatNullableFilter<"qms_queue"> | number | null
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    qms_queue_operator_lnk?: Qms_queue_operator_lnkListRelationFilter
    qms_ticket?: Qms_ticketListRelationFilter
  }

  export type qms_queueOrderByWithRelationInput = {
    id?: SortOrder
    queue_uuid?: SortOrder
    service_id?: SortOrder
    queue_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    avg_service_time?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrderInput | SortOrder
    service?: serviceOrderByWithRelationInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkOrderByRelationAggregateInput
    qms_ticket?: qms_ticketOrderByRelationAggregateInput
    _relevance?: qms_queueOrderByRelevanceInput
  }

  export type qms_queueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_queueWhereInput | qms_queueWhereInput[]
    OR?: qms_queueWhereInput[]
    NOT?: qms_queueWhereInput | qms_queueWhereInput[]
    queue_uuid?: StringFilter<"qms_queue"> | string
    service_id?: IntFilter<"qms_queue"> | number
    queue_date?: DateTimeFilter<"qms_queue"> | Date | string
    start_time?: DateTimeFilter<"qms_queue"> | Date | string
    end_time?: DateTimeFilter<"qms_queue"> | Date | string
    status?: Enumqms_queue_statusFilter<"qms_queue"> | $Enums.qms_queue_status
    avg_service_time?: FloatNullableFilter<"qms_queue"> | number | null
    created_at?: DateTimeFilter<"qms_queue"> | Date | string
    updated_at?: DateTimeFilter<"qms_queue"> | Date | string
    closure_notification?: IntFilter<"qms_queue"> | number
    inter_arrival_time?: FloatNullableFilter<"qms_queue"> | number | null
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    qms_queue_operator_lnk?: Qms_queue_operator_lnkListRelationFilter
    qms_ticket?: Qms_ticketListRelationFilter
  }, "id">

  export type qms_queueOrderByWithAggregationInput = {
    id?: SortOrder
    queue_uuid?: SortOrder
    service_id?: SortOrder
    queue_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    avg_service_time?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrderInput | SortOrder
    _count?: qms_queueCountOrderByAggregateInput
    _avg?: qms_queueAvgOrderByAggregateInput
    _max?: qms_queueMaxOrderByAggregateInput
    _min?: qms_queueMinOrderByAggregateInput
    _sum?: qms_queueSumOrderByAggregateInput
  }

  export type qms_queueScalarWhereWithAggregatesInput = {
    AND?: qms_queueScalarWhereWithAggregatesInput | qms_queueScalarWhereWithAggregatesInput[]
    OR?: qms_queueScalarWhereWithAggregatesInput[]
    NOT?: qms_queueScalarWhereWithAggregatesInput | qms_queueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_queue"> | number
    queue_uuid?: StringWithAggregatesFilter<"qms_queue"> | string
    service_id?: IntWithAggregatesFilter<"qms_queue"> | number
    queue_date?: DateTimeWithAggregatesFilter<"qms_queue"> | Date | string
    start_time?: DateTimeWithAggregatesFilter<"qms_queue"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"qms_queue"> | Date | string
    status?: Enumqms_queue_statusWithAggregatesFilter<"qms_queue"> | $Enums.qms_queue_status
    avg_service_time?: FloatNullableWithAggregatesFilter<"qms_queue"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"qms_queue"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"qms_queue"> | Date | string
    closure_notification?: IntWithAggregatesFilter<"qms_queue"> | number
    inter_arrival_time?: FloatNullableWithAggregatesFilter<"qms_queue"> | number | null
  }

  export type qms_queue_operator_lnkWhereInput = {
    AND?: qms_queue_operator_lnkWhereInput | qms_queue_operator_lnkWhereInput[]
    OR?: qms_queue_operator_lnkWhereInput[]
    NOT?: qms_queue_operator_lnkWhereInput | qms_queue_operator_lnkWhereInput[]
    id?: IntFilter<"qms_queue_operator_lnk"> | number
    queue_id?: IntFilter<"qms_queue_operator_lnk"> | number
    operator_id?: IntFilter<"qms_queue_operator_lnk"> | number
    operator_uuid?: StringNullableFilter<"qms_queue_operator_lnk"> | string | null
    counter_id?: IntNullableFilter<"qms_queue_operator_lnk"> | number | null
    first_login?: DateTimeNullableFilter<"qms_queue_operator_lnk"> | Date | string | null
    last_logout?: DateTimeNullableFilter<"qms_queue_operator_lnk"> | Date | string | null
    api_key?: StringNullableFilter<"qms_queue_operator_lnk"> | string | null
    qms_queue?: XOR<Qms_queueScalarRelationFilter, qms_queueWhereInput>
    qms_operator?: XOR<Qms_operatorScalarRelationFilter, qms_operatorWhereInput>
  }

  export type qms_queue_operator_lnkOrderByWithRelationInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    operator_uuid?: SortOrderInput | SortOrder
    counter_id?: SortOrderInput | SortOrder
    first_login?: SortOrderInput | SortOrder
    last_logout?: SortOrderInput | SortOrder
    api_key?: SortOrderInput | SortOrder
    qms_queue?: qms_queueOrderByWithRelationInput
    qms_operator?: qms_operatorOrderByWithRelationInput
    _relevance?: qms_queue_operator_lnkOrderByRelevanceInput
  }

  export type qms_queue_operator_lnkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_queue_operator_lnkWhereInput | qms_queue_operator_lnkWhereInput[]
    OR?: qms_queue_operator_lnkWhereInput[]
    NOT?: qms_queue_operator_lnkWhereInput | qms_queue_operator_lnkWhereInput[]
    queue_id?: IntFilter<"qms_queue_operator_lnk"> | number
    operator_id?: IntFilter<"qms_queue_operator_lnk"> | number
    operator_uuid?: StringNullableFilter<"qms_queue_operator_lnk"> | string | null
    counter_id?: IntNullableFilter<"qms_queue_operator_lnk"> | number | null
    first_login?: DateTimeNullableFilter<"qms_queue_operator_lnk"> | Date | string | null
    last_logout?: DateTimeNullableFilter<"qms_queue_operator_lnk"> | Date | string | null
    api_key?: StringNullableFilter<"qms_queue_operator_lnk"> | string | null
    qms_queue?: XOR<Qms_queueScalarRelationFilter, qms_queueWhereInput>
    qms_operator?: XOR<Qms_operatorScalarRelationFilter, qms_operatorWhereInput>
  }, "id">

  export type qms_queue_operator_lnkOrderByWithAggregationInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    operator_uuid?: SortOrderInput | SortOrder
    counter_id?: SortOrderInput | SortOrder
    first_login?: SortOrderInput | SortOrder
    last_logout?: SortOrderInput | SortOrder
    api_key?: SortOrderInput | SortOrder
    _count?: qms_queue_operator_lnkCountOrderByAggregateInput
    _avg?: qms_queue_operator_lnkAvgOrderByAggregateInput
    _max?: qms_queue_operator_lnkMaxOrderByAggregateInput
    _min?: qms_queue_operator_lnkMinOrderByAggregateInput
    _sum?: qms_queue_operator_lnkSumOrderByAggregateInput
  }

  export type qms_queue_operator_lnkScalarWhereWithAggregatesInput = {
    AND?: qms_queue_operator_lnkScalarWhereWithAggregatesInput | qms_queue_operator_lnkScalarWhereWithAggregatesInput[]
    OR?: qms_queue_operator_lnkScalarWhereWithAggregatesInput[]
    NOT?: qms_queue_operator_lnkScalarWhereWithAggregatesInput | qms_queue_operator_lnkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_queue_operator_lnk"> | number
    queue_id?: IntWithAggregatesFilter<"qms_queue_operator_lnk"> | number
    operator_id?: IntWithAggregatesFilter<"qms_queue_operator_lnk"> | number
    operator_uuid?: StringNullableWithAggregatesFilter<"qms_queue_operator_lnk"> | string | null
    counter_id?: IntNullableWithAggregatesFilter<"qms_queue_operator_lnk"> | number | null
    first_login?: DateTimeNullableWithAggregatesFilter<"qms_queue_operator_lnk"> | Date | string | null
    last_logout?: DateTimeNullableWithAggregatesFilter<"qms_queue_operator_lnk"> | Date | string | null
    api_key?: StringNullableWithAggregatesFilter<"qms_queue_operator_lnk"> | string | null
  }

  export type qms_ticketWhereInput = {
    AND?: qms_ticketWhereInput | qms_ticketWhereInput[]
    OR?: qms_ticketWhereInput[]
    NOT?: qms_ticketWhereInput | qms_ticketWhereInput[]
    id?: IntFilter<"qms_ticket"> | number
    ticket_uuid?: StringFilter<"qms_ticket"> | string
    queue_id?: IntFilter<"qms_ticket"> | number
    customer_id?: IntFilter<"qms_ticket"> | number
    ticket_number?: StringFilter<"qms_ticket"> | string
    full_ticket_number?: StringNullableFilter<"qms_ticket"> | string | null
    pin?: IntFilter<"qms_ticket"> | number
    status?: IntNullableFilter<"qms_ticket"> | number | null
    service_time?: FloatNullableFilter<"qms_ticket"> | number | null
    estimated_waiting_time?: IntNullableFilter<"qms_ticket"> | number | null
    created_at?: DateTimeFilter<"qms_ticket"> | Date | string
    waiting_ended_on?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    skipped_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    cancelled_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    on_hold_from?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    skips_count?: IntNullableFilter<"qms_ticket"> | number | null
    prioritized?: BoolNullableFilter<"qms_ticket"> | boolean | null
    reason_id?: IntNullableFilter<"qms_ticket"> | number | null
    prioritized_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    is_next?: BoolNullableFilter<"qms_ticket"> | boolean | null
    prev_ticket_id?: IntNullableFilter<"qms_ticket"> | number | null
    rating_notification_sent?: IntFilter<"qms_ticket"> | number
    source?: IntFilter<"qms_ticket"> | number
    option?: XOR<OptionNullableScalarRelationFilter, optionWhereInput> | null
    qms_customer?: XOR<Qms_customerScalarRelationFilter, qms_customerWhereInput>
    qms_queue?: XOR<Qms_queueScalarRelationFilter, qms_queueWhereInput>
    qms_ticket_assignment?: Qms_ticket_assignmentListRelationFilter
  }

  export type qms_ticketOrderByWithRelationInput = {
    id?: SortOrder
    ticket_uuid?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    ticket_number?: SortOrder
    full_ticket_number?: SortOrderInput | SortOrder
    pin?: SortOrder
    status?: SortOrderInput | SortOrder
    service_time?: SortOrderInput | SortOrder
    estimated_waiting_time?: SortOrderInput | SortOrder
    created_at?: SortOrder
    waiting_ended_on?: SortOrderInput | SortOrder
    skipped_at?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    on_hold_from?: SortOrderInput | SortOrder
    skips_count?: SortOrderInput | SortOrder
    prioritized?: SortOrderInput | SortOrder
    reason_id?: SortOrderInput | SortOrder
    prioritized_at?: SortOrderInput | SortOrder
    is_next?: SortOrderInput | SortOrder
    prev_ticket_id?: SortOrderInput | SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
    option?: optionOrderByWithRelationInput
    qms_customer?: qms_customerOrderByWithRelationInput
    qms_queue?: qms_queueOrderByWithRelationInput
    qms_ticket_assignment?: qms_ticket_assignmentOrderByRelationAggregateInput
    _relevance?: qms_ticketOrderByRelevanceInput
  }

  export type qms_ticketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    queue_id_ticket_number?: qms_ticketQueue_idTicket_numberCompoundUniqueInput
    AND?: qms_ticketWhereInput | qms_ticketWhereInput[]
    OR?: qms_ticketWhereInput[]
    NOT?: qms_ticketWhereInput | qms_ticketWhereInput[]
    ticket_uuid?: StringFilter<"qms_ticket"> | string
    queue_id?: IntFilter<"qms_ticket"> | number
    customer_id?: IntFilter<"qms_ticket"> | number
    ticket_number?: StringFilter<"qms_ticket"> | string
    full_ticket_number?: StringNullableFilter<"qms_ticket"> | string | null
    pin?: IntFilter<"qms_ticket"> | number
    status?: IntNullableFilter<"qms_ticket"> | number | null
    service_time?: FloatNullableFilter<"qms_ticket"> | number | null
    estimated_waiting_time?: IntNullableFilter<"qms_ticket"> | number | null
    created_at?: DateTimeFilter<"qms_ticket"> | Date | string
    waiting_ended_on?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    skipped_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    cancelled_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    on_hold_from?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    skips_count?: IntNullableFilter<"qms_ticket"> | number | null
    prioritized?: BoolNullableFilter<"qms_ticket"> | boolean | null
    reason_id?: IntNullableFilter<"qms_ticket"> | number | null
    prioritized_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    is_next?: BoolNullableFilter<"qms_ticket"> | boolean | null
    prev_ticket_id?: IntNullableFilter<"qms_ticket"> | number | null
    rating_notification_sent?: IntFilter<"qms_ticket"> | number
    source?: IntFilter<"qms_ticket"> | number
    option?: XOR<OptionNullableScalarRelationFilter, optionWhereInput> | null
    qms_customer?: XOR<Qms_customerScalarRelationFilter, qms_customerWhereInput>
    qms_queue?: XOR<Qms_queueScalarRelationFilter, qms_queueWhereInput>
    qms_ticket_assignment?: Qms_ticket_assignmentListRelationFilter
  }, "id" | "queue_id_ticket_number">

  export type qms_ticketOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_uuid?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    ticket_number?: SortOrder
    full_ticket_number?: SortOrderInput | SortOrder
    pin?: SortOrder
    status?: SortOrderInput | SortOrder
    service_time?: SortOrderInput | SortOrder
    estimated_waiting_time?: SortOrderInput | SortOrder
    created_at?: SortOrder
    waiting_ended_on?: SortOrderInput | SortOrder
    skipped_at?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    on_hold_from?: SortOrderInput | SortOrder
    skips_count?: SortOrderInput | SortOrder
    prioritized?: SortOrderInput | SortOrder
    reason_id?: SortOrderInput | SortOrder
    prioritized_at?: SortOrderInput | SortOrder
    is_next?: SortOrderInput | SortOrder
    prev_ticket_id?: SortOrderInput | SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
    _count?: qms_ticketCountOrderByAggregateInput
    _avg?: qms_ticketAvgOrderByAggregateInput
    _max?: qms_ticketMaxOrderByAggregateInput
    _min?: qms_ticketMinOrderByAggregateInput
    _sum?: qms_ticketSumOrderByAggregateInput
  }

  export type qms_ticketScalarWhereWithAggregatesInput = {
    AND?: qms_ticketScalarWhereWithAggregatesInput | qms_ticketScalarWhereWithAggregatesInput[]
    OR?: qms_ticketScalarWhereWithAggregatesInput[]
    NOT?: qms_ticketScalarWhereWithAggregatesInput | qms_ticketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_ticket"> | number
    ticket_uuid?: StringWithAggregatesFilter<"qms_ticket"> | string
    queue_id?: IntWithAggregatesFilter<"qms_ticket"> | number
    customer_id?: IntWithAggregatesFilter<"qms_ticket"> | number
    ticket_number?: StringWithAggregatesFilter<"qms_ticket"> | string
    full_ticket_number?: StringNullableWithAggregatesFilter<"qms_ticket"> | string | null
    pin?: IntWithAggregatesFilter<"qms_ticket"> | number
    status?: IntNullableWithAggregatesFilter<"qms_ticket"> | number | null
    service_time?: FloatNullableWithAggregatesFilter<"qms_ticket"> | number | null
    estimated_waiting_time?: IntNullableWithAggregatesFilter<"qms_ticket"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"qms_ticket"> | Date | string
    waiting_ended_on?: DateTimeNullableWithAggregatesFilter<"qms_ticket"> | Date | string | null
    skipped_at?: DateTimeNullableWithAggregatesFilter<"qms_ticket"> | Date | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"qms_ticket"> | Date | string | null
    on_hold_from?: DateTimeNullableWithAggregatesFilter<"qms_ticket"> | Date | string | null
    skips_count?: IntNullableWithAggregatesFilter<"qms_ticket"> | number | null
    prioritized?: BoolNullableWithAggregatesFilter<"qms_ticket"> | boolean | null
    reason_id?: IntNullableWithAggregatesFilter<"qms_ticket"> | number | null
    prioritized_at?: DateTimeNullableWithAggregatesFilter<"qms_ticket"> | Date | string | null
    is_next?: BoolNullableWithAggregatesFilter<"qms_ticket"> | boolean | null
    prev_ticket_id?: IntNullableWithAggregatesFilter<"qms_ticket"> | number | null
    rating_notification_sent?: IntWithAggregatesFilter<"qms_ticket"> | number
    source?: IntWithAggregatesFilter<"qms_ticket"> | number
  }

  export type qms_ticket_assignmentWhereInput = {
    AND?: qms_ticket_assignmentWhereInput | qms_ticket_assignmentWhereInput[]
    OR?: qms_ticket_assignmentWhereInput[]
    NOT?: qms_ticket_assignmentWhereInput | qms_ticket_assignmentWhereInput[]
    id?: IntFilter<"qms_ticket_assignment"> | number
    ticket_id?: IntFilter<"qms_ticket_assignment"> | number
    queue_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    operator_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    counter_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    status?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    started_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    assigned_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    state?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    comment?: StringNullableFilter<"qms_ticket_assignment"> | string | null
    qms_ticket?: XOR<Qms_ticketScalarRelationFilter, qms_ticketWhereInput>
    qms_operator?: XOR<Qms_operatorNullableScalarRelationFilter, qms_operatorWhereInput> | null
  }

  export type qms_ticket_assignmentOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    counter_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    assigned_at?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    qms_ticket?: qms_ticketOrderByWithRelationInput
    qms_operator?: qms_operatorOrderByWithRelationInput
    _relevance?: qms_ticket_assignmentOrderByRelevanceInput
  }

  export type qms_ticket_assignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: qms_ticket_assignmentWhereInput | qms_ticket_assignmentWhereInput[]
    OR?: qms_ticket_assignmentWhereInput[]
    NOT?: qms_ticket_assignmentWhereInput | qms_ticket_assignmentWhereInput[]
    ticket_id?: IntFilter<"qms_ticket_assignment"> | number
    queue_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    operator_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    counter_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    status?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    started_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    assigned_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    state?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    comment?: StringNullableFilter<"qms_ticket_assignment"> | string | null
    qms_ticket?: XOR<Qms_ticketScalarRelationFilter, qms_ticketWhereInput>
    qms_operator?: XOR<Qms_operatorNullableScalarRelationFilter, qms_operatorWhereInput> | null
  }, "id">

  export type qms_ticket_assignmentOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrderInput | SortOrder
    operator_id?: SortOrderInput | SortOrder
    counter_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    assigned_at?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: qms_ticket_assignmentCountOrderByAggregateInput
    _avg?: qms_ticket_assignmentAvgOrderByAggregateInput
    _max?: qms_ticket_assignmentMaxOrderByAggregateInput
    _min?: qms_ticket_assignmentMinOrderByAggregateInput
    _sum?: qms_ticket_assignmentSumOrderByAggregateInput
  }

  export type qms_ticket_assignmentScalarWhereWithAggregatesInput = {
    AND?: qms_ticket_assignmentScalarWhereWithAggregatesInput | qms_ticket_assignmentScalarWhereWithAggregatesInput[]
    OR?: qms_ticket_assignmentScalarWhereWithAggregatesInput[]
    NOT?: qms_ticket_assignmentScalarWhereWithAggregatesInput | qms_ticket_assignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"qms_ticket_assignment"> | number
    ticket_id?: IntWithAggregatesFilter<"qms_ticket_assignment"> | number
    queue_id?: IntNullableWithAggregatesFilter<"qms_ticket_assignment"> | number | null
    operator_id?: IntNullableWithAggregatesFilter<"qms_ticket_assignment"> | number | null
    counter_id?: IntNullableWithAggregatesFilter<"qms_ticket_assignment"> | number | null
    status?: IntNullableWithAggregatesFilter<"qms_ticket_assignment"> | number | null
    started_at?: DateTimeNullableWithAggregatesFilter<"qms_ticket_assignment"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"qms_ticket_assignment"> | Date | string | null
    assigned_at?: DateTimeNullableWithAggregatesFilter<"qms_ticket_assignment"> | Date | string | null
    state?: IntNullableWithAggregatesFilter<"qms_ticket_assignment"> | number | null
    comment?: StringNullableWithAggregatesFilter<"qms_ticket_assignment"> | string | null
  }

  export type ratingWhereInput = {
    AND?: ratingWhereInput | ratingWhereInput[]
    OR?: ratingWhereInput[]
    NOT?: ratingWhereInput | ratingWhereInput[]
    id?: BigIntFilter<"rating"> | bigint | number
    state?: BoolFilter<"rating"> | boolean
    time?: DateTimeFilter<"rating"> | Date | string
    service_id?: IntFilter<"rating"> | number
    comment?: StringNullableFilter<"rating"> | string | null
    gender?: IntNullableFilter<"rating"> | number | null
    age_range?: IntNullableFilter<"rating"> | number | null
    location?: IntNullableFilter<"rating"> | number | null
    device_id?: IntNullableFilter<"rating"> | number | null
    nps_score?: IntNullableFilter<"rating"> | number | null
    ticket_id?: IntNullableFilter<"rating"> | number | null
    finger_print?: StringNullableFilter<"rating"> | string | null
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    rating_assets?: Rating_assetsListRelationFilter
    tip?: TipListRelationFilter
  }

  export type ratingOrderByWithRelationInput = {
    id?: SortOrder
    state?: SortOrder
    time?: SortOrder
    service_id?: SortOrder
    comment?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    age_range?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    nps_score?: SortOrderInput | SortOrder
    ticket_id?: SortOrderInput | SortOrder
    finger_print?: SortOrderInput | SortOrder
    service?: serviceOrderByWithRelationInput
    device?: deviceOrderByWithRelationInput
    rating_assets?: rating_assetsOrderByRelationAggregateInput
    tip?: tipOrderByRelationAggregateInput
    _relevance?: ratingOrderByRelevanceInput
  }

  export type ratingWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ratingWhereInput | ratingWhereInput[]
    OR?: ratingWhereInput[]
    NOT?: ratingWhereInput | ratingWhereInput[]
    state?: BoolFilter<"rating"> | boolean
    time?: DateTimeFilter<"rating"> | Date | string
    service_id?: IntFilter<"rating"> | number
    comment?: StringNullableFilter<"rating"> | string | null
    gender?: IntNullableFilter<"rating"> | number | null
    age_range?: IntNullableFilter<"rating"> | number | null
    location?: IntNullableFilter<"rating"> | number | null
    device_id?: IntNullableFilter<"rating"> | number | null
    nps_score?: IntNullableFilter<"rating"> | number | null
    ticket_id?: IntNullableFilter<"rating"> | number | null
    finger_print?: StringNullableFilter<"rating"> | string | null
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    device?: XOR<DeviceNullableScalarRelationFilter, deviceWhereInput> | null
    rating_assets?: Rating_assetsListRelationFilter
    tip?: TipListRelationFilter
  }, "id">

  export type ratingOrderByWithAggregationInput = {
    id?: SortOrder
    state?: SortOrder
    time?: SortOrder
    service_id?: SortOrder
    comment?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    age_range?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    nps_score?: SortOrderInput | SortOrder
    ticket_id?: SortOrderInput | SortOrder
    finger_print?: SortOrderInput | SortOrder
    _count?: ratingCountOrderByAggregateInput
    _avg?: ratingAvgOrderByAggregateInput
    _max?: ratingMaxOrderByAggregateInput
    _min?: ratingMinOrderByAggregateInput
    _sum?: ratingSumOrderByAggregateInput
  }

  export type ratingScalarWhereWithAggregatesInput = {
    AND?: ratingScalarWhereWithAggregatesInput | ratingScalarWhereWithAggregatesInput[]
    OR?: ratingScalarWhereWithAggregatesInput[]
    NOT?: ratingScalarWhereWithAggregatesInput | ratingScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"rating"> | bigint | number
    state?: BoolWithAggregatesFilter<"rating"> | boolean
    time?: DateTimeWithAggregatesFilter<"rating"> | Date | string
    service_id?: IntWithAggregatesFilter<"rating"> | number
    comment?: StringNullableWithAggregatesFilter<"rating"> | string | null
    gender?: IntNullableWithAggregatesFilter<"rating"> | number | null
    age_range?: IntNullableWithAggregatesFilter<"rating"> | number | null
    location?: IntNullableWithAggregatesFilter<"rating"> | number | null
    device_id?: IntNullableWithAggregatesFilter<"rating"> | number | null
    nps_score?: IntNullableWithAggregatesFilter<"rating"> | number | null
    ticket_id?: IntNullableWithAggregatesFilter<"rating"> | number | null
    finger_print?: StringNullableWithAggregatesFilter<"rating"> | string | null
  }

  export type rating_assetsWhereInput = {
    AND?: rating_assetsWhereInput | rating_assetsWhereInput[]
    OR?: rating_assetsWhereInput[]
    NOT?: rating_assetsWhereInput | rating_assetsWhereInput[]
    rating_assets_id?: IntFilter<"rating_assets"> | number
    rating_assets_image?: StringNullableFilter<"rating_assets"> | string | null
    rating_assets_video?: StringNullableFilter<"rating_assets"> | string | null
    rating_id?: BigIntNullableFilter<"rating_assets"> | bigint | number | null
    rating?: XOR<RatingNullableScalarRelationFilter, ratingWhereInput> | null
  }

  export type rating_assetsOrderByWithRelationInput = {
    rating_assets_id?: SortOrder
    rating_assets_image?: SortOrderInput | SortOrder
    rating_assets_video?: SortOrderInput | SortOrder
    rating_id?: SortOrderInput | SortOrder
    rating?: ratingOrderByWithRelationInput
    _relevance?: rating_assetsOrderByRelevanceInput
  }

  export type rating_assetsWhereUniqueInput = Prisma.AtLeast<{
    rating_assets_id?: number
    AND?: rating_assetsWhereInput | rating_assetsWhereInput[]
    OR?: rating_assetsWhereInput[]
    NOT?: rating_assetsWhereInput | rating_assetsWhereInput[]
    rating_assets_image?: StringNullableFilter<"rating_assets"> | string | null
    rating_assets_video?: StringNullableFilter<"rating_assets"> | string | null
    rating_id?: BigIntNullableFilter<"rating_assets"> | bigint | number | null
    rating?: XOR<RatingNullableScalarRelationFilter, ratingWhereInput> | null
  }, "rating_assets_id">

  export type rating_assetsOrderByWithAggregationInput = {
    rating_assets_id?: SortOrder
    rating_assets_image?: SortOrderInput | SortOrder
    rating_assets_video?: SortOrderInput | SortOrder
    rating_id?: SortOrderInput | SortOrder
    _count?: rating_assetsCountOrderByAggregateInput
    _avg?: rating_assetsAvgOrderByAggregateInput
    _max?: rating_assetsMaxOrderByAggregateInput
    _min?: rating_assetsMinOrderByAggregateInput
    _sum?: rating_assetsSumOrderByAggregateInput
  }

  export type rating_assetsScalarWhereWithAggregatesInput = {
    AND?: rating_assetsScalarWhereWithAggregatesInput | rating_assetsScalarWhereWithAggregatesInput[]
    OR?: rating_assetsScalarWhereWithAggregatesInput[]
    NOT?: rating_assetsScalarWhereWithAggregatesInput | rating_assetsScalarWhereWithAggregatesInput[]
    rating_assets_id?: IntWithAggregatesFilter<"rating_assets"> | number
    rating_assets_image?: StringNullableWithAggregatesFilter<"rating_assets"> | string | null
    rating_assets_video?: StringNullableWithAggregatesFilter<"rating_assets"> | string | null
    rating_id?: BigIntNullableWithAggregatesFilter<"rating_assets"> | bigint | number | null
  }

  export type rating_qr_code_sessionsWhereInput = {
    AND?: rating_qr_code_sessionsWhereInput | rating_qr_code_sessionsWhereInput[]
    OR?: rating_qr_code_sessionsWhereInput[]
    NOT?: rating_qr_code_sessionsWhereInput | rating_qr_code_sessionsWhereInput[]
    id?: IntFilter<"rating_qr_code_sessions"> | number
    institution_uuid?: StringNullableFilter<"rating_qr_code_sessions"> | string | null
    service_uuid?: StringNullableFilter<"rating_qr_code_sessions"> | string | null
    user_agent?: StringFilter<"rating_qr_code_sessions"> | string
    finger_print?: StringFilter<"rating_qr_code_sessions"> | string
    ip_address?: StringFilter<"rating_qr_code_sessions"> | string
    session_token?: StringFilter<"rating_qr_code_sessions"> | string
    session_expiration?: DateTimeFilter<"rating_qr_code_sessions"> | Date | string
    status?: Enumrating_qr_code_sessions_statusFilter<"rating_qr_code_sessions"> | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeFilter<"rating_qr_code_sessions"> | Date | string
  }

  export type rating_qr_code_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    institution_uuid?: SortOrderInput | SortOrder
    service_uuid?: SortOrderInput | SortOrder
    user_agent?: SortOrder
    finger_print?: SortOrder
    ip_address?: SortOrder
    session_token?: SortOrder
    session_expiration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _relevance?: rating_qr_code_sessionsOrderByRelevanceInput
  }

  export type rating_qr_code_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    session_token?: string
    AND?: rating_qr_code_sessionsWhereInput | rating_qr_code_sessionsWhereInput[]
    OR?: rating_qr_code_sessionsWhereInput[]
    NOT?: rating_qr_code_sessionsWhereInput | rating_qr_code_sessionsWhereInput[]
    institution_uuid?: StringNullableFilter<"rating_qr_code_sessions"> | string | null
    service_uuid?: StringNullableFilter<"rating_qr_code_sessions"> | string | null
    user_agent?: StringFilter<"rating_qr_code_sessions"> | string
    finger_print?: StringFilter<"rating_qr_code_sessions"> | string
    ip_address?: StringFilter<"rating_qr_code_sessions"> | string
    session_expiration?: DateTimeFilter<"rating_qr_code_sessions"> | Date | string
    status?: Enumrating_qr_code_sessions_statusFilter<"rating_qr_code_sessions"> | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeFilter<"rating_qr_code_sessions"> | Date | string
  }, "id" | "session_token">

  export type rating_qr_code_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    institution_uuid?: SortOrderInput | SortOrder
    service_uuid?: SortOrderInput | SortOrder
    user_agent?: SortOrder
    finger_print?: SortOrder
    ip_address?: SortOrder
    session_token?: SortOrder
    session_expiration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: rating_qr_code_sessionsCountOrderByAggregateInput
    _avg?: rating_qr_code_sessionsAvgOrderByAggregateInput
    _max?: rating_qr_code_sessionsMaxOrderByAggregateInput
    _min?: rating_qr_code_sessionsMinOrderByAggregateInput
    _sum?: rating_qr_code_sessionsSumOrderByAggregateInput
  }

  export type rating_qr_code_sessionsScalarWhereWithAggregatesInput = {
    AND?: rating_qr_code_sessionsScalarWhereWithAggregatesInput | rating_qr_code_sessionsScalarWhereWithAggregatesInput[]
    OR?: rating_qr_code_sessionsScalarWhereWithAggregatesInput[]
    NOT?: rating_qr_code_sessionsScalarWhereWithAggregatesInput | rating_qr_code_sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rating_qr_code_sessions"> | number
    institution_uuid?: StringNullableWithAggregatesFilter<"rating_qr_code_sessions"> | string | null
    service_uuid?: StringNullableWithAggregatesFilter<"rating_qr_code_sessions"> | string | null
    user_agent?: StringWithAggregatesFilter<"rating_qr_code_sessions"> | string
    finger_print?: StringWithAggregatesFilter<"rating_qr_code_sessions"> | string
    ip_address?: StringWithAggregatesFilter<"rating_qr_code_sessions"> | string
    session_token?: StringWithAggregatesFilter<"rating_qr_code_sessions"> | string
    session_expiration?: DateTimeWithAggregatesFilter<"rating_qr_code_sessions"> | Date | string
    status?: Enumrating_qr_code_sessions_statusWithAggregatesFilter<"rating_qr_code_sessions"> | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeWithAggregatesFilter<"rating_qr_code_sessions"> | Date | string
  }

  export type rating_replyWhereInput = {
    AND?: rating_replyWhereInput | rating_replyWhereInput[]
    OR?: rating_replyWhereInput[]
    NOT?: rating_replyWhereInput | rating_replyWhereInput[]
    id?: IntFilter<"rating_reply"> | number
    specific?: BoolNullableFilter<"rating_reply"> | boolean | null
    rating_id?: IntNullableFilter<"rating_reply"> | number | null
    time?: DateTimeNullableFilter<"rating_reply"> | Date | string | null
    reply?: StringNullableFilter<"rating_reply"> | string | null
  }

  export type rating_replyOrderByWithRelationInput = {
    id?: SortOrder
    specific?: SortOrderInput | SortOrder
    rating_id?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    reply?: SortOrderInput | SortOrder
    _relevance?: rating_replyOrderByRelevanceInput
  }

  export type rating_replyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rating_replyWhereInput | rating_replyWhereInput[]
    OR?: rating_replyWhereInput[]
    NOT?: rating_replyWhereInput | rating_replyWhereInput[]
    specific?: BoolNullableFilter<"rating_reply"> | boolean | null
    rating_id?: IntNullableFilter<"rating_reply"> | number | null
    time?: DateTimeNullableFilter<"rating_reply"> | Date | string | null
    reply?: StringNullableFilter<"rating_reply"> | string | null
  }, "id">

  export type rating_replyOrderByWithAggregationInput = {
    id?: SortOrder
    specific?: SortOrderInput | SortOrder
    rating_id?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    reply?: SortOrderInput | SortOrder
    _count?: rating_replyCountOrderByAggregateInput
    _avg?: rating_replyAvgOrderByAggregateInput
    _max?: rating_replyMaxOrderByAggregateInput
    _min?: rating_replyMinOrderByAggregateInput
    _sum?: rating_replySumOrderByAggregateInput
  }

  export type rating_replyScalarWhereWithAggregatesInput = {
    AND?: rating_replyScalarWhereWithAggregatesInput | rating_replyScalarWhereWithAggregatesInput[]
    OR?: rating_replyScalarWhereWithAggregatesInput[]
    NOT?: rating_replyScalarWhereWithAggregatesInput | rating_replyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rating_reply"> | number
    specific?: BoolNullableWithAggregatesFilter<"rating_reply"> | boolean | null
    rating_id?: IntNullableWithAggregatesFilter<"rating_reply"> | number | null
    time?: DateTimeNullableWithAggregatesFilter<"rating_reply"> | Date | string | null
    reply?: StringNullableWithAggregatesFilter<"rating_reply"> | string | null
  }

  export type reportsWhereInput = {
    AND?: reportsWhereInput | reportsWhereInput[]
    OR?: reportsWhereInput[]
    NOT?: reportsWhereInput | reportsWhereInput[]
    id?: IntFilter<"reports"> | number
    title?: StringFilter<"reports"> | string
    type?: StringFilter<"reports"> | string
    institution_id?: IntFilter<"reports"> | number
    service_ids?: StringFilter<"reports"> | string
    start_date?: DateTimeFilter<"reports"> | Date | string
    end_date?: DateTimeFilter<"reports"> | Date | string
    report_created_by?: IntFilter<"reports"> | number
    report_institution_id?: StringFilter<"reports"> | string
    report_recipient?: StringFilter<"reports"> | string
    report_queue_uuid?: StringFilter<"reports"> | string
    report_content_key?: StringNullableFilter<"reports"> | string | null
    status?: IntFilter<"reports"> | number
    created_at?: DateTimeFilter<"reports"> | Date | string
  }

  export type reportsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    institution_id?: SortOrder
    service_ids?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    report_created_by?: SortOrder
    report_institution_id?: SortOrder
    report_recipient?: SortOrder
    report_queue_uuid?: SortOrder
    report_content_key?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _relevance?: reportsOrderByRelevanceInput
  }

  export type reportsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    report_queue_uuid?: string
    AND?: reportsWhereInput | reportsWhereInput[]
    OR?: reportsWhereInput[]
    NOT?: reportsWhereInput | reportsWhereInput[]
    title?: StringFilter<"reports"> | string
    type?: StringFilter<"reports"> | string
    institution_id?: IntFilter<"reports"> | number
    service_ids?: StringFilter<"reports"> | string
    start_date?: DateTimeFilter<"reports"> | Date | string
    end_date?: DateTimeFilter<"reports"> | Date | string
    report_created_by?: IntFilter<"reports"> | number
    report_institution_id?: StringFilter<"reports"> | string
    report_recipient?: StringFilter<"reports"> | string
    report_content_key?: StringNullableFilter<"reports"> | string | null
    status?: IntFilter<"reports"> | number
    created_at?: DateTimeFilter<"reports"> | Date | string
  }, "id" | "report_queue_uuid">

  export type reportsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    institution_id?: SortOrder
    service_ids?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    report_created_by?: SortOrder
    report_institution_id?: SortOrder
    report_recipient?: SortOrder
    report_queue_uuid?: SortOrder
    report_content_key?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: reportsCountOrderByAggregateInput
    _avg?: reportsAvgOrderByAggregateInput
    _max?: reportsMaxOrderByAggregateInput
    _min?: reportsMinOrderByAggregateInput
    _sum?: reportsSumOrderByAggregateInput
  }

  export type reportsScalarWhereWithAggregatesInput = {
    AND?: reportsScalarWhereWithAggregatesInput | reportsScalarWhereWithAggregatesInput[]
    OR?: reportsScalarWhereWithAggregatesInput[]
    NOT?: reportsScalarWhereWithAggregatesInput | reportsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reports"> | number
    title?: StringWithAggregatesFilter<"reports"> | string
    type?: StringWithAggregatesFilter<"reports"> | string
    institution_id?: IntWithAggregatesFilter<"reports"> | number
    service_ids?: StringWithAggregatesFilter<"reports"> | string
    start_date?: DateTimeWithAggregatesFilter<"reports"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"reports"> | Date | string
    report_created_by?: IntWithAggregatesFilter<"reports"> | number
    report_institution_id?: StringWithAggregatesFilter<"reports"> | string
    report_recipient?: StringWithAggregatesFilter<"reports"> | string
    report_queue_uuid?: StringWithAggregatesFilter<"reports"> | string
    report_content_key?: StringNullableWithAggregatesFilter<"reports"> | string | null
    status?: IntWithAggregatesFilter<"reports"> | number
    created_at?: DateTimeWithAggregatesFilter<"reports"> | Date | string
  }

  export type request_institutionWhereInput = {
    AND?: request_institutionWhereInput | request_institutionWhereInput[]
    OR?: request_institutionWhereInput[]
    NOT?: request_institutionWhereInput | request_institutionWhereInput[]
    id?: IntFilter<"request_institution"> | number
    owner_name?: StringFilter<"request_institution"> | string
    address?: StringFilter<"request_institution"> | string
    phone_number?: StringFilter<"request_institution"> | string
    email?: StringFilter<"request_institution"> | string
    name?: StringFilter<"request_institution"> | string
    category?: StringFilter<"request_institution"> | string
    location?: StringFilter<"request_institution"> | string
    type?: StringFilter<"request_institution"> | string
    business_certificate?: StringFilter<"request_institution"> | string
    product_type?: StringFilter<"request_institution"> | string
    approval_status?: IntFilter<"request_institution"> | number
  }

  export type request_institutionOrderByWithRelationInput = {
    id?: SortOrder
    owner_name?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    type?: SortOrder
    business_certificate?: SortOrder
    product_type?: SortOrder
    approval_status?: SortOrder
    _relevance?: request_institutionOrderByRelevanceInput
  }

  export type request_institutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: request_institutionWhereInput | request_institutionWhereInput[]
    OR?: request_institutionWhereInput[]
    NOT?: request_institutionWhereInput | request_institutionWhereInput[]
    owner_name?: StringFilter<"request_institution"> | string
    address?: StringFilter<"request_institution"> | string
    phone_number?: StringFilter<"request_institution"> | string
    email?: StringFilter<"request_institution"> | string
    name?: StringFilter<"request_institution"> | string
    category?: StringFilter<"request_institution"> | string
    location?: StringFilter<"request_institution"> | string
    type?: StringFilter<"request_institution"> | string
    business_certificate?: StringFilter<"request_institution"> | string
    product_type?: StringFilter<"request_institution"> | string
    approval_status?: IntFilter<"request_institution"> | number
  }, "id">

  export type request_institutionOrderByWithAggregationInput = {
    id?: SortOrder
    owner_name?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    type?: SortOrder
    business_certificate?: SortOrder
    product_type?: SortOrder
    approval_status?: SortOrder
    _count?: request_institutionCountOrderByAggregateInput
    _avg?: request_institutionAvgOrderByAggregateInput
    _max?: request_institutionMaxOrderByAggregateInput
    _min?: request_institutionMinOrderByAggregateInput
    _sum?: request_institutionSumOrderByAggregateInput
  }

  export type request_institutionScalarWhereWithAggregatesInput = {
    AND?: request_institutionScalarWhereWithAggregatesInput | request_institutionScalarWhereWithAggregatesInput[]
    OR?: request_institutionScalarWhereWithAggregatesInput[]
    NOT?: request_institutionScalarWhereWithAggregatesInput | request_institutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"request_institution"> | number
    owner_name?: StringWithAggregatesFilter<"request_institution"> | string
    address?: StringWithAggregatesFilter<"request_institution"> | string
    phone_number?: StringWithAggregatesFilter<"request_institution"> | string
    email?: StringWithAggregatesFilter<"request_institution"> | string
    name?: StringWithAggregatesFilter<"request_institution"> | string
    category?: StringWithAggregatesFilter<"request_institution"> | string
    location?: StringWithAggregatesFilter<"request_institution"> | string
    type?: StringWithAggregatesFilter<"request_institution"> | string
    business_certificate?: StringWithAggregatesFilter<"request_institution"> | string
    product_type?: StringWithAggregatesFilter<"request_institution"> | string
    approval_status?: IntWithAggregatesFilter<"request_institution"> | number
  }

  export type serviceWhereInput = {
    AND?: serviceWhereInput | serviceWhereInput[]
    OR?: serviceWhereInput[]
    NOT?: serviceWhereInput | serviceWhereInput[]
    id?: IntFilter<"service"> | number
    institution_id?: IntNullableFilter<"service"> | number | null
    status?: IntNullableFilter<"service"> | number | null
    created_at?: DateTimeFilter<"service"> | Date | string
    bad_rating_threshold?: IntNullableFilter<"service"> | number | null
    group?: IntNullableFilter<"service"> | number | null
    good_ratings?: IntNullableFilter<"service"> | number | null
    bad_ratings?: IntNullableFilter<"service"> | number | null
    excellent_ratings?: IntNullableFilter<"service"> | number | null
    nps?: IntNullableFilter<"service"> | number | null
    csat?: IntNullableFilter<"service"> | number | null
    mean_service_time?: IntNullableFilter<"service"> | number | null
    avg_service_time?: FloatNullableFilter<"service"> | number | null
    uuid?: StringNullableFilter<"service"> | string | null
    inter_arrival_time?: FloatNullableFilter<"service"> | number | null
    estimated_time?: FloatNullableFilter<"service"> | number | null
    appointments?: AppointmentsListRelationFilter
    qms_counter?: Qms_counterListRelationFilter
    qms_queue?: Qms_queueListRelationFilter
    rating?: RatingListRelationFilter
    service_group?: XOR<Service_groupNullableScalarRelationFilter, service_groupWhereInput> | null
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
  }

  export type serviceOrderByWithRelationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    bad_rating_threshold?: SortOrderInput | SortOrder
    group?: SortOrderInput | SortOrder
    good_ratings?: SortOrderInput | SortOrder
    bad_ratings?: SortOrderInput | SortOrder
    excellent_ratings?: SortOrderInput | SortOrder
    nps?: SortOrderInput | SortOrder
    csat?: SortOrderInput | SortOrder
    mean_service_time?: SortOrderInput | SortOrder
    avg_service_time?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    inter_arrival_time?: SortOrderInput | SortOrder
    estimated_time?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    qms_counter?: qms_counterOrderByRelationAggregateInput
    qms_queue?: qms_queueOrderByRelationAggregateInput
    rating?: ratingOrderByRelationAggregateInput
    service_group?: service_groupOrderByWithRelationInput
    institution?: institutionOrderByWithRelationInput
    _relevance?: serviceOrderByRelevanceInput
  }

  export type serviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: serviceWhereInput | serviceWhereInput[]
    OR?: serviceWhereInput[]
    NOT?: serviceWhereInput | serviceWhereInput[]
    institution_id?: IntNullableFilter<"service"> | number | null
    status?: IntNullableFilter<"service"> | number | null
    created_at?: DateTimeFilter<"service"> | Date | string
    bad_rating_threshold?: IntNullableFilter<"service"> | number | null
    group?: IntNullableFilter<"service"> | number | null
    good_ratings?: IntNullableFilter<"service"> | number | null
    bad_ratings?: IntNullableFilter<"service"> | number | null
    excellent_ratings?: IntNullableFilter<"service"> | number | null
    nps?: IntNullableFilter<"service"> | number | null
    csat?: IntNullableFilter<"service"> | number | null
    mean_service_time?: IntNullableFilter<"service"> | number | null
    avg_service_time?: FloatNullableFilter<"service"> | number | null
    uuid?: StringNullableFilter<"service"> | string | null
    inter_arrival_time?: FloatNullableFilter<"service"> | number | null
    estimated_time?: FloatNullableFilter<"service"> | number | null
    appointments?: AppointmentsListRelationFilter
    qms_counter?: Qms_counterListRelationFilter
    qms_queue?: Qms_queueListRelationFilter
    rating?: RatingListRelationFilter
    service_group?: XOR<Service_groupNullableScalarRelationFilter, service_groupWhereInput> | null
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
  }, "id">

  export type serviceOrderByWithAggregationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    bad_rating_threshold?: SortOrderInput | SortOrder
    group?: SortOrderInput | SortOrder
    good_ratings?: SortOrderInput | SortOrder
    bad_ratings?: SortOrderInput | SortOrder
    excellent_ratings?: SortOrderInput | SortOrder
    nps?: SortOrderInput | SortOrder
    csat?: SortOrderInput | SortOrder
    mean_service_time?: SortOrderInput | SortOrder
    avg_service_time?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    inter_arrival_time?: SortOrderInput | SortOrder
    estimated_time?: SortOrderInput | SortOrder
    _count?: serviceCountOrderByAggregateInput
    _avg?: serviceAvgOrderByAggregateInput
    _max?: serviceMaxOrderByAggregateInput
    _min?: serviceMinOrderByAggregateInput
    _sum?: serviceSumOrderByAggregateInput
  }

  export type serviceScalarWhereWithAggregatesInput = {
    AND?: serviceScalarWhereWithAggregatesInput | serviceScalarWhereWithAggregatesInput[]
    OR?: serviceScalarWhereWithAggregatesInput[]
    NOT?: serviceScalarWhereWithAggregatesInput | serviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"service"> | number
    institution_id?: IntNullableWithAggregatesFilter<"service"> | number | null
    status?: IntNullableWithAggregatesFilter<"service"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"service"> | Date | string
    bad_rating_threshold?: IntNullableWithAggregatesFilter<"service"> | number | null
    group?: IntNullableWithAggregatesFilter<"service"> | number | null
    good_ratings?: IntNullableWithAggregatesFilter<"service"> | number | null
    bad_ratings?: IntNullableWithAggregatesFilter<"service"> | number | null
    excellent_ratings?: IntNullableWithAggregatesFilter<"service"> | number | null
    nps?: IntNullableWithAggregatesFilter<"service"> | number | null
    csat?: IntNullableWithAggregatesFilter<"service"> | number | null
    mean_service_time?: IntNullableWithAggregatesFilter<"service"> | number | null
    avg_service_time?: FloatNullableWithAggregatesFilter<"service"> | number | null
    uuid?: StringNullableWithAggregatesFilter<"service"> | string | null
    inter_arrival_time?: FloatNullableWithAggregatesFilter<"service"> | number | null
    estimated_time?: FloatNullableWithAggregatesFilter<"service"> | number | null
  }

  export type service_groupWhereInput = {
    AND?: service_groupWhereInput | service_groupWhereInput[]
    OR?: service_groupWhereInput[]
    NOT?: service_groupWhereInput | service_groupWhereInput[]
    id?: IntFilter<"service_group"> | number
    name?: StringFilter<"service_group"> | string
    name_rw?: StringNullableFilter<"service_group"> | string | null
    name_fr?: StringNullableFilter<"service_group"> | string | null
    name_sw?: StringNullableFilter<"service_group"> | string | null
    search_term?: StringNullableFilter<"service_group"> | string | null
    institution_id?: IntFilter<"service_group"> | number
    created_at?: DateTimeFilter<"service_group"> | Date | string
    updated_at?: DateTimeFilter<"service_group"> | Date | string
    uuid?: StringNullableFilter<"service_group"> | string | null
    status?: IntNullableFilter<"service_group"> | number | null
    good_ratings?: IntNullableFilter<"service_group"> | number | null
    bad_ratings?: IntNullableFilter<"service_group"> | number | null
    excellent_ratings?: IntNullableFilter<"service_group"> | number | null
    nps?: IntNullableFilter<"service_group"> | number | null
    csat?: IntNullableFilter<"service_group"> | number | null
    mean_service_time?: IntNullableFilter<"service_group"> | number | null
    ticket_prefix?: StringNullableFilter<"service_group"> | string | null
    bad_rating_threshold?: IntNullableFilter<"service_group"> | number | null
    service?: ServiceListRelationFilter
    serviceReview?: ServiceReviewListRelationFilter
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    surveyQuestions?: SurveyQuestionsListRelationFilter
  }

  export type service_groupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_rw?: SortOrderInput | SortOrder
    name_fr?: SortOrderInput | SortOrder
    name_sw?: SortOrderInput | SortOrder
    search_term?: SortOrderInput | SortOrder
    institution_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    good_ratings?: SortOrderInput | SortOrder
    bad_ratings?: SortOrderInput | SortOrder
    excellent_ratings?: SortOrderInput | SortOrder
    nps?: SortOrderInput | SortOrder
    csat?: SortOrderInput | SortOrder
    mean_service_time?: SortOrderInput | SortOrder
    ticket_prefix?: SortOrderInput | SortOrder
    bad_rating_threshold?: SortOrderInput | SortOrder
    service?: serviceOrderByRelationAggregateInput
    serviceReview?: serviceReviewOrderByRelationAggregateInput
    institution?: institutionOrderByWithRelationInput
    surveyQuestions?: surveyQuestionsOrderByRelationAggregateInput
    _relevance?: service_groupOrderByRelevanceInput
  }

  export type service_groupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: service_groupWhereInput | service_groupWhereInput[]
    OR?: service_groupWhereInput[]
    NOT?: service_groupWhereInput | service_groupWhereInput[]
    name?: StringFilter<"service_group"> | string
    name_rw?: StringNullableFilter<"service_group"> | string | null
    name_fr?: StringNullableFilter<"service_group"> | string | null
    name_sw?: StringNullableFilter<"service_group"> | string | null
    search_term?: StringNullableFilter<"service_group"> | string | null
    institution_id?: IntFilter<"service_group"> | number
    created_at?: DateTimeFilter<"service_group"> | Date | string
    updated_at?: DateTimeFilter<"service_group"> | Date | string
    uuid?: StringNullableFilter<"service_group"> | string | null
    status?: IntNullableFilter<"service_group"> | number | null
    good_ratings?: IntNullableFilter<"service_group"> | number | null
    bad_ratings?: IntNullableFilter<"service_group"> | number | null
    excellent_ratings?: IntNullableFilter<"service_group"> | number | null
    nps?: IntNullableFilter<"service_group"> | number | null
    csat?: IntNullableFilter<"service_group"> | number | null
    mean_service_time?: IntNullableFilter<"service_group"> | number | null
    ticket_prefix?: StringNullableFilter<"service_group"> | string | null
    bad_rating_threshold?: IntNullableFilter<"service_group"> | number | null
    service?: ServiceListRelationFilter
    serviceReview?: ServiceReviewListRelationFilter
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    surveyQuestions?: SurveyQuestionsListRelationFilter
  }, "id">

  export type service_groupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_rw?: SortOrderInput | SortOrder
    name_fr?: SortOrderInput | SortOrder
    name_sw?: SortOrderInput | SortOrder
    search_term?: SortOrderInput | SortOrder
    institution_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    good_ratings?: SortOrderInput | SortOrder
    bad_ratings?: SortOrderInput | SortOrder
    excellent_ratings?: SortOrderInput | SortOrder
    nps?: SortOrderInput | SortOrder
    csat?: SortOrderInput | SortOrder
    mean_service_time?: SortOrderInput | SortOrder
    ticket_prefix?: SortOrderInput | SortOrder
    bad_rating_threshold?: SortOrderInput | SortOrder
    _count?: service_groupCountOrderByAggregateInput
    _avg?: service_groupAvgOrderByAggregateInput
    _max?: service_groupMaxOrderByAggregateInput
    _min?: service_groupMinOrderByAggregateInput
    _sum?: service_groupSumOrderByAggregateInput
  }

  export type service_groupScalarWhereWithAggregatesInput = {
    AND?: service_groupScalarWhereWithAggregatesInput | service_groupScalarWhereWithAggregatesInput[]
    OR?: service_groupScalarWhereWithAggregatesInput[]
    NOT?: service_groupScalarWhereWithAggregatesInput | service_groupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"service_group"> | number
    name?: StringWithAggregatesFilter<"service_group"> | string
    name_rw?: StringNullableWithAggregatesFilter<"service_group"> | string | null
    name_fr?: StringNullableWithAggregatesFilter<"service_group"> | string | null
    name_sw?: StringNullableWithAggregatesFilter<"service_group"> | string | null
    search_term?: StringNullableWithAggregatesFilter<"service_group"> | string | null
    institution_id?: IntWithAggregatesFilter<"service_group"> | number
    created_at?: DateTimeWithAggregatesFilter<"service_group"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"service_group"> | Date | string
    uuid?: StringNullableWithAggregatesFilter<"service_group"> | string | null
    status?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    good_ratings?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    bad_ratings?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    excellent_ratings?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    nps?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    csat?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    mean_service_time?: IntNullableWithAggregatesFilter<"service_group"> | number | null
    ticket_prefix?: StringNullableWithAggregatesFilter<"service_group"> | string | null
    bad_rating_threshold?: IntNullableWithAggregatesFilter<"service_group"> | number | null
  }

  export type surveyWhereInput = {
    AND?: surveyWhereInput | surveyWhereInput[]
    OR?: surveyWhereInput[]
    NOT?: surveyWhereInput | surveyWhereInput[]
    id?: IntFilter<"survey"> | number
    uuid?: StringNullableFilter<"survey"> | string | null
    type?: BoolNullableFilter<"survey"> | boolean | null
    name?: StringFilter<"survey"> | string
    description?: StringFilter<"survey"> | string
    url?: StringNullableFilter<"survey"> | string | null
    survey_data?: StringNullableFilter<"survey"> | string | null
    institution_id?: IntFilter<"survey"> | number
    service_id?: StringFilter<"survey"> | string
    created_at?: DateTimeFilter<"survey"> | Date | string
    updated_at?: DateTimeFilter<"survey"> | Date | string
    status?: BoolNullableFilter<"survey"> | boolean | null
    access_key?: StringNullableFilter<"survey"> | string | null
  }

  export type surveyOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrderInput | SortOrder
    survey_data?: SortOrderInput | SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrderInput | SortOrder
    access_key?: SortOrderInput | SortOrder
    _relevance?: surveyOrderByRelevanceInput
  }

  export type surveyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: surveyWhereInput | surveyWhereInput[]
    OR?: surveyWhereInput[]
    NOT?: surveyWhereInput | surveyWhereInput[]
    uuid?: StringNullableFilter<"survey"> | string | null
    type?: BoolNullableFilter<"survey"> | boolean | null
    name?: StringFilter<"survey"> | string
    description?: StringFilter<"survey"> | string
    url?: StringNullableFilter<"survey"> | string | null
    survey_data?: StringNullableFilter<"survey"> | string | null
    institution_id?: IntFilter<"survey"> | number
    service_id?: StringFilter<"survey"> | string
    created_at?: DateTimeFilter<"survey"> | Date | string
    updated_at?: DateTimeFilter<"survey"> | Date | string
    status?: BoolNullableFilter<"survey"> | boolean | null
    access_key?: StringNullableFilter<"survey"> | string | null
  }, "id">

  export type surveyOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrderInput | SortOrder
    survey_data?: SortOrderInput | SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrderInput | SortOrder
    access_key?: SortOrderInput | SortOrder
    _count?: surveyCountOrderByAggregateInput
    _avg?: surveyAvgOrderByAggregateInput
    _max?: surveyMaxOrderByAggregateInput
    _min?: surveyMinOrderByAggregateInput
    _sum?: surveySumOrderByAggregateInput
  }

  export type surveyScalarWhereWithAggregatesInput = {
    AND?: surveyScalarWhereWithAggregatesInput | surveyScalarWhereWithAggregatesInput[]
    OR?: surveyScalarWhereWithAggregatesInput[]
    NOT?: surveyScalarWhereWithAggregatesInput | surveyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"survey"> | number
    uuid?: StringNullableWithAggregatesFilter<"survey"> | string | null
    type?: BoolNullableWithAggregatesFilter<"survey"> | boolean | null
    name?: StringWithAggregatesFilter<"survey"> | string
    description?: StringWithAggregatesFilter<"survey"> | string
    url?: StringNullableWithAggregatesFilter<"survey"> | string | null
    survey_data?: StringNullableWithAggregatesFilter<"survey"> | string | null
    institution_id?: IntWithAggregatesFilter<"survey"> | number
    service_id?: StringWithAggregatesFilter<"survey"> | string
    created_at?: DateTimeWithAggregatesFilter<"survey"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"survey"> | Date | string
    status?: BoolNullableWithAggregatesFilter<"survey"> | boolean | null
    access_key?: StringNullableWithAggregatesFilter<"survey"> | string | null
  }

  export type survey_resultWhereInput = {
    AND?: survey_resultWhereInput | survey_resultWhereInput[]
    OR?: survey_resultWhereInput[]
    NOT?: survey_resultWhereInput | survey_resultWhereInput[]
    id?: IntFilter<"survey_result"> | number
    survey_id?: IntFilter<"survey_result"> | number
    rating_id?: IntNullableFilter<"survey_result"> | number | null
    service_id?: IntNullableFilter<"survey_result"> | number | null
    device_id?: IntNullableFilter<"survey_result"> | number | null
    agent?: StringNullableFilter<"survey_result"> | string | null
    result_data?: StringFilter<"survey_result"> | string
    replied_at?: DateTimeNullableFilter<"survey_result"> | Date | string | null
  }

  export type survey_resultOrderByWithRelationInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    agent?: SortOrderInput | SortOrder
    result_data?: SortOrder
    replied_at?: SortOrderInput | SortOrder
    _relevance?: survey_resultOrderByRelevanceInput
  }

  export type survey_resultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: survey_resultWhereInput | survey_resultWhereInput[]
    OR?: survey_resultWhereInput[]
    NOT?: survey_resultWhereInput | survey_resultWhereInput[]
    survey_id?: IntFilter<"survey_result"> | number
    rating_id?: IntNullableFilter<"survey_result"> | number | null
    service_id?: IntNullableFilter<"survey_result"> | number | null
    device_id?: IntNullableFilter<"survey_result"> | number | null
    agent?: StringNullableFilter<"survey_result"> | string | null
    result_data?: StringFilter<"survey_result"> | string
    replied_at?: DateTimeNullableFilter<"survey_result"> | Date | string | null
  }, "id">

  export type survey_resultOrderByWithAggregationInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    agent?: SortOrderInput | SortOrder
    result_data?: SortOrder
    replied_at?: SortOrderInput | SortOrder
    _count?: survey_resultCountOrderByAggregateInput
    _avg?: survey_resultAvgOrderByAggregateInput
    _max?: survey_resultMaxOrderByAggregateInput
    _min?: survey_resultMinOrderByAggregateInput
    _sum?: survey_resultSumOrderByAggregateInput
  }

  export type survey_resultScalarWhereWithAggregatesInput = {
    AND?: survey_resultScalarWhereWithAggregatesInput | survey_resultScalarWhereWithAggregatesInput[]
    OR?: survey_resultScalarWhereWithAggregatesInput[]
    NOT?: survey_resultScalarWhereWithAggregatesInput | survey_resultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"survey_result"> | number
    survey_id?: IntWithAggregatesFilter<"survey_result"> | number
    rating_id?: IntNullableWithAggregatesFilter<"survey_result"> | number | null
    service_id?: IntNullableWithAggregatesFilter<"survey_result"> | number | null
    device_id?: IntNullableWithAggregatesFilter<"survey_result"> | number | null
    agent?: StringNullableWithAggregatesFilter<"survey_result"> | string | null
    result_data?: StringWithAggregatesFilter<"survey_result"> | string
    replied_at?: DateTimeNullableWithAggregatesFilter<"survey_result"> | Date | string | null
  }

  export type tagsWhereInput = {
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    id?: IntFilter<"tags"> | number
    name?: StringFilter<"tags"> | string
    services?: StringFilter<"tags"> | string
    created_at?: DateTimeNullableFilter<"tags"> | Date | string | null
    created_by?: IntFilter<"tags"> | number
    updated_by?: IntNullableFilter<"tags"> | number | null
    status?: BoolNullableFilter<"tags"> | boolean | null
    user_tags_created_byTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    user_tags_updated_byTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type tagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    services?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    user_tags_created_byTouser?: userOrderByWithRelationInput
    user_tags_updated_byTouser?: userOrderByWithRelationInput
    _relevance?: tagsOrderByRelevanceInput
  }

  export type tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    name?: StringFilter<"tags"> | string
    services?: StringFilter<"tags"> | string
    created_at?: DateTimeNullableFilter<"tags"> | Date | string | null
    created_by?: IntFilter<"tags"> | number
    updated_by?: IntNullableFilter<"tags"> | number | null
    status?: BoolNullableFilter<"tags"> | boolean | null
    user_tags_created_byTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    user_tags_updated_byTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type tagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    services?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_by?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: tagsCountOrderByAggregateInput
    _avg?: tagsAvgOrderByAggregateInput
    _max?: tagsMaxOrderByAggregateInput
    _min?: tagsMinOrderByAggregateInput
    _sum?: tagsSumOrderByAggregateInput
  }

  export type tagsScalarWhereWithAggregatesInput = {
    AND?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    OR?: tagsScalarWhereWithAggregatesInput[]
    NOT?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tags"> | number
    name?: StringWithAggregatesFilter<"tags"> | string
    services?: StringWithAggregatesFilter<"tags"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"tags"> | Date | string | null
    created_by?: IntWithAggregatesFilter<"tags"> | number
    updated_by?: IntNullableWithAggregatesFilter<"tags"> | number | null
    status?: BoolNullableWithAggregatesFilter<"tags"> | boolean | null
  }

  export type tipWhereInput = {
    AND?: tipWhereInput | tipWhereInput[]
    OR?: tipWhereInput[]
    NOT?: tipWhereInput | tipWhereInput[]
    id?: IntFilter<"tip"> | number
    collection_reference_id?: StringFilter<"tip"> | string
    disbursement_reference_id?: StringFilter<"tip"> | string
    device_id?: IntFilter<"tip"> | number
    rating_id?: BigIntNullableFilter<"tip"> | bigint | number | null
    payee?: StringFilter<"tip"> | string
    payer?: StringFilter<"tip"> | string
    amount?: IntFilter<"tip"> | number
    tip_amount?: IntFilter<"tip"> | number
    collection_status?: StringNullableFilter<"tip"> | string | null
    collection_status_details?: StringNullableFilter<"tip"> | string | null
    closed_at?: DateTimeNullableFilter<"tip"> | Date | string | null
    disbursed_at?: DateTimeNullableFilter<"tip"> | Date | string | null
    disbursement_status?: StringNullableFilter<"tip"> | string | null
    disbursement_status_details?: StringNullableFilter<"tip"> | string | null
    created_at?: DateTimeFilter<"tip"> | Date | string
    updated_at?: DateTimeFilter<"tip"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, deviceWhereInput>
    rating?: XOR<RatingNullableScalarRelationFilter, ratingWhereInput> | null
  }

  export type tipOrderByWithRelationInput = {
    id?: SortOrder
    collection_reference_id?: SortOrder
    disbursement_reference_id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrderInput | SortOrder
    payee?: SortOrder
    payer?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
    collection_status?: SortOrderInput | SortOrder
    collection_status_details?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    disbursed_at?: SortOrderInput | SortOrder
    disbursement_status?: SortOrderInput | SortOrder
    disbursement_status_details?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    device?: deviceOrderByWithRelationInput
    rating?: ratingOrderByWithRelationInput
    _relevance?: tipOrderByRelevanceInput
  }

  export type tipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipWhereInput | tipWhereInput[]
    OR?: tipWhereInput[]
    NOT?: tipWhereInput | tipWhereInput[]
    collection_reference_id?: StringFilter<"tip"> | string
    disbursement_reference_id?: StringFilter<"tip"> | string
    device_id?: IntFilter<"tip"> | number
    rating_id?: BigIntNullableFilter<"tip"> | bigint | number | null
    payee?: StringFilter<"tip"> | string
    payer?: StringFilter<"tip"> | string
    amount?: IntFilter<"tip"> | number
    tip_amount?: IntFilter<"tip"> | number
    collection_status?: StringNullableFilter<"tip"> | string | null
    collection_status_details?: StringNullableFilter<"tip"> | string | null
    closed_at?: DateTimeNullableFilter<"tip"> | Date | string | null
    disbursed_at?: DateTimeNullableFilter<"tip"> | Date | string | null
    disbursement_status?: StringNullableFilter<"tip"> | string | null
    disbursement_status_details?: StringNullableFilter<"tip"> | string | null
    created_at?: DateTimeFilter<"tip"> | Date | string
    updated_at?: DateTimeFilter<"tip"> | Date | string
    device?: XOR<DeviceScalarRelationFilter, deviceWhereInput>
    rating?: XOR<RatingNullableScalarRelationFilter, ratingWhereInput> | null
  }, "id">

  export type tipOrderByWithAggregationInput = {
    id?: SortOrder
    collection_reference_id?: SortOrder
    disbursement_reference_id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrderInput | SortOrder
    payee?: SortOrder
    payer?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
    collection_status?: SortOrderInput | SortOrder
    collection_status_details?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    disbursed_at?: SortOrderInput | SortOrder
    disbursement_status?: SortOrderInput | SortOrder
    disbursement_status_details?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tipCountOrderByAggregateInput
    _avg?: tipAvgOrderByAggregateInput
    _max?: tipMaxOrderByAggregateInput
    _min?: tipMinOrderByAggregateInput
    _sum?: tipSumOrderByAggregateInput
  }

  export type tipScalarWhereWithAggregatesInput = {
    AND?: tipScalarWhereWithAggregatesInput | tipScalarWhereWithAggregatesInput[]
    OR?: tipScalarWhereWithAggregatesInput[]
    NOT?: tipScalarWhereWithAggregatesInput | tipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tip"> | number
    collection_reference_id?: StringWithAggregatesFilter<"tip"> | string
    disbursement_reference_id?: StringWithAggregatesFilter<"tip"> | string
    device_id?: IntWithAggregatesFilter<"tip"> | number
    rating_id?: BigIntNullableWithAggregatesFilter<"tip"> | bigint | number | null
    payee?: StringWithAggregatesFilter<"tip"> | string
    payer?: StringWithAggregatesFilter<"tip"> | string
    amount?: IntWithAggregatesFilter<"tip"> | number
    tip_amount?: IntWithAggregatesFilter<"tip"> | number
    collection_status?: StringNullableWithAggregatesFilter<"tip"> | string | null
    collection_status_details?: StringNullableWithAggregatesFilter<"tip"> | string | null
    closed_at?: DateTimeNullableWithAggregatesFilter<"tip"> | Date | string | null
    disbursed_at?: DateTimeNullableWithAggregatesFilter<"tip"> | Date | string | null
    disbursement_status?: StringNullableWithAggregatesFilter<"tip"> | string | null
    disbursement_status_details?: StringNullableWithAggregatesFilter<"tip"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"tip"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tip"> | Date | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    name?: StringNullableFilter<"user"> | string | null
    title?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    username?: StringFilter<"user"> | string
    auth_key?: StringFilter<"user"> | string
    password_hash?: StringFilter<"user"> | string
    password_reset_token?: StringNullableFilter<"user"> | string | null
    email?: StringNullableFilter<"user"> | string | null
    status?: BoolFilter<"user"> | boolean
    role?: BoolFilter<"user"> | boolean
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    verification_token?: StringNullableFilter<"user"> | string | null
    allowed_context?: IntNullableFilter<"user"> | number | null
    institution_id?: StringNullableFilter<"user"> | string | null
    last_received_hb_alert_at?: DateTimeFilter<"user"> | Date | string
    last_received_rating_notification_at?: DateTimeFilter<"user"> | Date | string
    language?: StringNullableFilter<"user"> | string | null
    notifications_enabled?: BoolNullableFilter<"user"> | boolean | null
    last_login?: DateTimeNullableFilter<"user"> | Date | string | null
    allow_auto_approved_changes?: BoolNullableFilter<"user"> | boolean | null
    appointments_appointments_creator_idTouser?: AppointmentsListRelationFilter
    appointments_appointments_user_idTouser?: AppointmentsListRelationFilter
    tags_tags_created_byTouser?: TagsListRelationFilter
    tags_tags_updated_byTouser?: TagsListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    username?: SortOrder
    auth_key?: SortOrder
    password_hash?: SortOrder
    password_reset_token?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verification_token?: SortOrderInput | SortOrder
    allowed_context?: SortOrderInput | SortOrder
    institution_id?: SortOrderInput | SortOrder
    last_received_hb_alert_at?: SortOrder
    last_received_rating_notification_at?: SortOrder
    language?: SortOrderInput | SortOrder
    notifications_enabled?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    allow_auto_approved_changes?: SortOrderInput | SortOrder
    appointments_appointments_creator_idTouser?: appointmentsOrderByRelationAggregateInput
    appointments_appointments_user_idTouser?: appointmentsOrderByRelationAggregateInput
    tags_tags_created_byTouser?: tagsOrderByRelationAggregateInput
    tags_tags_updated_byTouser?: tagsOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    password_reset_token?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringNullableFilter<"user"> | string | null
    title?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    auth_key?: StringFilter<"user"> | string
    password_hash?: StringFilter<"user"> | string
    status?: BoolFilter<"user"> | boolean
    role?: BoolFilter<"user"> | boolean
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    verification_token?: StringNullableFilter<"user"> | string | null
    allowed_context?: IntNullableFilter<"user"> | number | null
    institution_id?: StringNullableFilter<"user"> | string | null
    last_received_hb_alert_at?: DateTimeFilter<"user"> | Date | string
    last_received_rating_notification_at?: DateTimeFilter<"user"> | Date | string
    language?: StringNullableFilter<"user"> | string | null
    notifications_enabled?: BoolNullableFilter<"user"> | boolean | null
    last_login?: DateTimeNullableFilter<"user"> | Date | string | null
    allow_auto_approved_changes?: BoolNullableFilter<"user"> | boolean | null
    appointments_appointments_creator_idTouser?: AppointmentsListRelationFilter
    appointments_appointments_user_idTouser?: AppointmentsListRelationFilter
    tags_tags_created_byTouser?: TagsListRelationFilter
    tags_tags_updated_byTouser?: TagsListRelationFilter
  }, "id" | "username" | "password_reset_token" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    username?: SortOrder
    auth_key?: SortOrder
    password_hash?: SortOrder
    password_reset_token?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verification_token?: SortOrderInput | SortOrder
    allowed_context?: SortOrderInput | SortOrder
    institution_id?: SortOrderInput | SortOrder
    last_received_hb_alert_at?: SortOrder
    last_received_rating_notification_at?: SortOrder
    language?: SortOrderInput | SortOrder
    notifications_enabled?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    allow_auto_approved_changes?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    name?: StringNullableWithAggregatesFilter<"user"> | string | null
    title?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"user"> | string | null
    username?: StringWithAggregatesFilter<"user"> | string
    auth_key?: StringWithAggregatesFilter<"user"> | string
    password_hash?: StringWithAggregatesFilter<"user"> | string
    password_reset_token?: StringNullableWithAggregatesFilter<"user"> | string | null
    email?: StringNullableWithAggregatesFilter<"user"> | string | null
    status?: BoolWithAggregatesFilter<"user"> | boolean
    role?: BoolWithAggregatesFilter<"user"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    verification_token?: StringNullableWithAggregatesFilter<"user"> | string | null
    allowed_context?: IntNullableWithAggregatesFilter<"user"> | number | null
    institution_id?: StringNullableWithAggregatesFilter<"user"> | string | null
    last_received_hb_alert_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    last_received_rating_notification_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    language?: StringNullableWithAggregatesFilter<"user"> | string | null
    notifications_enabled?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    allow_auto_approved_changes?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
  }

  export type wallet_accountsWhereInput = {
    AND?: wallet_accountsWhereInput | wallet_accountsWhereInput[]
    OR?: wallet_accountsWhereInput[]
    NOT?: wallet_accountsWhereInput | wallet_accountsWhereInput[]
    id?: IntFilter<"wallet_accounts"> | number
    user_id?: IntNullableFilter<"wallet_accounts"> | number | null
    account_type_id?: IntNullableFilter<"wallet_accounts"> | number | null
    account_number?: StringNullableFilter<"wallet_accounts"> | string | null
    account_name?: StringNullableFilter<"wallet_accounts"> | string | null
    balance?: FloatNullableFilter<"wallet_accounts"> | number | null
    public_key?: StringNullableFilter<"wallet_accounts"> | string | null
    private_key?: StringNullableFilter<"wallet_accounts"> | string | null
    added_at?: DateTimeFilter<"wallet_accounts"> | Date | string
  }

  export type wallet_accountsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    account_type_id?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    public_key?: SortOrderInput | SortOrder
    private_key?: SortOrderInput | SortOrder
    added_at?: SortOrder
    _relevance?: wallet_accountsOrderByRelevanceInput
  }

  export type wallet_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wallet_accountsWhereInput | wallet_accountsWhereInput[]
    OR?: wallet_accountsWhereInput[]
    NOT?: wallet_accountsWhereInput | wallet_accountsWhereInput[]
    user_id?: IntNullableFilter<"wallet_accounts"> | number | null
    account_type_id?: IntNullableFilter<"wallet_accounts"> | number | null
    account_number?: StringNullableFilter<"wallet_accounts"> | string | null
    account_name?: StringNullableFilter<"wallet_accounts"> | string | null
    balance?: FloatNullableFilter<"wallet_accounts"> | number | null
    public_key?: StringNullableFilter<"wallet_accounts"> | string | null
    private_key?: StringNullableFilter<"wallet_accounts"> | string | null
    added_at?: DateTimeFilter<"wallet_accounts"> | Date | string
  }, "id">

  export type wallet_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    account_type_id?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    public_key?: SortOrderInput | SortOrder
    private_key?: SortOrderInput | SortOrder
    added_at?: SortOrder
    _count?: wallet_accountsCountOrderByAggregateInput
    _avg?: wallet_accountsAvgOrderByAggregateInput
    _max?: wallet_accountsMaxOrderByAggregateInput
    _min?: wallet_accountsMinOrderByAggregateInput
    _sum?: wallet_accountsSumOrderByAggregateInput
  }

  export type wallet_accountsScalarWhereWithAggregatesInput = {
    AND?: wallet_accountsScalarWhereWithAggregatesInput | wallet_accountsScalarWhereWithAggregatesInput[]
    OR?: wallet_accountsScalarWhereWithAggregatesInput[]
    NOT?: wallet_accountsScalarWhereWithAggregatesInput | wallet_accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_accounts"> | number
    user_id?: IntNullableWithAggregatesFilter<"wallet_accounts"> | number | null
    account_type_id?: IntNullableWithAggregatesFilter<"wallet_accounts"> | number | null
    account_number?: StringNullableWithAggregatesFilter<"wallet_accounts"> | string | null
    account_name?: StringNullableWithAggregatesFilter<"wallet_accounts"> | string | null
    balance?: FloatNullableWithAggregatesFilter<"wallet_accounts"> | number | null
    public_key?: StringNullableWithAggregatesFilter<"wallet_accounts"> | string | null
    private_key?: StringNullableWithAggregatesFilter<"wallet_accounts"> | string | null
    added_at?: DateTimeWithAggregatesFilter<"wallet_accounts"> | Date | string
  }

  export type wallet_accounts_typesWhereInput = {
    AND?: wallet_accounts_typesWhereInput | wallet_accounts_typesWhereInput[]
    OR?: wallet_accounts_typesWhereInput[]
    NOT?: wallet_accounts_typesWhereInput | wallet_accounts_typesWhereInput[]
    id?: IntFilter<"wallet_accounts_types"> | number
    category?: StringNullableFilter<"wallet_accounts_types"> | string | null
    abbreviation?: StringNullableFilter<"wallet_accounts_types"> | string | null
    name?: StringNullableFilter<"wallet_accounts_types"> | string | null
    added_at?: DateTimeFilter<"wallet_accounts_types"> | Date | string
  }

  export type wallet_accounts_typesOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrderInput | SortOrder
    abbreviation?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    added_at?: SortOrder
    _relevance?: wallet_accounts_typesOrderByRelevanceInput
  }

  export type wallet_accounts_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wallet_accounts_typesWhereInput | wallet_accounts_typesWhereInput[]
    OR?: wallet_accounts_typesWhereInput[]
    NOT?: wallet_accounts_typesWhereInput | wallet_accounts_typesWhereInput[]
    category?: StringNullableFilter<"wallet_accounts_types"> | string | null
    abbreviation?: StringNullableFilter<"wallet_accounts_types"> | string | null
    name?: StringNullableFilter<"wallet_accounts_types"> | string | null
    added_at?: DateTimeFilter<"wallet_accounts_types"> | Date | string
  }, "id">

  export type wallet_accounts_typesOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrderInput | SortOrder
    abbreviation?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    added_at?: SortOrder
    _count?: wallet_accounts_typesCountOrderByAggregateInput
    _avg?: wallet_accounts_typesAvgOrderByAggregateInput
    _max?: wallet_accounts_typesMaxOrderByAggregateInput
    _min?: wallet_accounts_typesMinOrderByAggregateInput
    _sum?: wallet_accounts_typesSumOrderByAggregateInput
  }

  export type wallet_accounts_typesScalarWhereWithAggregatesInput = {
    AND?: wallet_accounts_typesScalarWhereWithAggregatesInput | wallet_accounts_typesScalarWhereWithAggregatesInput[]
    OR?: wallet_accounts_typesScalarWhereWithAggregatesInput[]
    NOT?: wallet_accounts_typesScalarWhereWithAggregatesInput | wallet_accounts_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_accounts_types"> | number
    category?: StringNullableWithAggregatesFilter<"wallet_accounts_types"> | string | null
    abbreviation?: StringNullableWithAggregatesFilter<"wallet_accounts_types"> | string | null
    name?: StringNullableWithAggregatesFilter<"wallet_accounts_types"> | string | null
    added_at?: DateTimeWithAggregatesFilter<"wallet_accounts_types"> | Date | string
  }

  export type wallet_transfersWhereInput = {
    AND?: wallet_transfersWhereInput | wallet_transfersWhereInput[]
    OR?: wallet_transfersWhereInput[]
    NOT?: wallet_transfersWhereInput | wallet_transfersWhereInput[]
    id?: IntFilter<"wallet_transfers"> | number
    amount?: FloatNullableFilter<"wallet_transfers"> | number | null
    currency?: StringNullableFilter<"wallet_transfers"> | string | null
    time?: DateTimeNullableFilter<"wallet_transfers"> | Date | string | null
    payer_id?: IntNullableFilter<"wallet_transfers"> | number | null
    payer_account_id?: IntNullableFilter<"wallet_transfers"> | number | null
    payee_address?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_name?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_account_type?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_account_number?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_type?: StringNullableFilter<"wallet_transfers"> | string | null
    tx_id?: StringNullableFilter<"wallet_transfers"> | string | null
    fspid?: StringNullableFilter<"wallet_transfers"> | string | null
    ext_trx_id?: StringNullableFilter<"wallet_transfers"> | string | null
    pay_money_ext_res?: StringNullableFilter<"wallet_transfers"> | string | null
    confirm_party_ext_res?: StringNullableFilter<"wallet_transfers"> | string | null
    confirm_quote_ext_res?: StringNullableFilter<"wallet_transfers"> | string | null
    status?: StringNullableFilter<"wallet_transfers"> | string | null
    quote_id?: StringNullableFilter<"wallet_transfers"> | string | null
    note?: StringNullableFilter<"wallet_transfers"> | string | null
    transfer_fees?: StringNullableFilter<"wallet_transfers"> | string | null
  }

  export type wallet_transfersOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    payer_id?: SortOrderInput | SortOrder
    payer_account_id?: SortOrderInput | SortOrder
    payee_address?: SortOrderInput | SortOrder
    payee_name?: SortOrderInput | SortOrder
    payee_account_type?: SortOrderInput | SortOrder
    payee_account_number?: SortOrderInput | SortOrder
    payee_type?: SortOrderInput | SortOrder
    tx_id?: SortOrderInput | SortOrder
    fspid?: SortOrderInput | SortOrder
    ext_trx_id?: SortOrderInput | SortOrder
    pay_money_ext_res?: SortOrderInput | SortOrder
    confirm_party_ext_res?: SortOrderInput | SortOrder
    confirm_quote_ext_res?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    quote_id?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    transfer_fees?: SortOrderInput | SortOrder
    _relevance?: wallet_transfersOrderByRelevanceInput
  }

  export type wallet_transfersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wallet_transfersWhereInput | wallet_transfersWhereInput[]
    OR?: wallet_transfersWhereInput[]
    NOT?: wallet_transfersWhereInput | wallet_transfersWhereInput[]
    amount?: FloatNullableFilter<"wallet_transfers"> | number | null
    currency?: StringNullableFilter<"wallet_transfers"> | string | null
    time?: DateTimeNullableFilter<"wallet_transfers"> | Date | string | null
    payer_id?: IntNullableFilter<"wallet_transfers"> | number | null
    payer_account_id?: IntNullableFilter<"wallet_transfers"> | number | null
    payee_address?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_name?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_account_type?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_account_number?: StringNullableFilter<"wallet_transfers"> | string | null
    payee_type?: StringNullableFilter<"wallet_transfers"> | string | null
    tx_id?: StringNullableFilter<"wallet_transfers"> | string | null
    fspid?: StringNullableFilter<"wallet_transfers"> | string | null
    ext_trx_id?: StringNullableFilter<"wallet_transfers"> | string | null
    pay_money_ext_res?: StringNullableFilter<"wallet_transfers"> | string | null
    confirm_party_ext_res?: StringNullableFilter<"wallet_transfers"> | string | null
    confirm_quote_ext_res?: StringNullableFilter<"wallet_transfers"> | string | null
    status?: StringNullableFilter<"wallet_transfers"> | string | null
    quote_id?: StringNullableFilter<"wallet_transfers"> | string | null
    note?: StringNullableFilter<"wallet_transfers"> | string | null
    transfer_fees?: StringNullableFilter<"wallet_transfers"> | string | null
  }, "id">

  export type wallet_transfersOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    payer_id?: SortOrderInput | SortOrder
    payer_account_id?: SortOrderInput | SortOrder
    payee_address?: SortOrderInput | SortOrder
    payee_name?: SortOrderInput | SortOrder
    payee_account_type?: SortOrderInput | SortOrder
    payee_account_number?: SortOrderInput | SortOrder
    payee_type?: SortOrderInput | SortOrder
    tx_id?: SortOrderInput | SortOrder
    fspid?: SortOrderInput | SortOrder
    ext_trx_id?: SortOrderInput | SortOrder
    pay_money_ext_res?: SortOrderInput | SortOrder
    confirm_party_ext_res?: SortOrderInput | SortOrder
    confirm_quote_ext_res?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    quote_id?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    transfer_fees?: SortOrderInput | SortOrder
    _count?: wallet_transfersCountOrderByAggregateInput
    _avg?: wallet_transfersAvgOrderByAggregateInput
    _max?: wallet_transfersMaxOrderByAggregateInput
    _min?: wallet_transfersMinOrderByAggregateInput
    _sum?: wallet_transfersSumOrderByAggregateInput
  }

  export type wallet_transfersScalarWhereWithAggregatesInput = {
    AND?: wallet_transfersScalarWhereWithAggregatesInput | wallet_transfersScalarWhereWithAggregatesInput[]
    OR?: wallet_transfersScalarWhereWithAggregatesInput[]
    NOT?: wallet_transfersScalarWhereWithAggregatesInput | wallet_transfersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_transfers"> | number
    amount?: FloatNullableWithAggregatesFilter<"wallet_transfers"> | number | null
    currency?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    time?: DateTimeNullableWithAggregatesFilter<"wallet_transfers"> | Date | string | null
    payer_id?: IntNullableWithAggregatesFilter<"wallet_transfers"> | number | null
    payer_account_id?: IntNullableWithAggregatesFilter<"wallet_transfers"> | number | null
    payee_address?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    payee_name?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    payee_account_type?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    payee_account_number?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    payee_type?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    tx_id?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    fspid?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    ext_trx_id?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    pay_money_ext_res?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    confirm_party_ext_res?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    confirm_quote_ext_res?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    status?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    quote_id?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    note?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
    transfer_fees?: StringNullableWithAggregatesFilter<"wallet_transfers"> | string | null
  }

  export type wallet_usersWhereInput = {
    AND?: wallet_usersWhereInput | wallet_usersWhereInput[]
    OR?: wallet_usersWhereInput[]
    NOT?: wallet_usersWhereInput | wallet_usersWhereInput[]
    id?: IntFilter<"wallet_users"> | number
    device_id?: IntNullableFilter<"wallet_users"> | number | null
    fullname?: StringNullableFilter<"wallet_users"> | string | null
    email?: StringNullableFilter<"wallet_users"> | string | null
    private_key?: StringNullableFilter<"wallet_users"> | string | null
    public_key?: StringNullableFilter<"wallet_users"> | string | null
    initiated_at?: DateTimeFilter<"wallet_users"> | Date | string
  }

  export type wallet_usersOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    private_key?: SortOrderInput | SortOrder
    public_key?: SortOrderInput | SortOrder
    initiated_at?: SortOrder
    _relevance?: wallet_usersOrderByRelevanceInput
  }

  export type wallet_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wallet_usersWhereInput | wallet_usersWhereInput[]
    OR?: wallet_usersWhereInput[]
    NOT?: wallet_usersWhereInput | wallet_usersWhereInput[]
    device_id?: IntNullableFilter<"wallet_users"> | number | null
    fullname?: StringNullableFilter<"wallet_users"> | string | null
    email?: StringNullableFilter<"wallet_users"> | string | null
    private_key?: StringNullableFilter<"wallet_users"> | string | null
    public_key?: StringNullableFilter<"wallet_users"> | string | null
    initiated_at?: DateTimeFilter<"wallet_users"> | Date | string
  }, "id">

  export type wallet_usersOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    private_key?: SortOrderInput | SortOrder
    public_key?: SortOrderInput | SortOrder
    initiated_at?: SortOrder
    _count?: wallet_usersCountOrderByAggregateInput
    _avg?: wallet_usersAvgOrderByAggregateInput
    _max?: wallet_usersMaxOrderByAggregateInput
    _min?: wallet_usersMinOrderByAggregateInput
    _sum?: wallet_usersSumOrderByAggregateInput
  }

  export type wallet_usersScalarWhereWithAggregatesInput = {
    AND?: wallet_usersScalarWhereWithAggregatesInput | wallet_usersScalarWhereWithAggregatesInput[]
    OR?: wallet_usersScalarWhereWithAggregatesInput[]
    NOT?: wallet_usersScalarWhereWithAggregatesInput | wallet_usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_users"> | number
    device_id?: IntNullableWithAggregatesFilter<"wallet_users"> | number | null
    fullname?: StringNullableWithAggregatesFilter<"wallet_users"> | string | null
    email?: StringNullableWithAggregatesFilter<"wallet_users"> | string | null
    private_key?: StringNullableWithAggregatesFilter<"wallet_users"> | string | null
    public_key?: StringNullableWithAggregatesFilter<"wallet_users"> | string | null
    initiated_at?: DateTimeWithAggregatesFilter<"wallet_users"> | Date | string
  }

  export type imagesWhereInput = {
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    id?: IntFilter<"images"> | number
    institution_id?: IntNullableFilter<"images"> | number | null
    user_id?: IntNullableFilter<"images"> | number | null
    type?: StringNullableFilter<"images"> | string | null
    image_url?: StringNullableFilter<"images"> | string | null
    caption?: StringNullableFilter<"images"> | string | null
    uploaded_at?: DateTimeFilter<"images"> | Date | string
    review_id?: IntNullableFilter<"images"> | number | null
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    reviews?: XOR<ReviewsNullableScalarRelationFilter, reviewsWhereInput> | null
    users_profile?: XOR<Users_profileNullableScalarRelationFilter, users_profileWhereInput> | null
  }

  export type imagesOrderByWithRelationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    uploaded_at?: SortOrder
    review_id?: SortOrderInput | SortOrder
    institution?: institutionOrderByWithRelationInput
    reviews?: reviewsOrderByWithRelationInput
    users_profile?: users_profileOrderByWithRelationInput
    _relevance?: imagesOrderByRelevanceInput
  }

  export type imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: imagesWhereInput | imagesWhereInput[]
    OR?: imagesWhereInput[]
    NOT?: imagesWhereInput | imagesWhereInput[]
    institution_id?: IntNullableFilter<"images"> | number | null
    user_id?: IntNullableFilter<"images"> | number | null
    type?: StringNullableFilter<"images"> | string | null
    image_url?: StringNullableFilter<"images"> | string | null
    caption?: StringNullableFilter<"images"> | string | null
    uploaded_at?: DateTimeFilter<"images"> | Date | string
    review_id?: IntNullableFilter<"images"> | number | null
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
    reviews?: XOR<ReviewsNullableScalarRelationFilter, reviewsWhereInput> | null
    users_profile?: XOR<Users_profileNullableScalarRelationFilter, users_profileWhereInput> | null
  }, "id">

  export type imagesOrderByWithAggregationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    uploaded_at?: SortOrder
    review_id?: SortOrderInput | SortOrder
    _count?: imagesCountOrderByAggregateInput
    _avg?: imagesAvgOrderByAggregateInput
    _max?: imagesMaxOrderByAggregateInput
    _min?: imagesMinOrderByAggregateInput
    _sum?: imagesSumOrderByAggregateInput
  }

  export type imagesScalarWhereWithAggregatesInput = {
    AND?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    OR?: imagesScalarWhereWithAggregatesInput[]
    NOT?: imagesScalarWhereWithAggregatesInput | imagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"images"> | number
    institution_id?: IntNullableWithAggregatesFilter<"images"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"images"> | number | null
    type?: StringNullableWithAggregatesFilter<"images"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"images"> | string | null
    caption?: StringNullableWithAggregatesFilter<"images"> | string | null
    uploaded_at?: DateTimeWithAggregatesFilter<"images"> | Date | string
    review_id?: IntNullableWithAggregatesFilter<"images"> | number | null
  }

  export type sectorsWhereInput = {
    AND?: sectorsWhereInput | sectorsWhereInput[]
    OR?: sectorsWhereInput[]
    NOT?: sectorsWhereInput | sectorsWhereInput[]
    id?: IntFilter<"sectors"> | number
    name?: StringNullableFilter<"sectors"> | string | null
    description?: StringNullableFilter<"sectors"> | string | null
    categories?: CategoriesListRelationFilter
  }

  export type sectorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    categories?: categoriesOrderByRelationAggregateInput
    _relevance?: sectorsOrderByRelevanceInput
  }

  export type sectorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sectorsWhereInput | sectorsWhereInput[]
    OR?: sectorsWhereInput[]
    NOT?: sectorsWhereInput | sectorsWhereInput[]
    name?: StringNullableFilter<"sectors"> | string | null
    description?: StringNullableFilter<"sectors"> | string | null
    categories?: CategoriesListRelationFilter
  }, "id">

  export type sectorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: sectorsCountOrderByAggregateInput
    _avg?: sectorsAvgOrderByAggregateInput
    _max?: sectorsMaxOrderByAggregateInput
    _min?: sectorsMinOrderByAggregateInput
    _sum?: sectorsSumOrderByAggregateInput
  }

  export type sectorsScalarWhereWithAggregatesInput = {
    AND?: sectorsScalarWhereWithAggregatesInput | sectorsScalarWhereWithAggregatesInput[]
    OR?: sectorsScalarWhereWithAggregatesInput[]
    NOT?: sectorsScalarWhereWithAggregatesInput | sectorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sectors"> | number
    name?: StringNullableWithAggregatesFilter<"sectors"> | string | null
    description?: StringNullableWithAggregatesFilter<"sectors"> | string | null
  }

  export type users_profileWhereInput = {
    AND?: users_profileWhereInput | users_profileWhereInput[]
    OR?: users_profileWhereInput[]
    NOT?: users_profileWhereInput | users_profileWhereInput[]
    id?: IntFilter<"users_profile"> | number
    first_name?: StringFilter<"users_profile"> | string
    last_name?: StringFilter<"users_profile"> | string
    email?: StringFilter<"users_profile"> | string
    password?: StringFilter<"users_profile"> | string
    phone_number?: StringNullableFilter<"users_profile"> | string | null
    age_group?: StringNullableFilter<"users_profile"> | string | null
    gender?: StringNullableFilter<"users_profile"> | string | null
    address?: StringNullableFilter<"users_profile"> | string | null
    added_at?: DateTimeFilter<"users_profile"> | Date | string
    isVerified?: BoolNullableFilter<"users_profile"> | boolean | null
    verifyToken?: StringNullableFilter<"users_profile"> | string | null
    images?: ImagesListRelationFilter
    reviews?: ReviewsListRelationFilter
    serviceReview?: ServiceReviewListRelationFilter
  }

  export type users_profileOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    age_group?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    added_at?: SortOrder
    isVerified?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    images?: imagesOrderByRelationAggregateInput
    reviews?: reviewsOrderByRelationAggregateInput
    serviceReview?: serviceReviewOrderByRelationAggregateInput
    _relevance?: users_profileOrderByRelevanceInput
  }

  export type users_profileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: users_profileWhereInput | users_profileWhereInput[]
    OR?: users_profileWhereInput[]
    NOT?: users_profileWhereInput | users_profileWhereInput[]
    first_name?: StringFilter<"users_profile"> | string
    last_name?: StringFilter<"users_profile"> | string
    password?: StringFilter<"users_profile"> | string
    phone_number?: StringNullableFilter<"users_profile"> | string | null
    age_group?: StringNullableFilter<"users_profile"> | string | null
    gender?: StringNullableFilter<"users_profile"> | string | null
    address?: StringNullableFilter<"users_profile"> | string | null
    added_at?: DateTimeFilter<"users_profile"> | Date | string
    isVerified?: BoolNullableFilter<"users_profile"> | boolean | null
    verifyToken?: StringNullableFilter<"users_profile"> | string | null
    images?: ImagesListRelationFilter
    reviews?: ReviewsListRelationFilter
    serviceReview?: ServiceReviewListRelationFilter
  }, "id" | "email">

  export type users_profileOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    age_group?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    added_at?: SortOrder
    isVerified?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    _count?: users_profileCountOrderByAggregateInput
    _avg?: users_profileAvgOrderByAggregateInput
    _max?: users_profileMaxOrderByAggregateInput
    _min?: users_profileMinOrderByAggregateInput
    _sum?: users_profileSumOrderByAggregateInput
  }

  export type users_profileScalarWhereWithAggregatesInput = {
    AND?: users_profileScalarWhereWithAggregatesInput | users_profileScalarWhereWithAggregatesInput[]
    OR?: users_profileScalarWhereWithAggregatesInput[]
    NOT?: users_profileScalarWhereWithAggregatesInput | users_profileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users_profile"> | number
    first_name?: StringWithAggregatesFilter<"users_profile"> | string
    last_name?: StringWithAggregatesFilter<"users_profile"> | string
    email?: StringWithAggregatesFilter<"users_profile"> | string
    password?: StringWithAggregatesFilter<"users_profile"> | string
    phone_number?: StringNullableWithAggregatesFilter<"users_profile"> | string | null
    age_group?: StringNullableWithAggregatesFilter<"users_profile"> | string | null
    gender?: StringNullableWithAggregatesFilter<"users_profile"> | string | null
    address?: StringNullableWithAggregatesFilter<"users_profile"> | string | null
    added_at?: DateTimeWithAggregatesFilter<"users_profile"> | Date | string
    isVerified?: BoolNullableWithAggregatesFilter<"users_profile"> | boolean | null
    verifyToken?: StringNullableWithAggregatesFilter<"users_profile"> | string | null
  }

  export type reviewsWhereInput = {
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id?: IntFilter<"reviews"> | number
    user_id?: IntFilter<"reviews"> | number
    institution_id?: IntFilter<"reviews"> | number
    rating?: IntFilter<"reviews"> | number
    review?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeFilter<"reviews"> | Date | string
    is_approved?: BoolNullableFilter<"reviews"> | boolean | null
    images?: ImagesListRelationFilter
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    users_profile?: XOR<Users_profileScalarRelationFilter, users_profileWhereInput>
  }

  export type reviewsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_approved?: SortOrderInput | SortOrder
    images?: imagesOrderByRelationAggregateInput
    institution?: institutionOrderByWithRelationInput
    users_profile?: users_profileOrderByWithRelationInput
    _relevance?: reviewsOrderByRelevanceInput
  }

  export type reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    user_id?: IntFilter<"reviews"> | number
    institution_id?: IntFilter<"reviews"> | number
    rating?: IntFilter<"reviews"> | number
    review?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeFilter<"reviews"> | Date | string
    is_approved?: BoolNullableFilter<"reviews"> | boolean | null
    images?: ImagesListRelationFilter
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
    users_profile?: XOR<Users_profileScalarRelationFilter, users_profileWhereInput>
  }, "id">

  export type reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_approved?: SortOrderInput | SortOrder
    _count?: reviewsCountOrderByAggregateInput
    _avg?: reviewsAvgOrderByAggregateInput
    _max?: reviewsMaxOrderByAggregateInput
    _min?: reviewsMinOrderByAggregateInput
    _sum?: reviewsSumOrderByAggregateInput
  }

  export type reviewsScalarWhereWithAggregatesInput = {
    AND?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    OR?: reviewsScalarWhereWithAggregatesInput[]
    NOT?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reviews"> | number
    user_id?: IntWithAggregatesFilter<"reviews"> | number
    institution_id?: IntWithAggregatesFilter<"reviews"> | number
    rating?: IntWithAggregatesFilter<"reviews"> | number
    review?: StringNullableWithAggregatesFilter<"reviews"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"reviews"> | Date | string
    is_approved?: BoolNullableWithAggregatesFilter<"reviews"> | boolean | null
  }

  export type workingHourWhereInput = {
    AND?: workingHourWhereInput | workingHourWhereInput[]
    OR?: workingHourWhereInput[]
    NOT?: workingHourWhereInput | workingHourWhereInput[]
    id?: IntFilter<"workingHour"> | number
    institution_id?: IntFilter<"workingHour"> | number
    day_of_week?: StringFilter<"workingHour"> | string
    open_time?: DateTimeNullableFilter<"workingHour"> | Date | string | null
    close_time?: DateTimeNullableFilter<"workingHour"> | Date | string | null
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
  }

  export type workingHourOrderByWithRelationInput = {
    id?: SortOrder
    institution_id?: SortOrder
    day_of_week?: SortOrder
    open_time?: SortOrderInput | SortOrder
    close_time?: SortOrderInput | SortOrder
    institution?: institutionOrderByWithRelationInput
    _relevance?: workingHourOrderByRelevanceInput
  }

  export type workingHourWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: workingHourWhereInput | workingHourWhereInput[]
    OR?: workingHourWhereInput[]
    NOT?: workingHourWhereInput | workingHourWhereInput[]
    institution_id?: IntFilter<"workingHour"> | number
    day_of_week?: StringFilter<"workingHour"> | string
    open_time?: DateTimeNullableFilter<"workingHour"> | Date | string | null
    close_time?: DateTimeNullableFilter<"workingHour"> | Date | string | null
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
  }, "id">

  export type workingHourOrderByWithAggregationInput = {
    id?: SortOrder
    institution_id?: SortOrder
    day_of_week?: SortOrder
    open_time?: SortOrderInput | SortOrder
    close_time?: SortOrderInput | SortOrder
    _count?: workingHourCountOrderByAggregateInput
    _avg?: workingHourAvgOrderByAggregateInput
    _max?: workingHourMaxOrderByAggregateInput
    _min?: workingHourMinOrderByAggregateInput
    _sum?: workingHourSumOrderByAggregateInput
  }

  export type workingHourScalarWhereWithAggregatesInput = {
    AND?: workingHourScalarWhereWithAggregatesInput | workingHourScalarWhereWithAggregatesInput[]
    OR?: workingHourScalarWhereWithAggregatesInput[]
    NOT?: workingHourScalarWhereWithAggregatesInput | workingHourScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"workingHour"> | number
    institution_id?: IntWithAggregatesFilter<"workingHour"> | number
    day_of_week?: StringWithAggregatesFilter<"workingHour"> | string
    open_time?: DateTimeNullableWithAggregatesFilter<"workingHour"> | Date | string | null
    close_time?: DateTimeNullableWithAggregatesFilter<"workingHour"> | Date | string | null
  }

  export type amenitiesWhereInput = {
    AND?: amenitiesWhereInput | amenitiesWhereInput[]
    OR?: amenitiesWhereInput[]
    NOT?: amenitiesWhereInput | amenitiesWhereInput[]
    id?: IntFilter<"amenities"> | number
    name?: StringFilter<"amenities"> | string
    icon?: StringNullableFilter<"amenities"> | string | null
    added_at?: DateTimeNullableFilter<"amenities"> | Date | string | null
    business_amenities?: Business_amenitiesListRelationFilter
  }

  export type amenitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    added_at?: SortOrderInput | SortOrder
    business_amenities?: business_amenitiesOrderByRelationAggregateInput
    _relevance?: amenitiesOrderByRelevanceInput
  }

  export type amenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: amenitiesWhereInput | amenitiesWhereInput[]
    OR?: amenitiesWhereInput[]
    NOT?: amenitiesWhereInput | amenitiesWhereInput[]
    name?: StringFilter<"amenities"> | string
    icon?: StringNullableFilter<"amenities"> | string | null
    added_at?: DateTimeNullableFilter<"amenities"> | Date | string | null
    business_amenities?: Business_amenitiesListRelationFilter
  }, "id">

  export type amenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    added_at?: SortOrderInput | SortOrder
    _count?: amenitiesCountOrderByAggregateInput
    _avg?: amenitiesAvgOrderByAggregateInput
    _max?: amenitiesMaxOrderByAggregateInput
    _min?: amenitiesMinOrderByAggregateInput
    _sum?: amenitiesSumOrderByAggregateInput
  }

  export type amenitiesScalarWhereWithAggregatesInput = {
    AND?: amenitiesScalarWhereWithAggregatesInput | amenitiesScalarWhereWithAggregatesInput[]
    OR?: amenitiesScalarWhereWithAggregatesInput[]
    NOT?: amenitiesScalarWhereWithAggregatesInput | amenitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"amenities"> | number
    name?: StringWithAggregatesFilter<"amenities"> | string
    icon?: StringNullableWithAggregatesFilter<"amenities"> | string | null
    added_at?: DateTimeNullableWithAggregatesFilter<"amenities"> | Date | string | null
  }

  export type business_amenitiesWhereInput = {
    AND?: business_amenitiesWhereInput | business_amenitiesWhereInput[]
    OR?: business_amenitiesWhereInput[]
    NOT?: business_amenitiesWhereInput | business_amenitiesWhereInput[]
    id?: IntFilter<"business_amenities"> | number
    institution_id?: IntNullableFilter<"business_amenities"> | number | null
    amenitY_id?: IntNullableFilter<"business_amenities"> | number | null
    amenities?: XOR<AmenitiesNullableScalarRelationFilter, amenitiesWhereInput> | null
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
  }

  export type business_amenitiesOrderByWithRelationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    amenitY_id?: SortOrderInput | SortOrder
    amenities?: amenitiesOrderByWithRelationInput
    institution?: institutionOrderByWithRelationInput
  }

  export type business_amenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    amenitY_id_institution_id?: business_amenitiesAmenitY_idInstitution_idCompoundUniqueInput
    AND?: business_amenitiesWhereInput | business_amenitiesWhereInput[]
    OR?: business_amenitiesWhereInput[]
    NOT?: business_amenitiesWhereInput | business_amenitiesWhereInput[]
    institution_id?: IntNullableFilter<"business_amenities"> | number | null
    amenitY_id?: IntNullableFilter<"business_amenities"> | number | null
    amenities?: XOR<AmenitiesNullableScalarRelationFilter, amenitiesWhereInput> | null
    institution?: XOR<InstitutionNullableScalarRelationFilter, institutionWhereInput> | null
  }, "id" | "amenitY_id_institution_id">

  export type business_amenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    amenitY_id?: SortOrderInput | SortOrder
    _count?: business_amenitiesCountOrderByAggregateInput
    _avg?: business_amenitiesAvgOrderByAggregateInput
    _max?: business_amenitiesMaxOrderByAggregateInput
    _min?: business_amenitiesMinOrderByAggregateInput
    _sum?: business_amenitiesSumOrderByAggregateInput
  }

  export type business_amenitiesScalarWhereWithAggregatesInput = {
    AND?: business_amenitiesScalarWhereWithAggregatesInput | business_amenitiesScalarWhereWithAggregatesInput[]
    OR?: business_amenitiesScalarWhereWithAggregatesInput[]
    NOT?: business_amenitiesScalarWhereWithAggregatesInput | business_amenitiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"business_amenities"> | number
    institution_id?: IntNullableWithAggregatesFilter<"business_amenities"> | number | null
    amenitY_id?: IntNullableWithAggregatesFilter<"business_amenities"> | number | null
  }

  export type price_rangesWhereInput = {
    AND?: price_rangesWhereInput | price_rangesWhereInput[]
    OR?: price_rangesWhereInput[]
    NOT?: price_rangesWhereInput | price_rangesWhereInput[]
    id?: IntFilter<"price_ranges"> | number
    max_value?: IntFilter<"price_ranges"> | number
    min_value?: IntFilter<"price_ranges"> | number
    institution_id?: IntFilter<"price_ranges"> | number
    label?: StringNullableFilter<"price_ranges"> | string | null
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
  }

  export type price_rangesOrderByWithRelationInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
    label?: SortOrderInput | SortOrder
    institution?: institutionOrderByWithRelationInput
    _relevance?: price_rangesOrderByRelevanceInput
  }

  export type price_rangesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: price_rangesWhereInput | price_rangesWhereInput[]
    OR?: price_rangesWhereInput[]
    NOT?: price_rangesWhereInput | price_rangesWhereInput[]
    max_value?: IntFilter<"price_ranges"> | number
    min_value?: IntFilter<"price_ranges"> | number
    institution_id?: IntFilter<"price_ranges"> | number
    label?: StringNullableFilter<"price_ranges"> | string | null
    institution?: XOR<InstitutionScalarRelationFilter, institutionWhereInput>
  }, "id">

  export type price_rangesOrderByWithAggregationInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
    label?: SortOrderInput | SortOrder
    _count?: price_rangesCountOrderByAggregateInput
    _avg?: price_rangesAvgOrderByAggregateInput
    _max?: price_rangesMaxOrderByAggregateInput
    _min?: price_rangesMinOrderByAggregateInput
    _sum?: price_rangesSumOrderByAggregateInput
  }

  export type price_rangesScalarWhereWithAggregatesInput = {
    AND?: price_rangesScalarWhereWithAggregatesInput | price_rangesScalarWhereWithAggregatesInput[]
    OR?: price_rangesScalarWhereWithAggregatesInput[]
    NOT?: price_rangesScalarWhereWithAggregatesInput | price_rangesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"price_ranges"> | number
    max_value?: IntWithAggregatesFilter<"price_ranges"> | number
    min_value?: IntWithAggregatesFilter<"price_ranges"> | number
    institution_id?: IntWithAggregatesFilter<"price_ranges"> | number
    label?: StringNullableWithAggregatesFilter<"price_ranges"> | string | null
  }

  export type surveyAnswersWhereInput = {
    AND?: surveyAnswersWhereInput | surveyAnswersWhereInput[]
    OR?: surveyAnswersWhereInput[]
    NOT?: surveyAnswersWhereInput | surveyAnswersWhereInput[]
    id?: IntFilter<"surveyAnswers"> | number
    question_id?: IntFilter<"surveyAnswers"> | number
    user_id?: IntNullableFilter<"surveyAnswers"> | number | null
    answer?: StringNullableFilter<"surveyAnswers"> | string | null
    scale_rating?: IntNullableFilter<"surveyAnswers"> | number | null
    added_at?: DateTimeFilter<"surveyAnswers"> | Date | string
    surveyQuestions?: XOR<SurveyQuestionsScalarRelationFilter, surveyQuestionsWhereInput>
  }

  export type surveyAnswersOrderByWithRelationInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    answer?: SortOrderInput | SortOrder
    scale_rating?: SortOrderInput | SortOrder
    added_at?: SortOrder
    surveyQuestions?: surveyQuestionsOrderByWithRelationInput
    _relevance?: surveyAnswersOrderByRelevanceInput
  }

  export type surveyAnswersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: surveyAnswersWhereInput | surveyAnswersWhereInput[]
    OR?: surveyAnswersWhereInput[]
    NOT?: surveyAnswersWhereInput | surveyAnswersWhereInput[]
    question_id?: IntFilter<"surveyAnswers"> | number
    user_id?: IntNullableFilter<"surveyAnswers"> | number | null
    answer?: StringNullableFilter<"surveyAnswers"> | string | null
    scale_rating?: IntNullableFilter<"surveyAnswers"> | number | null
    added_at?: DateTimeFilter<"surveyAnswers"> | Date | string
    surveyQuestions?: XOR<SurveyQuestionsScalarRelationFilter, surveyQuestionsWhereInput>
  }, "id">

  export type surveyAnswersOrderByWithAggregationInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    answer?: SortOrderInput | SortOrder
    scale_rating?: SortOrderInput | SortOrder
    added_at?: SortOrder
    _count?: surveyAnswersCountOrderByAggregateInput
    _avg?: surveyAnswersAvgOrderByAggregateInput
    _max?: surveyAnswersMaxOrderByAggregateInput
    _min?: surveyAnswersMinOrderByAggregateInput
    _sum?: surveyAnswersSumOrderByAggregateInput
  }

  export type surveyAnswersScalarWhereWithAggregatesInput = {
    AND?: surveyAnswersScalarWhereWithAggregatesInput | surveyAnswersScalarWhereWithAggregatesInput[]
    OR?: surveyAnswersScalarWhereWithAggregatesInput[]
    NOT?: surveyAnswersScalarWhereWithAggregatesInput | surveyAnswersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"surveyAnswers"> | number
    question_id?: IntWithAggregatesFilter<"surveyAnswers"> | number
    user_id?: IntNullableWithAggregatesFilter<"surveyAnswers"> | number | null
    answer?: StringNullableWithAggregatesFilter<"surveyAnswers"> | string | null
    scale_rating?: IntNullableWithAggregatesFilter<"surveyAnswers"> | number | null
    added_at?: DateTimeWithAggregatesFilter<"surveyAnswers"> | Date | string
  }

  export type surveyQuestionsWhereInput = {
    AND?: surveyQuestionsWhereInput | surveyQuestionsWhereInput[]
    OR?: surveyQuestionsWhereInput[]
    NOT?: surveyQuestionsWhereInput | surveyQuestionsWhereInput[]
    id?: IntFilter<"surveyQuestions"> | number
    service_id?: IntFilter<"surveyQuestions"> | number
    question?: StringNullableFilter<"surveyQuestions"> | string | null
    choices?: StringNullableFilter<"surveyQuestions"> | string | null
    added_at?: DateTimeFilter<"surveyQuestions"> | Date | string
    surveyAnswers?: SurveyAnswersListRelationFilter
    service_group?: XOR<Service_groupScalarRelationFilter, service_groupWhereInput>
  }

  export type surveyQuestionsOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    question?: SortOrderInput | SortOrder
    choices?: SortOrderInput | SortOrder
    added_at?: SortOrder
    surveyAnswers?: surveyAnswersOrderByRelationAggregateInput
    service_group?: service_groupOrderByWithRelationInput
    _relevance?: surveyQuestionsOrderByRelevanceInput
  }

  export type surveyQuestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: surveyQuestionsWhereInput | surveyQuestionsWhereInput[]
    OR?: surveyQuestionsWhereInput[]
    NOT?: surveyQuestionsWhereInput | surveyQuestionsWhereInput[]
    service_id?: IntFilter<"surveyQuestions"> | number
    question?: StringNullableFilter<"surveyQuestions"> | string | null
    choices?: StringNullableFilter<"surveyQuestions"> | string | null
    added_at?: DateTimeFilter<"surveyQuestions"> | Date | string
    surveyAnswers?: SurveyAnswersListRelationFilter
    service_group?: XOR<Service_groupScalarRelationFilter, service_groupWhereInput>
  }, "id">

  export type surveyQuestionsOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    question?: SortOrderInput | SortOrder
    choices?: SortOrderInput | SortOrder
    added_at?: SortOrder
    _count?: surveyQuestionsCountOrderByAggregateInput
    _avg?: surveyQuestionsAvgOrderByAggregateInput
    _max?: surveyQuestionsMaxOrderByAggregateInput
    _min?: surveyQuestionsMinOrderByAggregateInput
    _sum?: surveyQuestionsSumOrderByAggregateInput
  }

  export type surveyQuestionsScalarWhereWithAggregatesInput = {
    AND?: surveyQuestionsScalarWhereWithAggregatesInput | surveyQuestionsScalarWhereWithAggregatesInput[]
    OR?: surveyQuestionsScalarWhereWithAggregatesInput[]
    NOT?: surveyQuestionsScalarWhereWithAggregatesInput | surveyQuestionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"surveyQuestions"> | number
    service_id?: IntWithAggregatesFilter<"surveyQuestions"> | number
    question?: StringNullableWithAggregatesFilter<"surveyQuestions"> | string | null
    choices?: StringNullableWithAggregatesFilter<"surveyQuestions"> | string | null
    added_at?: DateTimeWithAggregatesFilter<"surveyQuestions"> | Date | string
  }

  export type serviceReviewWhereInput = {
    AND?: serviceReviewWhereInput | serviceReviewWhereInput[]
    OR?: serviceReviewWhereInput[]
    NOT?: serviceReviewWhereInput | serviceReviewWhereInput[]
    id?: IntFilter<"serviceReview"> | number
    user_id?: IntNullableFilter<"serviceReview"> | number | null
    service_id?: IntNullableFilter<"serviceReview"> | number | null
    rating?: IntNullableFilter<"serviceReview"> | number | null
    emoRating?: StringFilter<"serviceReview"> | string
    added_at?: DateTimeNullableFilter<"serviceReview"> | Date | string | null
    service_group?: XOR<Service_groupNullableScalarRelationFilter, service_groupWhereInput> | null
    users_profile?: XOR<Users_profileNullableScalarRelationFilter, users_profileWhereInput> | null
  }

  export type serviceReviewOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    emoRating?: SortOrder
    added_at?: SortOrderInput | SortOrder
    service_group?: service_groupOrderByWithRelationInput
    users_profile?: users_profileOrderByWithRelationInput
    _relevance?: serviceReviewOrderByRelevanceInput
  }

  export type serviceReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: serviceReviewWhereInput | serviceReviewWhereInput[]
    OR?: serviceReviewWhereInput[]
    NOT?: serviceReviewWhereInput | serviceReviewWhereInput[]
    user_id?: IntNullableFilter<"serviceReview"> | number | null
    service_id?: IntNullableFilter<"serviceReview"> | number | null
    rating?: IntNullableFilter<"serviceReview"> | number | null
    emoRating?: StringFilter<"serviceReview"> | string
    added_at?: DateTimeNullableFilter<"serviceReview"> | Date | string | null
    service_group?: XOR<Service_groupNullableScalarRelationFilter, service_groupWhereInput> | null
    users_profile?: XOR<Users_profileNullableScalarRelationFilter, users_profileWhereInput> | null
  }, "id">

  export type serviceReviewOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    service_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    emoRating?: SortOrder
    added_at?: SortOrderInput | SortOrder
    _count?: serviceReviewCountOrderByAggregateInput
    _avg?: serviceReviewAvgOrderByAggregateInput
    _max?: serviceReviewMaxOrderByAggregateInput
    _min?: serviceReviewMinOrderByAggregateInput
    _sum?: serviceReviewSumOrderByAggregateInput
  }

  export type serviceReviewScalarWhereWithAggregatesInput = {
    AND?: serviceReviewScalarWhereWithAggregatesInput | serviceReviewScalarWhereWithAggregatesInput[]
    OR?: serviceReviewScalarWhereWithAggregatesInput[]
    NOT?: serviceReviewScalarWhereWithAggregatesInput | serviceReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"serviceReview"> | number
    user_id?: IntNullableWithAggregatesFilter<"serviceReview"> | number | null
    service_id?: IntNullableWithAggregatesFilter<"serviceReview"> | number | null
    rating?: IntNullableWithAggregatesFilter<"serviceReview"> | number | null
    emoRating?: StringWithAggregatesFilter<"serviceReview"> | string
    added_at?: DateTimeNullableWithAggregatesFilter<"serviceReview"> | Date | string | null
  }

  export type category_search_termsWhereInput = {
    AND?: category_search_termsWhereInput | category_search_termsWhereInput[]
    OR?: category_search_termsWhereInput[]
    NOT?: category_search_termsWhereInput | category_search_termsWhereInput[]
    id?: IntFilter<"category_search_terms"> | number
    category_id?: IntFilter<"category_search_terms"> | number
    term?: StringFilter<"category_search_terms"> | string
    categories?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>
  }

  export type category_search_termsOrderByWithRelationInput = {
    id?: SortOrder
    category_id?: SortOrder
    term?: SortOrder
    categories?: categoriesOrderByWithRelationInput
    _relevance?: category_search_termsOrderByRelevanceInput
  }

  export type category_search_termsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: category_search_termsWhereInput | category_search_termsWhereInput[]
    OR?: category_search_termsWhereInput[]
    NOT?: category_search_termsWhereInput | category_search_termsWhereInput[]
    category_id?: IntFilter<"category_search_terms"> | number
    term?: StringFilter<"category_search_terms"> | string
    categories?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>
  }, "id">

  export type category_search_termsOrderByWithAggregationInput = {
    id?: SortOrder
    category_id?: SortOrder
    term?: SortOrder
    _count?: category_search_termsCountOrderByAggregateInput
    _avg?: category_search_termsAvgOrderByAggregateInput
    _max?: category_search_termsMaxOrderByAggregateInput
    _min?: category_search_termsMinOrderByAggregateInput
    _sum?: category_search_termsSumOrderByAggregateInput
  }

  export type category_search_termsScalarWhereWithAggregatesInput = {
    AND?: category_search_termsScalarWhereWithAggregatesInput | category_search_termsScalarWhereWithAggregatesInput[]
    OR?: category_search_termsScalarWhereWithAggregatesInput[]
    NOT?: category_search_termsScalarWhereWithAggregatesInput | category_search_termsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category_search_terms"> | number
    category_id?: IntWithAggregatesFilter<"category_search_terms"> | number
    term?: StringWithAggregatesFilter<"category_search_terms"> | string
  }

  export type app_releasesCreateInput = {
    release_version: string
    app_name: $Enums.app_releases_app_name
    platform: $Enums.app_releases_platform
    release_note?: string | null
    release_url: string
    minimum_version: string
    added_at?: Date | string
  }

  export type app_releasesUncheckedCreateInput = {
    id?: number
    release_version: string
    app_name: $Enums.app_releases_app_name
    platform: $Enums.app_releases_platform
    release_note?: string | null
    release_url: string
    minimum_version: string
    added_at?: Date | string
  }

  export type app_releasesUpdateInput = {
    release_version?: StringFieldUpdateOperationsInput | string
    app_name?: Enumapp_releases_app_nameFieldUpdateOperationsInput | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformFieldUpdateOperationsInput | $Enums.app_releases_platform
    release_note?: NullableStringFieldUpdateOperationsInput | string | null
    release_url?: StringFieldUpdateOperationsInput | string
    minimum_version?: StringFieldUpdateOperationsInput | string
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_releasesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    release_version?: StringFieldUpdateOperationsInput | string
    app_name?: Enumapp_releases_app_nameFieldUpdateOperationsInput | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformFieldUpdateOperationsInput | $Enums.app_releases_platform
    release_note?: NullableStringFieldUpdateOperationsInput | string | null
    release_url?: StringFieldUpdateOperationsInput | string
    minimum_version?: StringFieldUpdateOperationsInput | string
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_releasesCreateManyInput = {
    id?: number
    release_version: string
    app_name: $Enums.app_releases_app_name
    platform: $Enums.app_releases_platform
    release_note?: string | null
    release_url: string
    minimum_version: string
    added_at?: Date | string
  }

  export type app_releasesUpdateManyMutationInput = {
    release_version?: StringFieldUpdateOperationsInput | string
    app_name?: Enumapp_releases_app_nameFieldUpdateOperationsInput | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformFieldUpdateOperationsInput | $Enums.app_releases_platform
    release_note?: NullableStringFieldUpdateOperationsInput | string | null
    release_url?: StringFieldUpdateOperationsInput | string
    minimum_version?: StringFieldUpdateOperationsInput | string
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_releasesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    release_version?: StringFieldUpdateOperationsInput | string
    app_name?: Enumapp_releases_app_nameFieldUpdateOperationsInput | $Enums.app_releases_app_name
    platform?: Enumapp_releases_platformFieldUpdateOperationsInput | $Enums.app_releases_platform
    release_note?: NullableStringFieldUpdateOperationsInput | string | null
    release_url?: StringFieldUpdateOperationsInput | string
    minimum_version?: StringFieldUpdateOperationsInput | string
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsCreateInput = {
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
    user_appointments_creator_idTouser: userCreateNestedOneWithoutAppointments_appointments_creator_idTouserInput
    institution?: institutionCreateNestedOneWithoutAppointmentsInput
    qms_operator?: qms_operatorCreateNestedOneWithoutAppointmentsInput
    service?: serviceCreateNestedOneWithoutAppointmentsInput
    user_appointments_user_idTouser?: userCreateNestedOneWithoutAppointments_appointments_user_idTouserInput
  }

  export type appointmentsUncheckedCreateInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments_creator_idTouser?: userUpdateOneRequiredWithoutAppointments_appointments_creator_idTouserNestedInput
    institution?: institutionUpdateOneWithoutAppointmentsNestedInput
    qms_operator?: qms_operatorUpdateOneWithoutAppointmentsNestedInput
    service?: serviceUpdateOneWithoutAppointmentsNestedInput
    user_appointments_user_idTouser?: userUpdateOneWithoutAppointments_appointments_user_idTouserNestedInput
  }

  export type appointmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsCreateManyInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appsCreateInput = {
    name: string
    status?: number
    secret_key?: string | null
    access_key?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    institution: institutionCreateNestedOneWithoutAppsInput
  }

  export type appsUncheckedCreateInput = {
    id?: number
    name: string
    status?: number
    institution_id: number
    secret_key?: string | null
    access_key?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type appsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    institution?: institutionUpdateOneRequiredWithoutAppsNestedInput
  }

  export type appsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appsCreateManyInput = {
    id?: number
    name: string
    status?: number
    institution_id: number
    secret_key?: string | null
    access_key?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type appsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type audit_trailCreateInput = {
    old_value?: string | null
    new_value?: string | null
    action: string
    model: string
    field?: string | null
    user_id?: number | null
    ip?: string | null
    user_agent?: string | null
    model_id: string
    display_name?: string | null
    time: Date | string
    status?: $Enums.audit_trail_status | null
    reviewed_by?: number | null
  }

  export type audit_trailUncheckedCreateInput = {
    id?: number
    old_value?: string | null
    new_value?: string | null
    action: string
    model: string
    field?: string | null
    user_id?: number | null
    ip?: string | null
    user_agent?: string | null
    model_id: string
    display_name?: string | null
    time: Date | string
    status?: $Enums.audit_trail_status | null
    reviewed_by?: number | null
  }

  export type audit_trailUpdateInput = {
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumaudit_trail_statusFieldUpdateOperationsInput | $Enums.audit_trail_status | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audit_trailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumaudit_trail_statusFieldUpdateOperationsInput | $Enums.audit_trail_status | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audit_trailCreateManyInput = {
    id?: number
    old_value?: string | null
    new_value?: string | null
    action: string
    model: string
    field?: string | null
    user_id?: number | null
    ip?: string | null
    user_agent?: string | null
    model_id: string
    display_name?: string | null
    time: Date | string
    status?: $Enums.audit_trail_status | null
    reviewed_by?: number | null
  }

  export type audit_trailUpdateManyMutationInput = {
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumaudit_trail_statusFieldUpdateOperationsInput | $Enums.audit_trail_status | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type audit_trailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    field?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    model_id?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumaudit_trail_statusFieldUpdateOperationsInput | $Enums.audit_trail_status | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoriesCreateInput = {
    name: string
    sectors?: sectorsCreateNestedOneWithoutCategoriesInput
    category_search_terms?: category_search_termsCreateNestedManyWithoutCategoriesInput
    institution?: institutionCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: number
    name: string
    sector_id?: number | null
    category_search_terms?: category_search_termsUncheckedCreateNestedManyWithoutCategoriesInput
    institution?: institutionUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    sectors?: sectorsUpdateOneWithoutCategoriesNestedInput
    category_search_terms?: category_search_termsUpdateManyWithoutCategoriesNestedInput
    institution?: institutionUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_search_terms?: category_search_termsUncheckedUpdateManyWithoutCategoriesNestedInput
    institution?: institutionUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: number
    name: string
    sector_id?: number | null
  }

  export type categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type change_requestCreateInput = {
    old_value?: string | null
    new_value?: string | null
    action: string
    model: string
    model_id?: number | null
    user_id: number
    ip?: string | null
    user_agent?: string | null
    display_name?: string | null
    status?: boolean | null
    reviewed_by?: number | null
    time: Date | string
    institution_id?: number | null
  }

  export type change_requestUncheckedCreateInput = {
    id?: number
    old_value?: string | null
    new_value?: string | null
    action: string
    model: string
    model_id?: number | null
    user_id: number
    ip?: string | null
    user_agent?: string | null
    display_name?: string | null
    status?: boolean | null
    reviewed_by?: number | null
    time: Date | string
    institution_id?: number | null
  }

  export type change_requestUpdateInput = {
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    model_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type change_requestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    model_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type change_requestCreateManyInput = {
    id?: number
    old_value?: string | null
    new_value?: string | null
    action: string
    model: string
    model_id?: number | null
    user_id: number
    ip?: string | null
    user_agent?: string | null
    display_name?: string | null
    status?: boolean | null
    reviewed_by?: number | null
    time: Date | string
    institution_id?: number | null
  }

  export type change_requestUpdateManyMutationInput = {
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    model_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type change_requestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    old_value?: NullableStringFieldUpdateOperationsInput | string | null
    new_value?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    model_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviewed_by?: NullableIntFieldUpdateOperationsInput | number | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type deviceCreateInput = {
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    institution?: institutionCreateNestedOneWithoutDeviceInput
    qms_customer?: qms_customerCreateNestedManyWithoutDeviceInput
    rating?: ratingCreateNestedManyWithoutDeviceInput
    tip?: tipCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    affiliate_id?: number | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    qms_customer?: qms_customerUncheckedCreateNestedManyWithoutDeviceInput
    rating?: ratingUncheckedCreateNestedManyWithoutDeviceInput
    tip?: tipUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutDeviceNestedInput
    qms_customer?: qms_customerUpdateManyWithoutDeviceNestedInput
    rating?: ratingUpdateManyWithoutDeviceNestedInput
    tip?: tipUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_customer?: qms_customerUncheckedUpdateManyWithoutDeviceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutDeviceNestedInput
    tip?: tipUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type deviceCreateManyInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    affiliate_id?: number | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
  }

  export type deviceUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type device_heartbeatCreateInput = {
    time?: Date | string
    device_id?: number | null
    operator_id?: number | null
    version?: string | null
  }

  export type device_heartbeatUncheckedCreateInput = {
    id?: number
    time?: Date | string
    device_id?: number | null
    operator_id?: number | null
    version?: string | null
  }

  export type device_heartbeatUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_heartbeatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_heartbeatCreateManyInput = {
    id?: number
    time?: Date | string
    device_id?: number | null
    operator_id?: number | null
    version?: string | null
  }

  export type device_heartbeatUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_heartbeatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type institutionCreateInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionCreateManyInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
  }

  export type institutionUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type institutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type institution_invoicesCreateInput = {
    invoice_number: string
    institution_id: number
    institution_name: string
    period_start: Date | string
    period_end: Date | string
    generated_at: Date | string
    expiry: Date | string
    payment_reference_number: string
    ext_payment_reference_number?: string | null
    payment_status: $Enums.institution_invoices_payment_status
    payment_status_desc?: string | null
    payment_method?: string | null
    payment_retries?: number | null
    status: $Enums.institution_invoices_status
    total_amount?: number | null
  }

  export type institution_invoicesUncheckedCreateInput = {
    id?: number
    invoice_number: string
    institution_id: number
    institution_name: string
    period_start: Date | string
    period_end: Date | string
    generated_at: Date | string
    expiry: Date | string
    payment_reference_number: string
    ext_payment_reference_number?: string | null
    payment_status: $Enums.institution_invoices_payment_status
    payment_status_desc?: string | null
    payment_method?: string | null
    payment_retries?: number | null
    status: $Enums.institution_invoices_status
    total_amount?: number | null
  }

  export type institution_invoicesUpdateInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    institution_name?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_reference_number?: StringFieldUpdateOperationsInput | string
    ext_payment_reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: Enuminstitution_invoices_payment_statusFieldUpdateOperationsInput | $Enums.institution_invoices_payment_status
    payment_status_desc?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_retries?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enuminstitution_invoices_statusFieldUpdateOperationsInput | $Enums.institution_invoices_status
    total_amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type institution_invoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    institution_name?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_reference_number?: StringFieldUpdateOperationsInput | string
    ext_payment_reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: Enuminstitution_invoices_payment_statusFieldUpdateOperationsInput | $Enums.institution_invoices_payment_status
    payment_status_desc?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_retries?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enuminstitution_invoices_statusFieldUpdateOperationsInput | $Enums.institution_invoices_status
    total_amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type institution_invoicesCreateManyInput = {
    id?: number
    invoice_number: string
    institution_id: number
    institution_name: string
    period_start: Date | string
    period_end: Date | string
    generated_at: Date | string
    expiry: Date | string
    payment_reference_number: string
    ext_payment_reference_number?: string | null
    payment_status: $Enums.institution_invoices_payment_status
    payment_status_desc?: string | null
    payment_method?: string | null
    payment_retries?: number | null
    status: $Enums.institution_invoices_status
    total_amount?: number | null
  }

  export type institution_invoicesUpdateManyMutationInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    institution_name?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_reference_number?: StringFieldUpdateOperationsInput | string
    ext_payment_reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: Enuminstitution_invoices_payment_statusFieldUpdateOperationsInput | $Enums.institution_invoices_payment_status
    payment_status_desc?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_retries?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enuminstitution_invoices_statusFieldUpdateOperationsInput | $Enums.institution_invoices_status
    total_amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type institution_invoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    institution_name?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    generated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_reference_number?: StringFieldUpdateOperationsInput | string
    ext_payment_reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: Enuminstitution_invoices_payment_statusFieldUpdateOperationsInput | $Enums.institution_invoices_payment_status
    payment_status_desc?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_retries?: NullableIntFieldUpdateOperationsInput | number | null
    status?: Enuminstitution_invoices_statusFieldUpdateOperationsInput | $Enums.institution_invoices_status
    total_amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type institution_service_trackingCreateInput = {
    institution_id?: number | null
    branch_id?: number | null
    service_id?: number | null
    branch_name?: string | null
    service_group_name?: string | null
    time?: Date | string
    action?: boolean | null
    status?: boolean | null
    invoice_number?: string | null
  }

  export type institution_service_trackingUncheckedCreateInput = {
    id?: number
    institution_id?: number | null
    branch_id?: number | null
    service_id?: number | null
    branch_name?: string | null
    service_group_name?: string | null
    time?: Date | string
    action?: boolean | null
    status?: boolean | null
    invoice_number?: string | null
  }

  export type institution_service_trackingUpdateInput = {
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    service_group_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type institution_service_trackingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    service_group_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type institution_service_trackingCreateManyInput = {
    id?: number
    institution_id?: number | null
    branch_id?: number | null
    service_id?: number | null
    branch_name?: string | null
    service_group_name?: string | null
    time?: Date | string
    action?: boolean | null
    status?: boolean | null
    invoice_number?: string | null
  }

  export type institution_service_trackingUpdateManyMutationInput = {
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    service_group_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type institution_service_trackingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    branch_name?: NullableStringFieldUpdateOperationsInput | string | null
    service_group_name?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    invoice_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type login_historyCreateInput = {
    user_id?: number | null
    ip?: string | null
    user_agent?: string | null
    time: Date | string
  }

  export type login_historyUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    ip?: string | null
    user_agent?: string | null
    time: Date | string
  }

  export type login_historyUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyCreateManyInput = {
    id?: number
    user_id?: number | null
    ip?: string | null
    user_agent?: string | null
    time: Date | string
  }

  export type login_historyUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type login_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type migrationCreateInput = {
    version: string
    apply_time?: number | null
  }

  export type migrationUncheckedCreateInput = {
    version: string
    apply_time?: number | null
  }

  export type migrationUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    apply_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type migrationUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    apply_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type migrationCreateManyInput = {
    version: string
    apply_time?: number | null
  }

  export type migrationUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    apply_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type migrationUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    apply_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mms_fileCreateInput = {
    device_uuid: string
    institution_id: number
    path: string
    comment?: string | null
    type: number
    longitude?: number | null
    latitude?: number | null
    height?: number | null
    width?: number | null
    first_view_time?: Date | string | null
    last_view_time?: Date | string | null
    created_at?: Date | string | null
  }

  export type mms_fileUncheckedCreateInput = {
    id?: number
    device_uuid: string
    institution_id: number
    path: string
    comment?: string | null
    type: number
    longitude?: number | null
    latitude?: number | null
    height?: number | null
    width?: number | null
    first_view_time?: Date | string | null
    last_view_time?: Date | string | null
    created_at?: Date | string | null
  }

  export type mms_fileUpdateInput = {
    device_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    first_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mms_fileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    first_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mms_fileCreateManyInput = {
    id?: number
    device_uuid: string
    institution_id: number
    path: string
    comment?: string | null
    type: number
    longitude?: number | null
    latitude?: number | null
    height?: number | null
    width?: number | null
    first_view_time?: Date | string | null
    last_view_time?: Date | string | null
    created_at?: Date | string | null
  }

  export type mms_fileUpdateManyMutationInput = {
    device_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    first_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mms_fileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    first_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_view_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationCreateInput = {
    title?: string | null
    content: string
    link?: string | null
    seen?: boolean | null
    time_sent?: Date | string | null
    time_seen?: Date | string | null
  }

  export type notificationUncheckedCreateInput = {
    id?: number
    title?: string | null
    content: string
    link?: string | null
    seen?: boolean | null
    time_sent?: Date | string | null
    time_seen?: Date | string | null
  }

  export type notificationUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    time_sent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    time_sent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationCreateManyInput = {
    id?: number
    title?: string | null
    content: string
    link?: string | null
    seen?: boolean | null
    time_sent?: Date | string | null
    time_seen?: Date | string | null
  }

  export type notificationUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    time_sent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    seen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    time_sent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_seen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notification_recipientCreateInput = {
    id_notification: number
    id_user?: number | null
    seen?: number | null
    ticket?: number | null
    reference_id?: number | null
  }

  export type notification_recipientUncheckedCreateInput = {
    id?: number
    id_notification: number
    id_user?: number | null
    seen?: number | null
    ticket?: number | null
    reference_id?: number | null
  }

  export type notification_recipientUpdateInput = {
    id_notification?: IntFieldUpdateOperationsInput | number
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    seen?: NullableIntFieldUpdateOperationsInput | number | null
    ticket?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notification_recipientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_notification?: IntFieldUpdateOperationsInput | number
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    seen?: NullableIntFieldUpdateOperationsInput | number | null
    ticket?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notification_recipientCreateManyInput = {
    id?: number
    id_notification: number
    id_user?: number | null
    seen?: number | null
    ticket?: number | null
    reference_id?: number | null
  }

  export type notification_recipientUpdateManyMutationInput = {
    id_notification?: IntFieldUpdateOperationsInput | number
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    seen?: NullableIntFieldUpdateOperationsInput | number | null
    ticket?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notification_recipientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_notification?: IntFieldUpdateOperationsInput | number
    id_user?: NullableIntFieldUpdateOperationsInput | number | null
    seen?: NullableIntFieldUpdateOperationsInput | number | null
    ticket?: NullableIntFieldUpdateOperationsInput | number | null
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type optionCreateInput = {
    name?: string | null
    description?: string | null
    type?: number | null
    parent_id?: number | null
    created_at?: Date | string
    qms_ticket?: qms_ticketCreateNestedManyWithoutOptionInput
  }

  export type optionUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    type?: number | null
    parent_id?: number | null
    created_at?: Date | string
    qms_ticket?: qms_ticketUncheckedCreateNestedManyWithoutOptionInput
  }

  export type optionUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_ticket?: qms_ticketUpdateManyWithoutOptionNestedInput
  }

  export type optionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_ticket?: qms_ticketUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type optionCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
    type?: number | null
    parent_id?: number | null
    created_at?: Date | string
  }

  export type optionUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type optionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questionsCreateInput = {
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    institution: institutionCreateNestedOneWithoutPopup_questionsInput
    popup_questions_possible_answers?: popup_questions_possible_answersCreateNestedManyWithoutPopup_questionsInput
  }

  export type popup_questionsUncheckedCreateInput = {
    id?: number
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    institution_id: number
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersUncheckedCreateNestedManyWithoutPopup_questionsInput
  }

  export type popup_questionsUpdateInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneRequiredWithoutPopup_questionsNestedInput
    popup_questions_possible_answers?: popup_questions_possible_answersUpdateManyWithoutPopup_questionsNestedInput
  }

  export type popup_questionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    institution_id?: IntFieldUpdateOperationsInput | number
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersUncheckedUpdateManyWithoutPopup_questionsNestedInput
  }

  export type popup_questionsCreateManyInput = {
    id?: number
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    institution_id: number
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type popup_questionsUpdateManyMutationInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    institution_id?: IntFieldUpdateOperationsInput | number
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questions_answersCreateInput = {
    device_id: number
    rating_id?: number | null
    ticket_id?: number | null
    answered_at?: Date | string
    popup_questions_possible_answers: popup_questions_possible_answersCreateNestedOneWithoutPopup_questions_answersInput
  }

  export type popup_questions_answersUncheckedCreateInput = {
    id?: number
    device_id: number
    rating_id?: number | null
    ticket_id?: number | null
    answer_id: number
    answered_at?: Date | string
  }

  export type popup_questions_answersUpdateInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersUpdateOneRequiredWithoutPopup_questions_answersNestedInput
  }

  export type popup_questions_answersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer_id?: IntFieldUpdateOperationsInput | number
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questions_answersCreateManyInput = {
    id?: number
    device_id: number
    rating_id?: number | null
    ticket_id?: number | null
    answer_id: number
    answered_at?: Date | string
  }

  export type popup_questions_answersUpdateManyMutationInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questions_answersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer_id?: IntFieldUpdateOperationsInput | number
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questions_possible_answersCreateInput = {
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
    popup_questions_answers?: popup_questions_answersCreateNestedManyWithoutPopup_questions_possible_answersInput
    popup_questions: popup_questionsCreateNestedOneWithoutPopup_questions_possible_answersInput
  }

  export type popup_questions_possible_answersUncheckedCreateInput = {
    id?: number
    popup_question_id: number
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
    popup_questions_answers?: popup_questions_answersUncheckedCreateNestedManyWithoutPopup_questions_possible_answersInput
  }

  export type popup_questions_possible_answersUpdateInput = {
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    popup_questions_answers?: popup_questions_answersUpdateManyWithoutPopup_questions_possible_answersNestedInput
    popup_questions?: popup_questionsUpdateOneRequiredWithoutPopup_questions_possible_answersNestedInput
  }

  export type popup_questions_possible_answersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    popup_question_id?: IntFieldUpdateOperationsInput | number
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    popup_questions_answers?: popup_questions_answersUncheckedUpdateManyWithoutPopup_questions_possible_answersNestedInput
  }

  export type popup_questions_possible_answersCreateManyInput = {
    id?: number
    popup_question_id: number
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
  }

  export type popup_questions_possible_answersUpdateManyMutationInput = {
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type popup_questions_possible_answersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    popup_question_id?: IntFieldUpdateOperationsInput | number
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type qms_branch_operatorCreateInput = {
    service_id: string
    linked_at?: Date | string
    status?: number
    institution: institutionCreateNestedOneWithoutQms_branch_operatorInput
    qms_operator: qms_operatorCreateNestedOneWithoutQms_branch_operatorInput
  }

  export type qms_branch_operatorUncheckedCreateInput = {
    id?: number
    operator_id: number
    institution_id: number
    service_id: string
    linked_at?: Date | string
    status?: number
  }

  export type qms_branch_operatorUpdateInput = {
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    institution?: institutionUpdateOneRequiredWithoutQms_branch_operatorNestedInput
    qms_operator?: qms_operatorUpdateOneRequiredWithoutQms_branch_operatorNestedInput
  }

  export type qms_branch_operatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_branch_operatorCreateManyInput = {
    id?: number
    operator_id: number
    institution_id: number
    service_id: string
    linked_at?: Date | string
    status?: number
  }

  export type qms_branch_operatorUpdateManyMutationInput = {
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_branch_operatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_branch_transactionsCreateInput = {
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
    institution: institutionCreateNestedOneWithoutQms_branch_transactionsInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_branch_transactionsInput
  }

  export type qms_branch_transactionsUncheckedCreateInput = {
    id?: number
    affiliate_id: number
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_branch_transactionsInput
  }

  export type qms_branch_transactionsUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneRequiredWithoutQms_branch_transactionsNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_branch_transactionsNestedInput
  }

  export type qms_branch_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_branch_transactionsNestedInput
  }

  export type qms_branch_transactionsCreateManyInput = {
    id?: number
    affiliate_id: number
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_branch_transactionsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_branch_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_counterCreateInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    service?: serviceCreateNestedOneWithoutQms_counterInput
  }

  export type qms_counterUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    service_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_counterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: serviceUpdateOneWithoutQms_counterNestedInput
  }

  export type qms_counterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_counterCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    service_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_counterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_counterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_customerCreateInput = {
    customer_uuid: string
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    device?: deviceCreateNestedOneWithoutQms_customerInput
    qms_ticket?: qms_ticketCreateNestedManyWithoutQms_customerInput
  }

  export type qms_customerUncheckedCreateInput = {
    id?: number
    customer_uuid: string
    device_id?: number | null
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    qms_ticket?: qms_ticketUncheckedCreateNestedManyWithoutQms_customerInput
  }

  export type qms_customerUpdateInput = {
    customer_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: deviceUpdateOneWithoutQms_customerNestedInput
    qms_ticket?: qms_ticketUpdateManyWithoutQms_customerNestedInput
  }

  export type qms_customerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_uuid?: StringFieldUpdateOperationsInput | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_ticket?: qms_ticketUncheckedUpdateManyWithoutQms_customerNestedInput
  }

  export type qms_customerCreateManyInput = {
    id?: number
    customer_uuid: string
    device_id?: number | null
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_customerUpdateManyMutationInput = {
    customer_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_customerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_uuid?: StringFieldUpdateOperationsInput | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operatorCreateInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutQms_operatorInput
    institution?: institutionCreateNestedOneWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUpdateInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput
    institution?: institutionUpdateOneWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorCreateManyInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
  }

  export type qms_operatorUpdateManyMutationInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type qms_operatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type qms_operator_transactionsCreateInput = {
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
    qms_branch_transactions: qms_branch_transactionsCreateNestedOneWithoutQms_operator_transactionsInput
    qms_operator: qms_operatorCreateNestedOneWithoutQms_operator_transactionsInput
  }

  export type qms_operator_transactionsUncheckedCreateInput = {
    id?: number
    branch_transaction_id: number
    operator_id: number
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_operator_transactionsUpdateInput = {
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_branch_transactions?: qms_branch_transactionsUpdateOneRequiredWithoutQms_operator_transactionsNestedInput
    qms_operator?: qms_operatorUpdateOneRequiredWithoutQms_operator_transactionsNestedInput
  }

  export type qms_operator_transactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch_transaction_id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operator_transactionsCreateManyInput = {
    id?: number
    branch_transaction_id: number
    operator_id: number
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_operator_transactionsUpdateManyMutationInput = {
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operator_transactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch_transaction_id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_queueCreateInput = {
    queue_uuid: string
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    service: serviceCreateNestedOneWithoutQms_queueInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_queueInput
    qms_ticket?: qms_ticketCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueUncheckedCreateInput = {
    id?: number
    queue_uuid: string
    service_id: number
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_queueInput
    qms_ticket?: qms_ticketUncheckedCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueUpdateInput = {
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    service?: serviceUpdateOneRequiredWithoutQms_queueNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_queueNestedInput
    qms_ticket?: qms_ticketUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_queueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_uuid?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_queueNestedInput
    qms_ticket?: qms_ticketUncheckedUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_queueCreateManyInput = {
    id?: number
    queue_uuid: string
    service_id: number
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
  }

  export type qms_queueUpdateManyMutationInput = {
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type qms_queueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_uuid?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type qms_queue_operator_lnkCreateInput = {
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
    qms_queue: qms_queueCreateNestedOneWithoutQms_queue_operator_lnkInput
    qms_operator: qms_operatorCreateNestedOneWithoutQms_queue_operator_lnkInput
  }

  export type qms_queue_operator_lnkUncheckedCreateInput = {
    id?: number
    queue_id: number
    operator_id: number
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
  }

  export type qms_queue_operator_lnkUpdateInput = {
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
    qms_queue?: qms_queueUpdateOneRequiredWithoutQms_queue_operator_lnkNestedInput
    qms_operator?: qms_operatorUpdateOneRequiredWithoutQms_queue_operator_lnkNestedInput
  }

  export type qms_queue_operator_lnkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_queue_operator_lnkCreateManyInput = {
    id?: number
    queue_id: number
    operator_id: number
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
  }

  export type qms_queue_operator_lnkUpdateManyMutationInput = {
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_queue_operator_lnkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticketCreateInput = {
    ticket_uuid: string
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    option?: optionCreateNestedOneWithoutQms_ticketInput
    qms_customer: qms_customerCreateNestedOneWithoutQms_ticketInput
    qms_queue: qms_queueCreateNestedOneWithoutQms_ticketInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketUncheckedCreateInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketUpdateInput = {
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    option?: optionUpdateOneWithoutQms_ticketNestedInput
    qms_customer?: qms_customerUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_queue?: qms_queueUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketCreateManyInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
  }

  export type qms_ticketUpdateManyMutationInput = {
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
  }

  export type qms_ticketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
  }

  export type qms_ticket_assignmentCreateInput = {
    queue_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
    qms_ticket: qms_ticketCreateNestedOneWithoutQms_ticket_assignmentInput
    qms_operator?: qms_operatorCreateNestedOneWithoutQms_ticket_assignmentInput
  }

  export type qms_ticket_assignmentUncheckedCreateInput = {
    id?: number
    ticket_id: number
    queue_id?: number | null
    operator_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
  }

  export type qms_ticket_assignmentUpdateInput = {
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    qms_ticket?: qms_ticketUpdateOneRequiredWithoutQms_ticket_assignmentNestedInput
    qms_operator?: qms_operatorUpdateOneWithoutQms_ticket_assignmentNestedInput
  }

  export type qms_ticket_assignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticket_assignmentCreateManyInput = {
    id?: number
    ticket_id: number
    queue_id?: number | null
    operator_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
  }

  export type qms_ticket_assignmentUpdateManyMutationInput = {
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticket_assignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ratingCreateInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    service: serviceCreateNestedOneWithoutRatingInput
    device?: deviceCreateNestedOneWithoutRatingInput
    rating_assets?: rating_assetsCreateNestedManyWithoutRatingInput
    tip?: tipCreateNestedManyWithoutRatingInput
  }

  export type ratingUncheckedCreateInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    service_id: number
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    device_id?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    rating_assets?: rating_assetsUncheckedCreateNestedManyWithoutRatingInput
    tip?: tipUncheckedCreateNestedManyWithoutRatingInput
  }

  export type ratingUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateOneRequiredWithoutRatingNestedInput
    device?: deviceUpdateOneWithoutRatingNestedInput
    rating_assets?: rating_assetsUpdateManyWithoutRatingNestedInput
    tip?: tipUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    service_id?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets?: rating_assetsUncheckedUpdateManyWithoutRatingNestedInput
    tip?: tipUncheckedUpdateManyWithoutRatingNestedInput
  }

  export type ratingCreateManyInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    service_id: number
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    device_id?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
  }

  export type ratingUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ratingUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    service_id?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_assetsCreateInput = {
    rating_assets_image?: string | null
    rating_assets_video?: string | null
    rating?: ratingCreateNestedOneWithoutRating_assetsInput
  }

  export type rating_assetsUncheckedCreateInput = {
    rating_assets_id?: number
    rating_assets_image?: string | null
    rating_assets_video?: string | null
    rating_id?: bigint | number | null
  }

  export type rating_assetsUpdateInput = {
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: ratingUpdateOneWithoutRating_assetsNestedInput
  }

  export type rating_assetsUncheckedUpdateInput = {
    rating_assets_id?: IntFieldUpdateOperationsInput | number
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
    rating_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type rating_assetsCreateManyInput = {
    rating_assets_id?: number
    rating_assets_image?: string | null
    rating_assets_video?: string | null
    rating_id?: bigint | number | null
  }

  export type rating_assetsUpdateManyMutationInput = {
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_assetsUncheckedUpdateManyInput = {
    rating_assets_id?: IntFieldUpdateOperationsInput | number
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
    rating_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type rating_qr_code_sessionsCreateInput = {
    institution_uuid?: string | null
    service_uuid?: string | null
    user_agent: string
    finger_print: string
    ip_address: string
    session_token: string
    session_expiration: Date | string
    status?: $Enums.rating_qr_code_sessions_status
    created_at?: Date | string
  }

  export type rating_qr_code_sessionsUncheckedCreateInput = {
    id?: number
    institution_uuid?: string | null
    service_uuid?: string | null
    user_agent: string
    finger_print: string
    ip_address: string
    session_token: string
    session_expiration: Date | string
    status?: $Enums.rating_qr_code_sessions_status
    created_at?: Date | string
  }

  export type rating_qr_code_sessionsUpdateInput = {
    institution_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    service_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: StringFieldUpdateOperationsInput | string
    finger_print?: StringFieldUpdateOperationsInput | string
    ip_address?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    session_expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrating_qr_code_sessions_statusFieldUpdateOperationsInput | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_qr_code_sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    service_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: StringFieldUpdateOperationsInput | string
    finger_print?: StringFieldUpdateOperationsInput | string
    ip_address?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    session_expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrating_qr_code_sessions_statusFieldUpdateOperationsInput | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_qr_code_sessionsCreateManyInput = {
    id?: number
    institution_uuid?: string | null
    service_uuid?: string | null
    user_agent: string
    finger_print: string
    ip_address: string
    session_token: string
    session_expiration: Date | string
    status?: $Enums.rating_qr_code_sessions_status
    created_at?: Date | string
  }

  export type rating_qr_code_sessionsUpdateManyMutationInput = {
    institution_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    service_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: StringFieldUpdateOperationsInput | string
    finger_print?: StringFieldUpdateOperationsInput | string
    ip_address?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    session_expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrating_qr_code_sessions_statusFieldUpdateOperationsInput | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_qr_code_sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    service_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: StringFieldUpdateOperationsInput | string
    finger_print?: StringFieldUpdateOperationsInput | string
    ip_address?: StringFieldUpdateOperationsInput | string
    session_token?: StringFieldUpdateOperationsInput | string
    session_expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumrating_qr_code_sessions_statusFieldUpdateOperationsInput | $Enums.rating_qr_code_sessions_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rating_replyCreateInput = {
    specific?: boolean | null
    rating_id?: number | null
    time?: Date | string | null
    reply?: string | null
  }

  export type rating_replyUncheckedCreateInput = {
    id?: number
    specific?: boolean | null
    rating_id?: number | null
    time?: Date | string | null
    reply?: string | null
  }

  export type rating_replyUpdateInput = {
    specific?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_replyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    specific?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_replyCreateManyInput = {
    id?: number
    specific?: boolean | null
    rating_id?: number | null
    time?: Date | string | null
    reply?: string | null
  }

  export type rating_replyUpdateManyMutationInput = {
    specific?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_replyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    specific?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reportsCreateInput = {
    title: string
    type: string
    institution_id: number
    service_ids: string
    start_date: Date | string
    end_date: Date | string
    report_created_by: number
    report_institution_id: string
    report_recipient: string
    report_queue_uuid: string
    report_content_key?: string | null
    status?: number
    created_at?: Date | string
  }

  export type reportsUncheckedCreateInput = {
    id?: number
    title: string
    type: string
    institution_id: number
    service_ids: string
    start_date: Date | string
    end_date: Date | string
    report_created_by: number
    report_institution_id: string
    report_recipient: string
    report_queue_uuid: string
    report_content_key?: string | null
    status?: number
    created_at?: Date | string
  }

  export type reportsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    service_ids?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    report_created_by?: IntFieldUpdateOperationsInput | number
    report_institution_id?: StringFieldUpdateOperationsInput | string
    report_recipient?: StringFieldUpdateOperationsInput | string
    report_queue_uuid?: StringFieldUpdateOperationsInput | string
    report_content_key?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    service_ids?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    report_created_by?: IntFieldUpdateOperationsInput | number
    report_institution_id?: StringFieldUpdateOperationsInput | string
    report_recipient?: StringFieldUpdateOperationsInput | string
    report_queue_uuid?: StringFieldUpdateOperationsInput | string
    report_content_key?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportsCreateManyInput = {
    id?: number
    title: string
    type: string
    institution_id: number
    service_ids: string
    start_date: Date | string
    end_date: Date | string
    report_created_by: number
    report_institution_id: string
    report_recipient: string
    report_queue_uuid: string
    report_content_key?: string | null
    status?: number
    created_at?: Date | string
  }

  export type reportsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    service_ids?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    report_created_by?: IntFieldUpdateOperationsInput | number
    report_institution_id?: StringFieldUpdateOperationsInput | string
    report_recipient?: StringFieldUpdateOperationsInput | string
    report_queue_uuid?: StringFieldUpdateOperationsInput | string
    report_content_key?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    institution_id?: IntFieldUpdateOperationsInput | number
    service_ids?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    report_created_by?: IntFieldUpdateOperationsInput | number
    report_institution_id?: StringFieldUpdateOperationsInput | string
    report_recipient?: StringFieldUpdateOperationsInput | string
    report_queue_uuid?: StringFieldUpdateOperationsInput | string
    report_content_key?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type request_institutionCreateInput = {
    owner_name: string
    address: string
    phone_number: string
    email: string
    name: string
    category: string
    location: string
    type: string
    business_certificate: string
    product_type: string
    approval_status?: number
  }

  export type request_institutionUncheckedCreateInput = {
    id?: number
    owner_name: string
    address: string
    phone_number: string
    email: string
    name: string
    category: string
    location: string
    type: string
    business_certificate: string
    product_type: string
    approval_status?: number
  }

  export type request_institutionUpdateInput = {
    owner_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    business_certificate?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    approval_status?: IntFieldUpdateOperationsInput | number
  }

  export type request_institutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    business_certificate?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    approval_status?: IntFieldUpdateOperationsInput | number
  }

  export type request_institutionCreateManyInput = {
    id?: number
    owner_name: string
    address: string
    phone_number: string
    email: string
    name: string
    category: string
    location: string
    type: string
    business_certificate: string
    product_type: string
    approval_status?: number
  }

  export type request_institutionUpdateManyMutationInput = {
    owner_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    business_certificate?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    approval_status?: IntFieldUpdateOperationsInput | number
  }

  export type request_institutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    business_certificate?: StringFieldUpdateOperationsInput | string
    product_type?: StringFieldUpdateOperationsInput | string
    approval_status?: IntFieldUpdateOperationsInput | number
  }

  export type serviceCreateInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueCreateNestedManyWithoutServiceInput
    rating?: ratingCreateNestedManyWithoutServiceInput
    service_group?: service_groupCreateNestedOneWithoutServiceInput
    institution?: institutionCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterUncheckedCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueUncheckedCreateNestedManyWithoutServiceInput
    rating?: ratingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceUpdateInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUpdateManyWithoutServiceNestedInput
    rating?: ratingUpdateManyWithoutServiceNestedInput
    service_group?: service_groupUpdateOneWithoutServiceNestedInput
    institution?: institutionUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUncheckedUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUncheckedUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceCreateManyInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
  }

  export type serviceUpdateManyMutationInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type serviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type service_groupCreateInput = {
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceCreateNestedManyWithoutService_groupInput
    serviceReview?: serviceReviewCreateNestedManyWithoutService_groupInput
    institution: institutionCreateNestedOneWithoutService_groupInput
    surveyQuestions?: surveyQuestionsCreateNestedManyWithoutService_groupInput
  }

  export type service_groupUncheckedCreateInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    institution_id: number
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceUncheckedCreateNestedManyWithoutService_groupInput
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutService_groupInput
    surveyQuestions?: surveyQuestionsUncheckedCreateNestedManyWithoutService_groupInput
  }

  export type service_groupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUpdateManyWithoutService_groupNestedInput
    serviceReview?: serviceReviewUpdateManyWithoutService_groupNestedInput
    institution?: institutionUpdateOneRequiredWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUncheckedUpdateManyWithoutService_groupNestedInput
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUncheckedUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupCreateManyInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    institution_id: number
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
  }

  export type service_groupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type service_groupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type surveyCreateInput = {
    uuid?: string | null
    type?: boolean | null
    name: string
    description: string
    url?: string | null
    survey_data?: string | null
    institution_id: number
    service_id: string
    created_at?: Date | string
    updated_at?: Date | string
    status?: boolean | null
    access_key?: string | null
  }

  export type surveyUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    type?: boolean | null
    name: string
    description: string
    url?: string | null
    survey_data?: string | null
    institution_id: number
    service_id: string
    created_at?: Date | string
    updated_at?: Date | string
    status?: boolean | null
    access_key?: string | null
  }

  export type surveyUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    survey_data?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type surveyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    survey_data?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type surveyCreateManyInput = {
    id?: number
    uuid?: string | null
    type?: boolean | null
    name: string
    description: string
    url?: string | null
    survey_data?: string | null
    institution_id: number
    service_id: string
    created_at?: Date | string
    updated_at?: Date | string
    status?: boolean | null
    access_key?: string | null
  }

  export type surveyUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    survey_data?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type surveyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    survey_data?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type survey_resultCreateInput = {
    survey_id: number
    rating_id?: number | null
    service_id?: number | null
    device_id?: number | null
    agent?: string | null
    result_data: string
    replied_at?: Date | string | null
  }

  export type survey_resultUncheckedCreateInput = {
    id?: number
    survey_id: number
    rating_id?: number | null
    service_id?: number | null
    device_id?: number | null
    agent?: string | null
    result_data: string
    replied_at?: Date | string | null
  }

  export type survey_resultUpdateInput = {
    survey_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    result_data?: StringFieldUpdateOperationsInput | string
    replied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type survey_resultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    survey_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    result_data?: StringFieldUpdateOperationsInput | string
    replied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type survey_resultCreateManyInput = {
    id?: number
    survey_id: number
    rating_id?: number | null
    service_id?: number | null
    device_id?: number | null
    agent?: string | null
    result_data: string
    replied_at?: Date | string | null
  }

  export type survey_resultUpdateManyMutationInput = {
    survey_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    result_data?: StringFieldUpdateOperationsInput | string
    replied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type survey_resultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    survey_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    result_data?: StringFieldUpdateOperationsInput | string
    replied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tagsCreateInput = {
    name: string
    services: string
    created_at?: Date | string | null
    status?: boolean | null
    user_tags_created_byTouser: userCreateNestedOneWithoutTags_tags_created_byTouserInput
    user_tags_updated_byTouser?: userCreateNestedOneWithoutTags_tags_updated_byTouserInput
  }

  export type tagsUncheckedCreateInput = {
    id?: number
    name: string
    services: string
    created_at?: Date | string | null
    created_by: number
    updated_by?: number | null
    status?: boolean | null
  }

  export type tagsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_tags_created_byTouser?: userUpdateOneRequiredWithoutTags_tags_created_byTouserNestedInput
    user_tags_updated_byTouser?: userUpdateOneWithoutTags_tags_updated_byTouserNestedInput
  }

  export type tagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tagsCreateManyInput = {
    id?: number
    name: string
    services: string
    created_at?: Date | string | null
    created_by: number
    updated_by?: number | null
    status?: boolean | null
  }

  export type tagsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tipCreateInput = {
    collection_reference_id: string
    disbursement_reference_id: string
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    device: deviceCreateNestedOneWithoutTipInput
    rating?: ratingCreateNestedOneWithoutTipInput
  }

  export type tipUncheckedCreateInput = {
    id?: number
    collection_reference_id: string
    disbursement_reference_id: string
    device_id: number
    rating_id?: bigint | number | null
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tipUpdateInput = {
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: deviceUpdateOneRequiredWithoutTipNestedInput
    rating?: ratingUpdateOneWithoutTipNestedInput
  }

  export type tipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tipCreateManyInput = {
    id?: number
    collection_reference_id: string
    disbursement_reference_id: string
    device_id: number
    rating_id?: bigint | number | null
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tipUpdateManyMutationInput = {
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    appointments_appointments_user_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_created_byTouser?: tagsCreateNestedManyWithoutUser_tags_created_byTouserInput
    tags_tags_updated_byTouser?: tagsCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    appointments_appointments_user_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_created_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_created_byTouserInput
    tags_tags_updated_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    appointments_appointments_user_idTouser?: appointmentsUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUpdateManyWithoutUser_tags_created_byTouserNestedInput
    tags_tags_updated_byTouser?: tagsUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    appointments_appointments_user_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserNestedInput
    tags_tags_updated_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
  }

  export type userUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type wallet_accountsCreateInput = {
    user_id?: number | null
    account_type_id?: number | null
    account_number?: string | null
    account_name?: string | null
    balance?: number | null
    public_key?: string | null
    private_key?: string | null
    added_at?: Date | string
  }

  export type wallet_accountsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    account_type_id?: number | null
    account_number?: string | null
    account_name?: string | null
    balance?: number | null
    public_key?: string | null
    private_key?: string | null
    added_at?: Date | string
  }

  export type wallet_accountsUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accountsCreateManyInput = {
    id?: number
    user_id?: number | null
    account_type_id?: number | null
    account_number?: string | null
    account_name?: string | null
    balance?: number | null
    public_key?: string | null
    private_key?: string | null
    added_at?: Date | string
  }

  export type wallet_accountsUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accounts_typesCreateInput = {
    category?: string | null
    abbreviation?: string | null
    name?: string | null
    added_at?: Date | string
  }

  export type wallet_accounts_typesUncheckedCreateInput = {
    id?: number
    category?: string | null
    abbreviation?: string | null
    name?: string | null
    added_at?: Date | string
  }

  export type wallet_accounts_typesUpdateInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accounts_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accounts_typesCreateManyInput = {
    id?: number
    category?: string | null
    abbreviation?: string | null
    name?: string | null
    added_at?: Date | string
  }

  export type wallet_accounts_typesUpdateManyMutationInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_accounts_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_transfersCreateInput = {
    amount?: number | null
    currency?: string | null
    time?: Date | string | null
    payer_id?: number | null
    payer_account_id?: number | null
    payee_address?: string | null
    payee_name?: string | null
    payee_account_type?: string | null
    payee_account_number?: string | null
    payee_type?: string | null
    tx_id?: string | null
    fspid?: string | null
    ext_trx_id?: string | null
    pay_money_ext_res?: string | null
    confirm_party_ext_res?: string | null
    confirm_quote_ext_res?: string | null
    status?: string | null
    quote_id?: string | null
    note?: string | null
    transfer_fees?: string | null
  }

  export type wallet_transfersUncheckedCreateInput = {
    id?: number
    amount?: number | null
    currency?: string | null
    time?: Date | string | null
    payer_id?: number | null
    payer_account_id?: number | null
    payee_address?: string | null
    payee_name?: string | null
    payee_account_type?: string | null
    payee_account_number?: string | null
    payee_type?: string | null
    tx_id?: string | null
    fspid?: string | null
    ext_trx_id?: string | null
    pay_money_ext_res?: string | null
    confirm_party_ext_res?: string | null
    confirm_quote_ext_res?: string | null
    status?: string | null
    quote_id?: string | null
    note?: string | null
    transfer_fees?: string | null
  }

  export type wallet_transfersUpdateInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payer_id?: NullableIntFieldUpdateOperationsInput | number | null
    payer_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    payee_address?: NullableStringFieldUpdateOperationsInput | string | null
    payee_name?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_type?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    payee_type?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableStringFieldUpdateOperationsInput | string | null
    fspid?: NullableStringFieldUpdateOperationsInput | string | null
    ext_trx_id?: NullableStringFieldUpdateOperationsInput | string | null
    pay_money_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_party_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_quote_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_fees?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallet_transfersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payer_id?: NullableIntFieldUpdateOperationsInput | number | null
    payer_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    payee_address?: NullableStringFieldUpdateOperationsInput | string | null
    payee_name?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_type?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    payee_type?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableStringFieldUpdateOperationsInput | string | null
    fspid?: NullableStringFieldUpdateOperationsInput | string | null
    ext_trx_id?: NullableStringFieldUpdateOperationsInput | string | null
    pay_money_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_party_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_quote_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_fees?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallet_transfersCreateManyInput = {
    id?: number
    amount?: number | null
    currency?: string | null
    time?: Date | string | null
    payer_id?: number | null
    payer_account_id?: number | null
    payee_address?: string | null
    payee_name?: string | null
    payee_account_type?: string | null
    payee_account_number?: string | null
    payee_type?: string | null
    tx_id?: string | null
    fspid?: string | null
    ext_trx_id?: string | null
    pay_money_ext_res?: string | null
    confirm_party_ext_res?: string | null
    confirm_quote_ext_res?: string | null
    status?: string | null
    quote_id?: string | null
    note?: string | null
    transfer_fees?: string | null
  }

  export type wallet_transfersUpdateManyMutationInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payer_id?: NullableIntFieldUpdateOperationsInput | number | null
    payer_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    payee_address?: NullableStringFieldUpdateOperationsInput | string | null
    payee_name?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_type?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    payee_type?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableStringFieldUpdateOperationsInput | string | null
    fspid?: NullableStringFieldUpdateOperationsInput | string | null
    ext_trx_id?: NullableStringFieldUpdateOperationsInput | string | null
    pay_money_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_party_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_quote_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_fees?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallet_transfersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payer_id?: NullableIntFieldUpdateOperationsInput | number | null
    payer_account_id?: NullableIntFieldUpdateOperationsInput | number | null
    payee_address?: NullableStringFieldUpdateOperationsInput | string | null
    payee_name?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_type?: NullableStringFieldUpdateOperationsInput | string | null
    payee_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    payee_type?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableStringFieldUpdateOperationsInput | string | null
    fspid?: NullableStringFieldUpdateOperationsInput | string | null
    ext_trx_id?: NullableStringFieldUpdateOperationsInput | string | null
    pay_money_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_party_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    confirm_quote_ext_res?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    quote_id?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    transfer_fees?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallet_usersCreateInput = {
    device_id?: number | null
    fullname?: string | null
    email?: string | null
    private_key?: string | null
    public_key?: string | null
    initiated_at?: Date | string
  }

  export type wallet_usersUncheckedCreateInput = {
    id?: number
    device_id?: number | null
    fullname?: string | null
    email?: string | null
    private_key?: string | null
    public_key?: string | null
    initiated_at?: Date | string
  }

  export type wallet_usersUpdateInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    initiated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    initiated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_usersCreateManyInput = {
    id?: number
    device_id?: number | null
    fullname?: string | null
    email?: string | null
    private_key?: string | null
    public_key?: string | null
    initiated_at?: Date | string
  }

  export type wallet_usersUpdateManyMutationInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    initiated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    private_key?: NullableStringFieldUpdateOperationsInput | string | null
    public_key?: NullableStringFieldUpdateOperationsInput | string | null
    initiated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesCreateInput = {
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    institution?: institutionCreateNestedOneWithoutImagesInput
    reviews?: reviewsCreateNestedOneWithoutImagesInput
    users_profile?: users_profileCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateInput = {
    id?: number
    institution_id?: number | null
    user_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    review_id?: number | null
  }

  export type imagesUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutImagesNestedInput
    reviews?: reviewsUpdateOneWithoutImagesNestedInput
    users_profile?: users_profileUpdateOneWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    review_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type imagesCreateManyInput = {
    id?: number
    institution_id?: number | null
    user_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    review_id?: number | null
  }

  export type imagesUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    review_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sectorsCreateInput = {
    name?: string | null
    description?: string | null
    categories?: categoriesCreateNestedManyWithoutSectorsInput
  }

  export type sectorsUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutSectorsInput
  }

  export type sectorsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUpdateManyWithoutSectorsNestedInput
  }

  export type sectorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUncheckedUpdateManyWithoutSectorsNestedInput
  }

  export type sectorsCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
  }

  export type sectorsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sectorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type users_profileCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    images?: imagesCreateNestedManyWithoutUsers_profileInput
    reviews?: reviewsCreateNestedManyWithoutUsers_profileInput
    serviceReview?: serviceReviewCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    images?: imagesUncheckedCreateNestedManyWithoutUsers_profileInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsers_profileInput
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    images?: imagesUpdateManyWithoutUsers_profileNestedInput
    reviews?: reviewsUpdateManyWithoutUsers_profileNestedInput
    serviceReview?: serviceReviewUpdateManyWithoutUsers_profileNestedInput
  }

  export type users_profileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    images?: imagesUncheckedUpdateManyWithoutUsers_profileNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsers_profileNestedInput
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutUsers_profileNestedInput
  }

  export type users_profileCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
  }

  export type users_profileUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type users_profileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewsCreateInput = {
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    images?: imagesCreateNestedManyWithoutReviewsInput
    institution: institutionCreateNestedOneWithoutReviewsInput
    users_profile: users_profileCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateInput = {
    id?: number
    user_id: number
    institution_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    images?: imagesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: imagesUpdateManyWithoutReviewsNestedInput
    institution?: institutionUpdateOneRequiredWithoutReviewsNestedInput
    users_profile?: users_profileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: imagesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsCreateManyInput = {
    id?: number
    user_id: number
    institution_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
  }

  export type reviewsUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type reviewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type workingHourCreateInput = {
    day_of_week: string
    open_time?: Date | string | null
    close_time?: Date | string | null
    institution: institutionCreateNestedOneWithoutWorkingHourInput
  }

  export type workingHourUncheckedCreateInput = {
    id?: number
    institution_id: number
    day_of_week: string
    open_time?: Date | string | null
    close_time?: Date | string | null
  }

  export type workingHourUpdateInput = {
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    institution?: institutionUpdateOneRequiredWithoutWorkingHourNestedInput
  }

  export type workingHourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workingHourCreateManyInput = {
    id?: number
    institution_id: number
    day_of_week: string
    open_time?: Date | string | null
    close_time?: Date | string | null
  }

  export type workingHourUpdateManyMutationInput = {
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workingHourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type amenitiesCreateInput = {
    name: string
    icon?: string | null
    added_at?: Date | string | null
    business_amenities?: business_amenitiesCreateNestedManyWithoutAmenitiesInput
  }

  export type amenitiesUncheckedCreateInput = {
    id?: number
    name: string
    icon?: string | null
    added_at?: Date | string | null
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutAmenitiesInput
  }

  export type amenitiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_amenities?: business_amenitiesUpdateManyWithoutAmenitiesNestedInput
  }

  export type amenitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutAmenitiesNestedInput
  }

  export type amenitiesCreateManyInput = {
    id?: number
    name: string
    icon?: string | null
    added_at?: Date | string | null
  }

  export type amenitiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type amenitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type business_amenitiesCreateInput = {
    amenities?: amenitiesCreateNestedOneWithoutBusiness_amenitiesInput
    institution?: institutionCreateNestedOneWithoutBusiness_amenitiesInput
  }

  export type business_amenitiesUncheckedCreateInput = {
    id?: number
    institution_id?: number | null
    amenitY_id?: number | null
  }

  export type business_amenitiesUpdateInput = {
    amenities?: amenitiesUpdateOneWithoutBusiness_amenitiesNestedInput
    institution?: institutionUpdateOneWithoutBusiness_amenitiesNestedInput
  }

  export type business_amenitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    amenitY_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type business_amenitiesCreateManyInput = {
    id?: number
    institution_id?: number | null
    amenitY_id?: number | null
  }

  export type business_amenitiesUpdateManyMutationInput = {

  }

  export type business_amenitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    amenitY_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type price_rangesCreateInput = {
    max_value: number
    min_value: number
    label?: string | null
    institution: institutionCreateNestedOneWithoutPrice_rangesInput
  }

  export type price_rangesUncheckedCreateInput = {
    id?: number
    max_value: number
    min_value: number
    institution_id: number
    label?: string | null
  }

  export type price_rangesUpdateInput = {
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: institutionUpdateOneRequiredWithoutPrice_rangesNestedInput
  }

  export type price_rangesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_rangesCreateManyInput = {
    id?: number
    max_value: number
    min_value: number
    institution_id: number
    label?: string | null
  }

  export type price_rangesUpdateManyMutationInput = {
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_rangesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type surveyAnswersCreateInput = {
    user_id?: number | null
    answer?: string | null
    scale_rating?: number | null
    added_at?: Date | string
    surveyQuestions: surveyQuestionsCreateNestedOneWithoutSurveyAnswersInput
  }

  export type surveyAnswersUncheckedCreateInput = {
    id?: number
    question_id: number
    user_id?: number | null
    answer?: string | null
    scale_rating?: number | null
    added_at?: Date | string
  }

  export type surveyAnswersUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: surveyQuestionsUpdateOneRequiredWithoutSurveyAnswersNestedInput
  }

  export type surveyAnswersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyAnswersCreateManyInput = {
    id?: number
    question_id: number
    user_id?: number | null
    answer?: string | null
    scale_rating?: number | null
    added_at?: Date | string
  }

  export type surveyAnswersUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyAnswersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyQuestionsCreateInput = {
    question?: string | null
    choices?: string | null
    added_at?: Date | string
    surveyAnswers?: surveyAnswersCreateNestedManyWithoutSurveyQuestionsInput
    service_group: service_groupCreateNestedOneWithoutSurveyQuestionsInput
  }

  export type surveyQuestionsUncheckedCreateInput = {
    id?: number
    service_id: number
    question?: string | null
    choices?: string | null
    added_at?: Date | string
    surveyAnswers?: surveyAnswersUncheckedCreateNestedManyWithoutSurveyQuestionsInput
  }

  export type surveyQuestionsUpdateInput = {
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: surveyAnswersUpdateManyWithoutSurveyQuestionsNestedInput
    service_group?: service_groupUpdateOneRequiredWithoutSurveyQuestionsNestedInput
  }

  export type surveyQuestionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: surveyAnswersUncheckedUpdateManyWithoutSurveyQuestionsNestedInput
  }

  export type surveyQuestionsCreateManyInput = {
    id?: number
    service_id: number
    question?: string | null
    choices?: string | null
    added_at?: Date | string
  }

  export type surveyQuestionsUpdateManyMutationInput = {
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyQuestionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type serviceReviewCreateInput = {
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
    service_group?: service_groupCreateNestedOneWithoutServiceReviewInput
    users_profile?: users_profileCreateNestedOneWithoutServiceReviewInput
  }

  export type serviceReviewUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    service_id?: number | null
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
  }

  export type serviceReviewUpdateInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_group?: service_groupUpdateOneWithoutServiceReviewNestedInput
    users_profile?: users_profileUpdateOneWithoutServiceReviewNestedInput
  }

  export type serviceReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceReviewCreateManyInput = {
    id?: number
    user_id?: number | null
    service_id?: number | null
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
  }

  export type serviceReviewUpdateManyMutationInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type category_search_termsCreateInput = {
    term: string
    categories: categoriesCreateNestedOneWithoutCategory_search_termsInput
  }

  export type category_search_termsUncheckedCreateInput = {
    id?: number
    category_id: number
    term: string
  }

  export type category_search_termsUpdateInput = {
    term?: StringFieldUpdateOperationsInput | string
    categories?: categoriesUpdateOneRequiredWithoutCategory_search_termsNestedInput
  }

  export type category_search_termsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
  }

  export type category_search_termsCreateManyInput = {
    id?: number
    category_id: number
    term: string
  }

  export type category_search_termsUpdateManyMutationInput = {
    term?: StringFieldUpdateOperationsInput | string
  }

  export type category_search_termsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Enumapp_releases_app_nameFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_app_name | Enumapp_releases_app_nameFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_app_name[]
    notIn?: $Enums.app_releases_app_name[]
    not?: NestedEnumapp_releases_app_nameFilter<$PrismaModel> | $Enums.app_releases_app_name
  }

  export type Enumapp_releases_platformFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_platform | Enumapp_releases_platformFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_platform[]
    notIn?: $Enums.app_releases_platform[]
    not?: NestedEnumapp_releases_platformFilter<$PrismaModel> | $Enums.app_releases_platform
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type app_releasesOrderByRelevanceInput = {
    fields: app_releasesOrderByRelevanceFieldEnum | app_releasesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type app_releasesCountOrderByAggregateInput = {
    id?: SortOrder
    release_version?: SortOrder
    app_name?: SortOrder
    platform?: SortOrder
    release_note?: SortOrder
    release_url?: SortOrder
    minimum_version?: SortOrder
    added_at?: SortOrder
  }

  export type app_releasesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type app_releasesMaxOrderByAggregateInput = {
    id?: SortOrder
    release_version?: SortOrder
    app_name?: SortOrder
    platform?: SortOrder
    release_note?: SortOrder
    release_url?: SortOrder
    minimum_version?: SortOrder
    added_at?: SortOrder
  }

  export type app_releasesMinOrderByAggregateInput = {
    id?: SortOrder
    release_version?: SortOrder
    app_name?: SortOrder
    platform?: SortOrder
    release_note?: SortOrder
    release_url?: SortOrder
    minimum_version?: SortOrder
    added_at?: SortOrder
  }

  export type app_releasesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Enumapp_releases_app_nameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_app_name | Enumapp_releases_app_nameFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_app_name[]
    notIn?: $Enums.app_releases_app_name[]
    not?: NestedEnumapp_releases_app_nameWithAggregatesFilter<$PrismaModel> | $Enums.app_releases_app_name
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapp_releases_app_nameFilter<$PrismaModel>
    _max?: NestedEnumapp_releases_app_nameFilter<$PrismaModel>
  }

  export type Enumapp_releases_platformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_platform | Enumapp_releases_platformFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_platform[]
    notIn?: $Enums.app_releases_platform[]
    not?: NestedEnumapp_releases_platformWithAggregatesFilter<$PrismaModel> | $Enums.app_releases_platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapp_releases_platformFilter<$PrismaModel>
    _max?: NestedEnumapp_releases_platformFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type InstitutionNullableScalarRelationFilter = {
    is?: institutionWhereInput | null
    isNot?: institutionWhereInput | null
  }

  export type Qms_operatorNullableScalarRelationFilter = {
    is?: qms_operatorWhereInput | null
    isNot?: qms_operatorWhereInput | null
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: serviceWhereInput | null
    isNot?: serviceWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type appointmentsOrderByRelevanceInput = {
    fields: appointmentsOrderByRelevanceFieldEnum | appointmentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type appointmentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    operator_id?: SortOrder
    user_id?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    location?: SortOrder
    additional_note?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrder
    notification_status?: SortOrder
    ticket_created?: SortOrder
    appointment_cancelled?: SortOrder
    created_at?: SortOrder
    cancellation_reason?: SortOrder
  }

  export type appointmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    operator_id?: SortOrder
    user_id?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrder
    notification_status?: SortOrder
    ticket_created?: SortOrder
    appointment_cancelled?: SortOrder
  }

  export type appointmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    operator_id?: SortOrder
    user_id?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    location?: SortOrder
    additional_note?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrder
    notification_status?: SortOrder
    ticket_created?: SortOrder
    appointment_cancelled?: SortOrder
    created_at?: SortOrder
    cancellation_reason?: SortOrder
  }

  export type appointmentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    operator_id?: SortOrder
    user_id?: SortOrder
    reason?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    location?: SortOrder
    additional_note?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrder
    notification_status?: SortOrder
    ticket_created?: SortOrder
    appointment_cancelled?: SortOrder
    created_at?: SortOrder
    cancellation_reason?: SortOrder
  }

  export type appointmentsSumOrderByAggregateInput = {
    id?: SortOrder
    registry_type?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    operator_id?: SortOrder
    user_id?: SortOrder
    creator_id?: SortOrder
    recurring?: SortOrder
    notification_status?: SortOrder
    ticket_created?: SortOrder
    appointment_cancelled?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type InstitutionScalarRelationFilter = {
    is?: institutionWhereInput
    isNot?: institutionWhereInput
  }

  export type appsOrderByRelevanceInput = {
    fields: appsOrderByRelevanceFieldEnum | appsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type appsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
    secret_key?: SortOrder
    access_key?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type appsAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
  }

  export type appsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
    secret_key?: SortOrder
    access_key?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type appsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
    secret_key?: SortOrder
    access_key?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type appsSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    institution_id?: SortOrder
  }

  export type Enumaudit_trail_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_trail_status | Enumaudit_trail_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.audit_trail_status[] | null
    notIn?: $Enums.audit_trail_status[] | null
    not?: NestedEnumaudit_trail_statusNullableFilter<$PrismaModel> | $Enums.audit_trail_status | null
  }

  export type audit_trailOrderByRelevanceInput = {
    fields: audit_trailOrderByRelevanceFieldEnum | audit_trailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type audit_trailCountOrderByAggregateInput = {
    id?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    action?: SortOrder
    model?: SortOrder
    field?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    model_id?: SortOrder
    display_name?: SortOrder
    time?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
  }

  export type audit_trailAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reviewed_by?: SortOrder
  }

  export type audit_trailMaxOrderByAggregateInput = {
    id?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    action?: SortOrder
    model?: SortOrder
    field?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    model_id?: SortOrder
    display_name?: SortOrder
    time?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
  }

  export type audit_trailMinOrderByAggregateInput = {
    id?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    action?: SortOrder
    model?: SortOrder
    field?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    model_id?: SortOrder
    display_name?: SortOrder
    time?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
  }

  export type audit_trailSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reviewed_by?: SortOrder
  }

  export type Enumaudit_trail_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_trail_status | Enumaudit_trail_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.audit_trail_status[] | null
    notIn?: $Enums.audit_trail_status[] | null
    not?: NestedEnumaudit_trail_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.audit_trail_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumaudit_trail_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumaudit_trail_statusNullableFilter<$PrismaModel>
  }

  export type SectorsNullableScalarRelationFilter = {
    is?: sectorsWhereInput | null
    isNot?: sectorsWhereInput | null
  }

  export type Category_search_termsListRelationFilter = {
    every?: category_search_termsWhereInput
    some?: category_search_termsWhereInput
    none?: category_search_termsWhereInput
  }

  export type InstitutionListRelationFilter = {
    every?: institutionWhereInput
    some?: institutionWhereInput
    none?: institutionWhereInput
  }

  export type category_search_termsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type institutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesOrderByRelevanceInput = {
    fields: categoriesOrderByRelevanceFieldEnum | categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sector_id?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    sector_id?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sector_id?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sector_id?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    sector_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type change_requestOrderByRelevanceInput = {
    fields: change_requestOrderByRelevanceFieldEnum | change_requestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type change_requestCountOrderByAggregateInput = {
    id?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    action?: SortOrder
    model?: SortOrder
    model_id?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    display_name?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    time?: SortOrder
    institution_id?: SortOrder
  }

  export type change_requestAvgOrderByAggregateInput = {
    id?: SortOrder
    model_id?: SortOrder
    user_id?: SortOrder
    reviewed_by?: SortOrder
    institution_id?: SortOrder
  }

  export type change_requestMaxOrderByAggregateInput = {
    id?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    action?: SortOrder
    model?: SortOrder
    model_id?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    display_name?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    time?: SortOrder
    institution_id?: SortOrder
  }

  export type change_requestMinOrderByAggregateInput = {
    id?: SortOrder
    old_value?: SortOrder
    new_value?: SortOrder
    action?: SortOrder
    model?: SortOrder
    model_id?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    display_name?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    time?: SortOrder
    institution_id?: SortOrder
  }

  export type change_requestSumOrderByAggregateInput = {
    id?: SortOrder
    model_id?: SortOrder
    user_id?: SortOrder
    reviewed_by?: SortOrder
    institution_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Qms_customerListRelationFilter = {
    every?: qms_customerWhereInput
    some?: qms_customerWhereInput
    none?: qms_customerWhereInput
  }

  export type RatingListRelationFilter = {
    every?: ratingWhereInput
    some?: ratingWhereInput
    none?: ratingWhereInput
  }

  export type TipListRelationFilter = {
    every?: tipWhereInput
    some?: tipWhereInput
    none?: tipWhereInput
  }

  export type qms_customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ratingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deviceOrderByRelevanceInput = {
    fields: deviceOrderByRelevanceFieldEnum | deviceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type deviceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    notification_token?: SortOrder
    affiliate_id?: SortOrder
    service_id?: SortOrder
    serial_number?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    device_type?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    language?: SortOrder
    notification_enabled?: SortOrder
    apiKey?: SortOrder
    nonce?: SortOrder
    linkShortCode?: SortOrder
    linkShortCodeExp?: SortOrder
    phone_number?: SortOrder
    latest_hb?: SortOrder
    latest_hb_version?: SortOrder
    updated_at?: SortOrder
  }

  export type deviceAvgOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    status?: SortOrder
    device_type?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    language?: SortOrder
    nonce?: SortOrder
  }

  export type deviceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    notification_token?: SortOrder
    affiliate_id?: SortOrder
    service_id?: SortOrder
    serial_number?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    device_type?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    language?: SortOrder
    notification_enabled?: SortOrder
    apiKey?: SortOrder
    nonce?: SortOrder
    linkShortCode?: SortOrder
    linkShortCodeExp?: SortOrder
    phone_number?: SortOrder
    latest_hb?: SortOrder
    latest_hb_version?: SortOrder
    updated_at?: SortOrder
  }

  export type deviceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    notification_token?: SortOrder
    affiliate_id?: SortOrder
    service_id?: SortOrder
    serial_number?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    device_type?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    language?: SortOrder
    notification_enabled?: SortOrder
    apiKey?: SortOrder
    nonce?: SortOrder
    linkShortCode?: SortOrder
    linkShortCodeExp?: SortOrder
    phone_number?: SortOrder
    latest_hb?: SortOrder
    latest_hb_version?: SortOrder
    updated_at?: SortOrder
  }

  export type deviceSumOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    status?: SortOrder
    device_type?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    language?: SortOrder
    nonce?: SortOrder
  }

  export type device_heartbeatOrderByRelevanceInput = {
    fields: device_heartbeatOrderByRelevanceFieldEnum | device_heartbeatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type device_heartbeatCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    device_id?: SortOrder
    operator_id?: SortOrder
    version?: SortOrder
  }

  export type device_heartbeatAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    operator_id?: SortOrder
  }

  export type device_heartbeatMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    device_id?: SortOrder
    operator_id?: SortOrder
    version?: SortOrder
  }

  export type device_heartbeatMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    device_id?: SortOrder
    operator_id?: SortOrder
    version?: SortOrder
  }

  export type device_heartbeatSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    operator_id?: SortOrder
  }

  export type AppointmentsListRelationFilter = {
    every?: appointmentsWhereInput
    some?: appointmentsWhereInput
    none?: appointmentsWhereInput
  }

  export type AppsListRelationFilter = {
    every?: appsWhereInput
    some?: appsWhereInput
    none?: appsWhereInput
  }

  export type Business_amenitiesListRelationFilter = {
    every?: business_amenitiesWhereInput
    some?: business_amenitiesWhereInput
    none?: business_amenitiesWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: deviceWhereInput
    some?: deviceWhereInput
    none?: deviceWhereInput
  }

  export type ImagesListRelationFilter = {
    every?: imagesWhereInput
    some?: imagesWhereInput
    none?: imagesWhereInput
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type Popup_questionsListRelationFilter = {
    every?: popup_questionsWhereInput
    some?: popup_questionsWhereInput
    none?: popup_questionsWhereInput
  }

  export type Price_rangesListRelationFilter = {
    every?: price_rangesWhereInput
    some?: price_rangesWhereInput
    none?: price_rangesWhereInput
  }

  export type Qms_branch_operatorListRelationFilter = {
    every?: qms_branch_operatorWhereInput
    some?: qms_branch_operatorWhereInput
    none?: qms_branch_operatorWhereInput
  }

  export type Qms_branch_transactionsListRelationFilter = {
    every?: qms_branch_transactionsWhereInput
    some?: qms_branch_transactionsWhereInput
    none?: qms_branch_transactionsWhereInput
  }

  export type Qms_operatorListRelationFilter = {
    every?: qms_operatorWhereInput
    some?: qms_operatorWhereInput
    none?: qms_operatorWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: reviewsWhereInput
    some?: reviewsWhereInput
    none?: reviewsWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: serviceWhereInput
    some?: serviceWhereInput
    none?: serviceWhereInput
  }

  export type Service_groupListRelationFilter = {
    every?: service_groupWhereInput
    some?: service_groupWhereInput
    none?: service_groupWhereInput
  }

  export type WorkingHourListRelationFilter = {
    every?: workingHourWhereInput
    some?: workingHourWhereInput
    none?: workingHourWhereInput
  }

  export type appointmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type appsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type business_amenitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type popup_questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type price_rangesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_branch_operatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_branch_transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_operatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_groupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type workingHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type institutionOrderByRelevanceInput = {
    fields: institutionOrderByRelevanceFieldEnum | institutionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type institutionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    search_term?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    plan?: SortOrder
    type?: SortOrder
    level?: SortOrder
    parent_id?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    queue_autocreation?: SortOrder
    queue_manual_creation?: SortOrder
    working_hours?: SortOrder
    qms_message?: SortOrder
    priority_list?: SortOrder
    logo?: SortOrder
    app_name?: SortOrder
    allowed_context?: SortOrder
    host_name?: SortOrder
    membership_type?: SortOrder
    category_id?: SortOrder
    latest_membership_renew_time?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    button_one?: SortOrder
    button_two?: SortOrder
    amenities?: SortOrder
  }

  export type institutionAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    type?: SortOrder
    level?: SortOrder
    parent_id?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    queue_autocreation?: SortOrder
    queue_manual_creation?: SortOrder
    allowed_context?: SortOrder
    membership_type?: SortOrder
    category_id?: SortOrder
  }

  export type institutionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    search_term?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    plan?: SortOrder
    type?: SortOrder
    level?: SortOrder
    parent_id?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    queue_autocreation?: SortOrder
    queue_manual_creation?: SortOrder
    working_hours?: SortOrder
    qms_message?: SortOrder
    priority_list?: SortOrder
    logo?: SortOrder
    app_name?: SortOrder
    allowed_context?: SortOrder
    host_name?: SortOrder
    membership_type?: SortOrder
    category_id?: SortOrder
    latest_membership_renew_time?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    button_one?: SortOrder
    button_two?: SortOrder
    amenities?: SortOrder
  }

  export type institutionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    search_term?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    url?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    plan?: SortOrder
    type?: SortOrder
    level?: SortOrder
    parent_id?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    queue_autocreation?: SortOrder
    queue_manual_creation?: SortOrder
    working_hours?: SortOrder
    qms_message?: SortOrder
    priority_list?: SortOrder
    logo?: SortOrder
    app_name?: SortOrder
    allowed_context?: SortOrder
    host_name?: SortOrder
    membership_type?: SortOrder
    category_id?: SortOrder
    latest_membership_renew_time?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    button_one?: SortOrder
    button_two?: SortOrder
    amenities?: SortOrder
  }

  export type institutionSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    plan?: SortOrder
    type?: SortOrder
    level?: SortOrder
    parent_id?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    queue_autocreation?: SortOrder
    queue_manual_creation?: SortOrder
    allowed_context?: SortOrder
    membership_type?: SortOrder
    category_id?: SortOrder
  }

  export type Enuminstitution_invoices_payment_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_payment_status | Enuminstitution_invoices_payment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_payment_status[]
    notIn?: $Enums.institution_invoices_payment_status[]
    not?: NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel> | $Enums.institution_invoices_payment_status
  }

  export type Enuminstitution_invoices_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_status | Enuminstitution_invoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_status[]
    notIn?: $Enums.institution_invoices_status[]
    not?: NestedEnuminstitution_invoices_statusFilter<$PrismaModel> | $Enums.institution_invoices_status
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type institution_invoicesOrderByRelevanceInput = {
    fields: institution_invoicesOrderByRelevanceFieldEnum | institution_invoicesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type institution_invoicesCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    generated_at?: SortOrder
    expiry?: SortOrder
    payment_reference_number?: SortOrder
    ext_payment_reference_number?: SortOrder
    payment_status?: SortOrder
    payment_status_desc?: SortOrder
    payment_method?: SortOrder
    payment_retries?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
  }

  export type institution_invoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    payment_retries?: SortOrder
    total_amount?: SortOrder
  }

  export type institution_invoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    generated_at?: SortOrder
    expiry?: SortOrder
    payment_reference_number?: SortOrder
    ext_payment_reference_number?: SortOrder
    payment_status?: SortOrder
    payment_status_desc?: SortOrder
    payment_method?: SortOrder
    payment_retries?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
  }

  export type institution_invoicesMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    institution_id?: SortOrder
    institution_name?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    generated_at?: SortOrder
    expiry?: SortOrder
    payment_reference_number?: SortOrder
    ext_payment_reference_number?: SortOrder
    payment_status?: SortOrder
    payment_status_desc?: SortOrder
    payment_method?: SortOrder
    payment_retries?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
  }

  export type institution_invoicesSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    payment_retries?: SortOrder
    total_amount?: SortOrder
  }

  export type Enuminstitution_invoices_payment_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_payment_status | Enuminstitution_invoices_payment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_payment_status[]
    notIn?: $Enums.institution_invoices_payment_status[]
    not?: NestedEnuminstitution_invoices_payment_statusWithAggregatesFilter<$PrismaModel> | $Enums.institution_invoices_payment_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel>
    _max?: NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel>
  }

  export type Enuminstitution_invoices_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_status | Enuminstitution_invoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_status[]
    notIn?: $Enums.institution_invoices_status[]
    not?: NestedEnuminstitution_invoices_statusWithAggregatesFilter<$PrismaModel> | $Enums.institution_invoices_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminstitution_invoices_statusFilter<$PrismaModel>
    _max?: NestedEnuminstitution_invoices_statusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type institution_service_trackingOrderByRelevanceInput = {
    fields: institution_service_trackingOrderByRelevanceFieldEnum | institution_service_trackingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type institution_service_trackingCountOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    branch_id?: SortOrder
    service_id?: SortOrder
    branch_name?: SortOrder
    service_group_name?: SortOrder
    time?: SortOrder
    action?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
  }

  export type institution_service_trackingAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    branch_id?: SortOrder
    service_id?: SortOrder
  }

  export type institution_service_trackingMaxOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    branch_id?: SortOrder
    service_id?: SortOrder
    branch_name?: SortOrder
    service_group_name?: SortOrder
    time?: SortOrder
    action?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
  }

  export type institution_service_trackingMinOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    branch_id?: SortOrder
    service_id?: SortOrder
    branch_name?: SortOrder
    service_group_name?: SortOrder
    time?: SortOrder
    action?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
  }

  export type institution_service_trackingSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    branch_id?: SortOrder
    service_id?: SortOrder
  }

  export type login_historyOrderByRelevanceInput = {
    fields: login_historyOrderByRelevanceFieldEnum | login_historyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type login_historyCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    time?: SortOrder
  }

  export type login_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type login_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    time?: SortOrder
  }

  export type login_historyMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip?: SortOrder
    user_agent?: SortOrder
    time?: SortOrder
  }

  export type login_historySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type migrationOrderByRelevanceInput = {
    fields: migrationOrderByRelevanceFieldEnum | migrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type migrationCountOrderByAggregateInput = {
    version?: SortOrder
    apply_time?: SortOrder
  }

  export type migrationAvgOrderByAggregateInput = {
    apply_time?: SortOrder
  }

  export type migrationMaxOrderByAggregateInput = {
    version?: SortOrder
    apply_time?: SortOrder
  }

  export type migrationMinOrderByAggregateInput = {
    version?: SortOrder
    apply_time?: SortOrder
  }

  export type migrationSumOrderByAggregateInput = {
    apply_time?: SortOrder
  }

  export type mms_fileOrderByRelevanceInput = {
    fields: mms_fileOrderByRelevanceFieldEnum | mms_fileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type mms_fileCountOrderByAggregateInput = {
    id?: SortOrder
    device_uuid?: SortOrder
    institution_id?: SortOrder
    path?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    height?: SortOrder
    width?: SortOrder
    first_view_time?: SortOrder
    last_view_time?: SortOrder
    created_at?: SortOrder
  }

  export type mms_fileAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    type?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    height?: SortOrder
    width?: SortOrder
  }

  export type mms_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    device_uuid?: SortOrder
    institution_id?: SortOrder
    path?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    height?: SortOrder
    width?: SortOrder
    first_view_time?: SortOrder
    last_view_time?: SortOrder
    created_at?: SortOrder
  }

  export type mms_fileMinOrderByAggregateInput = {
    id?: SortOrder
    device_uuid?: SortOrder
    institution_id?: SortOrder
    path?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    height?: SortOrder
    width?: SortOrder
    first_view_time?: SortOrder
    last_view_time?: SortOrder
    created_at?: SortOrder
  }

  export type mms_fileSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    type?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    height?: SortOrder
    width?: SortOrder
  }

  export type notificationOrderByRelevanceInput = {
    fields: notificationOrderByRelevanceFieldEnum | notificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    seen?: SortOrder
    time_sent?: SortOrder
    time_seen?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    seen?: SortOrder
    time_sent?: SortOrder
    time_seen?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    link?: SortOrder
    seen?: SortOrder
    time_sent?: SortOrder
    time_seen?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type notification_recipientCountOrderByAggregateInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrder
    seen?: SortOrder
    ticket?: SortOrder
    reference_id?: SortOrder
  }

  export type notification_recipientAvgOrderByAggregateInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrder
    seen?: SortOrder
    ticket?: SortOrder
    reference_id?: SortOrder
  }

  export type notification_recipientMaxOrderByAggregateInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrder
    seen?: SortOrder
    ticket?: SortOrder
    reference_id?: SortOrder
  }

  export type notification_recipientMinOrderByAggregateInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrder
    seen?: SortOrder
    ticket?: SortOrder
    reference_id?: SortOrder
  }

  export type notification_recipientSumOrderByAggregateInput = {
    id?: SortOrder
    id_notification?: SortOrder
    id_user?: SortOrder
    seen?: SortOrder
    ticket?: SortOrder
    reference_id?: SortOrder
  }

  export type Qms_ticketListRelationFilter = {
    every?: qms_ticketWhereInput
    some?: qms_ticketWhereInput
    none?: qms_ticketWhereInput
  }

  export type qms_ticketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type optionOrderByRelevanceInput = {
    fields: optionOrderByRelevanceFieldEnum | optionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type optionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
  }

  export type optionAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    parent_id?: SortOrder
  }

  export type optionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
  }

  export type optionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
  }

  export type optionSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    parent_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Popup_questions_possible_answersListRelationFilter = {
    every?: popup_questions_possible_answersWhereInput
    some?: popup_questions_possible_answersWhereInput
    none?: popup_questions_possible_answersWhereInput
  }

  export type popup_questions_possible_answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type popup_questionsOrderByRelevanceInput = {
    fields: popup_questionsOrderByRelevanceFieldEnum | popup_questionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type popup_questionsCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_fr?: SortOrder
    name_rw?: SortOrder
    name_sw?: SortOrder
    service_id?: SortOrder
    description_en?: SortOrder
    description_fr?: SortOrder
    description_rw?: SortOrder
    description_sw?: SortOrder
    applies_to_bad?: SortOrder
    applies_to_good?: SortOrder
    applies_to_excellent?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type popup_questionsAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    type?: SortOrder
  }

  export type popup_questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_fr?: SortOrder
    name_rw?: SortOrder
    name_sw?: SortOrder
    service_id?: SortOrder
    description_en?: SortOrder
    description_fr?: SortOrder
    description_rw?: SortOrder
    description_sw?: SortOrder
    applies_to_bad?: SortOrder
    applies_to_good?: SortOrder
    applies_to_excellent?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type popup_questionsMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_fr?: SortOrder
    name_rw?: SortOrder
    name_sw?: SortOrder
    service_id?: SortOrder
    description_en?: SortOrder
    description_fr?: SortOrder
    description_rw?: SortOrder
    description_sw?: SortOrder
    applies_to_bad?: SortOrder
    applies_to_good?: SortOrder
    applies_to_excellent?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type popup_questionsSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    type?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Popup_questions_possible_answersScalarRelationFilter = {
    is?: popup_questions_possible_answersWhereInput
    isNot?: popup_questions_possible_answersWhereInput
  }

  export type popup_questions_answersCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    ticket_id?: SortOrder
    answer_id?: SortOrder
    answered_at?: SortOrder
  }

  export type popup_questions_answersAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    ticket_id?: SortOrder
    answer_id?: SortOrder
  }

  export type popup_questions_answersMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    ticket_id?: SortOrder
    answer_id?: SortOrder
    answered_at?: SortOrder
  }

  export type popup_questions_answersMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    ticket_id?: SortOrder
    answer_id?: SortOrder
    answered_at?: SortOrder
  }

  export type popup_questions_answersSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    ticket_id?: SortOrder
    answer_id?: SortOrder
  }

  export type Popup_questions_answersListRelationFilter = {
    every?: popup_questions_answersWhereInput
    some?: popup_questions_answersWhereInput
    none?: popup_questions_answersWhereInput
  }

  export type Popup_questionsScalarRelationFilter = {
    is?: popup_questionsWhereInput
    isNot?: popup_questionsWhereInput
  }

  export type popup_questions_answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type popup_questions_possible_answersOrderByRelevanceInput = {
    fields: popup_questions_possible_answersOrderByRelevanceFieldEnum | popup_questions_possible_answersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type popup_questions_possible_answersCountOrderByAggregateInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    answer_en?: SortOrder
    answer_fr?: SortOrder
    answer_rw?: SortOrder
    answer_sw?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    priority?: SortOrder
  }

  export type popup_questions_possible_answersAvgOrderByAggregateInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    priority?: SortOrder
  }

  export type popup_questions_possible_answersMaxOrderByAggregateInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    answer_en?: SortOrder
    answer_fr?: SortOrder
    answer_rw?: SortOrder
    answer_sw?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    priority?: SortOrder
  }

  export type popup_questions_possible_answersMinOrderByAggregateInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    answer_en?: SortOrder
    answer_fr?: SortOrder
    answer_rw?: SortOrder
    answer_sw?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    priority?: SortOrder
  }

  export type popup_questions_possible_answersSumOrderByAggregateInput = {
    id?: SortOrder
    popup_question_id?: SortOrder
    priority?: SortOrder
  }

  export type Qms_operatorScalarRelationFilter = {
    is?: qms_operatorWhereInput
    isNot?: qms_operatorWhereInput
  }

  export type qms_branch_operatorOrderByRelevanceInput = {
    fields: qms_branch_operatorOrderByRelevanceFieldEnum | qms_branch_operatorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_branch_operatorCountOrderByAggregateInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    linked_at?: SortOrder
    status?: SortOrder
  }

  export type qms_branch_operatorAvgOrderByAggregateInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
  }

  export type qms_branch_operatorMaxOrderByAggregateInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    linked_at?: SortOrder
    status?: SortOrder
  }

  export type qms_branch_operatorMinOrderByAggregateInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    linked_at?: SortOrder
    status?: SortOrder
  }

  export type qms_branch_operatorSumOrderByAggregateInput = {
    id?: SortOrder
    operator_id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
  }

  export type Qms_operator_transactionsListRelationFilter = {
    every?: qms_operator_transactionsWhereInput
    some?: qms_operator_transactionsWhereInput
    none?: qms_operator_transactionsWhereInput
  }

  export type qms_operator_transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_branch_transactionsOrderByRelevanceInput = {
    fields: qms_branch_transactionsOrderByRelevanceFieldEnum | qms_branch_transactionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_branch_transactionsAffiliate_idDateCompoundUniqueInput = {
    affiliate_id: number
    date: Date | string
  }

  export type qms_branch_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    date?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
  }

  export type qms_branch_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
  }

  export type qms_branch_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    date?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
  }

  export type qms_branch_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
    date?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
  }

  export type qms_branch_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    affiliate_id?: SortOrder
  }

  export type qms_counterOrderByRelevanceInput = {
    fields: qms_counterOrderByRelevanceFieldEnum | qms_counterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_counterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type qms_counterAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
  }

  export type qms_counterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type qms_counterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type qms_counterSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: deviceWhereInput | null
    isNot?: deviceWhereInput | null
  }

  export type qms_customerOrderByRelevanceInput = {
    fields: qms_customerOrderByRelevanceFieldEnum | qms_customerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_customerCountOrderByAggregateInput = {
    id?: SortOrder
    customer_uuid?: SortOrder
    device_id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    has_priority_service?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type qms_customerAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type qms_customerMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_uuid?: SortOrder
    device_id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    has_priority_service?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type qms_customerMinOrderByAggregateInput = {
    id?: SortOrder
    customer_uuid?: SortOrder
    device_id?: SortOrder
    name?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    has_priority_service?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type qms_customerSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type Qms_queue_operator_lnkListRelationFilter = {
    every?: qms_queue_operator_lnkWhereInput
    some?: qms_queue_operator_lnkWhereInput
    none?: qms_queue_operator_lnkWhereInput
  }

  export type Qms_ticket_assignmentListRelationFilter = {
    every?: qms_ticket_assignmentWhereInput
    some?: qms_ticket_assignmentWhereInput
    none?: qms_ticket_assignmentWhereInput
  }

  export type qms_queue_operator_lnkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_ticket_assignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_operatorOrderByRelevanceInput = {
    fields: qms_operatorOrderByRelevanceFieldEnum | qms_operatorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_operatorCountOrderByAggregateInput = {
    id?: SortOrder
    operator_uuid?: SortOrder
    institution_id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_address?: SortOrder
    phone_number?: SortOrder
    terminal?: SortOrder
  }

  export type qms_operatorAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
  }

  export type qms_operatorMaxOrderByAggregateInput = {
    id?: SortOrder
    operator_uuid?: SortOrder
    institution_id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_address?: SortOrder
    phone_number?: SortOrder
    terminal?: SortOrder
  }

  export type qms_operatorMinOrderByAggregateInput = {
    id?: SortOrder
    operator_uuid?: SortOrder
    institution_id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_address?: SortOrder
    phone_number?: SortOrder
    terminal?: SortOrder
  }

  export type qms_operatorSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
  }

  export type Qms_branch_transactionsScalarRelationFilter = {
    is?: qms_branch_transactionsWhereInput
    isNot?: qms_branch_transactionsWhereInput
  }

  export type qms_operator_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
  }

  export type qms_operator_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
  }

  export type qms_operator_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
  }

  export type qms_operator_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
    created_at?: SortOrder
    last_updated?: SortOrder
  }

  export type qms_operator_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    branch_transaction_id?: SortOrder
    operator_id?: SortOrder
    transaction?: SortOrder
  }

  export type Enumqms_queue_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.qms_queue_status | Enumqms_queue_statusFieldRefInput<$PrismaModel>
    in?: $Enums.qms_queue_status[]
    notIn?: $Enums.qms_queue_status[]
    not?: NestedEnumqms_queue_statusFilter<$PrismaModel> | $Enums.qms_queue_status
  }

  export type ServiceScalarRelationFilter = {
    is?: serviceWhereInput
    isNot?: serviceWhereInput
  }

  export type qms_queueOrderByRelevanceInput = {
    fields: qms_queueOrderByRelevanceFieldEnum | qms_queueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_queueCountOrderByAggregateInput = {
    id?: SortOrder
    queue_uuid?: SortOrder
    service_id?: SortOrder
    queue_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    avg_service_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrder
  }

  export type qms_queueAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    avg_service_time?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrder
  }

  export type qms_queueMaxOrderByAggregateInput = {
    id?: SortOrder
    queue_uuid?: SortOrder
    service_id?: SortOrder
    queue_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    avg_service_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrder
  }

  export type qms_queueMinOrderByAggregateInput = {
    id?: SortOrder
    queue_uuid?: SortOrder
    service_id?: SortOrder
    queue_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    avg_service_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrder
  }

  export type qms_queueSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    avg_service_time?: SortOrder
    closure_notification?: SortOrder
    inter_arrival_time?: SortOrder
  }

  export type Enumqms_queue_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.qms_queue_status | Enumqms_queue_statusFieldRefInput<$PrismaModel>
    in?: $Enums.qms_queue_status[]
    notIn?: $Enums.qms_queue_status[]
    not?: NestedEnumqms_queue_statusWithAggregatesFilter<$PrismaModel> | $Enums.qms_queue_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumqms_queue_statusFilter<$PrismaModel>
    _max?: NestedEnumqms_queue_statusFilter<$PrismaModel>
  }

  export type Qms_queueScalarRelationFilter = {
    is?: qms_queueWhereInput
    isNot?: qms_queueWhereInput
  }

  export type qms_queue_operator_lnkOrderByRelevanceInput = {
    fields: qms_queue_operator_lnkOrderByRelevanceFieldEnum | qms_queue_operator_lnkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_queue_operator_lnkCountOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    operator_uuid?: SortOrder
    counter_id?: SortOrder
    first_login?: SortOrder
    last_logout?: SortOrder
    api_key?: SortOrder
  }

  export type qms_queue_operator_lnkAvgOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
  }

  export type qms_queue_operator_lnkMaxOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    operator_uuid?: SortOrder
    counter_id?: SortOrder
    first_login?: SortOrder
    last_logout?: SortOrder
    api_key?: SortOrder
  }

  export type qms_queue_operator_lnkMinOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    operator_uuid?: SortOrder
    counter_id?: SortOrder
    first_login?: SortOrder
    last_logout?: SortOrder
    api_key?: SortOrder
  }

  export type qms_queue_operator_lnkSumOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
  }

  export type OptionNullableScalarRelationFilter = {
    is?: optionWhereInput | null
    isNot?: optionWhereInput | null
  }

  export type Qms_customerScalarRelationFilter = {
    is?: qms_customerWhereInput
    isNot?: qms_customerWhereInput
  }

  export type qms_ticketOrderByRelevanceInput = {
    fields: qms_ticketOrderByRelevanceFieldEnum | qms_ticketOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_ticketQueue_idTicket_numberCompoundUniqueInput = {
    queue_id: number
    ticket_number: string
  }

  export type qms_ticketCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_uuid?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    ticket_number?: SortOrder
    full_ticket_number?: SortOrder
    pin?: SortOrder
    status?: SortOrder
    service_time?: SortOrder
    estimated_waiting_time?: SortOrder
    created_at?: SortOrder
    waiting_ended_on?: SortOrder
    skipped_at?: SortOrder
    cancelled_at?: SortOrder
    on_hold_from?: SortOrder
    skips_count?: SortOrder
    prioritized?: SortOrder
    reason_id?: SortOrder
    prioritized_at?: SortOrder
    is_next?: SortOrder
    prev_ticket_id?: SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
  }

  export type qms_ticketAvgOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    pin?: SortOrder
    status?: SortOrder
    service_time?: SortOrder
    estimated_waiting_time?: SortOrder
    skips_count?: SortOrder
    reason_id?: SortOrder
    prev_ticket_id?: SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
  }

  export type qms_ticketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_uuid?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    ticket_number?: SortOrder
    full_ticket_number?: SortOrder
    pin?: SortOrder
    status?: SortOrder
    service_time?: SortOrder
    estimated_waiting_time?: SortOrder
    created_at?: SortOrder
    waiting_ended_on?: SortOrder
    skipped_at?: SortOrder
    cancelled_at?: SortOrder
    on_hold_from?: SortOrder
    skips_count?: SortOrder
    prioritized?: SortOrder
    reason_id?: SortOrder
    prioritized_at?: SortOrder
    is_next?: SortOrder
    prev_ticket_id?: SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
  }

  export type qms_ticketMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_uuid?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    ticket_number?: SortOrder
    full_ticket_number?: SortOrder
    pin?: SortOrder
    status?: SortOrder
    service_time?: SortOrder
    estimated_waiting_time?: SortOrder
    created_at?: SortOrder
    waiting_ended_on?: SortOrder
    skipped_at?: SortOrder
    cancelled_at?: SortOrder
    on_hold_from?: SortOrder
    skips_count?: SortOrder
    prioritized?: SortOrder
    reason_id?: SortOrder
    prioritized_at?: SortOrder
    is_next?: SortOrder
    prev_ticket_id?: SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
  }

  export type qms_ticketSumOrderByAggregateInput = {
    id?: SortOrder
    queue_id?: SortOrder
    customer_id?: SortOrder
    pin?: SortOrder
    status?: SortOrder
    service_time?: SortOrder
    estimated_waiting_time?: SortOrder
    skips_count?: SortOrder
    reason_id?: SortOrder
    prev_ticket_id?: SortOrder
    rating_notification_sent?: SortOrder
    source?: SortOrder
  }

  export type Qms_ticketScalarRelationFilter = {
    is?: qms_ticketWhereInput
    isNot?: qms_ticketWhereInput
  }

  export type qms_ticket_assignmentOrderByRelevanceInput = {
    fields: qms_ticket_assignmentOrderByRelevanceFieldEnum | qms_ticket_assignmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type qms_ticket_assignmentCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    assigned_at?: SortOrder
    state?: SortOrder
    comment?: SortOrder
  }

  export type qms_ticket_assignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
    status?: SortOrder
    state?: SortOrder
  }

  export type qms_ticket_assignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    assigned_at?: SortOrder
    state?: SortOrder
    comment?: SortOrder
  }

  export type qms_ticket_assignmentMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    assigned_at?: SortOrder
    state?: SortOrder
    comment?: SortOrder
  }

  export type qms_ticket_assignmentSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    queue_id?: SortOrder
    operator_id?: SortOrder
    counter_id?: SortOrder
    status?: SortOrder
    state?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type Rating_assetsListRelationFilter = {
    every?: rating_assetsWhereInput
    some?: rating_assetsWhereInput
    none?: rating_assetsWhereInput
  }

  export type rating_assetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ratingOrderByRelevanceInput = {
    fields: ratingOrderByRelevanceFieldEnum | ratingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ratingCountOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    time?: SortOrder
    service_id?: SortOrder
    comment?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    location?: SortOrder
    device_id?: SortOrder
    nps_score?: SortOrder
    ticket_id?: SortOrder
    finger_print?: SortOrder
  }

  export type ratingAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    location?: SortOrder
    device_id?: SortOrder
    nps_score?: SortOrder
    ticket_id?: SortOrder
  }

  export type ratingMaxOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    time?: SortOrder
    service_id?: SortOrder
    comment?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    location?: SortOrder
    device_id?: SortOrder
    nps_score?: SortOrder
    ticket_id?: SortOrder
    finger_print?: SortOrder
  }

  export type ratingMinOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    time?: SortOrder
    service_id?: SortOrder
    comment?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    location?: SortOrder
    device_id?: SortOrder
    nps_score?: SortOrder
    ticket_id?: SortOrder
    finger_print?: SortOrder
  }

  export type ratingSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    gender?: SortOrder
    age_range?: SortOrder
    location?: SortOrder
    device_id?: SortOrder
    nps_score?: SortOrder
    ticket_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type RatingNullableScalarRelationFilter = {
    is?: ratingWhereInput | null
    isNot?: ratingWhereInput | null
  }

  export type rating_assetsOrderByRelevanceInput = {
    fields: rating_assetsOrderByRelevanceFieldEnum | rating_assetsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rating_assetsCountOrderByAggregateInput = {
    rating_assets_id?: SortOrder
    rating_assets_image?: SortOrder
    rating_assets_video?: SortOrder
    rating_id?: SortOrder
  }

  export type rating_assetsAvgOrderByAggregateInput = {
    rating_assets_id?: SortOrder
    rating_id?: SortOrder
  }

  export type rating_assetsMaxOrderByAggregateInput = {
    rating_assets_id?: SortOrder
    rating_assets_image?: SortOrder
    rating_assets_video?: SortOrder
    rating_id?: SortOrder
  }

  export type rating_assetsMinOrderByAggregateInput = {
    rating_assets_id?: SortOrder
    rating_assets_image?: SortOrder
    rating_assets_video?: SortOrder
    rating_id?: SortOrder
  }

  export type rating_assetsSumOrderByAggregateInput = {
    rating_assets_id?: SortOrder
    rating_id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type Enumrating_qr_code_sessions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.rating_qr_code_sessions_status | Enumrating_qr_code_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.rating_qr_code_sessions_status[]
    notIn?: $Enums.rating_qr_code_sessions_status[]
    not?: NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel> | $Enums.rating_qr_code_sessions_status
  }

  export type rating_qr_code_sessionsOrderByRelevanceInput = {
    fields: rating_qr_code_sessionsOrderByRelevanceFieldEnum | rating_qr_code_sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rating_qr_code_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    institution_uuid?: SortOrder
    service_uuid?: SortOrder
    user_agent?: SortOrder
    finger_print?: SortOrder
    ip_address?: SortOrder
    session_token?: SortOrder
    session_expiration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type rating_qr_code_sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rating_qr_code_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    institution_uuid?: SortOrder
    service_uuid?: SortOrder
    user_agent?: SortOrder
    finger_print?: SortOrder
    ip_address?: SortOrder
    session_token?: SortOrder
    session_expiration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type rating_qr_code_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    institution_uuid?: SortOrder
    service_uuid?: SortOrder
    user_agent?: SortOrder
    finger_print?: SortOrder
    ip_address?: SortOrder
    session_token?: SortOrder
    session_expiration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type rating_qr_code_sessionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumrating_qr_code_sessions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rating_qr_code_sessions_status | Enumrating_qr_code_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.rating_qr_code_sessions_status[]
    notIn?: $Enums.rating_qr_code_sessions_status[]
    not?: NestedEnumrating_qr_code_sessions_statusWithAggregatesFilter<$PrismaModel> | $Enums.rating_qr_code_sessions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel>
    _max?: NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel>
  }

  export type rating_replyOrderByRelevanceInput = {
    fields: rating_replyOrderByRelevanceFieldEnum | rating_replyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rating_replyCountOrderByAggregateInput = {
    id?: SortOrder
    specific?: SortOrder
    rating_id?: SortOrder
    time?: SortOrder
    reply?: SortOrder
  }

  export type rating_replyAvgOrderByAggregateInput = {
    id?: SortOrder
    rating_id?: SortOrder
  }

  export type rating_replyMaxOrderByAggregateInput = {
    id?: SortOrder
    specific?: SortOrder
    rating_id?: SortOrder
    time?: SortOrder
    reply?: SortOrder
  }

  export type rating_replyMinOrderByAggregateInput = {
    id?: SortOrder
    specific?: SortOrder
    rating_id?: SortOrder
    time?: SortOrder
    reply?: SortOrder
  }

  export type rating_replySumOrderByAggregateInput = {
    id?: SortOrder
    rating_id?: SortOrder
  }

  export type reportsOrderByRelevanceInput = {
    fields: reportsOrderByRelevanceFieldEnum | reportsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type reportsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    institution_id?: SortOrder
    service_ids?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    report_created_by?: SortOrder
    report_institution_id?: SortOrder
    report_recipient?: SortOrder
    report_queue_uuid?: SortOrder
    report_content_key?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type reportsAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    report_created_by?: SortOrder
    status?: SortOrder
  }

  export type reportsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    institution_id?: SortOrder
    service_ids?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    report_created_by?: SortOrder
    report_institution_id?: SortOrder
    report_recipient?: SortOrder
    report_queue_uuid?: SortOrder
    report_content_key?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type reportsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    institution_id?: SortOrder
    service_ids?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    report_created_by?: SortOrder
    report_institution_id?: SortOrder
    report_recipient?: SortOrder
    report_queue_uuid?: SortOrder
    report_content_key?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type reportsSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    report_created_by?: SortOrder
    status?: SortOrder
  }

  export type request_institutionOrderByRelevanceInput = {
    fields: request_institutionOrderByRelevanceFieldEnum | request_institutionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type request_institutionCountOrderByAggregateInput = {
    id?: SortOrder
    owner_name?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    type?: SortOrder
    business_certificate?: SortOrder
    product_type?: SortOrder
    approval_status?: SortOrder
  }

  export type request_institutionAvgOrderByAggregateInput = {
    id?: SortOrder
    approval_status?: SortOrder
  }

  export type request_institutionMaxOrderByAggregateInput = {
    id?: SortOrder
    owner_name?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    type?: SortOrder
    business_certificate?: SortOrder
    product_type?: SortOrder
    approval_status?: SortOrder
  }

  export type request_institutionMinOrderByAggregateInput = {
    id?: SortOrder
    owner_name?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    type?: SortOrder
    business_certificate?: SortOrder
    product_type?: SortOrder
    approval_status?: SortOrder
  }

  export type request_institutionSumOrderByAggregateInput = {
    id?: SortOrder
    approval_status?: SortOrder
  }

  export type Qms_counterListRelationFilter = {
    every?: qms_counterWhereInput
    some?: qms_counterWhereInput
    none?: qms_counterWhereInput
  }

  export type Qms_queueListRelationFilter = {
    every?: qms_queueWhereInput
    some?: qms_queueWhereInput
    none?: qms_queueWhereInput
  }

  export type Service_groupNullableScalarRelationFilter = {
    is?: service_groupWhereInput | null
    isNot?: service_groupWhereInput | null
  }

  export type qms_counterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qms_queueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceOrderByRelevanceInput = {
    fields: serviceOrderByRelevanceFieldEnum | serviceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type serviceCountOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    bad_rating_threshold?: SortOrder
    group?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    avg_service_time?: SortOrder
    uuid?: SortOrder
    inter_arrival_time?: SortOrder
    estimated_time?: SortOrder
  }

  export type serviceAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    bad_rating_threshold?: SortOrder
    group?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    avg_service_time?: SortOrder
    inter_arrival_time?: SortOrder
    estimated_time?: SortOrder
  }

  export type serviceMaxOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    bad_rating_threshold?: SortOrder
    group?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    avg_service_time?: SortOrder
    uuid?: SortOrder
    inter_arrival_time?: SortOrder
    estimated_time?: SortOrder
  }

  export type serviceMinOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    bad_rating_threshold?: SortOrder
    group?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    avg_service_time?: SortOrder
    uuid?: SortOrder
    inter_arrival_time?: SortOrder
    estimated_time?: SortOrder
  }

  export type serviceSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    bad_rating_threshold?: SortOrder
    group?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    avg_service_time?: SortOrder
    inter_arrival_time?: SortOrder
    estimated_time?: SortOrder
  }

  export type ServiceReviewListRelationFilter = {
    every?: serviceReviewWhereInput
    some?: serviceReviewWhereInput
    none?: serviceReviewWhereInput
  }

  export type SurveyQuestionsListRelationFilter = {
    every?: surveyQuestionsWhereInput
    some?: surveyQuestionsWhereInput
    none?: surveyQuestionsWhereInput
  }

  export type serviceReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type surveyQuestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_groupOrderByRelevanceInput = {
    fields: service_groupOrderByRelevanceFieldEnum | service_groupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type service_groupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_rw?: SortOrder
    name_fr?: SortOrder
    name_sw?: SortOrder
    search_term?: SortOrder
    institution_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    ticket_prefix?: SortOrder
    bad_rating_threshold?: SortOrder
  }

  export type service_groupAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    bad_rating_threshold?: SortOrder
  }

  export type service_groupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_rw?: SortOrder
    name_fr?: SortOrder
    name_sw?: SortOrder
    search_term?: SortOrder
    institution_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    ticket_prefix?: SortOrder
    bad_rating_threshold?: SortOrder
  }

  export type service_groupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_rw?: SortOrder
    name_fr?: SortOrder
    name_sw?: SortOrder
    search_term?: SortOrder
    institution_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    uuid?: SortOrder
    status?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    ticket_prefix?: SortOrder
    bad_rating_threshold?: SortOrder
  }

  export type service_groupSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    status?: SortOrder
    good_ratings?: SortOrder
    bad_ratings?: SortOrder
    excellent_ratings?: SortOrder
    nps?: SortOrder
    csat?: SortOrder
    mean_service_time?: SortOrder
    bad_rating_threshold?: SortOrder
  }

  export type surveyOrderByRelevanceInput = {
    fields: surveyOrderByRelevanceFieldEnum | surveyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type surveyCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    survey_data?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    access_key?: SortOrder
  }

  export type surveyAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
  }

  export type surveyMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    survey_data?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    access_key?: SortOrder
  }

  export type surveyMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    survey_data?: SortOrder
    institution_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    access_key?: SortOrder
  }

  export type surveySumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
  }

  export type survey_resultOrderByRelevanceInput = {
    fields: survey_resultOrderByRelevanceFieldEnum | survey_resultOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type survey_resultCountOrderByAggregateInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrder
    service_id?: SortOrder
    device_id?: SortOrder
    agent?: SortOrder
    result_data?: SortOrder
    replied_at?: SortOrder
  }

  export type survey_resultAvgOrderByAggregateInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrder
    service_id?: SortOrder
    device_id?: SortOrder
  }

  export type survey_resultMaxOrderByAggregateInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrder
    service_id?: SortOrder
    device_id?: SortOrder
    agent?: SortOrder
    result_data?: SortOrder
    replied_at?: SortOrder
  }

  export type survey_resultMinOrderByAggregateInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrder
    service_id?: SortOrder
    device_id?: SortOrder
    agent?: SortOrder
    result_data?: SortOrder
    replied_at?: SortOrder
  }

  export type survey_resultSumOrderByAggregateInput = {
    id?: SortOrder
    survey_id?: SortOrder
    rating_id?: SortOrder
    service_id?: SortOrder
    device_id?: SortOrder
  }

  export type tagsOrderByRelevanceInput = {
    fields: tagsOrderByRelevanceFieldEnum | tagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    services?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    status?: SortOrder
  }

  export type tagsAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    services?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    status?: SortOrder
  }

  export type tagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    services?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
    status?: SortOrder
  }

  export type tagsSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    updated_by?: SortOrder
  }

  export type DeviceScalarRelationFilter = {
    is?: deviceWhereInput
    isNot?: deviceWhereInput
  }

  export type tipOrderByRelevanceInput = {
    fields: tipOrderByRelevanceFieldEnum | tipOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tipCountOrderByAggregateInput = {
    id?: SortOrder
    collection_reference_id?: SortOrder
    disbursement_reference_id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    payee?: SortOrder
    payer?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
    collection_status?: SortOrder
    collection_status_details?: SortOrder
    closed_at?: SortOrder
    disbursed_at?: SortOrder
    disbursement_status?: SortOrder
    disbursement_status_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tipAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
  }

  export type tipMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_reference_id?: SortOrder
    disbursement_reference_id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    payee?: SortOrder
    payer?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
    collection_status?: SortOrder
    collection_status_details?: SortOrder
    closed_at?: SortOrder
    disbursed_at?: SortOrder
    disbursement_status?: SortOrder
    disbursement_status_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tipMinOrderByAggregateInput = {
    id?: SortOrder
    collection_reference_id?: SortOrder
    disbursement_reference_id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    payee?: SortOrder
    payer?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
    collection_status?: SortOrder
    collection_status_details?: SortOrder
    closed_at?: SortOrder
    disbursed_at?: SortOrder
    disbursement_status?: SortOrder
    disbursement_status_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tipSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    rating_id?: SortOrder
    amount?: SortOrder
    tip_amount?: SortOrder
  }

  export type TagsListRelationFilter = {
    every?: tagsWhereInput
    some?: tagsWhereInput
    none?: tagsWhereInput
  }

  export type tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone_number?: SortOrder
    username?: SortOrder
    auth_key?: SortOrder
    password_hash?: SortOrder
    password_reset_token?: SortOrder
    email?: SortOrder
    status?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verification_token?: SortOrder
    allowed_context?: SortOrder
    institution_id?: SortOrder
    last_received_hb_alert_at?: SortOrder
    last_received_rating_notification_at?: SortOrder
    language?: SortOrder
    notifications_enabled?: SortOrder
    last_login?: SortOrder
    allow_auto_approved_changes?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    allowed_context?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone_number?: SortOrder
    username?: SortOrder
    auth_key?: SortOrder
    password_hash?: SortOrder
    password_reset_token?: SortOrder
    email?: SortOrder
    status?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verification_token?: SortOrder
    allowed_context?: SortOrder
    institution_id?: SortOrder
    last_received_hb_alert_at?: SortOrder
    last_received_rating_notification_at?: SortOrder
    language?: SortOrder
    notifications_enabled?: SortOrder
    last_login?: SortOrder
    allow_auto_approved_changes?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    phone_number?: SortOrder
    username?: SortOrder
    auth_key?: SortOrder
    password_hash?: SortOrder
    password_reset_token?: SortOrder
    email?: SortOrder
    status?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verification_token?: SortOrder
    allowed_context?: SortOrder
    institution_id?: SortOrder
    last_received_hb_alert_at?: SortOrder
    last_received_rating_notification_at?: SortOrder
    language?: SortOrder
    notifications_enabled?: SortOrder
    last_login?: SortOrder
    allow_auto_approved_changes?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    allowed_context?: SortOrder
  }

  export type wallet_accountsOrderByRelevanceInput = {
    fields: wallet_accountsOrderByRelevanceFieldEnum | wallet_accountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type wallet_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    account_type_id?: SortOrder
    account_number?: SortOrder
    account_name?: SortOrder
    balance?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    added_at?: SortOrder
  }

  export type wallet_accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    account_type_id?: SortOrder
    balance?: SortOrder
  }

  export type wallet_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    account_type_id?: SortOrder
    account_number?: SortOrder
    account_name?: SortOrder
    balance?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    added_at?: SortOrder
  }

  export type wallet_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    account_type_id?: SortOrder
    account_number?: SortOrder
    account_name?: SortOrder
    balance?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    added_at?: SortOrder
  }

  export type wallet_accountsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    account_type_id?: SortOrder
    balance?: SortOrder
  }

  export type wallet_accounts_typesOrderByRelevanceInput = {
    fields: wallet_accounts_typesOrderByRelevanceFieldEnum | wallet_accounts_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type wallet_accounts_typesCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    abbreviation?: SortOrder
    name?: SortOrder
    added_at?: SortOrder
  }

  export type wallet_accounts_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type wallet_accounts_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    abbreviation?: SortOrder
    name?: SortOrder
    added_at?: SortOrder
  }

  export type wallet_accounts_typesMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    abbreviation?: SortOrder
    name?: SortOrder
    added_at?: SortOrder
  }

  export type wallet_accounts_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type wallet_transfersOrderByRelevanceInput = {
    fields: wallet_transfersOrderByRelevanceFieldEnum | wallet_transfersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type wallet_transfersCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    time?: SortOrder
    payer_id?: SortOrder
    payer_account_id?: SortOrder
    payee_address?: SortOrder
    payee_name?: SortOrder
    payee_account_type?: SortOrder
    payee_account_number?: SortOrder
    payee_type?: SortOrder
    tx_id?: SortOrder
    fspid?: SortOrder
    ext_trx_id?: SortOrder
    pay_money_ext_res?: SortOrder
    confirm_party_ext_res?: SortOrder
    confirm_quote_ext_res?: SortOrder
    status?: SortOrder
    quote_id?: SortOrder
    note?: SortOrder
    transfer_fees?: SortOrder
  }

  export type wallet_transfersAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payer_id?: SortOrder
    payer_account_id?: SortOrder
  }

  export type wallet_transfersMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    time?: SortOrder
    payer_id?: SortOrder
    payer_account_id?: SortOrder
    payee_address?: SortOrder
    payee_name?: SortOrder
    payee_account_type?: SortOrder
    payee_account_number?: SortOrder
    payee_type?: SortOrder
    tx_id?: SortOrder
    fspid?: SortOrder
    ext_trx_id?: SortOrder
    pay_money_ext_res?: SortOrder
    confirm_party_ext_res?: SortOrder
    confirm_quote_ext_res?: SortOrder
    status?: SortOrder
    quote_id?: SortOrder
    note?: SortOrder
    transfer_fees?: SortOrder
  }

  export type wallet_transfersMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    time?: SortOrder
    payer_id?: SortOrder
    payer_account_id?: SortOrder
    payee_address?: SortOrder
    payee_name?: SortOrder
    payee_account_type?: SortOrder
    payee_account_number?: SortOrder
    payee_type?: SortOrder
    tx_id?: SortOrder
    fspid?: SortOrder
    ext_trx_id?: SortOrder
    pay_money_ext_res?: SortOrder
    confirm_party_ext_res?: SortOrder
    confirm_quote_ext_res?: SortOrder
    status?: SortOrder
    quote_id?: SortOrder
    note?: SortOrder
    transfer_fees?: SortOrder
  }

  export type wallet_transfersSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    payer_id?: SortOrder
    payer_account_id?: SortOrder
  }

  export type wallet_usersOrderByRelevanceInput = {
    fields: wallet_usersOrderByRelevanceFieldEnum | wallet_usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type wallet_usersCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    private_key?: SortOrder
    public_key?: SortOrder
    initiated_at?: SortOrder
  }

  export type wallet_usersAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type wallet_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    private_key?: SortOrder
    public_key?: SortOrder
    initiated_at?: SortOrder
  }

  export type wallet_usersMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    private_key?: SortOrder
    public_key?: SortOrder
    initiated_at?: SortOrder
  }

  export type wallet_usersSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type ReviewsNullableScalarRelationFilter = {
    is?: reviewsWhereInput | null
    isNot?: reviewsWhereInput | null
  }

  export type Users_profileNullableScalarRelationFilter = {
    is?: users_profileWhereInput | null
    isNot?: users_profileWhereInput | null
  }

  export type imagesOrderByRelevanceInput = {
    fields: imagesOrderByRelevanceFieldEnum | imagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type imagesCountOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    image_url?: SortOrder
    caption?: SortOrder
    uploaded_at?: SortOrder
    review_id?: SortOrder
  }

  export type imagesAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    user_id?: SortOrder
    review_id?: SortOrder
  }

  export type imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    image_url?: SortOrder
    caption?: SortOrder
    uploaded_at?: SortOrder
    review_id?: SortOrder
  }

  export type imagesMinOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    image_url?: SortOrder
    caption?: SortOrder
    uploaded_at?: SortOrder
    review_id?: SortOrder
  }

  export type imagesSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    user_id?: SortOrder
    review_id?: SortOrder
  }

  export type CategoriesListRelationFilter = {
    every?: categoriesWhereInput
    some?: categoriesWhereInput
    none?: categoriesWhereInput
  }

  export type categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sectorsOrderByRelevanceInput = {
    fields: sectorsOrderByRelevanceFieldEnum | sectorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sectorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type sectorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sectorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type sectorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type sectorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type users_profileOrderByRelevanceInput = {
    fields: users_profileOrderByRelevanceFieldEnum | users_profileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type users_profileCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    added_at?: SortOrder
    isVerified?: SortOrder
    verifyToken?: SortOrder
  }

  export type users_profileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type users_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    added_at?: SortOrder
    isVerified?: SortOrder
    verifyToken?: SortOrder
  }

  export type users_profileMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    age_group?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    added_at?: SortOrder
    isVerified?: SortOrder
    verifyToken?: SortOrder
  }

  export type users_profileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Users_profileScalarRelationFilter = {
    is?: users_profileWhereInput
    isNot?: users_profileWhereInput
  }

  export type reviewsOrderByRelevanceInput = {
    fields: reviewsOrderByRelevanceFieldEnum | reviewsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    created_at?: SortOrder
    is_approved?: SortOrder
  }

  export type reviewsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
  }

  export type reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    created_at?: SortOrder
    is_approved?: SortOrder
  }

  export type reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    created_at?: SortOrder
    is_approved?: SortOrder
  }

  export type reviewsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    rating?: SortOrder
  }

  export type workingHourOrderByRelevanceInput = {
    fields: workingHourOrderByRelevanceFieldEnum | workingHourOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type workingHourCountOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    day_of_week?: SortOrder
    open_time?: SortOrder
    close_time?: SortOrder
  }

  export type workingHourAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
  }

  export type workingHourMaxOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    day_of_week?: SortOrder
    open_time?: SortOrder
    close_time?: SortOrder
  }

  export type workingHourMinOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    day_of_week?: SortOrder
    open_time?: SortOrder
    close_time?: SortOrder
  }

  export type workingHourSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
  }

  export type amenitiesOrderByRelevanceInput = {
    fields: amenitiesOrderByRelevanceFieldEnum | amenitiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type amenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    added_at?: SortOrder
  }

  export type amenitiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type amenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    added_at?: SortOrder
  }

  export type amenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    added_at?: SortOrder
  }

  export type amenitiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AmenitiesNullableScalarRelationFilter = {
    is?: amenitiesWhereInput | null
    isNot?: amenitiesWhereInput | null
  }

  export type business_amenitiesAmenitY_idInstitution_idCompoundUniqueInput = {
    amenitY_id: number
    institution_id: number
  }

  export type business_amenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    amenitY_id?: SortOrder
  }

  export type business_amenitiesAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    amenitY_id?: SortOrder
  }

  export type business_amenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    amenitY_id?: SortOrder
  }

  export type business_amenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    amenitY_id?: SortOrder
  }

  export type business_amenitiesSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    amenitY_id?: SortOrder
  }

  export type price_rangesOrderByRelevanceInput = {
    fields: price_rangesOrderByRelevanceFieldEnum | price_rangesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type price_rangesCountOrderByAggregateInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
    label?: SortOrder
  }

  export type price_rangesAvgOrderByAggregateInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
  }

  export type price_rangesMaxOrderByAggregateInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
    label?: SortOrder
  }

  export type price_rangesMinOrderByAggregateInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
    label?: SortOrder
  }

  export type price_rangesSumOrderByAggregateInput = {
    id?: SortOrder
    max_value?: SortOrder
    min_value?: SortOrder
    institution_id?: SortOrder
  }

  export type SurveyQuestionsScalarRelationFilter = {
    is?: surveyQuestionsWhereInput
    isNot?: surveyQuestionsWhereInput
  }

  export type surveyAnswersOrderByRelevanceInput = {
    fields: surveyAnswersOrderByRelevanceFieldEnum | surveyAnswersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type surveyAnswersCountOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrder
    answer?: SortOrder
    scale_rating?: SortOrder
    added_at?: SortOrder
  }

  export type surveyAnswersAvgOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrder
    scale_rating?: SortOrder
  }

  export type surveyAnswersMaxOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrder
    answer?: SortOrder
    scale_rating?: SortOrder
    added_at?: SortOrder
  }

  export type surveyAnswersMinOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrder
    answer?: SortOrder
    scale_rating?: SortOrder
    added_at?: SortOrder
  }

  export type surveyAnswersSumOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
    user_id?: SortOrder
    scale_rating?: SortOrder
  }

  export type SurveyAnswersListRelationFilter = {
    every?: surveyAnswersWhereInput
    some?: surveyAnswersWhereInput
    none?: surveyAnswersWhereInput
  }

  export type Service_groupScalarRelationFilter = {
    is?: service_groupWhereInput
    isNot?: service_groupWhereInput
  }

  export type surveyAnswersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type surveyQuestionsOrderByRelevanceInput = {
    fields: surveyQuestionsOrderByRelevanceFieldEnum | surveyQuestionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type surveyQuestionsCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    question?: SortOrder
    choices?: SortOrder
    added_at?: SortOrder
  }

  export type surveyQuestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
  }

  export type surveyQuestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    question?: SortOrder
    choices?: SortOrder
    added_at?: SortOrder
  }

  export type surveyQuestionsMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    question?: SortOrder
    choices?: SortOrder
    added_at?: SortOrder
  }

  export type surveyQuestionsSumOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
  }

  export type serviceReviewOrderByRelevanceInput = {
    fields: serviceReviewOrderByRelevanceFieldEnum | serviceReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type serviceReviewCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    rating?: SortOrder
    emoRating?: SortOrder
    added_at?: SortOrder
  }

  export type serviceReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    rating?: SortOrder
  }

  export type serviceReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    rating?: SortOrder
    emoRating?: SortOrder
    added_at?: SortOrder
  }

  export type serviceReviewMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    rating?: SortOrder
    emoRating?: SortOrder
    added_at?: SortOrder
  }

  export type serviceReviewSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    rating?: SortOrder
  }

  export type CategoriesScalarRelationFilter = {
    is?: categoriesWhereInput
    isNot?: categoriesWhereInput
  }

  export type category_search_termsOrderByRelevanceInput = {
    fields: category_search_termsOrderByRelevanceFieldEnum | category_search_termsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type category_search_termsCountOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    term?: SortOrder
  }

  export type category_search_termsAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type category_search_termsMaxOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    term?: SortOrder
  }

  export type category_search_termsMinOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    term?: SortOrder
  }

  export type category_search_termsSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type Enumapp_releases_app_nameFieldUpdateOperationsInput = {
    set?: $Enums.app_releases_app_name
  }

  export type Enumapp_releases_platformFieldUpdateOperationsInput = {
    set?: $Enums.app_releases_platform
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutAppointments_appointments_creator_idTouserInput = {
    create?: XOR<userCreateWithoutAppointments_appointments_creator_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_creator_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutAppointments_appointments_creator_idTouserInput
    connect?: userWhereUniqueInput
  }

  export type institutionCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<institutionCreateWithoutAppointmentsInput, institutionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutAppointmentsInput
    connect?: institutionWhereUniqueInput
  }

  export type qms_operatorCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<qms_operatorCreateWithoutAppointmentsInput, qms_operatorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutAppointmentsInput
    connect?: qms_operatorWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<serviceCreateWithoutAppointmentsInput, serviceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: serviceCreateOrConnectWithoutAppointmentsInput
    connect?: serviceWhereUniqueInput
  }

  export type userCreateNestedOneWithoutAppointments_appointments_user_idTouserInput = {
    create?: XOR<userCreateWithoutAppointments_appointments_user_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_user_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutAppointments_appointments_user_idTouserInput
    connect?: userWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneRequiredWithoutAppointments_appointments_creator_idTouserNestedInput = {
    create?: XOR<userCreateWithoutAppointments_appointments_creator_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_creator_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutAppointments_appointments_creator_idTouserInput
    upsert?: userUpsertWithoutAppointments_appointments_creator_idTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAppointments_appointments_creator_idTouserInput, userUpdateWithoutAppointments_appointments_creator_idTouserInput>, userUncheckedUpdateWithoutAppointments_appointments_creator_idTouserInput>
  }

  export type institutionUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<institutionCreateWithoutAppointmentsInput, institutionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutAppointmentsInput
    upsert?: institutionUpsertWithoutAppointmentsInput
    disconnect?: institutionWhereInput | boolean
    delete?: institutionWhereInput | boolean
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutAppointmentsInput, institutionUpdateWithoutAppointmentsInput>, institutionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type qms_operatorUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<qms_operatorCreateWithoutAppointmentsInput, qms_operatorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutAppointmentsInput
    upsert?: qms_operatorUpsertWithoutAppointmentsInput
    disconnect?: qms_operatorWhereInput | boolean
    delete?: qms_operatorWhereInput | boolean
    connect?: qms_operatorWhereUniqueInput
    update?: XOR<XOR<qms_operatorUpdateToOneWithWhereWithoutAppointmentsInput, qms_operatorUpdateWithoutAppointmentsInput>, qms_operatorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type serviceUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<serviceCreateWithoutAppointmentsInput, serviceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: serviceCreateOrConnectWithoutAppointmentsInput
    upsert?: serviceUpsertWithoutAppointmentsInput
    disconnect?: serviceWhereInput | boolean
    delete?: serviceWhereInput | boolean
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutAppointmentsInput, serviceUpdateWithoutAppointmentsInput>, serviceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type userUpdateOneWithoutAppointments_appointments_user_idTouserNestedInput = {
    create?: XOR<userCreateWithoutAppointments_appointments_user_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_user_idTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutAppointments_appointments_user_idTouserInput
    upsert?: userUpsertWithoutAppointments_appointments_user_idTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAppointments_appointments_user_idTouserInput, userUpdateWithoutAppointments_appointments_user_idTouserInput>, userUncheckedUpdateWithoutAppointments_appointments_user_idTouserInput>
  }

  export type institutionCreateNestedOneWithoutAppsInput = {
    create?: XOR<institutionCreateWithoutAppsInput, institutionUncheckedCreateWithoutAppsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutAppsInput
    connect?: institutionWhereUniqueInput
  }

  export type institutionUpdateOneRequiredWithoutAppsNestedInput = {
    create?: XOR<institutionCreateWithoutAppsInput, institutionUncheckedCreateWithoutAppsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutAppsInput
    upsert?: institutionUpsertWithoutAppsInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutAppsInput, institutionUpdateWithoutAppsInput>, institutionUncheckedUpdateWithoutAppsInput>
  }

  export type NullableEnumaudit_trail_statusFieldUpdateOperationsInput = {
    set?: $Enums.audit_trail_status | null
  }

  export type sectorsCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<sectorsCreateWithoutCategoriesInput, sectorsUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: sectorsCreateOrConnectWithoutCategoriesInput
    connect?: sectorsWhereUniqueInput
  }

  export type category_search_termsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<category_search_termsCreateWithoutCategoriesInput, category_search_termsUncheckedCreateWithoutCategoriesInput> | category_search_termsCreateWithoutCategoriesInput[] | category_search_termsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_search_termsCreateOrConnectWithoutCategoriesInput | category_search_termsCreateOrConnectWithoutCategoriesInput[]
    createMany?: category_search_termsCreateManyCategoriesInputEnvelope
    connect?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
  }

  export type institutionCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<institutionCreateWithoutCategoriesInput, institutionUncheckedCreateWithoutCategoriesInput> | institutionCreateWithoutCategoriesInput[] | institutionUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: institutionCreateOrConnectWithoutCategoriesInput | institutionCreateOrConnectWithoutCategoriesInput[]
    createMany?: institutionCreateManyCategoriesInputEnvelope
    connect?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
  }

  export type category_search_termsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<category_search_termsCreateWithoutCategoriesInput, category_search_termsUncheckedCreateWithoutCategoriesInput> | category_search_termsCreateWithoutCategoriesInput[] | category_search_termsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_search_termsCreateOrConnectWithoutCategoriesInput | category_search_termsCreateOrConnectWithoutCategoriesInput[]
    createMany?: category_search_termsCreateManyCategoriesInputEnvelope
    connect?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
  }

  export type institutionUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<institutionCreateWithoutCategoriesInput, institutionUncheckedCreateWithoutCategoriesInput> | institutionCreateWithoutCategoriesInput[] | institutionUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: institutionCreateOrConnectWithoutCategoriesInput | institutionCreateOrConnectWithoutCategoriesInput[]
    createMany?: institutionCreateManyCategoriesInputEnvelope
    connect?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
  }

  export type sectorsUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<sectorsCreateWithoutCategoriesInput, sectorsUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: sectorsCreateOrConnectWithoutCategoriesInput
    upsert?: sectorsUpsertWithoutCategoriesInput
    disconnect?: sectorsWhereInput | boolean
    delete?: sectorsWhereInput | boolean
    connect?: sectorsWhereUniqueInput
    update?: XOR<XOR<sectorsUpdateToOneWithWhereWithoutCategoriesInput, sectorsUpdateWithoutCategoriesInput>, sectorsUncheckedUpdateWithoutCategoriesInput>
  }

  export type category_search_termsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<category_search_termsCreateWithoutCategoriesInput, category_search_termsUncheckedCreateWithoutCategoriesInput> | category_search_termsCreateWithoutCategoriesInput[] | category_search_termsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_search_termsCreateOrConnectWithoutCategoriesInput | category_search_termsCreateOrConnectWithoutCategoriesInput[]
    upsert?: category_search_termsUpsertWithWhereUniqueWithoutCategoriesInput | category_search_termsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: category_search_termsCreateManyCategoriesInputEnvelope
    set?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    disconnect?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    delete?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    connect?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    update?: category_search_termsUpdateWithWhereUniqueWithoutCategoriesInput | category_search_termsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: category_search_termsUpdateManyWithWhereWithoutCategoriesInput | category_search_termsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: category_search_termsScalarWhereInput | category_search_termsScalarWhereInput[]
  }

  export type institutionUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<institutionCreateWithoutCategoriesInput, institutionUncheckedCreateWithoutCategoriesInput> | institutionCreateWithoutCategoriesInput[] | institutionUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: institutionCreateOrConnectWithoutCategoriesInput | institutionCreateOrConnectWithoutCategoriesInput[]
    upsert?: institutionUpsertWithWhereUniqueWithoutCategoriesInput | institutionUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: institutionCreateManyCategoriesInputEnvelope
    set?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    disconnect?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    delete?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    connect?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    update?: institutionUpdateWithWhereUniqueWithoutCategoriesInput | institutionUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: institutionUpdateManyWithWhereWithoutCategoriesInput | institutionUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: institutionScalarWhereInput | institutionScalarWhereInput[]
  }

  export type category_search_termsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<category_search_termsCreateWithoutCategoriesInput, category_search_termsUncheckedCreateWithoutCategoriesInput> | category_search_termsCreateWithoutCategoriesInput[] | category_search_termsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: category_search_termsCreateOrConnectWithoutCategoriesInput | category_search_termsCreateOrConnectWithoutCategoriesInput[]
    upsert?: category_search_termsUpsertWithWhereUniqueWithoutCategoriesInput | category_search_termsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: category_search_termsCreateManyCategoriesInputEnvelope
    set?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    disconnect?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    delete?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    connect?: category_search_termsWhereUniqueInput | category_search_termsWhereUniqueInput[]
    update?: category_search_termsUpdateWithWhereUniqueWithoutCategoriesInput | category_search_termsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: category_search_termsUpdateManyWithWhereWithoutCategoriesInput | category_search_termsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: category_search_termsScalarWhereInput | category_search_termsScalarWhereInput[]
  }

  export type institutionUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<institutionCreateWithoutCategoriesInput, institutionUncheckedCreateWithoutCategoriesInput> | institutionCreateWithoutCategoriesInput[] | institutionUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: institutionCreateOrConnectWithoutCategoriesInput | institutionCreateOrConnectWithoutCategoriesInput[]
    upsert?: institutionUpsertWithWhereUniqueWithoutCategoriesInput | institutionUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: institutionCreateManyCategoriesInputEnvelope
    set?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    disconnect?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    delete?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    connect?: institutionWhereUniqueInput | institutionWhereUniqueInput[]
    update?: institutionUpdateWithWhereUniqueWithoutCategoriesInput | institutionUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: institutionUpdateManyWithWhereWithoutCategoriesInput | institutionUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: institutionScalarWhereInput | institutionScalarWhereInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type institutionCreateNestedOneWithoutDeviceInput = {
    create?: XOR<institutionCreateWithoutDeviceInput, institutionUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: institutionCreateOrConnectWithoutDeviceInput
    connect?: institutionWhereUniqueInput
  }

  export type qms_customerCreateNestedManyWithoutDeviceInput = {
    create?: XOR<qms_customerCreateWithoutDeviceInput, qms_customerUncheckedCreateWithoutDeviceInput> | qms_customerCreateWithoutDeviceInput[] | qms_customerUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: qms_customerCreateOrConnectWithoutDeviceInput | qms_customerCreateOrConnectWithoutDeviceInput[]
    createMany?: qms_customerCreateManyDeviceInputEnvelope
    connect?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
  }

  export type ratingCreateNestedManyWithoutDeviceInput = {
    create?: XOR<ratingCreateWithoutDeviceInput, ratingUncheckedCreateWithoutDeviceInput> | ratingCreateWithoutDeviceInput[] | ratingUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutDeviceInput | ratingCreateOrConnectWithoutDeviceInput[]
    createMany?: ratingCreateManyDeviceInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type tipCreateNestedManyWithoutDeviceInput = {
    create?: XOR<tipCreateWithoutDeviceInput, tipUncheckedCreateWithoutDeviceInput> | tipCreateWithoutDeviceInput[] | tipUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: tipCreateOrConnectWithoutDeviceInput | tipCreateOrConnectWithoutDeviceInput[]
    createMany?: tipCreateManyDeviceInputEnvelope
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
  }

  export type qms_customerUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<qms_customerCreateWithoutDeviceInput, qms_customerUncheckedCreateWithoutDeviceInput> | qms_customerCreateWithoutDeviceInput[] | qms_customerUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: qms_customerCreateOrConnectWithoutDeviceInput | qms_customerCreateOrConnectWithoutDeviceInput[]
    createMany?: qms_customerCreateManyDeviceInputEnvelope
    connect?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
  }

  export type ratingUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<ratingCreateWithoutDeviceInput, ratingUncheckedCreateWithoutDeviceInput> | ratingCreateWithoutDeviceInput[] | ratingUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutDeviceInput | ratingCreateOrConnectWithoutDeviceInput[]
    createMany?: ratingCreateManyDeviceInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type tipUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<tipCreateWithoutDeviceInput, tipUncheckedCreateWithoutDeviceInput> | tipCreateWithoutDeviceInput[] | tipUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: tipCreateOrConnectWithoutDeviceInput | tipCreateOrConnectWithoutDeviceInput[]
    createMany?: tipCreateManyDeviceInputEnvelope
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
  }

  export type institutionUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<institutionCreateWithoutDeviceInput, institutionUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: institutionCreateOrConnectWithoutDeviceInput
    upsert?: institutionUpsertWithoutDeviceInput
    disconnect?: institutionWhereInput | boolean
    delete?: institutionWhereInput | boolean
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutDeviceInput, institutionUpdateWithoutDeviceInput>, institutionUncheckedUpdateWithoutDeviceInput>
  }

  export type qms_customerUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<qms_customerCreateWithoutDeviceInput, qms_customerUncheckedCreateWithoutDeviceInput> | qms_customerCreateWithoutDeviceInput[] | qms_customerUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: qms_customerCreateOrConnectWithoutDeviceInput | qms_customerCreateOrConnectWithoutDeviceInput[]
    upsert?: qms_customerUpsertWithWhereUniqueWithoutDeviceInput | qms_customerUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: qms_customerCreateManyDeviceInputEnvelope
    set?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    disconnect?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    delete?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    connect?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    update?: qms_customerUpdateWithWhereUniqueWithoutDeviceInput | qms_customerUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: qms_customerUpdateManyWithWhereWithoutDeviceInput | qms_customerUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: qms_customerScalarWhereInput | qms_customerScalarWhereInput[]
  }

  export type ratingUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<ratingCreateWithoutDeviceInput, ratingUncheckedCreateWithoutDeviceInput> | ratingCreateWithoutDeviceInput[] | ratingUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutDeviceInput | ratingCreateOrConnectWithoutDeviceInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutDeviceInput | ratingUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: ratingCreateManyDeviceInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutDeviceInput | ratingUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutDeviceInput | ratingUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type tipUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<tipCreateWithoutDeviceInput, tipUncheckedCreateWithoutDeviceInput> | tipCreateWithoutDeviceInput[] | tipUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: tipCreateOrConnectWithoutDeviceInput | tipCreateOrConnectWithoutDeviceInput[]
    upsert?: tipUpsertWithWhereUniqueWithoutDeviceInput | tipUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: tipCreateManyDeviceInputEnvelope
    set?: tipWhereUniqueInput | tipWhereUniqueInput[]
    disconnect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    delete?: tipWhereUniqueInput | tipWhereUniqueInput[]
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    update?: tipUpdateWithWhereUniqueWithoutDeviceInput | tipUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: tipUpdateManyWithWhereWithoutDeviceInput | tipUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: tipScalarWhereInput | tipScalarWhereInput[]
  }

  export type qms_customerUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<qms_customerCreateWithoutDeviceInput, qms_customerUncheckedCreateWithoutDeviceInput> | qms_customerCreateWithoutDeviceInput[] | qms_customerUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: qms_customerCreateOrConnectWithoutDeviceInput | qms_customerCreateOrConnectWithoutDeviceInput[]
    upsert?: qms_customerUpsertWithWhereUniqueWithoutDeviceInput | qms_customerUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: qms_customerCreateManyDeviceInputEnvelope
    set?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    disconnect?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    delete?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    connect?: qms_customerWhereUniqueInput | qms_customerWhereUniqueInput[]
    update?: qms_customerUpdateWithWhereUniqueWithoutDeviceInput | qms_customerUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: qms_customerUpdateManyWithWhereWithoutDeviceInput | qms_customerUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: qms_customerScalarWhereInput | qms_customerScalarWhereInput[]
  }

  export type ratingUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<ratingCreateWithoutDeviceInput, ratingUncheckedCreateWithoutDeviceInput> | ratingCreateWithoutDeviceInput[] | ratingUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutDeviceInput | ratingCreateOrConnectWithoutDeviceInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutDeviceInput | ratingUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: ratingCreateManyDeviceInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutDeviceInput | ratingUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutDeviceInput | ratingUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type tipUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<tipCreateWithoutDeviceInput, tipUncheckedCreateWithoutDeviceInput> | tipCreateWithoutDeviceInput[] | tipUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: tipCreateOrConnectWithoutDeviceInput | tipCreateOrConnectWithoutDeviceInput[]
    upsert?: tipUpsertWithWhereUniqueWithoutDeviceInput | tipUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: tipCreateManyDeviceInputEnvelope
    set?: tipWhereUniqueInput | tipWhereUniqueInput[]
    disconnect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    delete?: tipWhereUniqueInput | tipWhereUniqueInput[]
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    update?: tipUpdateWithWhereUniqueWithoutDeviceInput | tipUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: tipUpdateManyWithWhereWithoutDeviceInput | tipUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: tipScalarWhereInput | tipScalarWhereInput[]
  }

  export type appointmentsCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<appointmentsCreateWithoutInstitutionInput, appointmentsUncheckedCreateWithoutInstitutionInput> | appointmentsCreateWithoutInstitutionInput[] | appointmentsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutInstitutionInput | appointmentsCreateOrConnectWithoutInstitutionInput[]
    createMany?: appointmentsCreateManyInstitutionInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type appsCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<appsCreateWithoutInstitutionInput, appsUncheckedCreateWithoutInstitutionInput> | appsCreateWithoutInstitutionInput[] | appsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appsCreateOrConnectWithoutInstitutionInput | appsCreateOrConnectWithoutInstitutionInput[]
    createMany?: appsCreateManyInstitutionInputEnvelope
    connect?: appsWhereUniqueInput | appsWhereUniqueInput[]
  }

  export type business_amenitiesCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<business_amenitiesCreateWithoutInstitutionInput, business_amenitiesUncheckedCreateWithoutInstitutionInput> | business_amenitiesCreateWithoutInstitutionInput[] | business_amenitiesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutInstitutionInput | business_amenitiesCreateOrConnectWithoutInstitutionInput[]
    createMany?: business_amenitiesCreateManyInstitutionInputEnvelope
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
  }

  export type deviceCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<deviceCreateWithoutInstitutionInput, deviceUncheckedCreateWithoutInstitutionInput> | deviceCreateWithoutInstitutionInput[] | deviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutInstitutionInput | deviceCreateOrConnectWithoutInstitutionInput[]
    createMany?: deviceCreateManyInstitutionInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type imagesCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<imagesCreateWithoutInstitutionInput, imagesUncheckedCreateWithoutInstitutionInput> | imagesCreateWithoutInstitutionInput[] | imagesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutInstitutionInput | imagesCreateOrConnectWithoutInstitutionInput[]
    createMany?: imagesCreateManyInstitutionInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutInstitutionInput = {
    create?: XOR<categoriesCreateWithoutInstitutionInput, categoriesUncheckedCreateWithoutInstitutionInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutInstitutionInput
    connect?: categoriesWhereUniqueInput
  }

  export type popup_questionsCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<popup_questionsCreateWithoutInstitutionInput, popup_questionsUncheckedCreateWithoutInstitutionInput> | popup_questionsCreateWithoutInstitutionInput[] | popup_questionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: popup_questionsCreateOrConnectWithoutInstitutionInput | popup_questionsCreateOrConnectWithoutInstitutionInput[]
    createMany?: popup_questionsCreateManyInstitutionInputEnvelope
    connect?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
  }

  export type price_rangesCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<price_rangesCreateWithoutInstitutionInput, price_rangesUncheckedCreateWithoutInstitutionInput> | price_rangesCreateWithoutInstitutionInput[] | price_rangesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: price_rangesCreateOrConnectWithoutInstitutionInput | price_rangesCreateOrConnectWithoutInstitutionInput[]
    createMany?: price_rangesCreateManyInstitutionInputEnvelope
    connect?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
  }

  export type qms_branch_operatorCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<qms_branch_operatorCreateWithoutInstitutionInput, qms_branch_operatorUncheckedCreateWithoutInstitutionInput> | qms_branch_operatorCreateWithoutInstitutionInput[] | qms_branch_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutInstitutionInput | qms_branch_operatorCreateOrConnectWithoutInstitutionInput[]
    createMany?: qms_branch_operatorCreateManyInstitutionInputEnvelope
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
  }

  export type qms_branch_transactionsCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<qms_branch_transactionsCreateWithoutInstitutionInput, qms_branch_transactionsUncheckedCreateWithoutInstitutionInput> | qms_branch_transactionsCreateWithoutInstitutionInput[] | qms_branch_transactionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_transactionsCreateOrConnectWithoutInstitutionInput | qms_branch_transactionsCreateOrConnectWithoutInstitutionInput[]
    createMany?: qms_branch_transactionsCreateManyInstitutionInputEnvelope
    connect?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
  }

  export type qms_operatorCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<qms_operatorCreateWithoutInstitutionInput, qms_operatorUncheckedCreateWithoutInstitutionInput> | qms_operatorCreateWithoutInstitutionInput[] | qms_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_operatorCreateOrConnectWithoutInstitutionInput | qms_operatorCreateOrConnectWithoutInstitutionInput[]
    createMany?: qms_operatorCreateManyInstitutionInputEnvelope
    connect?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<reviewsCreateWithoutInstitutionInput, reviewsUncheckedCreateWithoutInstitutionInput> | reviewsCreateWithoutInstitutionInput[] | reviewsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutInstitutionInput | reviewsCreateOrConnectWithoutInstitutionInput[]
    createMany?: reviewsCreateManyInstitutionInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type serviceCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<serviceCreateWithoutInstitutionInput, serviceUncheckedCreateWithoutInstitutionInput> | serviceCreateWithoutInstitutionInput[] | serviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutInstitutionInput | serviceCreateOrConnectWithoutInstitutionInput[]
    createMany?: serviceCreateManyInstitutionInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type service_groupCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<service_groupCreateWithoutInstitutionInput, service_groupUncheckedCreateWithoutInstitutionInput> | service_groupCreateWithoutInstitutionInput[] | service_groupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: service_groupCreateOrConnectWithoutInstitutionInput | service_groupCreateOrConnectWithoutInstitutionInput[]
    createMany?: service_groupCreateManyInstitutionInputEnvelope
    connect?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
  }

  export type workingHourCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<workingHourCreateWithoutInstitutionInput, workingHourUncheckedCreateWithoutInstitutionInput> | workingHourCreateWithoutInstitutionInput[] | workingHourUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: workingHourCreateOrConnectWithoutInstitutionInput | workingHourCreateOrConnectWithoutInstitutionInput[]
    createMany?: workingHourCreateManyInstitutionInputEnvelope
    connect?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<appointmentsCreateWithoutInstitutionInput, appointmentsUncheckedCreateWithoutInstitutionInput> | appointmentsCreateWithoutInstitutionInput[] | appointmentsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutInstitutionInput | appointmentsCreateOrConnectWithoutInstitutionInput[]
    createMany?: appointmentsCreateManyInstitutionInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type appsUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<appsCreateWithoutInstitutionInput, appsUncheckedCreateWithoutInstitutionInput> | appsCreateWithoutInstitutionInput[] | appsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appsCreateOrConnectWithoutInstitutionInput | appsCreateOrConnectWithoutInstitutionInput[]
    createMany?: appsCreateManyInstitutionInputEnvelope
    connect?: appsWhereUniqueInput | appsWhereUniqueInput[]
  }

  export type business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<business_amenitiesCreateWithoutInstitutionInput, business_amenitiesUncheckedCreateWithoutInstitutionInput> | business_amenitiesCreateWithoutInstitutionInput[] | business_amenitiesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutInstitutionInput | business_amenitiesCreateOrConnectWithoutInstitutionInput[]
    createMany?: business_amenitiesCreateManyInstitutionInputEnvelope
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
  }

  export type deviceUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<deviceCreateWithoutInstitutionInput, deviceUncheckedCreateWithoutInstitutionInput> | deviceCreateWithoutInstitutionInput[] | deviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutInstitutionInput | deviceCreateOrConnectWithoutInstitutionInput[]
    createMany?: deviceCreateManyInstitutionInputEnvelope
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
  }

  export type imagesUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<imagesCreateWithoutInstitutionInput, imagesUncheckedCreateWithoutInstitutionInput> | imagesCreateWithoutInstitutionInput[] | imagesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutInstitutionInput | imagesCreateOrConnectWithoutInstitutionInput[]
    createMany?: imagesCreateManyInstitutionInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<popup_questionsCreateWithoutInstitutionInput, popup_questionsUncheckedCreateWithoutInstitutionInput> | popup_questionsCreateWithoutInstitutionInput[] | popup_questionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: popup_questionsCreateOrConnectWithoutInstitutionInput | popup_questionsCreateOrConnectWithoutInstitutionInput[]
    createMany?: popup_questionsCreateManyInstitutionInputEnvelope
    connect?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
  }

  export type price_rangesUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<price_rangesCreateWithoutInstitutionInput, price_rangesUncheckedCreateWithoutInstitutionInput> | price_rangesCreateWithoutInstitutionInput[] | price_rangesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: price_rangesCreateOrConnectWithoutInstitutionInput | price_rangesCreateOrConnectWithoutInstitutionInput[]
    createMany?: price_rangesCreateManyInstitutionInputEnvelope
    connect?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
  }

  export type qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<qms_branch_operatorCreateWithoutInstitutionInput, qms_branch_operatorUncheckedCreateWithoutInstitutionInput> | qms_branch_operatorCreateWithoutInstitutionInput[] | qms_branch_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutInstitutionInput | qms_branch_operatorCreateOrConnectWithoutInstitutionInput[]
    createMany?: qms_branch_operatorCreateManyInstitutionInputEnvelope
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
  }

  export type qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<qms_branch_transactionsCreateWithoutInstitutionInput, qms_branch_transactionsUncheckedCreateWithoutInstitutionInput> | qms_branch_transactionsCreateWithoutInstitutionInput[] | qms_branch_transactionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_transactionsCreateOrConnectWithoutInstitutionInput | qms_branch_transactionsCreateOrConnectWithoutInstitutionInput[]
    createMany?: qms_branch_transactionsCreateManyInstitutionInputEnvelope
    connect?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
  }

  export type qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<qms_operatorCreateWithoutInstitutionInput, qms_operatorUncheckedCreateWithoutInstitutionInput> | qms_operatorCreateWithoutInstitutionInput[] | qms_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_operatorCreateOrConnectWithoutInstitutionInput | qms_operatorCreateOrConnectWithoutInstitutionInput[]
    createMany?: qms_operatorCreateManyInstitutionInputEnvelope
    connect?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<reviewsCreateWithoutInstitutionInput, reviewsUncheckedCreateWithoutInstitutionInput> | reviewsCreateWithoutInstitutionInput[] | reviewsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutInstitutionInput | reviewsCreateOrConnectWithoutInstitutionInput[]
    createMany?: reviewsCreateManyInstitutionInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type serviceUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<serviceCreateWithoutInstitutionInput, serviceUncheckedCreateWithoutInstitutionInput> | serviceCreateWithoutInstitutionInput[] | serviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutInstitutionInput | serviceCreateOrConnectWithoutInstitutionInput[]
    createMany?: serviceCreateManyInstitutionInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type service_groupUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<service_groupCreateWithoutInstitutionInput, service_groupUncheckedCreateWithoutInstitutionInput> | service_groupCreateWithoutInstitutionInput[] | service_groupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: service_groupCreateOrConnectWithoutInstitutionInput | service_groupCreateOrConnectWithoutInstitutionInput[]
    createMany?: service_groupCreateManyInstitutionInputEnvelope
    connect?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
  }

  export type workingHourUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<workingHourCreateWithoutInstitutionInput, workingHourUncheckedCreateWithoutInstitutionInput> | workingHourCreateWithoutInstitutionInput[] | workingHourUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: workingHourCreateOrConnectWithoutInstitutionInput | workingHourCreateOrConnectWithoutInstitutionInput[]
    createMany?: workingHourCreateManyInstitutionInputEnvelope
    connect?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<appointmentsCreateWithoutInstitutionInput, appointmentsUncheckedCreateWithoutInstitutionInput> | appointmentsCreateWithoutInstitutionInput[] | appointmentsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutInstitutionInput | appointmentsCreateOrConnectWithoutInstitutionInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutInstitutionInput | appointmentsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: appointmentsCreateManyInstitutionInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutInstitutionInput | appointmentsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutInstitutionInput | appointmentsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type appsUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<appsCreateWithoutInstitutionInput, appsUncheckedCreateWithoutInstitutionInput> | appsCreateWithoutInstitutionInput[] | appsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appsCreateOrConnectWithoutInstitutionInput | appsCreateOrConnectWithoutInstitutionInput[]
    upsert?: appsUpsertWithWhereUniqueWithoutInstitutionInput | appsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: appsCreateManyInstitutionInputEnvelope
    set?: appsWhereUniqueInput | appsWhereUniqueInput[]
    disconnect?: appsWhereUniqueInput | appsWhereUniqueInput[]
    delete?: appsWhereUniqueInput | appsWhereUniqueInput[]
    connect?: appsWhereUniqueInput | appsWhereUniqueInput[]
    update?: appsUpdateWithWhereUniqueWithoutInstitutionInput | appsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: appsUpdateManyWithWhereWithoutInstitutionInput | appsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: appsScalarWhereInput | appsScalarWhereInput[]
  }

  export type business_amenitiesUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<business_amenitiesCreateWithoutInstitutionInput, business_amenitiesUncheckedCreateWithoutInstitutionInput> | business_amenitiesCreateWithoutInstitutionInput[] | business_amenitiesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutInstitutionInput | business_amenitiesCreateOrConnectWithoutInstitutionInput[]
    upsert?: business_amenitiesUpsertWithWhereUniqueWithoutInstitutionInput | business_amenitiesUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: business_amenitiesCreateManyInstitutionInputEnvelope
    set?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    disconnect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    delete?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    update?: business_amenitiesUpdateWithWhereUniqueWithoutInstitutionInput | business_amenitiesUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: business_amenitiesUpdateManyWithWhereWithoutInstitutionInput | business_amenitiesUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: business_amenitiesScalarWhereInput | business_amenitiesScalarWhereInput[]
  }

  export type deviceUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<deviceCreateWithoutInstitutionInput, deviceUncheckedCreateWithoutInstitutionInput> | deviceCreateWithoutInstitutionInput[] | deviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutInstitutionInput | deviceCreateOrConnectWithoutInstitutionInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutInstitutionInput | deviceUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: deviceCreateManyInstitutionInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutInstitutionInput | deviceUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutInstitutionInput | deviceUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type imagesUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<imagesCreateWithoutInstitutionInput, imagesUncheckedCreateWithoutInstitutionInput> | imagesCreateWithoutInstitutionInput[] | imagesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutInstitutionInput | imagesCreateOrConnectWithoutInstitutionInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutInstitutionInput | imagesUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: imagesCreateManyInstitutionInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutInstitutionInput | imagesUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutInstitutionInput | imagesUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutInstitutionNestedInput = {
    create?: XOR<categoriesCreateWithoutInstitutionInput, categoriesUncheckedCreateWithoutInstitutionInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutInstitutionInput
    upsert?: categoriesUpsertWithoutInstitutionInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutInstitutionInput, categoriesUpdateWithoutInstitutionInput>, categoriesUncheckedUpdateWithoutInstitutionInput>
  }

  export type popup_questionsUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<popup_questionsCreateWithoutInstitutionInput, popup_questionsUncheckedCreateWithoutInstitutionInput> | popup_questionsCreateWithoutInstitutionInput[] | popup_questionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: popup_questionsCreateOrConnectWithoutInstitutionInput | popup_questionsCreateOrConnectWithoutInstitutionInput[]
    upsert?: popup_questionsUpsertWithWhereUniqueWithoutInstitutionInput | popup_questionsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: popup_questionsCreateManyInstitutionInputEnvelope
    set?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    disconnect?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    delete?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    connect?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    update?: popup_questionsUpdateWithWhereUniqueWithoutInstitutionInput | popup_questionsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: popup_questionsUpdateManyWithWhereWithoutInstitutionInput | popup_questionsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: popup_questionsScalarWhereInput | popup_questionsScalarWhereInput[]
  }

  export type price_rangesUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<price_rangesCreateWithoutInstitutionInput, price_rangesUncheckedCreateWithoutInstitutionInput> | price_rangesCreateWithoutInstitutionInput[] | price_rangesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: price_rangesCreateOrConnectWithoutInstitutionInput | price_rangesCreateOrConnectWithoutInstitutionInput[]
    upsert?: price_rangesUpsertWithWhereUniqueWithoutInstitutionInput | price_rangesUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: price_rangesCreateManyInstitutionInputEnvelope
    set?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    disconnect?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    delete?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    connect?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    update?: price_rangesUpdateWithWhereUniqueWithoutInstitutionInput | price_rangesUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: price_rangesUpdateManyWithWhereWithoutInstitutionInput | price_rangesUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: price_rangesScalarWhereInput | price_rangesScalarWhereInput[]
  }

  export type qms_branch_operatorUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<qms_branch_operatorCreateWithoutInstitutionInput, qms_branch_operatorUncheckedCreateWithoutInstitutionInput> | qms_branch_operatorCreateWithoutInstitutionInput[] | qms_branch_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutInstitutionInput | qms_branch_operatorCreateOrConnectWithoutInstitutionInput[]
    upsert?: qms_branch_operatorUpsertWithWhereUniqueWithoutInstitutionInput | qms_branch_operatorUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: qms_branch_operatorCreateManyInstitutionInputEnvelope
    set?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    disconnect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    delete?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    update?: qms_branch_operatorUpdateWithWhereUniqueWithoutInstitutionInput | qms_branch_operatorUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: qms_branch_operatorUpdateManyWithWhereWithoutInstitutionInput | qms_branch_operatorUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: qms_branch_operatorScalarWhereInput | qms_branch_operatorScalarWhereInput[]
  }

  export type qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<qms_branch_transactionsCreateWithoutInstitutionInput, qms_branch_transactionsUncheckedCreateWithoutInstitutionInput> | qms_branch_transactionsCreateWithoutInstitutionInput[] | qms_branch_transactionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_transactionsCreateOrConnectWithoutInstitutionInput | qms_branch_transactionsCreateOrConnectWithoutInstitutionInput[]
    upsert?: qms_branch_transactionsUpsertWithWhereUniqueWithoutInstitutionInput | qms_branch_transactionsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: qms_branch_transactionsCreateManyInstitutionInputEnvelope
    set?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    disconnect?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    delete?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    connect?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    update?: qms_branch_transactionsUpdateWithWhereUniqueWithoutInstitutionInput | qms_branch_transactionsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: qms_branch_transactionsUpdateManyWithWhereWithoutInstitutionInput | qms_branch_transactionsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: qms_branch_transactionsScalarWhereInput | qms_branch_transactionsScalarWhereInput[]
  }

  export type qms_operatorUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<qms_operatorCreateWithoutInstitutionInput, qms_operatorUncheckedCreateWithoutInstitutionInput> | qms_operatorCreateWithoutInstitutionInput[] | qms_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_operatorCreateOrConnectWithoutInstitutionInput | qms_operatorCreateOrConnectWithoutInstitutionInput[]
    upsert?: qms_operatorUpsertWithWhereUniqueWithoutInstitutionInput | qms_operatorUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: qms_operatorCreateManyInstitutionInputEnvelope
    set?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    disconnect?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    delete?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    connect?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    update?: qms_operatorUpdateWithWhereUniqueWithoutInstitutionInput | qms_operatorUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: qms_operatorUpdateManyWithWhereWithoutInstitutionInput | qms_operatorUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: qms_operatorScalarWhereInput | qms_operatorScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<reviewsCreateWithoutInstitutionInput, reviewsUncheckedCreateWithoutInstitutionInput> | reviewsCreateWithoutInstitutionInput[] | reviewsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutInstitutionInput | reviewsCreateOrConnectWithoutInstitutionInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutInstitutionInput | reviewsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: reviewsCreateManyInstitutionInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutInstitutionInput | reviewsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutInstitutionInput | reviewsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type serviceUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<serviceCreateWithoutInstitutionInput, serviceUncheckedCreateWithoutInstitutionInput> | serviceCreateWithoutInstitutionInput[] | serviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutInstitutionInput | serviceCreateOrConnectWithoutInstitutionInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutInstitutionInput | serviceUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: serviceCreateManyInstitutionInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutInstitutionInput | serviceUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutInstitutionInput | serviceUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type service_groupUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<service_groupCreateWithoutInstitutionInput, service_groupUncheckedCreateWithoutInstitutionInput> | service_groupCreateWithoutInstitutionInput[] | service_groupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: service_groupCreateOrConnectWithoutInstitutionInput | service_groupCreateOrConnectWithoutInstitutionInput[]
    upsert?: service_groupUpsertWithWhereUniqueWithoutInstitutionInput | service_groupUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: service_groupCreateManyInstitutionInputEnvelope
    set?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    disconnect?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    delete?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    connect?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    update?: service_groupUpdateWithWhereUniqueWithoutInstitutionInput | service_groupUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: service_groupUpdateManyWithWhereWithoutInstitutionInput | service_groupUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: service_groupScalarWhereInput | service_groupScalarWhereInput[]
  }

  export type workingHourUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<workingHourCreateWithoutInstitutionInput, workingHourUncheckedCreateWithoutInstitutionInput> | workingHourCreateWithoutInstitutionInput[] | workingHourUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: workingHourCreateOrConnectWithoutInstitutionInput | workingHourCreateOrConnectWithoutInstitutionInput[]
    upsert?: workingHourUpsertWithWhereUniqueWithoutInstitutionInput | workingHourUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: workingHourCreateManyInstitutionInputEnvelope
    set?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    disconnect?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    delete?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    connect?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    update?: workingHourUpdateWithWhereUniqueWithoutInstitutionInput | workingHourUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: workingHourUpdateManyWithWhereWithoutInstitutionInput | workingHourUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: workingHourScalarWhereInput | workingHourScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<appointmentsCreateWithoutInstitutionInput, appointmentsUncheckedCreateWithoutInstitutionInput> | appointmentsCreateWithoutInstitutionInput[] | appointmentsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutInstitutionInput | appointmentsCreateOrConnectWithoutInstitutionInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutInstitutionInput | appointmentsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: appointmentsCreateManyInstitutionInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutInstitutionInput | appointmentsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutInstitutionInput | appointmentsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type appsUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<appsCreateWithoutInstitutionInput, appsUncheckedCreateWithoutInstitutionInput> | appsCreateWithoutInstitutionInput[] | appsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: appsCreateOrConnectWithoutInstitutionInput | appsCreateOrConnectWithoutInstitutionInput[]
    upsert?: appsUpsertWithWhereUniqueWithoutInstitutionInput | appsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: appsCreateManyInstitutionInputEnvelope
    set?: appsWhereUniqueInput | appsWhereUniqueInput[]
    disconnect?: appsWhereUniqueInput | appsWhereUniqueInput[]
    delete?: appsWhereUniqueInput | appsWhereUniqueInput[]
    connect?: appsWhereUniqueInput | appsWhereUniqueInput[]
    update?: appsUpdateWithWhereUniqueWithoutInstitutionInput | appsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: appsUpdateManyWithWhereWithoutInstitutionInput | appsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: appsScalarWhereInput | appsScalarWhereInput[]
  }

  export type business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<business_amenitiesCreateWithoutInstitutionInput, business_amenitiesUncheckedCreateWithoutInstitutionInput> | business_amenitiesCreateWithoutInstitutionInput[] | business_amenitiesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutInstitutionInput | business_amenitiesCreateOrConnectWithoutInstitutionInput[]
    upsert?: business_amenitiesUpsertWithWhereUniqueWithoutInstitutionInput | business_amenitiesUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: business_amenitiesCreateManyInstitutionInputEnvelope
    set?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    disconnect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    delete?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    update?: business_amenitiesUpdateWithWhereUniqueWithoutInstitutionInput | business_amenitiesUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: business_amenitiesUpdateManyWithWhereWithoutInstitutionInput | business_amenitiesUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: business_amenitiesScalarWhereInput | business_amenitiesScalarWhereInput[]
  }

  export type deviceUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<deviceCreateWithoutInstitutionInput, deviceUncheckedCreateWithoutInstitutionInput> | deviceCreateWithoutInstitutionInput[] | deviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: deviceCreateOrConnectWithoutInstitutionInput | deviceCreateOrConnectWithoutInstitutionInput[]
    upsert?: deviceUpsertWithWhereUniqueWithoutInstitutionInput | deviceUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: deviceCreateManyInstitutionInputEnvelope
    set?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    disconnect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    delete?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    connect?: deviceWhereUniqueInput | deviceWhereUniqueInput[]
    update?: deviceUpdateWithWhereUniqueWithoutInstitutionInput | deviceUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: deviceUpdateManyWithWhereWithoutInstitutionInput | deviceUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: deviceScalarWhereInput | deviceScalarWhereInput[]
  }

  export type imagesUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<imagesCreateWithoutInstitutionInput, imagesUncheckedCreateWithoutInstitutionInput> | imagesCreateWithoutInstitutionInput[] | imagesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutInstitutionInput | imagesCreateOrConnectWithoutInstitutionInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutInstitutionInput | imagesUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: imagesCreateManyInstitutionInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutInstitutionInput | imagesUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutInstitutionInput | imagesUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<popup_questionsCreateWithoutInstitutionInput, popup_questionsUncheckedCreateWithoutInstitutionInput> | popup_questionsCreateWithoutInstitutionInput[] | popup_questionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: popup_questionsCreateOrConnectWithoutInstitutionInput | popup_questionsCreateOrConnectWithoutInstitutionInput[]
    upsert?: popup_questionsUpsertWithWhereUniqueWithoutInstitutionInput | popup_questionsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: popup_questionsCreateManyInstitutionInputEnvelope
    set?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    disconnect?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    delete?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    connect?: popup_questionsWhereUniqueInput | popup_questionsWhereUniqueInput[]
    update?: popup_questionsUpdateWithWhereUniqueWithoutInstitutionInput | popup_questionsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: popup_questionsUpdateManyWithWhereWithoutInstitutionInput | popup_questionsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: popup_questionsScalarWhereInput | popup_questionsScalarWhereInput[]
  }

  export type price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<price_rangesCreateWithoutInstitutionInput, price_rangesUncheckedCreateWithoutInstitutionInput> | price_rangesCreateWithoutInstitutionInput[] | price_rangesUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: price_rangesCreateOrConnectWithoutInstitutionInput | price_rangesCreateOrConnectWithoutInstitutionInput[]
    upsert?: price_rangesUpsertWithWhereUniqueWithoutInstitutionInput | price_rangesUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: price_rangesCreateManyInstitutionInputEnvelope
    set?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    disconnect?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    delete?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    connect?: price_rangesWhereUniqueInput | price_rangesWhereUniqueInput[]
    update?: price_rangesUpdateWithWhereUniqueWithoutInstitutionInput | price_rangesUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: price_rangesUpdateManyWithWhereWithoutInstitutionInput | price_rangesUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: price_rangesScalarWhereInput | price_rangesScalarWhereInput[]
  }

  export type qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<qms_branch_operatorCreateWithoutInstitutionInput, qms_branch_operatorUncheckedCreateWithoutInstitutionInput> | qms_branch_operatorCreateWithoutInstitutionInput[] | qms_branch_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutInstitutionInput | qms_branch_operatorCreateOrConnectWithoutInstitutionInput[]
    upsert?: qms_branch_operatorUpsertWithWhereUniqueWithoutInstitutionInput | qms_branch_operatorUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: qms_branch_operatorCreateManyInstitutionInputEnvelope
    set?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    disconnect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    delete?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    update?: qms_branch_operatorUpdateWithWhereUniqueWithoutInstitutionInput | qms_branch_operatorUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: qms_branch_operatorUpdateManyWithWhereWithoutInstitutionInput | qms_branch_operatorUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: qms_branch_operatorScalarWhereInput | qms_branch_operatorScalarWhereInput[]
  }

  export type qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<qms_branch_transactionsCreateWithoutInstitutionInput, qms_branch_transactionsUncheckedCreateWithoutInstitutionInput> | qms_branch_transactionsCreateWithoutInstitutionInput[] | qms_branch_transactionsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_branch_transactionsCreateOrConnectWithoutInstitutionInput | qms_branch_transactionsCreateOrConnectWithoutInstitutionInput[]
    upsert?: qms_branch_transactionsUpsertWithWhereUniqueWithoutInstitutionInput | qms_branch_transactionsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: qms_branch_transactionsCreateManyInstitutionInputEnvelope
    set?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    disconnect?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    delete?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    connect?: qms_branch_transactionsWhereUniqueInput | qms_branch_transactionsWhereUniqueInput[]
    update?: qms_branch_transactionsUpdateWithWhereUniqueWithoutInstitutionInput | qms_branch_transactionsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: qms_branch_transactionsUpdateManyWithWhereWithoutInstitutionInput | qms_branch_transactionsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: qms_branch_transactionsScalarWhereInput | qms_branch_transactionsScalarWhereInput[]
  }

  export type qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<qms_operatorCreateWithoutInstitutionInput, qms_operatorUncheckedCreateWithoutInstitutionInput> | qms_operatorCreateWithoutInstitutionInput[] | qms_operatorUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: qms_operatorCreateOrConnectWithoutInstitutionInput | qms_operatorCreateOrConnectWithoutInstitutionInput[]
    upsert?: qms_operatorUpsertWithWhereUniqueWithoutInstitutionInput | qms_operatorUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: qms_operatorCreateManyInstitutionInputEnvelope
    set?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    disconnect?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    delete?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    connect?: qms_operatorWhereUniqueInput | qms_operatorWhereUniqueInput[]
    update?: qms_operatorUpdateWithWhereUniqueWithoutInstitutionInput | qms_operatorUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: qms_operatorUpdateManyWithWhereWithoutInstitutionInput | qms_operatorUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: qms_operatorScalarWhereInput | qms_operatorScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<reviewsCreateWithoutInstitutionInput, reviewsUncheckedCreateWithoutInstitutionInput> | reviewsCreateWithoutInstitutionInput[] | reviewsUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutInstitutionInput | reviewsCreateOrConnectWithoutInstitutionInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutInstitutionInput | reviewsUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: reviewsCreateManyInstitutionInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutInstitutionInput | reviewsUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutInstitutionInput | reviewsUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type serviceUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<serviceCreateWithoutInstitutionInput, serviceUncheckedCreateWithoutInstitutionInput> | serviceCreateWithoutInstitutionInput[] | serviceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutInstitutionInput | serviceCreateOrConnectWithoutInstitutionInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutInstitutionInput | serviceUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: serviceCreateManyInstitutionInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutInstitutionInput | serviceUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutInstitutionInput | serviceUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type service_groupUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<service_groupCreateWithoutInstitutionInput, service_groupUncheckedCreateWithoutInstitutionInput> | service_groupCreateWithoutInstitutionInput[] | service_groupUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: service_groupCreateOrConnectWithoutInstitutionInput | service_groupCreateOrConnectWithoutInstitutionInput[]
    upsert?: service_groupUpsertWithWhereUniqueWithoutInstitutionInput | service_groupUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: service_groupCreateManyInstitutionInputEnvelope
    set?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    disconnect?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    delete?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    connect?: service_groupWhereUniqueInput | service_groupWhereUniqueInput[]
    update?: service_groupUpdateWithWhereUniqueWithoutInstitutionInput | service_groupUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: service_groupUpdateManyWithWhereWithoutInstitutionInput | service_groupUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: service_groupScalarWhereInput | service_groupScalarWhereInput[]
  }

  export type workingHourUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<workingHourCreateWithoutInstitutionInput, workingHourUncheckedCreateWithoutInstitutionInput> | workingHourCreateWithoutInstitutionInput[] | workingHourUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: workingHourCreateOrConnectWithoutInstitutionInput | workingHourCreateOrConnectWithoutInstitutionInput[]
    upsert?: workingHourUpsertWithWhereUniqueWithoutInstitutionInput | workingHourUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: workingHourCreateManyInstitutionInputEnvelope
    set?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    disconnect?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    delete?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    connect?: workingHourWhereUniqueInput | workingHourWhereUniqueInput[]
    update?: workingHourUpdateWithWhereUniqueWithoutInstitutionInput | workingHourUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: workingHourUpdateManyWithWhereWithoutInstitutionInput | workingHourUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: workingHourScalarWhereInput | workingHourScalarWhereInput[]
  }

  export type Enuminstitution_invoices_payment_statusFieldUpdateOperationsInput = {
    set?: $Enums.institution_invoices_payment_status
  }

  export type Enuminstitution_invoices_statusFieldUpdateOperationsInput = {
    set?: $Enums.institution_invoices_status
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type qms_ticketCreateNestedManyWithoutOptionInput = {
    create?: XOR<qms_ticketCreateWithoutOptionInput, qms_ticketUncheckedCreateWithoutOptionInput> | qms_ticketCreateWithoutOptionInput[] | qms_ticketUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutOptionInput | qms_ticketCreateOrConnectWithoutOptionInput[]
    createMany?: qms_ticketCreateManyOptionInputEnvelope
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
  }

  export type qms_ticketUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<qms_ticketCreateWithoutOptionInput, qms_ticketUncheckedCreateWithoutOptionInput> | qms_ticketCreateWithoutOptionInput[] | qms_ticketUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutOptionInput | qms_ticketCreateOrConnectWithoutOptionInput[]
    createMany?: qms_ticketCreateManyOptionInputEnvelope
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
  }

  export type qms_ticketUpdateManyWithoutOptionNestedInput = {
    create?: XOR<qms_ticketCreateWithoutOptionInput, qms_ticketUncheckedCreateWithoutOptionInput> | qms_ticketCreateWithoutOptionInput[] | qms_ticketUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutOptionInput | qms_ticketCreateOrConnectWithoutOptionInput[]
    upsert?: qms_ticketUpsertWithWhereUniqueWithoutOptionInput | qms_ticketUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: qms_ticketCreateManyOptionInputEnvelope
    set?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    disconnect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    delete?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    update?: qms_ticketUpdateWithWhereUniqueWithoutOptionInput | qms_ticketUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: qms_ticketUpdateManyWithWhereWithoutOptionInput | qms_ticketUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
  }

  export type qms_ticketUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<qms_ticketCreateWithoutOptionInput, qms_ticketUncheckedCreateWithoutOptionInput> | qms_ticketCreateWithoutOptionInput[] | qms_ticketUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutOptionInput | qms_ticketCreateOrConnectWithoutOptionInput[]
    upsert?: qms_ticketUpsertWithWhereUniqueWithoutOptionInput | qms_ticketUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: qms_ticketCreateManyOptionInputEnvelope
    set?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    disconnect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    delete?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    update?: qms_ticketUpdateWithWhereUniqueWithoutOptionInput | qms_ticketUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: qms_ticketUpdateManyWithWhereWithoutOptionInput | qms_ticketUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
  }

  export type institutionCreateNestedOneWithoutPopup_questionsInput = {
    create?: XOR<institutionCreateWithoutPopup_questionsInput, institutionUncheckedCreateWithoutPopup_questionsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutPopup_questionsInput
    connect?: institutionWhereUniqueInput
  }

  export type popup_questions_possible_answersCreateNestedManyWithoutPopup_questionsInput = {
    create?: XOR<popup_questions_possible_answersCreateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput> | popup_questions_possible_answersCreateWithoutPopup_questionsInput[] | popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput[]
    connectOrCreate?: popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput | popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput[]
    createMany?: popup_questions_possible_answersCreateManyPopup_questionsInputEnvelope
    connect?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
  }

  export type popup_questions_possible_answersUncheckedCreateNestedManyWithoutPopup_questionsInput = {
    create?: XOR<popup_questions_possible_answersCreateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput> | popup_questions_possible_answersCreateWithoutPopup_questionsInput[] | popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput[]
    connectOrCreate?: popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput | popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput[]
    createMany?: popup_questions_possible_answersCreateManyPopup_questionsInputEnvelope
    connect?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type institutionUpdateOneRequiredWithoutPopup_questionsNestedInput = {
    create?: XOR<institutionCreateWithoutPopup_questionsInput, institutionUncheckedCreateWithoutPopup_questionsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutPopup_questionsInput
    upsert?: institutionUpsertWithoutPopup_questionsInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutPopup_questionsInput, institutionUpdateWithoutPopup_questionsInput>, institutionUncheckedUpdateWithoutPopup_questionsInput>
  }

  export type popup_questions_possible_answersUpdateManyWithoutPopup_questionsNestedInput = {
    create?: XOR<popup_questions_possible_answersCreateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput> | popup_questions_possible_answersCreateWithoutPopup_questionsInput[] | popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput[]
    connectOrCreate?: popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput | popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput[]
    upsert?: popup_questions_possible_answersUpsertWithWhereUniqueWithoutPopup_questionsInput | popup_questions_possible_answersUpsertWithWhereUniqueWithoutPopup_questionsInput[]
    createMany?: popup_questions_possible_answersCreateManyPopup_questionsInputEnvelope
    set?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    disconnect?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    delete?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    connect?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    update?: popup_questions_possible_answersUpdateWithWhereUniqueWithoutPopup_questionsInput | popup_questions_possible_answersUpdateWithWhereUniqueWithoutPopup_questionsInput[]
    updateMany?: popup_questions_possible_answersUpdateManyWithWhereWithoutPopup_questionsInput | popup_questions_possible_answersUpdateManyWithWhereWithoutPopup_questionsInput[]
    deleteMany?: popup_questions_possible_answersScalarWhereInput | popup_questions_possible_answersScalarWhereInput[]
  }

  export type popup_questions_possible_answersUncheckedUpdateManyWithoutPopup_questionsNestedInput = {
    create?: XOR<popup_questions_possible_answersCreateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput> | popup_questions_possible_answersCreateWithoutPopup_questionsInput[] | popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput[]
    connectOrCreate?: popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput | popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput[]
    upsert?: popup_questions_possible_answersUpsertWithWhereUniqueWithoutPopup_questionsInput | popup_questions_possible_answersUpsertWithWhereUniqueWithoutPopup_questionsInput[]
    createMany?: popup_questions_possible_answersCreateManyPopup_questionsInputEnvelope
    set?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    disconnect?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    delete?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    connect?: popup_questions_possible_answersWhereUniqueInput | popup_questions_possible_answersWhereUniqueInput[]
    update?: popup_questions_possible_answersUpdateWithWhereUniqueWithoutPopup_questionsInput | popup_questions_possible_answersUpdateWithWhereUniqueWithoutPopup_questionsInput[]
    updateMany?: popup_questions_possible_answersUpdateManyWithWhereWithoutPopup_questionsInput | popup_questions_possible_answersUpdateManyWithWhereWithoutPopup_questionsInput[]
    deleteMany?: popup_questions_possible_answersScalarWhereInput | popup_questions_possible_answersScalarWhereInput[]
  }

  export type popup_questions_possible_answersCreateNestedOneWithoutPopup_questions_answersInput = {
    create?: XOR<popup_questions_possible_answersCreateWithoutPopup_questions_answersInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questions_answersInput>
    connectOrCreate?: popup_questions_possible_answersCreateOrConnectWithoutPopup_questions_answersInput
    connect?: popup_questions_possible_answersWhereUniqueInput
  }

  export type popup_questions_possible_answersUpdateOneRequiredWithoutPopup_questions_answersNestedInput = {
    create?: XOR<popup_questions_possible_answersCreateWithoutPopup_questions_answersInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questions_answersInput>
    connectOrCreate?: popup_questions_possible_answersCreateOrConnectWithoutPopup_questions_answersInput
    upsert?: popup_questions_possible_answersUpsertWithoutPopup_questions_answersInput
    connect?: popup_questions_possible_answersWhereUniqueInput
    update?: XOR<XOR<popup_questions_possible_answersUpdateToOneWithWhereWithoutPopup_questions_answersInput, popup_questions_possible_answersUpdateWithoutPopup_questions_answersInput>, popup_questions_possible_answersUncheckedUpdateWithoutPopup_questions_answersInput>
  }

  export type popup_questions_answersCreateNestedManyWithoutPopup_questions_possible_answersInput = {
    create?: XOR<popup_questions_answersCreateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput> | popup_questions_answersCreateWithoutPopup_questions_possible_answersInput[] | popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput[]
    connectOrCreate?: popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput | popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput[]
    createMany?: popup_questions_answersCreateManyPopup_questions_possible_answersInputEnvelope
    connect?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
  }

  export type popup_questionsCreateNestedOneWithoutPopup_questions_possible_answersInput = {
    create?: XOR<popup_questionsCreateWithoutPopup_questions_possible_answersInput, popup_questionsUncheckedCreateWithoutPopup_questions_possible_answersInput>
    connectOrCreate?: popup_questionsCreateOrConnectWithoutPopup_questions_possible_answersInput
    connect?: popup_questionsWhereUniqueInput
  }

  export type popup_questions_answersUncheckedCreateNestedManyWithoutPopup_questions_possible_answersInput = {
    create?: XOR<popup_questions_answersCreateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput> | popup_questions_answersCreateWithoutPopup_questions_possible_answersInput[] | popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput[]
    connectOrCreate?: popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput | popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput[]
    createMany?: popup_questions_answersCreateManyPopup_questions_possible_answersInputEnvelope
    connect?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
  }

  export type popup_questions_answersUpdateManyWithoutPopup_questions_possible_answersNestedInput = {
    create?: XOR<popup_questions_answersCreateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput> | popup_questions_answersCreateWithoutPopup_questions_possible_answersInput[] | popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput[]
    connectOrCreate?: popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput | popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput[]
    upsert?: popup_questions_answersUpsertWithWhereUniqueWithoutPopup_questions_possible_answersInput | popup_questions_answersUpsertWithWhereUniqueWithoutPopup_questions_possible_answersInput[]
    createMany?: popup_questions_answersCreateManyPopup_questions_possible_answersInputEnvelope
    set?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    disconnect?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    delete?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    connect?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    update?: popup_questions_answersUpdateWithWhereUniqueWithoutPopup_questions_possible_answersInput | popup_questions_answersUpdateWithWhereUniqueWithoutPopup_questions_possible_answersInput[]
    updateMany?: popup_questions_answersUpdateManyWithWhereWithoutPopup_questions_possible_answersInput | popup_questions_answersUpdateManyWithWhereWithoutPopup_questions_possible_answersInput[]
    deleteMany?: popup_questions_answersScalarWhereInput | popup_questions_answersScalarWhereInput[]
  }

  export type popup_questionsUpdateOneRequiredWithoutPopup_questions_possible_answersNestedInput = {
    create?: XOR<popup_questionsCreateWithoutPopup_questions_possible_answersInput, popup_questionsUncheckedCreateWithoutPopup_questions_possible_answersInput>
    connectOrCreate?: popup_questionsCreateOrConnectWithoutPopup_questions_possible_answersInput
    upsert?: popup_questionsUpsertWithoutPopup_questions_possible_answersInput
    connect?: popup_questionsWhereUniqueInput
    update?: XOR<XOR<popup_questionsUpdateToOneWithWhereWithoutPopup_questions_possible_answersInput, popup_questionsUpdateWithoutPopup_questions_possible_answersInput>, popup_questionsUncheckedUpdateWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questions_answersUncheckedUpdateManyWithoutPopup_questions_possible_answersNestedInput = {
    create?: XOR<popup_questions_answersCreateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput> | popup_questions_answersCreateWithoutPopup_questions_possible_answersInput[] | popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput[]
    connectOrCreate?: popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput | popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput[]
    upsert?: popup_questions_answersUpsertWithWhereUniqueWithoutPopup_questions_possible_answersInput | popup_questions_answersUpsertWithWhereUniqueWithoutPopup_questions_possible_answersInput[]
    createMany?: popup_questions_answersCreateManyPopup_questions_possible_answersInputEnvelope
    set?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    disconnect?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    delete?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    connect?: popup_questions_answersWhereUniqueInput | popup_questions_answersWhereUniqueInput[]
    update?: popup_questions_answersUpdateWithWhereUniqueWithoutPopup_questions_possible_answersInput | popup_questions_answersUpdateWithWhereUniqueWithoutPopup_questions_possible_answersInput[]
    updateMany?: popup_questions_answersUpdateManyWithWhereWithoutPopup_questions_possible_answersInput | popup_questions_answersUpdateManyWithWhereWithoutPopup_questions_possible_answersInput[]
    deleteMany?: popup_questions_answersScalarWhereInput | popup_questions_answersScalarWhereInput[]
  }

  export type institutionCreateNestedOneWithoutQms_branch_operatorInput = {
    create?: XOR<institutionCreateWithoutQms_branch_operatorInput, institutionUncheckedCreateWithoutQms_branch_operatorInput>
    connectOrCreate?: institutionCreateOrConnectWithoutQms_branch_operatorInput
    connect?: institutionWhereUniqueInput
  }

  export type qms_operatorCreateNestedOneWithoutQms_branch_operatorInput = {
    create?: XOR<qms_operatorCreateWithoutQms_branch_operatorInput, qms_operatorUncheckedCreateWithoutQms_branch_operatorInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_branch_operatorInput
    connect?: qms_operatorWhereUniqueInput
  }

  export type institutionUpdateOneRequiredWithoutQms_branch_operatorNestedInput = {
    create?: XOR<institutionCreateWithoutQms_branch_operatorInput, institutionUncheckedCreateWithoutQms_branch_operatorInput>
    connectOrCreate?: institutionCreateOrConnectWithoutQms_branch_operatorInput
    upsert?: institutionUpsertWithoutQms_branch_operatorInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutQms_branch_operatorInput, institutionUpdateWithoutQms_branch_operatorInput>, institutionUncheckedUpdateWithoutQms_branch_operatorInput>
  }

  export type qms_operatorUpdateOneRequiredWithoutQms_branch_operatorNestedInput = {
    create?: XOR<qms_operatorCreateWithoutQms_branch_operatorInput, qms_operatorUncheckedCreateWithoutQms_branch_operatorInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_branch_operatorInput
    upsert?: qms_operatorUpsertWithoutQms_branch_operatorInput
    connect?: qms_operatorWhereUniqueInput
    update?: XOR<XOR<qms_operatorUpdateToOneWithWhereWithoutQms_branch_operatorInput, qms_operatorUpdateWithoutQms_branch_operatorInput>, qms_operatorUncheckedUpdateWithoutQms_branch_operatorInput>
  }

  export type institutionCreateNestedOneWithoutQms_branch_transactionsInput = {
    create?: XOR<institutionCreateWithoutQms_branch_transactionsInput, institutionUncheckedCreateWithoutQms_branch_transactionsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutQms_branch_transactionsInput
    connect?: institutionWhereUniqueInput
  }

  export type qms_operator_transactionsCreateNestedManyWithoutQms_branch_transactionsInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput> | qms_operator_transactionsCreateWithoutQms_branch_transactionsInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput | qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput[]
    createMany?: qms_operator_transactionsCreateManyQms_branch_transactionsInputEnvelope
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
  }

  export type qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_branch_transactionsInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput> | qms_operator_transactionsCreateWithoutQms_branch_transactionsInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput | qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput[]
    createMany?: qms_operator_transactionsCreateManyQms_branch_transactionsInputEnvelope
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
  }

  export type institutionUpdateOneRequiredWithoutQms_branch_transactionsNestedInput = {
    create?: XOR<institutionCreateWithoutQms_branch_transactionsInput, institutionUncheckedCreateWithoutQms_branch_transactionsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutQms_branch_transactionsInput
    upsert?: institutionUpsertWithoutQms_branch_transactionsInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutQms_branch_transactionsInput, institutionUpdateWithoutQms_branch_transactionsInput>, institutionUncheckedUpdateWithoutQms_branch_transactionsInput>
  }

  export type qms_operator_transactionsUpdateManyWithoutQms_branch_transactionsNestedInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput> | qms_operator_transactionsCreateWithoutQms_branch_transactionsInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput | qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput[]
    upsert?: qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_branch_transactionsInput | qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_branch_transactionsInput[]
    createMany?: qms_operator_transactionsCreateManyQms_branch_transactionsInputEnvelope
    set?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    disconnect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    delete?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    update?: qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_branch_transactionsInput | qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_branch_transactionsInput[]
    updateMany?: qms_operator_transactionsUpdateManyWithWhereWithoutQms_branch_transactionsInput | qms_operator_transactionsUpdateManyWithWhereWithoutQms_branch_transactionsInput[]
    deleteMany?: qms_operator_transactionsScalarWhereInput | qms_operator_transactionsScalarWhereInput[]
  }

  export type qms_operator_transactionsUncheckedUpdateManyWithoutQms_branch_transactionsNestedInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput> | qms_operator_transactionsCreateWithoutQms_branch_transactionsInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput | qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput[]
    upsert?: qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_branch_transactionsInput | qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_branch_transactionsInput[]
    createMany?: qms_operator_transactionsCreateManyQms_branch_transactionsInputEnvelope
    set?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    disconnect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    delete?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    update?: qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_branch_transactionsInput | qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_branch_transactionsInput[]
    updateMany?: qms_operator_transactionsUpdateManyWithWhereWithoutQms_branch_transactionsInput | qms_operator_transactionsUpdateManyWithWhereWithoutQms_branch_transactionsInput[]
    deleteMany?: qms_operator_transactionsScalarWhereInput | qms_operator_transactionsScalarWhereInput[]
  }

  export type serviceCreateNestedOneWithoutQms_counterInput = {
    create?: XOR<serviceCreateWithoutQms_counterInput, serviceUncheckedCreateWithoutQms_counterInput>
    connectOrCreate?: serviceCreateOrConnectWithoutQms_counterInput
    connect?: serviceWhereUniqueInput
  }

  export type serviceUpdateOneWithoutQms_counterNestedInput = {
    create?: XOR<serviceCreateWithoutQms_counterInput, serviceUncheckedCreateWithoutQms_counterInput>
    connectOrCreate?: serviceCreateOrConnectWithoutQms_counterInput
    upsert?: serviceUpsertWithoutQms_counterInput
    disconnect?: serviceWhereInput | boolean
    delete?: serviceWhereInput | boolean
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutQms_counterInput, serviceUpdateWithoutQms_counterInput>, serviceUncheckedUpdateWithoutQms_counterInput>
  }

  export type deviceCreateNestedOneWithoutQms_customerInput = {
    create?: XOR<deviceCreateWithoutQms_customerInput, deviceUncheckedCreateWithoutQms_customerInput>
    connectOrCreate?: deviceCreateOrConnectWithoutQms_customerInput
    connect?: deviceWhereUniqueInput
  }

  export type qms_ticketCreateNestedManyWithoutQms_customerInput = {
    create?: XOR<qms_ticketCreateWithoutQms_customerInput, qms_ticketUncheckedCreateWithoutQms_customerInput> | qms_ticketCreateWithoutQms_customerInput[] | qms_ticketUncheckedCreateWithoutQms_customerInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_customerInput | qms_ticketCreateOrConnectWithoutQms_customerInput[]
    createMany?: qms_ticketCreateManyQms_customerInputEnvelope
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
  }

  export type qms_ticketUncheckedCreateNestedManyWithoutQms_customerInput = {
    create?: XOR<qms_ticketCreateWithoutQms_customerInput, qms_ticketUncheckedCreateWithoutQms_customerInput> | qms_ticketCreateWithoutQms_customerInput[] | qms_ticketUncheckedCreateWithoutQms_customerInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_customerInput | qms_ticketCreateOrConnectWithoutQms_customerInput[]
    createMany?: qms_ticketCreateManyQms_customerInputEnvelope
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
  }

  export type deviceUpdateOneWithoutQms_customerNestedInput = {
    create?: XOR<deviceCreateWithoutQms_customerInput, deviceUncheckedCreateWithoutQms_customerInput>
    connectOrCreate?: deviceCreateOrConnectWithoutQms_customerInput
    upsert?: deviceUpsertWithoutQms_customerInput
    disconnect?: deviceWhereInput | boolean
    delete?: deviceWhereInput | boolean
    connect?: deviceWhereUniqueInput
    update?: XOR<XOR<deviceUpdateToOneWithWhereWithoutQms_customerInput, deviceUpdateWithoutQms_customerInput>, deviceUncheckedUpdateWithoutQms_customerInput>
  }

  export type qms_ticketUpdateManyWithoutQms_customerNestedInput = {
    create?: XOR<qms_ticketCreateWithoutQms_customerInput, qms_ticketUncheckedCreateWithoutQms_customerInput> | qms_ticketCreateWithoutQms_customerInput[] | qms_ticketUncheckedCreateWithoutQms_customerInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_customerInput | qms_ticketCreateOrConnectWithoutQms_customerInput[]
    upsert?: qms_ticketUpsertWithWhereUniqueWithoutQms_customerInput | qms_ticketUpsertWithWhereUniqueWithoutQms_customerInput[]
    createMany?: qms_ticketCreateManyQms_customerInputEnvelope
    set?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    disconnect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    delete?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    update?: qms_ticketUpdateWithWhereUniqueWithoutQms_customerInput | qms_ticketUpdateWithWhereUniqueWithoutQms_customerInput[]
    updateMany?: qms_ticketUpdateManyWithWhereWithoutQms_customerInput | qms_ticketUpdateManyWithWhereWithoutQms_customerInput[]
    deleteMany?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
  }

  export type qms_ticketUncheckedUpdateManyWithoutQms_customerNestedInput = {
    create?: XOR<qms_ticketCreateWithoutQms_customerInput, qms_ticketUncheckedCreateWithoutQms_customerInput> | qms_ticketCreateWithoutQms_customerInput[] | qms_ticketUncheckedCreateWithoutQms_customerInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_customerInput | qms_ticketCreateOrConnectWithoutQms_customerInput[]
    upsert?: qms_ticketUpsertWithWhereUniqueWithoutQms_customerInput | qms_ticketUpsertWithWhereUniqueWithoutQms_customerInput[]
    createMany?: qms_ticketCreateManyQms_customerInputEnvelope
    set?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    disconnect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    delete?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    update?: qms_ticketUpdateWithWhereUniqueWithoutQms_customerInput | qms_ticketUpdateWithWhereUniqueWithoutQms_customerInput[]
    updateMany?: qms_ticketUpdateManyWithWhereWithoutQms_customerInput | qms_ticketUpdateManyWithWhereWithoutQms_customerInput[]
    deleteMany?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
  }

  export type appointmentsCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<appointmentsCreateWithoutQms_operatorInput, appointmentsUncheckedCreateWithoutQms_operatorInput> | appointmentsCreateWithoutQms_operatorInput[] | appointmentsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutQms_operatorInput | appointmentsCreateOrConnectWithoutQms_operatorInput[]
    createMany?: appointmentsCreateManyQms_operatorInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type qms_branch_operatorCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_branch_operatorCreateWithoutQms_operatorInput, qms_branch_operatorUncheckedCreateWithoutQms_operatorInput> | qms_branch_operatorCreateWithoutQms_operatorInput[] | qms_branch_operatorUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutQms_operatorInput | qms_branch_operatorCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_branch_operatorCreateManyQms_operatorInputEnvelope
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
  }

  export type institutionCreateNestedOneWithoutQms_operatorInput = {
    create?: XOR<institutionCreateWithoutQms_operatorInput, institutionUncheckedCreateWithoutQms_operatorInput>
    connectOrCreate?: institutionCreateOrConnectWithoutQms_operatorInput
    connect?: institutionWhereUniqueInput
  }

  export type qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_operatorInput, qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput> | qms_operator_transactionsCreateWithoutQms_operatorInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput | qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_operator_transactionsCreateManyQms_operatorInputEnvelope
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
  }

  export type qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput> | qms_queue_operator_lnkCreateWithoutQms_operatorInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_operatorInputEnvelope
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
  }

  export type qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput> | qms_ticket_assignmentCreateWithoutQms_operatorInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput | qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_operatorInputEnvelope
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<appointmentsCreateWithoutQms_operatorInput, appointmentsUncheckedCreateWithoutQms_operatorInput> | appointmentsCreateWithoutQms_operatorInput[] | appointmentsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutQms_operatorInput | appointmentsCreateOrConnectWithoutQms_operatorInput[]
    createMany?: appointmentsCreateManyQms_operatorInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_branch_operatorCreateWithoutQms_operatorInput, qms_branch_operatorUncheckedCreateWithoutQms_operatorInput> | qms_branch_operatorCreateWithoutQms_operatorInput[] | qms_branch_operatorUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutQms_operatorInput | qms_branch_operatorCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_branch_operatorCreateManyQms_operatorInputEnvelope
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
  }

  export type qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_operatorInput, qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput> | qms_operator_transactionsCreateWithoutQms_operatorInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput | qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_operator_transactionsCreateManyQms_operatorInputEnvelope
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
  }

  export type qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput> | qms_queue_operator_lnkCreateWithoutQms_operatorInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_operatorInputEnvelope
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
  }

  export type qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput> | qms_ticket_assignmentCreateWithoutQms_operatorInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput | qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_operatorInputEnvelope
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<appointmentsCreateWithoutQms_operatorInput, appointmentsUncheckedCreateWithoutQms_operatorInput> | appointmentsCreateWithoutQms_operatorInput[] | appointmentsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutQms_operatorInput | appointmentsCreateOrConnectWithoutQms_operatorInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutQms_operatorInput | appointmentsUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: appointmentsCreateManyQms_operatorInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutQms_operatorInput | appointmentsUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutQms_operatorInput | appointmentsUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_branch_operatorCreateWithoutQms_operatorInput, qms_branch_operatorUncheckedCreateWithoutQms_operatorInput> | qms_branch_operatorCreateWithoutQms_operatorInput[] | qms_branch_operatorUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutQms_operatorInput | qms_branch_operatorCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_branch_operatorUpsertWithWhereUniqueWithoutQms_operatorInput | qms_branch_operatorUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_branch_operatorCreateManyQms_operatorInputEnvelope
    set?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    disconnect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    delete?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    update?: qms_branch_operatorUpdateWithWhereUniqueWithoutQms_operatorInput | qms_branch_operatorUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_branch_operatorUpdateManyWithWhereWithoutQms_operatorInput | qms_branch_operatorUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_branch_operatorScalarWhereInput | qms_branch_operatorScalarWhereInput[]
  }

  export type institutionUpdateOneWithoutQms_operatorNestedInput = {
    create?: XOR<institutionCreateWithoutQms_operatorInput, institutionUncheckedCreateWithoutQms_operatorInput>
    connectOrCreate?: institutionCreateOrConnectWithoutQms_operatorInput
    upsert?: institutionUpsertWithoutQms_operatorInput
    disconnect?: institutionWhereInput | boolean
    delete?: institutionWhereInput | boolean
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutQms_operatorInput, institutionUpdateWithoutQms_operatorInput>, institutionUncheckedUpdateWithoutQms_operatorInput>
  }

  export type qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_operatorInput, qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput> | qms_operator_transactionsCreateWithoutQms_operatorInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput | qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_operatorInput | qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_operator_transactionsCreateManyQms_operatorInputEnvelope
    set?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    disconnect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    delete?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    update?: qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_operatorInput | qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_operator_transactionsUpdateManyWithWhereWithoutQms_operatorInput | qms_operator_transactionsUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_operator_transactionsScalarWhereInput | qms_operator_transactionsScalarWhereInput[]
  }

  export type qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput> | qms_queue_operator_lnkCreateWithoutQms_operatorInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_operatorInput | qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_operatorInputEnvelope
    set?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    disconnect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    delete?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    update?: qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_operatorInput | qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_operatorInput | qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_queue_operator_lnkScalarWhereInput | qms_queue_operator_lnkScalarWhereInput[]
  }

  export type qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput> | qms_ticket_assignmentCreateWithoutQms_operatorInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput | qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_operatorInput | qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_operatorInputEnvelope
    set?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    disconnect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    delete?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    update?: qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_operatorInput | qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_ticket_assignmentUpdateManyWithWhereWithoutQms_operatorInput | qms_ticket_assignmentUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_ticket_assignmentScalarWhereInput | qms_ticket_assignmentScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<appointmentsCreateWithoutQms_operatorInput, appointmentsUncheckedCreateWithoutQms_operatorInput> | appointmentsCreateWithoutQms_operatorInput[] | appointmentsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutQms_operatorInput | appointmentsCreateOrConnectWithoutQms_operatorInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutQms_operatorInput | appointmentsUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: appointmentsCreateManyQms_operatorInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutQms_operatorInput | appointmentsUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutQms_operatorInput | appointmentsUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_branch_operatorCreateWithoutQms_operatorInput, qms_branch_operatorUncheckedCreateWithoutQms_operatorInput> | qms_branch_operatorCreateWithoutQms_operatorInput[] | qms_branch_operatorUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_branch_operatorCreateOrConnectWithoutQms_operatorInput | qms_branch_operatorCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_branch_operatorUpsertWithWhereUniqueWithoutQms_operatorInput | qms_branch_operatorUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_branch_operatorCreateManyQms_operatorInputEnvelope
    set?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    disconnect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    delete?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    connect?: qms_branch_operatorWhereUniqueInput | qms_branch_operatorWhereUniqueInput[]
    update?: qms_branch_operatorUpdateWithWhereUniqueWithoutQms_operatorInput | qms_branch_operatorUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_branch_operatorUpdateManyWithWhereWithoutQms_operatorInput | qms_branch_operatorUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_branch_operatorScalarWhereInput | qms_branch_operatorScalarWhereInput[]
  }

  export type qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_operator_transactionsCreateWithoutQms_operatorInput, qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput> | qms_operator_transactionsCreateWithoutQms_operatorInput[] | qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput | qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_operatorInput | qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_operator_transactionsCreateManyQms_operatorInputEnvelope
    set?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    disconnect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    delete?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    connect?: qms_operator_transactionsWhereUniqueInput | qms_operator_transactionsWhereUniqueInput[]
    update?: qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_operatorInput | qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_operator_transactionsUpdateManyWithWhereWithoutQms_operatorInput | qms_operator_transactionsUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_operator_transactionsScalarWhereInput | qms_operator_transactionsScalarWhereInput[]
  }

  export type qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput> | qms_queue_operator_lnkCreateWithoutQms_operatorInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_operatorInput | qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_operatorInputEnvelope
    set?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    disconnect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    delete?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    update?: qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_operatorInput | qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_operatorInput | qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_queue_operator_lnkScalarWhereInput | qms_queue_operator_lnkScalarWhereInput[]
  }

  export type qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput> | qms_ticket_assignmentCreateWithoutQms_operatorInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput | qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput[]
    upsert?: qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_operatorInput | qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_operatorInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_operatorInputEnvelope
    set?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    disconnect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    delete?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    update?: qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_operatorInput | qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_operatorInput[]
    updateMany?: qms_ticket_assignmentUpdateManyWithWhereWithoutQms_operatorInput | qms_ticket_assignmentUpdateManyWithWhereWithoutQms_operatorInput[]
    deleteMany?: qms_ticket_assignmentScalarWhereInput | qms_ticket_assignmentScalarWhereInput[]
  }

  export type qms_branch_transactionsCreateNestedOneWithoutQms_operator_transactionsInput = {
    create?: XOR<qms_branch_transactionsCreateWithoutQms_operator_transactionsInput, qms_branch_transactionsUncheckedCreateWithoutQms_operator_transactionsInput>
    connectOrCreate?: qms_branch_transactionsCreateOrConnectWithoutQms_operator_transactionsInput
    connect?: qms_branch_transactionsWhereUniqueInput
  }

  export type qms_operatorCreateNestedOneWithoutQms_operator_transactionsInput = {
    create?: XOR<qms_operatorCreateWithoutQms_operator_transactionsInput, qms_operatorUncheckedCreateWithoutQms_operator_transactionsInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_operator_transactionsInput
    connect?: qms_operatorWhereUniqueInput
  }

  export type qms_branch_transactionsUpdateOneRequiredWithoutQms_operator_transactionsNestedInput = {
    create?: XOR<qms_branch_transactionsCreateWithoutQms_operator_transactionsInput, qms_branch_transactionsUncheckedCreateWithoutQms_operator_transactionsInput>
    connectOrCreate?: qms_branch_transactionsCreateOrConnectWithoutQms_operator_transactionsInput
    upsert?: qms_branch_transactionsUpsertWithoutQms_operator_transactionsInput
    connect?: qms_branch_transactionsWhereUniqueInput
    update?: XOR<XOR<qms_branch_transactionsUpdateToOneWithWhereWithoutQms_operator_transactionsInput, qms_branch_transactionsUpdateWithoutQms_operator_transactionsInput>, qms_branch_transactionsUncheckedUpdateWithoutQms_operator_transactionsInput>
  }

  export type qms_operatorUpdateOneRequiredWithoutQms_operator_transactionsNestedInput = {
    create?: XOR<qms_operatorCreateWithoutQms_operator_transactionsInput, qms_operatorUncheckedCreateWithoutQms_operator_transactionsInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_operator_transactionsInput
    upsert?: qms_operatorUpsertWithoutQms_operator_transactionsInput
    connect?: qms_operatorWhereUniqueInput
    update?: XOR<XOR<qms_operatorUpdateToOneWithWhereWithoutQms_operator_transactionsInput, qms_operatorUpdateWithoutQms_operator_transactionsInput>, qms_operatorUncheckedUpdateWithoutQms_operator_transactionsInput>
  }

  export type serviceCreateNestedOneWithoutQms_queueInput = {
    create?: XOR<serviceCreateWithoutQms_queueInput, serviceUncheckedCreateWithoutQms_queueInput>
    connectOrCreate?: serviceCreateOrConnectWithoutQms_queueInput
    connect?: serviceWhereUniqueInput
  }

  export type qms_queue_operator_lnkCreateNestedManyWithoutQms_queueInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput> | qms_queue_operator_lnkCreateWithoutQms_queueInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_queueInputEnvelope
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
  }

  export type qms_ticketCreateNestedManyWithoutQms_queueInput = {
    create?: XOR<qms_ticketCreateWithoutQms_queueInput, qms_ticketUncheckedCreateWithoutQms_queueInput> | qms_ticketCreateWithoutQms_queueInput[] | qms_ticketUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_queueInput | qms_ticketCreateOrConnectWithoutQms_queueInput[]
    createMany?: qms_ticketCreateManyQms_queueInputEnvelope
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
  }

  export type qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_queueInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput> | qms_queue_operator_lnkCreateWithoutQms_queueInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_queueInputEnvelope
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
  }

  export type qms_ticketUncheckedCreateNestedManyWithoutQms_queueInput = {
    create?: XOR<qms_ticketCreateWithoutQms_queueInput, qms_ticketUncheckedCreateWithoutQms_queueInput> | qms_ticketCreateWithoutQms_queueInput[] | qms_ticketUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_queueInput | qms_ticketCreateOrConnectWithoutQms_queueInput[]
    createMany?: qms_ticketCreateManyQms_queueInputEnvelope
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
  }

  export type Enumqms_queue_statusFieldUpdateOperationsInput = {
    set?: $Enums.qms_queue_status
  }

  export type serviceUpdateOneRequiredWithoutQms_queueNestedInput = {
    create?: XOR<serviceCreateWithoutQms_queueInput, serviceUncheckedCreateWithoutQms_queueInput>
    connectOrCreate?: serviceCreateOrConnectWithoutQms_queueInput
    upsert?: serviceUpsertWithoutQms_queueInput
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutQms_queueInput, serviceUpdateWithoutQms_queueInput>, serviceUncheckedUpdateWithoutQms_queueInput>
  }

  export type qms_queue_operator_lnkUpdateManyWithoutQms_queueNestedInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput> | qms_queue_operator_lnkCreateWithoutQms_queueInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput[]
    upsert?: qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_queueInput | qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_queueInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_queueInputEnvelope
    set?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    disconnect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    delete?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    update?: qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_queueInput | qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_queueInput[]
    updateMany?: qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_queueInput | qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_queueInput[]
    deleteMany?: qms_queue_operator_lnkScalarWhereInput | qms_queue_operator_lnkScalarWhereInput[]
  }

  export type qms_ticketUpdateManyWithoutQms_queueNestedInput = {
    create?: XOR<qms_ticketCreateWithoutQms_queueInput, qms_ticketUncheckedCreateWithoutQms_queueInput> | qms_ticketCreateWithoutQms_queueInput[] | qms_ticketUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_queueInput | qms_ticketCreateOrConnectWithoutQms_queueInput[]
    upsert?: qms_ticketUpsertWithWhereUniqueWithoutQms_queueInput | qms_ticketUpsertWithWhereUniqueWithoutQms_queueInput[]
    createMany?: qms_ticketCreateManyQms_queueInputEnvelope
    set?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    disconnect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    delete?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    update?: qms_ticketUpdateWithWhereUniqueWithoutQms_queueInput | qms_ticketUpdateWithWhereUniqueWithoutQms_queueInput[]
    updateMany?: qms_ticketUpdateManyWithWhereWithoutQms_queueInput | qms_ticketUpdateManyWithWhereWithoutQms_queueInput[]
    deleteMany?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
  }

  export type qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_queueNestedInput = {
    create?: XOR<qms_queue_operator_lnkCreateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput> | qms_queue_operator_lnkCreateWithoutQms_queueInput[] | qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput | qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput[]
    upsert?: qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_queueInput | qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_queueInput[]
    createMany?: qms_queue_operator_lnkCreateManyQms_queueInputEnvelope
    set?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    disconnect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    delete?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    connect?: qms_queue_operator_lnkWhereUniqueInput | qms_queue_operator_lnkWhereUniqueInput[]
    update?: qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_queueInput | qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_queueInput[]
    updateMany?: qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_queueInput | qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_queueInput[]
    deleteMany?: qms_queue_operator_lnkScalarWhereInput | qms_queue_operator_lnkScalarWhereInput[]
  }

  export type qms_ticketUncheckedUpdateManyWithoutQms_queueNestedInput = {
    create?: XOR<qms_ticketCreateWithoutQms_queueInput, qms_ticketUncheckedCreateWithoutQms_queueInput> | qms_ticketCreateWithoutQms_queueInput[] | qms_ticketUncheckedCreateWithoutQms_queueInput[]
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_queueInput | qms_ticketCreateOrConnectWithoutQms_queueInput[]
    upsert?: qms_ticketUpsertWithWhereUniqueWithoutQms_queueInput | qms_ticketUpsertWithWhereUniqueWithoutQms_queueInput[]
    createMany?: qms_ticketCreateManyQms_queueInputEnvelope
    set?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    disconnect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    delete?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    connect?: qms_ticketWhereUniqueInput | qms_ticketWhereUniqueInput[]
    update?: qms_ticketUpdateWithWhereUniqueWithoutQms_queueInput | qms_ticketUpdateWithWhereUniqueWithoutQms_queueInput[]
    updateMany?: qms_ticketUpdateManyWithWhereWithoutQms_queueInput | qms_ticketUpdateManyWithWhereWithoutQms_queueInput[]
    deleteMany?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
  }

  export type qms_queueCreateNestedOneWithoutQms_queue_operator_lnkInput = {
    create?: XOR<qms_queueCreateWithoutQms_queue_operator_lnkInput, qms_queueUncheckedCreateWithoutQms_queue_operator_lnkInput>
    connectOrCreate?: qms_queueCreateOrConnectWithoutQms_queue_operator_lnkInput
    connect?: qms_queueWhereUniqueInput
  }

  export type qms_operatorCreateNestedOneWithoutQms_queue_operator_lnkInput = {
    create?: XOR<qms_operatorCreateWithoutQms_queue_operator_lnkInput, qms_operatorUncheckedCreateWithoutQms_queue_operator_lnkInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_queue_operator_lnkInput
    connect?: qms_operatorWhereUniqueInput
  }

  export type qms_queueUpdateOneRequiredWithoutQms_queue_operator_lnkNestedInput = {
    create?: XOR<qms_queueCreateWithoutQms_queue_operator_lnkInput, qms_queueUncheckedCreateWithoutQms_queue_operator_lnkInput>
    connectOrCreate?: qms_queueCreateOrConnectWithoutQms_queue_operator_lnkInput
    upsert?: qms_queueUpsertWithoutQms_queue_operator_lnkInput
    connect?: qms_queueWhereUniqueInput
    update?: XOR<XOR<qms_queueUpdateToOneWithWhereWithoutQms_queue_operator_lnkInput, qms_queueUpdateWithoutQms_queue_operator_lnkInput>, qms_queueUncheckedUpdateWithoutQms_queue_operator_lnkInput>
  }

  export type qms_operatorUpdateOneRequiredWithoutQms_queue_operator_lnkNestedInput = {
    create?: XOR<qms_operatorCreateWithoutQms_queue_operator_lnkInput, qms_operatorUncheckedCreateWithoutQms_queue_operator_lnkInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_queue_operator_lnkInput
    upsert?: qms_operatorUpsertWithoutQms_queue_operator_lnkInput
    connect?: qms_operatorWhereUniqueInput
    update?: XOR<XOR<qms_operatorUpdateToOneWithWhereWithoutQms_queue_operator_lnkInput, qms_operatorUpdateWithoutQms_queue_operator_lnkInput>, qms_operatorUncheckedUpdateWithoutQms_queue_operator_lnkInput>
  }

  export type optionCreateNestedOneWithoutQms_ticketInput = {
    create?: XOR<optionCreateWithoutQms_ticketInput, optionUncheckedCreateWithoutQms_ticketInput>
    connectOrCreate?: optionCreateOrConnectWithoutQms_ticketInput
    connect?: optionWhereUniqueInput
  }

  export type qms_customerCreateNestedOneWithoutQms_ticketInput = {
    create?: XOR<qms_customerCreateWithoutQms_ticketInput, qms_customerUncheckedCreateWithoutQms_ticketInput>
    connectOrCreate?: qms_customerCreateOrConnectWithoutQms_ticketInput
    connect?: qms_customerWhereUniqueInput
  }

  export type qms_queueCreateNestedOneWithoutQms_ticketInput = {
    create?: XOR<qms_queueCreateWithoutQms_ticketInput, qms_queueUncheckedCreateWithoutQms_ticketInput>
    connectOrCreate?: qms_queueCreateOrConnectWithoutQms_ticketInput
    connect?: qms_queueWhereUniqueInput
  }

  export type qms_ticket_assignmentCreateNestedManyWithoutQms_ticketInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput> | qms_ticket_assignmentCreateWithoutQms_ticketInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput | qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_ticketInputEnvelope
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
  }

  export type qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_ticketInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput> | qms_ticket_assignmentCreateWithoutQms_ticketInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput | qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_ticketInputEnvelope
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
  }

  export type optionUpdateOneWithoutQms_ticketNestedInput = {
    create?: XOR<optionCreateWithoutQms_ticketInput, optionUncheckedCreateWithoutQms_ticketInput>
    connectOrCreate?: optionCreateOrConnectWithoutQms_ticketInput
    upsert?: optionUpsertWithoutQms_ticketInput
    disconnect?: optionWhereInput | boolean
    delete?: optionWhereInput | boolean
    connect?: optionWhereUniqueInput
    update?: XOR<XOR<optionUpdateToOneWithWhereWithoutQms_ticketInput, optionUpdateWithoutQms_ticketInput>, optionUncheckedUpdateWithoutQms_ticketInput>
  }

  export type qms_customerUpdateOneRequiredWithoutQms_ticketNestedInput = {
    create?: XOR<qms_customerCreateWithoutQms_ticketInput, qms_customerUncheckedCreateWithoutQms_ticketInput>
    connectOrCreate?: qms_customerCreateOrConnectWithoutQms_ticketInput
    upsert?: qms_customerUpsertWithoutQms_ticketInput
    connect?: qms_customerWhereUniqueInput
    update?: XOR<XOR<qms_customerUpdateToOneWithWhereWithoutQms_ticketInput, qms_customerUpdateWithoutQms_ticketInput>, qms_customerUncheckedUpdateWithoutQms_ticketInput>
  }

  export type qms_queueUpdateOneRequiredWithoutQms_ticketNestedInput = {
    create?: XOR<qms_queueCreateWithoutQms_ticketInput, qms_queueUncheckedCreateWithoutQms_ticketInput>
    connectOrCreate?: qms_queueCreateOrConnectWithoutQms_ticketInput
    upsert?: qms_queueUpsertWithoutQms_ticketInput
    connect?: qms_queueWhereUniqueInput
    update?: XOR<XOR<qms_queueUpdateToOneWithWhereWithoutQms_ticketInput, qms_queueUpdateWithoutQms_ticketInput>, qms_queueUncheckedUpdateWithoutQms_ticketInput>
  }

  export type qms_ticket_assignmentUpdateManyWithoutQms_ticketNestedInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput> | qms_ticket_assignmentCreateWithoutQms_ticketInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput | qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput[]
    upsert?: qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_ticketInput | qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_ticketInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_ticketInputEnvelope
    set?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    disconnect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    delete?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    update?: qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_ticketInput | qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_ticketInput[]
    updateMany?: qms_ticket_assignmentUpdateManyWithWhereWithoutQms_ticketInput | qms_ticket_assignmentUpdateManyWithWhereWithoutQms_ticketInput[]
    deleteMany?: qms_ticket_assignmentScalarWhereInput | qms_ticket_assignmentScalarWhereInput[]
  }

  export type qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketNestedInput = {
    create?: XOR<qms_ticket_assignmentCreateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput> | qms_ticket_assignmentCreateWithoutQms_ticketInput[] | qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput[]
    connectOrCreate?: qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput | qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput[]
    upsert?: qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_ticketInput | qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_ticketInput[]
    createMany?: qms_ticket_assignmentCreateManyQms_ticketInputEnvelope
    set?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    disconnect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    delete?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    connect?: qms_ticket_assignmentWhereUniqueInput | qms_ticket_assignmentWhereUniqueInput[]
    update?: qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_ticketInput | qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_ticketInput[]
    updateMany?: qms_ticket_assignmentUpdateManyWithWhereWithoutQms_ticketInput | qms_ticket_assignmentUpdateManyWithWhereWithoutQms_ticketInput[]
    deleteMany?: qms_ticket_assignmentScalarWhereInput | qms_ticket_assignmentScalarWhereInput[]
  }

  export type qms_ticketCreateNestedOneWithoutQms_ticket_assignmentInput = {
    create?: XOR<qms_ticketCreateWithoutQms_ticket_assignmentInput, qms_ticketUncheckedCreateWithoutQms_ticket_assignmentInput>
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_ticket_assignmentInput
    connect?: qms_ticketWhereUniqueInput
  }

  export type qms_operatorCreateNestedOneWithoutQms_ticket_assignmentInput = {
    create?: XOR<qms_operatorCreateWithoutQms_ticket_assignmentInput, qms_operatorUncheckedCreateWithoutQms_ticket_assignmentInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_ticket_assignmentInput
    connect?: qms_operatorWhereUniqueInput
  }

  export type qms_ticketUpdateOneRequiredWithoutQms_ticket_assignmentNestedInput = {
    create?: XOR<qms_ticketCreateWithoutQms_ticket_assignmentInput, qms_ticketUncheckedCreateWithoutQms_ticket_assignmentInput>
    connectOrCreate?: qms_ticketCreateOrConnectWithoutQms_ticket_assignmentInput
    upsert?: qms_ticketUpsertWithoutQms_ticket_assignmentInput
    connect?: qms_ticketWhereUniqueInput
    update?: XOR<XOR<qms_ticketUpdateToOneWithWhereWithoutQms_ticket_assignmentInput, qms_ticketUpdateWithoutQms_ticket_assignmentInput>, qms_ticketUncheckedUpdateWithoutQms_ticket_assignmentInput>
  }

  export type qms_operatorUpdateOneWithoutQms_ticket_assignmentNestedInput = {
    create?: XOR<qms_operatorCreateWithoutQms_ticket_assignmentInput, qms_operatorUncheckedCreateWithoutQms_ticket_assignmentInput>
    connectOrCreate?: qms_operatorCreateOrConnectWithoutQms_ticket_assignmentInput
    upsert?: qms_operatorUpsertWithoutQms_ticket_assignmentInput
    disconnect?: qms_operatorWhereInput | boolean
    delete?: qms_operatorWhereInput | boolean
    connect?: qms_operatorWhereUniqueInput
    update?: XOR<XOR<qms_operatorUpdateToOneWithWhereWithoutQms_ticket_assignmentInput, qms_operatorUpdateWithoutQms_ticket_assignmentInput>, qms_operatorUncheckedUpdateWithoutQms_ticket_assignmentInput>
  }

  export type serviceCreateNestedOneWithoutRatingInput = {
    create?: XOR<serviceCreateWithoutRatingInput, serviceUncheckedCreateWithoutRatingInput>
    connectOrCreate?: serviceCreateOrConnectWithoutRatingInput
    connect?: serviceWhereUniqueInput
  }

  export type deviceCreateNestedOneWithoutRatingInput = {
    create?: XOR<deviceCreateWithoutRatingInput, deviceUncheckedCreateWithoutRatingInput>
    connectOrCreate?: deviceCreateOrConnectWithoutRatingInput
    connect?: deviceWhereUniqueInput
  }

  export type rating_assetsCreateNestedManyWithoutRatingInput = {
    create?: XOR<rating_assetsCreateWithoutRatingInput, rating_assetsUncheckedCreateWithoutRatingInput> | rating_assetsCreateWithoutRatingInput[] | rating_assetsUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: rating_assetsCreateOrConnectWithoutRatingInput | rating_assetsCreateOrConnectWithoutRatingInput[]
    createMany?: rating_assetsCreateManyRatingInputEnvelope
    connect?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
  }

  export type tipCreateNestedManyWithoutRatingInput = {
    create?: XOR<tipCreateWithoutRatingInput, tipUncheckedCreateWithoutRatingInput> | tipCreateWithoutRatingInput[] | tipUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: tipCreateOrConnectWithoutRatingInput | tipCreateOrConnectWithoutRatingInput[]
    createMany?: tipCreateManyRatingInputEnvelope
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
  }

  export type rating_assetsUncheckedCreateNestedManyWithoutRatingInput = {
    create?: XOR<rating_assetsCreateWithoutRatingInput, rating_assetsUncheckedCreateWithoutRatingInput> | rating_assetsCreateWithoutRatingInput[] | rating_assetsUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: rating_assetsCreateOrConnectWithoutRatingInput | rating_assetsCreateOrConnectWithoutRatingInput[]
    createMany?: rating_assetsCreateManyRatingInputEnvelope
    connect?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
  }

  export type tipUncheckedCreateNestedManyWithoutRatingInput = {
    create?: XOR<tipCreateWithoutRatingInput, tipUncheckedCreateWithoutRatingInput> | tipCreateWithoutRatingInput[] | tipUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: tipCreateOrConnectWithoutRatingInput | tipCreateOrConnectWithoutRatingInput[]
    createMany?: tipCreateManyRatingInputEnvelope
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type serviceUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<serviceCreateWithoutRatingInput, serviceUncheckedCreateWithoutRatingInput>
    connectOrCreate?: serviceCreateOrConnectWithoutRatingInput
    upsert?: serviceUpsertWithoutRatingInput
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutRatingInput, serviceUpdateWithoutRatingInput>, serviceUncheckedUpdateWithoutRatingInput>
  }

  export type deviceUpdateOneWithoutRatingNestedInput = {
    create?: XOR<deviceCreateWithoutRatingInput, deviceUncheckedCreateWithoutRatingInput>
    connectOrCreate?: deviceCreateOrConnectWithoutRatingInput
    upsert?: deviceUpsertWithoutRatingInput
    disconnect?: deviceWhereInput | boolean
    delete?: deviceWhereInput | boolean
    connect?: deviceWhereUniqueInput
    update?: XOR<XOR<deviceUpdateToOneWithWhereWithoutRatingInput, deviceUpdateWithoutRatingInput>, deviceUncheckedUpdateWithoutRatingInput>
  }

  export type rating_assetsUpdateManyWithoutRatingNestedInput = {
    create?: XOR<rating_assetsCreateWithoutRatingInput, rating_assetsUncheckedCreateWithoutRatingInput> | rating_assetsCreateWithoutRatingInput[] | rating_assetsUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: rating_assetsCreateOrConnectWithoutRatingInput | rating_assetsCreateOrConnectWithoutRatingInput[]
    upsert?: rating_assetsUpsertWithWhereUniqueWithoutRatingInput | rating_assetsUpsertWithWhereUniqueWithoutRatingInput[]
    createMany?: rating_assetsCreateManyRatingInputEnvelope
    set?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    disconnect?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    delete?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    connect?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    update?: rating_assetsUpdateWithWhereUniqueWithoutRatingInput | rating_assetsUpdateWithWhereUniqueWithoutRatingInput[]
    updateMany?: rating_assetsUpdateManyWithWhereWithoutRatingInput | rating_assetsUpdateManyWithWhereWithoutRatingInput[]
    deleteMany?: rating_assetsScalarWhereInput | rating_assetsScalarWhereInput[]
  }

  export type tipUpdateManyWithoutRatingNestedInput = {
    create?: XOR<tipCreateWithoutRatingInput, tipUncheckedCreateWithoutRatingInput> | tipCreateWithoutRatingInput[] | tipUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: tipCreateOrConnectWithoutRatingInput | tipCreateOrConnectWithoutRatingInput[]
    upsert?: tipUpsertWithWhereUniqueWithoutRatingInput | tipUpsertWithWhereUniqueWithoutRatingInput[]
    createMany?: tipCreateManyRatingInputEnvelope
    set?: tipWhereUniqueInput | tipWhereUniqueInput[]
    disconnect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    delete?: tipWhereUniqueInput | tipWhereUniqueInput[]
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    update?: tipUpdateWithWhereUniqueWithoutRatingInput | tipUpdateWithWhereUniqueWithoutRatingInput[]
    updateMany?: tipUpdateManyWithWhereWithoutRatingInput | tipUpdateManyWithWhereWithoutRatingInput[]
    deleteMany?: tipScalarWhereInput | tipScalarWhereInput[]
  }

  export type rating_assetsUncheckedUpdateManyWithoutRatingNestedInput = {
    create?: XOR<rating_assetsCreateWithoutRatingInput, rating_assetsUncheckedCreateWithoutRatingInput> | rating_assetsCreateWithoutRatingInput[] | rating_assetsUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: rating_assetsCreateOrConnectWithoutRatingInput | rating_assetsCreateOrConnectWithoutRatingInput[]
    upsert?: rating_assetsUpsertWithWhereUniqueWithoutRatingInput | rating_assetsUpsertWithWhereUniqueWithoutRatingInput[]
    createMany?: rating_assetsCreateManyRatingInputEnvelope
    set?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    disconnect?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    delete?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    connect?: rating_assetsWhereUniqueInput | rating_assetsWhereUniqueInput[]
    update?: rating_assetsUpdateWithWhereUniqueWithoutRatingInput | rating_assetsUpdateWithWhereUniqueWithoutRatingInput[]
    updateMany?: rating_assetsUpdateManyWithWhereWithoutRatingInput | rating_assetsUpdateManyWithWhereWithoutRatingInput[]
    deleteMany?: rating_assetsScalarWhereInput | rating_assetsScalarWhereInput[]
  }

  export type tipUncheckedUpdateManyWithoutRatingNestedInput = {
    create?: XOR<tipCreateWithoutRatingInput, tipUncheckedCreateWithoutRatingInput> | tipCreateWithoutRatingInput[] | tipUncheckedCreateWithoutRatingInput[]
    connectOrCreate?: tipCreateOrConnectWithoutRatingInput | tipCreateOrConnectWithoutRatingInput[]
    upsert?: tipUpsertWithWhereUniqueWithoutRatingInput | tipUpsertWithWhereUniqueWithoutRatingInput[]
    createMany?: tipCreateManyRatingInputEnvelope
    set?: tipWhereUniqueInput | tipWhereUniqueInput[]
    disconnect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    delete?: tipWhereUniqueInput | tipWhereUniqueInput[]
    connect?: tipWhereUniqueInput | tipWhereUniqueInput[]
    update?: tipUpdateWithWhereUniqueWithoutRatingInput | tipUpdateWithWhereUniqueWithoutRatingInput[]
    updateMany?: tipUpdateManyWithWhereWithoutRatingInput | tipUpdateManyWithWhereWithoutRatingInput[]
    deleteMany?: tipScalarWhereInput | tipScalarWhereInput[]
  }

  export type ratingCreateNestedOneWithoutRating_assetsInput = {
    create?: XOR<ratingCreateWithoutRating_assetsInput, ratingUncheckedCreateWithoutRating_assetsInput>
    connectOrCreate?: ratingCreateOrConnectWithoutRating_assetsInput
    connect?: ratingWhereUniqueInput
  }

  export type ratingUpdateOneWithoutRating_assetsNestedInput = {
    create?: XOR<ratingCreateWithoutRating_assetsInput, ratingUncheckedCreateWithoutRating_assetsInput>
    connectOrCreate?: ratingCreateOrConnectWithoutRating_assetsInput
    upsert?: ratingUpsertWithoutRating_assetsInput
    disconnect?: ratingWhereInput | boolean
    delete?: ratingWhereInput | boolean
    connect?: ratingWhereUniqueInput
    update?: XOR<XOR<ratingUpdateToOneWithWhereWithoutRating_assetsInput, ratingUpdateWithoutRating_assetsInput>, ratingUncheckedUpdateWithoutRating_assetsInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type Enumrating_qr_code_sessions_statusFieldUpdateOperationsInput = {
    set?: $Enums.rating_qr_code_sessions_status
  }

  export type appointmentsCreateNestedManyWithoutServiceInput = {
    create?: XOR<appointmentsCreateWithoutServiceInput, appointmentsUncheckedCreateWithoutServiceInput> | appointmentsCreateWithoutServiceInput[] | appointmentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutServiceInput | appointmentsCreateOrConnectWithoutServiceInput[]
    createMany?: appointmentsCreateManyServiceInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type qms_counterCreateNestedManyWithoutServiceInput = {
    create?: XOR<qms_counterCreateWithoutServiceInput, qms_counterUncheckedCreateWithoutServiceInput> | qms_counterCreateWithoutServiceInput[] | qms_counterUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_counterCreateOrConnectWithoutServiceInput | qms_counterCreateOrConnectWithoutServiceInput[]
    createMany?: qms_counterCreateManyServiceInputEnvelope
    connect?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
  }

  export type qms_queueCreateNestedManyWithoutServiceInput = {
    create?: XOR<qms_queueCreateWithoutServiceInput, qms_queueUncheckedCreateWithoutServiceInput> | qms_queueCreateWithoutServiceInput[] | qms_queueUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_queueCreateOrConnectWithoutServiceInput | qms_queueCreateOrConnectWithoutServiceInput[]
    createMany?: qms_queueCreateManyServiceInputEnvelope
    connect?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
  }

  export type ratingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ratingCreateWithoutServiceInput, ratingUncheckedCreateWithoutServiceInput> | ratingCreateWithoutServiceInput[] | ratingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutServiceInput | ratingCreateOrConnectWithoutServiceInput[]
    createMany?: ratingCreateManyServiceInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type service_groupCreateNestedOneWithoutServiceInput = {
    create?: XOR<service_groupCreateWithoutServiceInput, service_groupUncheckedCreateWithoutServiceInput>
    connectOrCreate?: service_groupCreateOrConnectWithoutServiceInput
    connect?: service_groupWhereUniqueInput
  }

  export type institutionCreateNestedOneWithoutServiceInput = {
    create?: XOR<institutionCreateWithoutServiceInput, institutionUncheckedCreateWithoutServiceInput>
    connectOrCreate?: institutionCreateOrConnectWithoutServiceInput
    connect?: institutionWhereUniqueInput
  }

  export type appointmentsUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<appointmentsCreateWithoutServiceInput, appointmentsUncheckedCreateWithoutServiceInput> | appointmentsCreateWithoutServiceInput[] | appointmentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutServiceInput | appointmentsCreateOrConnectWithoutServiceInput[]
    createMany?: appointmentsCreateManyServiceInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type qms_counterUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<qms_counterCreateWithoutServiceInput, qms_counterUncheckedCreateWithoutServiceInput> | qms_counterCreateWithoutServiceInput[] | qms_counterUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_counterCreateOrConnectWithoutServiceInput | qms_counterCreateOrConnectWithoutServiceInput[]
    createMany?: qms_counterCreateManyServiceInputEnvelope
    connect?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
  }

  export type qms_queueUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<qms_queueCreateWithoutServiceInput, qms_queueUncheckedCreateWithoutServiceInput> | qms_queueCreateWithoutServiceInput[] | qms_queueUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_queueCreateOrConnectWithoutServiceInput | qms_queueCreateOrConnectWithoutServiceInput[]
    createMany?: qms_queueCreateManyServiceInputEnvelope
    connect?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
  }

  export type ratingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ratingCreateWithoutServiceInput, ratingUncheckedCreateWithoutServiceInput> | ratingCreateWithoutServiceInput[] | ratingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutServiceInput | ratingCreateOrConnectWithoutServiceInput[]
    createMany?: ratingCreateManyServiceInputEnvelope
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutServiceNestedInput = {
    create?: XOR<appointmentsCreateWithoutServiceInput, appointmentsUncheckedCreateWithoutServiceInput> | appointmentsCreateWithoutServiceInput[] | appointmentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutServiceInput | appointmentsCreateOrConnectWithoutServiceInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutServiceInput | appointmentsUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: appointmentsCreateManyServiceInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutServiceInput | appointmentsUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutServiceInput | appointmentsUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type qms_counterUpdateManyWithoutServiceNestedInput = {
    create?: XOR<qms_counterCreateWithoutServiceInput, qms_counterUncheckedCreateWithoutServiceInput> | qms_counterCreateWithoutServiceInput[] | qms_counterUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_counterCreateOrConnectWithoutServiceInput | qms_counterCreateOrConnectWithoutServiceInput[]
    upsert?: qms_counterUpsertWithWhereUniqueWithoutServiceInput | qms_counterUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: qms_counterCreateManyServiceInputEnvelope
    set?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    disconnect?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    delete?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    connect?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    update?: qms_counterUpdateWithWhereUniqueWithoutServiceInput | qms_counterUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: qms_counterUpdateManyWithWhereWithoutServiceInput | qms_counterUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: qms_counterScalarWhereInput | qms_counterScalarWhereInput[]
  }

  export type qms_queueUpdateManyWithoutServiceNestedInput = {
    create?: XOR<qms_queueCreateWithoutServiceInput, qms_queueUncheckedCreateWithoutServiceInput> | qms_queueCreateWithoutServiceInput[] | qms_queueUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_queueCreateOrConnectWithoutServiceInput | qms_queueCreateOrConnectWithoutServiceInput[]
    upsert?: qms_queueUpsertWithWhereUniqueWithoutServiceInput | qms_queueUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: qms_queueCreateManyServiceInputEnvelope
    set?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    disconnect?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    delete?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    connect?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    update?: qms_queueUpdateWithWhereUniqueWithoutServiceInput | qms_queueUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: qms_queueUpdateManyWithWhereWithoutServiceInput | qms_queueUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: qms_queueScalarWhereInput | qms_queueScalarWhereInput[]
  }

  export type ratingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ratingCreateWithoutServiceInput, ratingUncheckedCreateWithoutServiceInput> | ratingCreateWithoutServiceInput[] | ratingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutServiceInput | ratingCreateOrConnectWithoutServiceInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutServiceInput | ratingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ratingCreateManyServiceInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutServiceInput | ratingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutServiceInput | ratingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type service_groupUpdateOneWithoutServiceNestedInput = {
    create?: XOR<service_groupCreateWithoutServiceInput, service_groupUncheckedCreateWithoutServiceInput>
    connectOrCreate?: service_groupCreateOrConnectWithoutServiceInput
    upsert?: service_groupUpsertWithoutServiceInput
    disconnect?: service_groupWhereInput | boolean
    delete?: service_groupWhereInput | boolean
    connect?: service_groupWhereUniqueInput
    update?: XOR<XOR<service_groupUpdateToOneWithWhereWithoutServiceInput, service_groupUpdateWithoutServiceInput>, service_groupUncheckedUpdateWithoutServiceInput>
  }

  export type institutionUpdateOneWithoutServiceNestedInput = {
    create?: XOR<institutionCreateWithoutServiceInput, institutionUncheckedCreateWithoutServiceInput>
    connectOrCreate?: institutionCreateOrConnectWithoutServiceInput
    upsert?: institutionUpsertWithoutServiceInput
    disconnect?: institutionWhereInput | boolean
    delete?: institutionWhereInput | boolean
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutServiceInput, institutionUpdateWithoutServiceInput>, institutionUncheckedUpdateWithoutServiceInput>
  }

  export type appointmentsUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<appointmentsCreateWithoutServiceInput, appointmentsUncheckedCreateWithoutServiceInput> | appointmentsCreateWithoutServiceInput[] | appointmentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutServiceInput | appointmentsCreateOrConnectWithoutServiceInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutServiceInput | appointmentsUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: appointmentsCreateManyServiceInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutServiceInput | appointmentsUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutServiceInput | appointmentsUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type qms_counterUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<qms_counterCreateWithoutServiceInput, qms_counterUncheckedCreateWithoutServiceInput> | qms_counterCreateWithoutServiceInput[] | qms_counterUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_counterCreateOrConnectWithoutServiceInput | qms_counterCreateOrConnectWithoutServiceInput[]
    upsert?: qms_counterUpsertWithWhereUniqueWithoutServiceInput | qms_counterUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: qms_counterCreateManyServiceInputEnvelope
    set?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    disconnect?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    delete?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    connect?: qms_counterWhereUniqueInput | qms_counterWhereUniqueInput[]
    update?: qms_counterUpdateWithWhereUniqueWithoutServiceInput | qms_counterUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: qms_counterUpdateManyWithWhereWithoutServiceInput | qms_counterUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: qms_counterScalarWhereInput | qms_counterScalarWhereInput[]
  }

  export type qms_queueUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<qms_queueCreateWithoutServiceInput, qms_queueUncheckedCreateWithoutServiceInput> | qms_queueCreateWithoutServiceInput[] | qms_queueUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: qms_queueCreateOrConnectWithoutServiceInput | qms_queueCreateOrConnectWithoutServiceInput[]
    upsert?: qms_queueUpsertWithWhereUniqueWithoutServiceInput | qms_queueUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: qms_queueCreateManyServiceInputEnvelope
    set?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    disconnect?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    delete?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    connect?: qms_queueWhereUniqueInput | qms_queueWhereUniqueInput[]
    update?: qms_queueUpdateWithWhereUniqueWithoutServiceInput | qms_queueUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: qms_queueUpdateManyWithWhereWithoutServiceInput | qms_queueUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: qms_queueScalarWhereInput | qms_queueScalarWhereInput[]
  }

  export type ratingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ratingCreateWithoutServiceInput, ratingUncheckedCreateWithoutServiceInput> | ratingCreateWithoutServiceInput[] | ratingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ratingCreateOrConnectWithoutServiceInput | ratingCreateOrConnectWithoutServiceInput[]
    upsert?: ratingUpsertWithWhereUniqueWithoutServiceInput | ratingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ratingCreateManyServiceInputEnvelope
    set?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    disconnect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    delete?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    connect?: ratingWhereUniqueInput | ratingWhereUniqueInput[]
    update?: ratingUpdateWithWhereUniqueWithoutServiceInput | ratingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ratingUpdateManyWithWhereWithoutServiceInput | ratingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ratingScalarWhereInput | ratingScalarWhereInput[]
  }

  export type serviceCreateNestedManyWithoutService_groupInput = {
    create?: XOR<serviceCreateWithoutService_groupInput, serviceUncheckedCreateWithoutService_groupInput> | serviceCreateWithoutService_groupInput[] | serviceUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_groupInput | serviceCreateOrConnectWithoutService_groupInput[]
    createMany?: serviceCreateManyService_groupInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type serviceReviewCreateNestedManyWithoutService_groupInput = {
    create?: XOR<serviceReviewCreateWithoutService_groupInput, serviceReviewUncheckedCreateWithoutService_groupInput> | serviceReviewCreateWithoutService_groupInput[] | serviceReviewUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutService_groupInput | serviceReviewCreateOrConnectWithoutService_groupInput[]
    createMany?: serviceReviewCreateManyService_groupInputEnvelope
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
  }

  export type institutionCreateNestedOneWithoutService_groupInput = {
    create?: XOR<institutionCreateWithoutService_groupInput, institutionUncheckedCreateWithoutService_groupInput>
    connectOrCreate?: institutionCreateOrConnectWithoutService_groupInput
    connect?: institutionWhereUniqueInput
  }

  export type surveyQuestionsCreateNestedManyWithoutService_groupInput = {
    create?: XOR<surveyQuestionsCreateWithoutService_groupInput, surveyQuestionsUncheckedCreateWithoutService_groupInput> | surveyQuestionsCreateWithoutService_groupInput[] | surveyQuestionsUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: surveyQuestionsCreateOrConnectWithoutService_groupInput | surveyQuestionsCreateOrConnectWithoutService_groupInput[]
    createMany?: surveyQuestionsCreateManyService_groupInputEnvelope
    connect?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
  }

  export type serviceUncheckedCreateNestedManyWithoutService_groupInput = {
    create?: XOR<serviceCreateWithoutService_groupInput, serviceUncheckedCreateWithoutService_groupInput> | serviceCreateWithoutService_groupInput[] | serviceUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_groupInput | serviceCreateOrConnectWithoutService_groupInput[]
    createMany?: serviceCreateManyService_groupInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type serviceReviewUncheckedCreateNestedManyWithoutService_groupInput = {
    create?: XOR<serviceReviewCreateWithoutService_groupInput, serviceReviewUncheckedCreateWithoutService_groupInput> | serviceReviewCreateWithoutService_groupInput[] | serviceReviewUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutService_groupInput | serviceReviewCreateOrConnectWithoutService_groupInput[]
    createMany?: serviceReviewCreateManyService_groupInputEnvelope
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
  }

  export type surveyQuestionsUncheckedCreateNestedManyWithoutService_groupInput = {
    create?: XOR<surveyQuestionsCreateWithoutService_groupInput, surveyQuestionsUncheckedCreateWithoutService_groupInput> | surveyQuestionsCreateWithoutService_groupInput[] | surveyQuestionsUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: surveyQuestionsCreateOrConnectWithoutService_groupInput | surveyQuestionsCreateOrConnectWithoutService_groupInput[]
    createMany?: surveyQuestionsCreateManyService_groupInputEnvelope
    connect?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
  }

  export type serviceUpdateManyWithoutService_groupNestedInput = {
    create?: XOR<serviceCreateWithoutService_groupInput, serviceUncheckedCreateWithoutService_groupInput> | serviceCreateWithoutService_groupInput[] | serviceUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_groupInput | serviceCreateOrConnectWithoutService_groupInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutService_groupInput | serviceUpsertWithWhereUniqueWithoutService_groupInput[]
    createMany?: serviceCreateManyService_groupInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutService_groupInput | serviceUpdateWithWhereUniqueWithoutService_groupInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutService_groupInput | serviceUpdateManyWithWhereWithoutService_groupInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type serviceReviewUpdateManyWithoutService_groupNestedInput = {
    create?: XOR<serviceReviewCreateWithoutService_groupInput, serviceReviewUncheckedCreateWithoutService_groupInput> | serviceReviewCreateWithoutService_groupInput[] | serviceReviewUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutService_groupInput | serviceReviewCreateOrConnectWithoutService_groupInput[]
    upsert?: serviceReviewUpsertWithWhereUniqueWithoutService_groupInput | serviceReviewUpsertWithWhereUniqueWithoutService_groupInput[]
    createMany?: serviceReviewCreateManyService_groupInputEnvelope
    set?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    disconnect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    delete?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    update?: serviceReviewUpdateWithWhereUniqueWithoutService_groupInput | serviceReviewUpdateWithWhereUniqueWithoutService_groupInput[]
    updateMany?: serviceReviewUpdateManyWithWhereWithoutService_groupInput | serviceReviewUpdateManyWithWhereWithoutService_groupInput[]
    deleteMany?: serviceReviewScalarWhereInput | serviceReviewScalarWhereInput[]
  }

  export type institutionUpdateOneRequiredWithoutService_groupNestedInput = {
    create?: XOR<institutionCreateWithoutService_groupInput, institutionUncheckedCreateWithoutService_groupInput>
    connectOrCreate?: institutionCreateOrConnectWithoutService_groupInput
    upsert?: institutionUpsertWithoutService_groupInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutService_groupInput, institutionUpdateWithoutService_groupInput>, institutionUncheckedUpdateWithoutService_groupInput>
  }

  export type surveyQuestionsUpdateManyWithoutService_groupNestedInput = {
    create?: XOR<surveyQuestionsCreateWithoutService_groupInput, surveyQuestionsUncheckedCreateWithoutService_groupInput> | surveyQuestionsCreateWithoutService_groupInput[] | surveyQuestionsUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: surveyQuestionsCreateOrConnectWithoutService_groupInput | surveyQuestionsCreateOrConnectWithoutService_groupInput[]
    upsert?: surveyQuestionsUpsertWithWhereUniqueWithoutService_groupInput | surveyQuestionsUpsertWithWhereUniqueWithoutService_groupInput[]
    createMany?: surveyQuestionsCreateManyService_groupInputEnvelope
    set?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    disconnect?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    delete?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    connect?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    update?: surveyQuestionsUpdateWithWhereUniqueWithoutService_groupInput | surveyQuestionsUpdateWithWhereUniqueWithoutService_groupInput[]
    updateMany?: surveyQuestionsUpdateManyWithWhereWithoutService_groupInput | surveyQuestionsUpdateManyWithWhereWithoutService_groupInput[]
    deleteMany?: surveyQuestionsScalarWhereInput | surveyQuestionsScalarWhereInput[]
  }

  export type serviceUncheckedUpdateManyWithoutService_groupNestedInput = {
    create?: XOR<serviceCreateWithoutService_groupInput, serviceUncheckedCreateWithoutService_groupInput> | serviceCreateWithoutService_groupInput[] | serviceUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutService_groupInput | serviceCreateOrConnectWithoutService_groupInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutService_groupInput | serviceUpsertWithWhereUniqueWithoutService_groupInput[]
    createMany?: serviceCreateManyService_groupInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutService_groupInput | serviceUpdateWithWhereUniqueWithoutService_groupInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutService_groupInput | serviceUpdateManyWithWhereWithoutService_groupInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type serviceReviewUncheckedUpdateManyWithoutService_groupNestedInput = {
    create?: XOR<serviceReviewCreateWithoutService_groupInput, serviceReviewUncheckedCreateWithoutService_groupInput> | serviceReviewCreateWithoutService_groupInput[] | serviceReviewUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutService_groupInput | serviceReviewCreateOrConnectWithoutService_groupInput[]
    upsert?: serviceReviewUpsertWithWhereUniqueWithoutService_groupInput | serviceReviewUpsertWithWhereUniqueWithoutService_groupInput[]
    createMany?: serviceReviewCreateManyService_groupInputEnvelope
    set?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    disconnect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    delete?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    update?: serviceReviewUpdateWithWhereUniqueWithoutService_groupInput | serviceReviewUpdateWithWhereUniqueWithoutService_groupInput[]
    updateMany?: serviceReviewUpdateManyWithWhereWithoutService_groupInput | serviceReviewUpdateManyWithWhereWithoutService_groupInput[]
    deleteMany?: serviceReviewScalarWhereInput | serviceReviewScalarWhereInput[]
  }

  export type surveyQuestionsUncheckedUpdateManyWithoutService_groupNestedInput = {
    create?: XOR<surveyQuestionsCreateWithoutService_groupInput, surveyQuestionsUncheckedCreateWithoutService_groupInput> | surveyQuestionsCreateWithoutService_groupInput[] | surveyQuestionsUncheckedCreateWithoutService_groupInput[]
    connectOrCreate?: surveyQuestionsCreateOrConnectWithoutService_groupInput | surveyQuestionsCreateOrConnectWithoutService_groupInput[]
    upsert?: surveyQuestionsUpsertWithWhereUniqueWithoutService_groupInput | surveyQuestionsUpsertWithWhereUniqueWithoutService_groupInput[]
    createMany?: surveyQuestionsCreateManyService_groupInputEnvelope
    set?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    disconnect?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    delete?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    connect?: surveyQuestionsWhereUniqueInput | surveyQuestionsWhereUniqueInput[]
    update?: surveyQuestionsUpdateWithWhereUniqueWithoutService_groupInput | surveyQuestionsUpdateWithWhereUniqueWithoutService_groupInput[]
    updateMany?: surveyQuestionsUpdateManyWithWhereWithoutService_groupInput | surveyQuestionsUpdateManyWithWhereWithoutService_groupInput[]
    deleteMany?: surveyQuestionsScalarWhereInput | surveyQuestionsScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutTags_tags_created_byTouserInput = {
    create?: XOR<userCreateWithoutTags_tags_created_byTouserInput, userUncheckedCreateWithoutTags_tags_created_byTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutTags_tags_created_byTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTags_tags_updated_byTouserInput = {
    create?: XOR<userCreateWithoutTags_tags_updated_byTouserInput, userUncheckedCreateWithoutTags_tags_updated_byTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutTags_tags_updated_byTouserInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutTags_tags_created_byTouserNestedInput = {
    create?: XOR<userCreateWithoutTags_tags_created_byTouserInput, userUncheckedCreateWithoutTags_tags_created_byTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutTags_tags_created_byTouserInput
    upsert?: userUpsertWithoutTags_tags_created_byTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTags_tags_created_byTouserInput, userUpdateWithoutTags_tags_created_byTouserInput>, userUncheckedUpdateWithoutTags_tags_created_byTouserInput>
  }

  export type userUpdateOneWithoutTags_tags_updated_byTouserNestedInput = {
    create?: XOR<userCreateWithoutTags_tags_updated_byTouserInput, userUncheckedCreateWithoutTags_tags_updated_byTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutTags_tags_updated_byTouserInput
    upsert?: userUpsertWithoutTags_tags_updated_byTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTags_tags_updated_byTouserInput, userUpdateWithoutTags_tags_updated_byTouserInput>, userUncheckedUpdateWithoutTags_tags_updated_byTouserInput>
  }

  export type deviceCreateNestedOneWithoutTipInput = {
    create?: XOR<deviceCreateWithoutTipInput, deviceUncheckedCreateWithoutTipInput>
    connectOrCreate?: deviceCreateOrConnectWithoutTipInput
    connect?: deviceWhereUniqueInput
  }

  export type ratingCreateNestedOneWithoutTipInput = {
    create?: XOR<ratingCreateWithoutTipInput, ratingUncheckedCreateWithoutTipInput>
    connectOrCreate?: ratingCreateOrConnectWithoutTipInput
    connect?: ratingWhereUniqueInput
  }

  export type deviceUpdateOneRequiredWithoutTipNestedInput = {
    create?: XOR<deviceCreateWithoutTipInput, deviceUncheckedCreateWithoutTipInput>
    connectOrCreate?: deviceCreateOrConnectWithoutTipInput
    upsert?: deviceUpsertWithoutTipInput
    connect?: deviceWhereUniqueInput
    update?: XOR<XOR<deviceUpdateToOneWithWhereWithoutTipInput, deviceUpdateWithoutTipInput>, deviceUncheckedUpdateWithoutTipInput>
  }

  export type ratingUpdateOneWithoutTipNestedInput = {
    create?: XOR<ratingCreateWithoutTipInput, ratingUncheckedCreateWithoutTipInput>
    connectOrCreate?: ratingCreateOrConnectWithoutTipInput
    upsert?: ratingUpsertWithoutTipInput
    disconnect?: ratingWhereInput | boolean
    delete?: ratingWhereInput | boolean
    connect?: ratingWhereUniqueInput
    update?: XOR<XOR<ratingUpdateToOneWithWhereWithoutTipInput, ratingUpdateWithoutTipInput>, ratingUncheckedUpdateWithoutTipInput>
  }

  export type appointmentsCreateNestedManyWithoutUser_appointments_creator_idTouserInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput> | appointmentsCreateWithoutUser_appointments_creator_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_creator_idTouserInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type appointmentsCreateNestedManyWithoutUser_appointments_user_idTouserInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput> | appointmentsCreateWithoutUser_appointments_user_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_user_idTouserInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type tagsCreateNestedManyWithoutUser_tags_created_byTouserInput = {
    create?: XOR<tagsCreateWithoutUser_tags_created_byTouserInput, tagsUncheckedCreateWithoutUser_tags_created_byTouserInput> | tagsCreateWithoutUser_tags_created_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_created_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_created_byTouserInput | tagsCreateOrConnectWithoutUser_tags_created_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_created_byTouserInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type tagsCreateNestedManyWithoutUser_tags_updated_byTouserInput = {
    create?: XOR<tagsCreateWithoutUser_tags_updated_byTouserInput, tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput> | tagsCreateWithoutUser_tags_updated_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput | tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_updated_byTouserInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutUser_appointments_creator_idTouserInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput> | appointmentsCreateWithoutUser_appointments_creator_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_creator_idTouserInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutUser_appointments_user_idTouserInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput> | appointmentsCreateWithoutUser_appointments_user_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_user_idTouserInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type tagsUncheckedCreateNestedManyWithoutUser_tags_created_byTouserInput = {
    create?: XOR<tagsCreateWithoutUser_tags_created_byTouserInput, tagsUncheckedCreateWithoutUser_tags_created_byTouserInput> | tagsCreateWithoutUser_tags_created_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_created_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_created_byTouserInput | tagsCreateOrConnectWithoutUser_tags_created_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_created_byTouserInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type tagsUncheckedCreateNestedManyWithoutUser_tags_updated_byTouserInput = {
    create?: XOR<tagsCreateWithoutUser_tags_updated_byTouserInput, tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput> | tagsCreateWithoutUser_tags_updated_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput | tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_updated_byTouserInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutUser_appointments_creator_idTouserNestedInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput> | appointmentsCreateWithoutUser_appointments_creator_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutUser_appointments_creator_idTouserInput | appointmentsUpsertWithWhereUniqueWithoutUser_appointments_creator_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_creator_idTouserInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutUser_appointments_creator_idTouserInput | appointmentsUpdateWithWhereUniqueWithoutUser_appointments_creator_idTouserInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutUser_appointments_creator_idTouserInput | appointmentsUpdateManyWithWhereWithoutUser_appointments_creator_idTouserInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type appointmentsUpdateManyWithoutUser_appointments_user_idTouserNestedInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput> | appointmentsCreateWithoutUser_appointments_user_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutUser_appointments_user_idTouserInput | appointmentsUpsertWithWhereUniqueWithoutUser_appointments_user_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_user_idTouserInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutUser_appointments_user_idTouserInput | appointmentsUpdateWithWhereUniqueWithoutUser_appointments_user_idTouserInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutUser_appointments_user_idTouserInput | appointmentsUpdateManyWithWhereWithoutUser_appointments_user_idTouserInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type tagsUpdateManyWithoutUser_tags_created_byTouserNestedInput = {
    create?: XOR<tagsCreateWithoutUser_tags_created_byTouserInput, tagsUncheckedCreateWithoutUser_tags_created_byTouserInput> | tagsCreateWithoutUser_tags_created_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_created_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_created_byTouserInput | tagsCreateOrConnectWithoutUser_tags_created_byTouserInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutUser_tags_created_byTouserInput | tagsUpsertWithWhereUniqueWithoutUser_tags_created_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_created_byTouserInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutUser_tags_created_byTouserInput | tagsUpdateWithWhereUniqueWithoutUser_tags_created_byTouserInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutUser_tags_created_byTouserInput | tagsUpdateManyWithWhereWithoutUser_tags_created_byTouserInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type tagsUpdateManyWithoutUser_tags_updated_byTouserNestedInput = {
    create?: XOR<tagsCreateWithoutUser_tags_updated_byTouserInput, tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput> | tagsCreateWithoutUser_tags_updated_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput | tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutUser_tags_updated_byTouserInput | tagsUpsertWithWhereUniqueWithoutUser_tags_updated_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_updated_byTouserInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutUser_tags_updated_byTouserInput | tagsUpdateWithWhereUniqueWithoutUser_tags_updated_byTouserInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutUser_tags_updated_byTouserInput | tagsUpdateManyWithWhereWithoutUser_tags_updated_byTouserInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserNestedInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput> | appointmentsCreateWithoutUser_appointments_creator_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutUser_appointments_creator_idTouserInput | appointmentsUpsertWithWhereUniqueWithoutUser_appointments_creator_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_creator_idTouserInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutUser_appointments_creator_idTouserInput | appointmentsUpdateWithWhereUniqueWithoutUser_appointments_creator_idTouserInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutUser_appointments_creator_idTouserInput | appointmentsUpdateManyWithWhereWithoutUser_appointments_creator_idTouserInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserNestedInput = {
    create?: XOR<appointmentsCreateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput> | appointmentsCreateWithoutUser_appointments_user_idTouserInput[] | appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput | appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutUser_appointments_user_idTouserInput | appointmentsUpsertWithWhereUniqueWithoutUser_appointments_user_idTouserInput[]
    createMany?: appointmentsCreateManyUser_appointments_user_idTouserInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutUser_appointments_user_idTouserInput | appointmentsUpdateWithWhereUniqueWithoutUser_appointments_user_idTouserInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutUser_appointments_user_idTouserInput | appointmentsUpdateManyWithWhereWithoutUser_appointments_user_idTouserInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserNestedInput = {
    create?: XOR<tagsCreateWithoutUser_tags_created_byTouserInput, tagsUncheckedCreateWithoutUser_tags_created_byTouserInput> | tagsCreateWithoutUser_tags_created_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_created_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_created_byTouserInput | tagsCreateOrConnectWithoutUser_tags_created_byTouserInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutUser_tags_created_byTouserInput | tagsUpsertWithWhereUniqueWithoutUser_tags_created_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_created_byTouserInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutUser_tags_created_byTouserInput | tagsUpdateWithWhereUniqueWithoutUser_tags_created_byTouserInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutUser_tags_created_byTouserInput | tagsUpdateManyWithWhereWithoutUser_tags_created_byTouserInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserNestedInput = {
    create?: XOR<tagsCreateWithoutUser_tags_updated_byTouserInput, tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput> | tagsCreateWithoutUser_tags_updated_byTouserInput[] | tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput | tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutUser_tags_updated_byTouserInput | tagsUpsertWithWhereUniqueWithoutUser_tags_updated_byTouserInput[]
    createMany?: tagsCreateManyUser_tags_updated_byTouserInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutUser_tags_updated_byTouserInput | tagsUpdateWithWhereUniqueWithoutUser_tags_updated_byTouserInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutUser_tags_updated_byTouserInput | tagsUpdateManyWithWhereWithoutUser_tags_updated_byTouserInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type institutionCreateNestedOneWithoutImagesInput = {
    create?: XOR<institutionCreateWithoutImagesInput, institutionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: institutionCreateOrConnectWithoutImagesInput
    connect?: institutionWhereUniqueInput
  }

  export type reviewsCreateNestedOneWithoutImagesInput = {
    create?: XOR<reviewsCreateWithoutImagesInput, reviewsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutImagesInput
    connect?: reviewsWhereUniqueInput
  }

  export type users_profileCreateNestedOneWithoutImagesInput = {
    create?: XOR<users_profileCreateWithoutImagesInput, users_profileUncheckedCreateWithoutImagesInput>
    connectOrCreate?: users_profileCreateOrConnectWithoutImagesInput
    connect?: users_profileWhereUniqueInput
  }

  export type institutionUpdateOneWithoutImagesNestedInput = {
    create?: XOR<institutionCreateWithoutImagesInput, institutionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: institutionCreateOrConnectWithoutImagesInput
    upsert?: institutionUpsertWithoutImagesInput
    disconnect?: institutionWhereInput | boolean
    delete?: institutionWhereInput | boolean
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutImagesInput, institutionUpdateWithoutImagesInput>, institutionUncheckedUpdateWithoutImagesInput>
  }

  export type reviewsUpdateOneWithoutImagesNestedInput = {
    create?: XOR<reviewsCreateWithoutImagesInput, reviewsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutImagesInput
    upsert?: reviewsUpsertWithoutImagesInput
    disconnect?: reviewsWhereInput | boolean
    delete?: reviewsWhereInput | boolean
    connect?: reviewsWhereUniqueInput
    update?: XOR<XOR<reviewsUpdateToOneWithWhereWithoutImagesInput, reviewsUpdateWithoutImagesInput>, reviewsUncheckedUpdateWithoutImagesInput>
  }

  export type users_profileUpdateOneWithoutImagesNestedInput = {
    create?: XOR<users_profileCreateWithoutImagesInput, users_profileUncheckedCreateWithoutImagesInput>
    connectOrCreate?: users_profileCreateOrConnectWithoutImagesInput
    upsert?: users_profileUpsertWithoutImagesInput
    disconnect?: users_profileWhereInput | boolean
    delete?: users_profileWhereInput | boolean
    connect?: users_profileWhereUniqueInput
    update?: XOR<XOR<users_profileUpdateToOneWithWhereWithoutImagesInput, users_profileUpdateWithoutImagesInput>, users_profileUncheckedUpdateWithoutImagesInput>
  }

  export type categoriesCreateNestedManyWithoutSectorsInput = {
    create?: XOR<categoriesCreateWithoutSectorsInput, categoriesUncheckedCreateWithoutSectorsInput> | categoriesCreateWithoutSectorsInput[] | categoriesUncheckedCreateWithoutSectorsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSectorsInput | categoriesCreateOrConnectWithoutSectorsInput[]
    createMany?: categoriesCreateManySectorsInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type categoriesUncheckedCreateNestedManyWithoutSectorsInput = {
    create?: XOR<categoriesCreateWithoutSectorsInput, categoriesUncheckedCreateWithoutSectorsInput> | categoriesCreateWithoutSectorsInput[] | categoriesUncheckedCreateWithoutSectorsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSectorsInput | categoriesCreateOrConnectWithoutSectorsInput[]
    createMany?: categoriesCreateManySectorsInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type categoriesUpdateManyWithoutSectorsNestedInput = {
    create?: XOR<categoriesCreateWithoutSectorsInput, categoriesUncheckedCreateWithoutSectorsInput> | categoriesCreateWithoutSectorsInput[] | categoriesUncheckedCreateWithoutSectorsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSectorsInput | categoriesCreateOrConnectWithoutSectorsInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutSectorsInput | categoriesUpsertWithWhereUniqueWithoutSectorsInput[]
    createMany?: categoriesCreateManySectorsInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutSectorsInput | categoriesUpdateWithWhereUniqueWithoutSectorsInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutSectorsInput | categoriesUpdateManyWithWhereWithoutSectorsInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type categoriesUncheckedUpdateManyWithoutSectorsNestedInput = {
    create?: XOR<categoriesCreateWithoutSectorsInput, categoriesUncheckedCreateWithoutSectorsInput> | categoriesCreateWithoutSectorsInput[] | categoriesUncheckedCreateWithoutSectorsInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutSectorsInput | categoriesCreateOrConnectWithoutSectorsInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutSectorsInput | categoriesUpsertWithWhereUniqueWithoutSectorsInput[]
    createMany?: categoriesCreateManySectorsInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutSectorsInput | categoriesUpdateWithWhereUniqueWithoutSectorsInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutSectorsInput | categoriesUpdateManyWithWhereWithoutSectorsInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type imagesCreateNestedManyWithoutUsers_profileInput = {
    create?: XOR<imagesCreateWithoutUsers_profileInput, imagesUncheckedCreateWithoutUsers_profileInput> | imagesCreateWithoutUsers_profileInput[] | imagesUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutUsers_profileInput | imagesCreateOrConnectWithoutUsers_profileInput[]
    createMany?: imagesCreateManyUsers_profileInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutUsers_profileInput = {
    create?: XOR<reviewsCreateWithoutUsers_profileInput, reviewsUncheckedCreateWithoutUsers_profileInput> | reviewsCreateWithoutUsers_profileInput[] | reviewsUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_profileInput | reviewsCreateOrConnectWithoutUsers_profileInput[]
    createMany?: reviewsCreateManyUsers_profileInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type serviceReviewCreateNestedManyWithoutUsers_profileInput = {
    create?: XOR<serviceReviewCreateWithoutUsers_profileInput, serviceReviewUncheckedCreateWithoutUsers_profileInput> | serviceReviewCreateWithoutUsers_profileInput[] | serviceReviewUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutUsers_profileInput | serviceReviewCreateOrConnectWithoutUsers_profileInput[]
    createMany?: serviceReviewCreateManyUsers_profileInputEnvelope
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
  }

  export type imagesUncheckedCreateNestedManyWithoutUsers_profileInput = {
    create?: XOR<imagesCreateWithoutUsers_profileInput, imagesUncheckedCreateWithoutUsers_profileInput> | imagesCreateWithoutUsers_profileInput[] | imagesUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutUsers_profileInput | imagesCreateOrConnectWithoutUsers_profileInput[]
    createMany?: imagesCreateManyUsers_profileInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutUsers_profileInput = {
    create?: XOR<reviewsCreateWithoutUsers_profileInput, reviewsUncheckedCreateWithoutUsers_profileInput> | reviewsCreateWithoutUsers_profileInput[] | reviewsUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_profileInput | reviewsCreateOrConnectWithoutUsers_profileInput[]
    createMany?: reviewsCreateManyUsers_profileInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type serviceReviewUncheckedCreateNestedManyWithoutUsers_profileInput = {
    create?: XOR<serviceReviewCreateWithoutUsers_profileInput, serviceReviewUncheckedCreateWithoutUsers_profileInput> | serviceReviewCreateWithoutUsers_profileInput[] | serviceReviewUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutUsers_profileInput | serviceReviewCreateOrConnectWithoutUsers_profileInput[]
    createMany?: serviceReviewCreateManyUsers_profileInputEnvelope
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
  }

  export type imagesUpdateManyWithoutUsers_profileNestedInput = {
    create?: XOR<imagesCreateWithoutUsers_profileInput, imagesUncheckedCreateWithoutUsers_profileInput> | imagesCreateWithoutUsers_profileInput[] | imagesUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutUsers_profileInput | imagesCreateOrConnectWithoutUsers_profileInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutUsers_profileInput | imagesUpsertWithWhereUniqueWithoutUsers_profileInput[]
    createMany?: imagesCreateManyUsers_profileInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutUsers_profileInput | imagesUpdateWithWhereUniqueWithoutUsers_profileInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutUsers_profileInput | imagesUpdateManyWithWhereWithoutUsers_profileInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutUsers_profileNestedInput = {
    create?: XOR<reviewsCreateWithoutUsers_profileInput, reviewsUncheckedCreateWithoutUsers_profileInput> | reviewsCreateWithoutUsers_profileInput[] | reviewsUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_profileInput | reviewsCreateOrConnectWithoutUsers_profileInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsers_profileInput | reviewsUpsertWithWhereUniqueWithoutUsers_profileInput[]
    createMany?: reviewsCreateManyUsers_profileInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsers_profileInput | reviewsUpdateWithWhereUniqueWithoutUsers_profileInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsers_profileInput | reviewsUpdateManyWithWhereWithoutUsers_profileInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type serviceReviewUpdateManyWithoutUsers_profileNestedInput = {
    create?: XOR<serviceReviewCreateWithoutUsers_profileInput, serviceReviewUncheckedCreateWithoutUsers_profileInput> | serviceReviewCreateWithoutUsers_profileInput[] | serviceReviewUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutUsers_profileInput | serviceReviewCreateOrConnectWithoutUsers_profileInput[]
    upsert?: serviceReviewUpsertWithWhereUniqueWithoutUsers_profileInput | serviceReviewUpsertWithWhereUniqueWithoutUsers_profileInput[]
    createMany?: serviceReviewCreateManyUsers_profileInputEnvelope
    set?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    disconnect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    delete?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    update?: serviceReviewUpdateWithWhereUniqueWithoutUsers_profileInput | serviceReviewUpdateWithWhereUniqueWithoutUsers_profileInput[]
    updateMany?: serviceReviewUpdateManyWithWhereWithoutUsers_profileInput | serviceReviewUpdateManyWithWhereWithoutUsers_profileInput[]
    deleteMany?: serviceReviewScalarWhereInput | serviceReviewScalarWhereInput[]
  }

  export type imagesUncheckedUpdateManyWithoutUsers_profileNestedInput = {
    create?: XOR<imagesCreateWithoutUsers_profileInput, imagesUncheckedCreateWithoutUsers_profileInput> | imagesCreateWithoutUsers_profileInput[] | imagesUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutUsers_profileInput | imagesCreateOrConnectWithoutUsers_profileInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutUsers_profileInput | imagesUpsertWithWhereUniqueWithoutUsers_profileInput[]
    createMany?: imagesCreateManyUsers_profileInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutUsers_profileInput | imagesUpdateWithWhereUniqueWithoutUsers_profileInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutUsers_profileInput | imagesUpdateManyWithWhereWithoutUsers_profileInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutUsers_profileNestedInput = {
    create?: XOR<reviewsCreateWithoutUsers_profileInput, reviewsUncheckedCreateWithoutUsers_profileInput> | reviewsCreateWithoutUsers_profileInput[] | reviewsUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_profileInput | reviewsCreateOrConnectWithoutUsers_profileInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsers_profileInput | reviewsUpsertWithWhereUniqueWithoutUsers_profileInput[]
    createMany?: reviewsCreateManyUsers_profileInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsers_profileInput | reviewsUpdateWithWhereUniqueWithoutUsers_profileInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsers_profileInput | reviewsUpdateManyWithWhereWithoutUsers_profileInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type serviceReviewUncheckedUpdateManyWithoutUsers_profileNestedInput = {
    create?: XOR<serviceReviewCreateWithoutUsers_profileInput, serviceReviewUncheckedCreateWithoutUsers_profileInput> | serviceReviewCreateWithoutUsers_profileInput[] | serviceReviewUncheckedCreateWithoutUsers_profileInput[]
    connectOrCreate?: serviceReviewCreateOrConnectWithoutUsers_profileInput | serviceReviewCreateOrConnectWithoutUsers_profileInput[]
    upsert?: serviceReviewUpsertWithWhereUniqueWithoutUsers_profileInput | serviceReviewUpsertWithWhereUniqueWithoutUsers_profileInput[]
    createMany?: serviceReviewCreateManyUsers_profileInputEnvelope
    set?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    disconnect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    delete?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    connect?: serviceReviewWhereUniqueInput | serviceReviewWhereUniqueInput[]
    update?: serviceReviewUpdateWithWhereUniqueWithoutUsers_profileInput | serviceReviewUpdateWithWhereUniqueWithoutUsers_profileInput[]
    updateMany?: serviceReviewUpdateManyWithWhereWithoutUsers_profileInput | serviceReviewUpdateManyWithWhereWithoutUsers_profileInput[]
    deleteMany?: serviceReviewScalarWhereInput | serviceReviewScalarWhereInput[]
  }

  export type imagesCreateNestedManyWithoutReviewsInput = {
    create?: XOR<imagesCreateWithoutReviewsInput, imagesUncheckedCreateWithoutReviewsInput> | imagesCreateWithoutReviewsInput[] | imagesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutReviewsInput | imagesCreateOrConnectWithoutReviewsInput[]
    createMany?: imagesCreateManyReviewsInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type institutionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<institutionCreateWithoutReviewsInput, institutionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutReviewsInput
    connect?: institutionWhereUniqueInput
  }

  export type users_profileCreateNestedOneWithoutReviewsInput = {
    create?: XOR<users_profileCreateWithoutReviewsInput, users_profileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: users_profileCreateOrConnectWithoutReviewsInput
    connect?: users_profileWhereUniqueInput
  }

  export type imagesUncheckedCreateNestedManyWithoutReviewsInput = {
    create?: XOR<imagesCreateWithoutReviewsInput, imagesUncheckedCreateWithoutReviewsInput> | imagesCreateWithoutReviewsInput[] | imagesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutReviewsInput | imagesCreateOrConnectWithoutReviewsInput[]
    createMany?: imagesCreateManyReviewsInputEnvelope
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
  }

  export type imagesUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<imagesCreateWithoutReviewsInput, imagesUncheckedCreateWithoutReviewsInput> | imagesCreateWithoutReviewsInput[] | imagesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutReviewsInput | imagesCreateOrConnectWithoutReviewsInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutReviewsInput | imagesUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: imagesCreateManyReviewsInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutReviewsInput | imagesUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutReviewsInput | imagesUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type institutionUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<institutionCreateWithoutReviewsInput, institutionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: institutionCreateOrConnectWithoutReviewsInput
    upsert?: institutionUpsertWithoutReviewsInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutReviewsInput, institutionUpdateWithoutReviewsInput>, institutionUncheckedUpdateWithoutReviewsInput>
  }

  export type users_profileUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<users_profileCreateWithoutReviewsInput, users_profileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: users_profileCreateOrConnectWithoutReviewsInput
    upsert?: users_profileUpsertWithoutReviewsInput
    connect?: users_profileWhereUniqueInput
    update?: XOR<XOR<users_profileUpdateToOneWithWhereWithoutReviewsInput, users_profileUpdateWithoutReviewsInput>, users_profileUncheckedUpdateWithoutReviewsInput>
  }

  export type imagesUncheckedUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<imagesCreateWithoutReviewsInput, imagesUncheckedCreateWithoutReviewsInput> | imagesCreateWithoutReviewsInput[] | imagesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: imagesCreateOrConnectWithoutReviewsInput | imagesCreateOrConnectWithoutReviewsInput[]
    upsert?: imagesUpsertWithWhereUniqueWithoutReviewsInput | imagesUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: imagesCreateManyReviewsInputEnvelope
    set?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    disconnect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    delete?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    connect?: imagesWhereUniqueInput | imagesWhereUniqueInput[]
    update?: imagesUpdateWithWhereUniqueWithoutReviewsInput | imagesUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: imagesUpdateManyWithWhereWithoutReviewsInput | imagesUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: imagesScalarWhereInput | imagesScalarWhereInput[]
  }

  export type institutionCreateNestedOneWithoutWorkingHourInput = {
    create?: XOR<institutionCreateWithoutWorkingHourInput, institutionUncheckedCreateWithoutWorkingHourInput>
    connectOrCreate?: institutionCreateOrConnectWithoutWorkingHourInput
    connect?: institutionWhereUniqueInput
  }

  export type institutionUpdateOneRequiredWithoutWorkingHourNestedInput = {
    create?: XOR<institutionCreateWithoutWorkingHourInput, institutionUncheckedCreateWithoutWorkingHourInput>
    connectOrCreate?: institutionCreateOrConnectWithoutWorkingHourInput
    upsert?: institutionUpsertWithoutWorkingHourInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutWorkingHourInput, institutionUpdateWithoutWorkingHourInput>, institutionUncheckedUpdateWithoutWorkingHourInput>
  }

  export type business_amenitiesCreateNestedManyWithoutAmenitiesInput = {
    create?: XOR<business_amenitiesCreateWithoutAmenitiesInput, business_amenitiesUncheckedCreateWithoutAmenitiesInput> | business_amenitiesCreateWithoutAmenitiesInput[] | business_amenitiesUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutAmenitiesInput | business_amenitiesCreateOrConnectWithoutAmenitiesInput[]
    createMany?: business_amenitiesCreateManyAmenitiesInputEnvelope
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
  }

  export type business_amenitiesUncheckedCreateNestedManyWithoutAmenitiesInput = {
    create?: XOR<business_amenitiesCreateWithoutAmenitiesInput, business_amenitiesUncheckedCreateWithoutAmenitiesInput> | business_amenitiesCreateWithoutAmenitiesInput[] | business_amenitiesUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutAmenitiesInput | business_amenitiesCreateOrConnectWithoutAmenitiesInput[]
    createMany?: business_amenitiesCreateManyAmenitiesInputEnvelope
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
  }

  export type business_amenitiesUpdateManyWithoutAmenitiesNestedInput = {
    create?: XOR<business_amenitiesCreateWithoutAmenitiesInput, business_amenitiesUncheckedCreateWithoutAmenitiesInput> | business_amenitiesCreateWithoutAmenitiesInput[] | business_amenitiesUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutAmenitiesInput | business_amenitiesCreateOrConnectWithoutAmenitiesInput[]
    upsert?: business_amenitiesUpsertWithWhereUniqueWithoutAmenitiesInput | business_amenitiesUpsertWithWhereUniqueWithoutAmenitiesInput[]
    createMany?: business_amenitiesCreateManyAmenitiesInputEnvelope
    set?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    disconnect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    delete?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    update?: business_amenitiesUpdateWithWhereUniqueWithoutAmenitiesInput | business_amenitiesUpdateWithWhereUniqueWithoutAmenitiesInput[]
    updateMany?: business_amenitiesUpdateManyWithWhereWithoutAmenitiesInput | business_amenitiesUpdateManyWithWhereWithoutAmenitiesInput[]
    deleteMany?: business_amenitiesScalarWhereInput | business_amenitiesScalarWhereInput[]
  }

  export type business_amenitiesUncheckedUpdateManyWithoutAmenitiesNestedInput = {
    create?: XOR<business_amenitiesCreateWithoutAmenitiesInput, business_amenitiesUncheckedCreateWithoutAmenitiesInput> | business_amenitiesCreateWithoutAmenitiesInput[] | business_amenitiesUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: business_amenitiesCreateOrConnectWithoutAmenitiesInput | business_amenitiesCreateOrConnectWithoutAmenitiesInput[]
    upsert?: business_amenitiesUpsertWithWhereUniqueWithoutAmenitiesInput | business_amenitiesUpsertWithWhereUniqueWithoutAmenitiesInput[]
    createMany?: business_amenitiesCreateManyAmenitiesInputEnvelope
    set?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    disconnect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    delete?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    connect?: business_amenitiesWhereUniqueInput | business_amenitiesWhereUniqueInput[]
    update?: business_amenitiesUpdateWithWhereUniqueWithoutAmenitiesInput | business_amenitiesUpdateWithWhereUniqueWithoutAmenitiesInput[]
    updateMany?: business_amenitiesUpdateManyWithWhereWithoutAmenitiesInput | business_amenitiesUpdateManyWithWhereWithoutAmenitiesInput[]
    deleteMany?: business_amenitiesScalarWhereInput | business_amenitiesScalarWhereInput[]
  }

  export type amenitiesCreateNestedOneWithoutBusiness_amenitiesInput = {
    create?: XOR<amenitiesCreateWithoutBusiness_amenitiesInput, amenitiesUncheckedCreateWithoutBusiness_amenitiesInput>
    connectOrCreate?: amenitiesCreateOrConnectWithoutBusiness_amenitiesInput
    connect?: amenitiesWhereUniqueInput
  }

  export type institutionCreateNestedOneWithoutBusiness_amenitiesInput = {
    create?: XOR<institutionCreateWithoutBusiness_amenitiesInput, institutionUncheckedCreateWithoutBusiness_amenitiesInput>
    connectOrCreate?: institutionCreateOrConnectWithoutBusiness_amenitiesInput
    connect?: institutionWhereUniqueInput
  }

  export type amenitiesUpdateOneWithoutBusiness_amenitiesNestedInput = {
    create?: XOR<amenitiesCreateWithoutBusiness_amenitiesInput, amenitiesUncheckedCreateWithoutBusiness_amenitiesInput>
    connectOrCreate?: amenitiesCreateOrConnectWithoutBusiness_amenitiesInput
    upsert?: amenitiesUpsertWithoutBusiness_amenitiesInput
    disconnect?: amenitiesWhereInput | boolean
    delete?: amenitiesWhereInput | boolean
    connect?: amenitiesWhereUniqueInput
    update?: XOR<XOR<amenitiesUpdateToOneWithWhereWithoutBusiness_amenitiesInput, amenitiesUpdateWithoutBusiness_amenitiesInput>, amenitiesUncheckedUpdateWithoutBusiness_amenitiesInput>
  }

  export type institutionUpdateOneWithoutBusiness_amenitiesNestedInput = {
    create?: XOR<institutionCreateWithoutBusiness_amenitiesInput, institutionUncheckedCreateWithoutBusiness_amenitiesInput>
    connectOrCreate?: institutionCreateOrConnectWithoutBusiness_amenitiesInput
    upsert?: institutionUpsertWithoutBusiness_amenitiesInput
    disconnect?: institutionWhereInput | boolean
    delete?: institutionWhereInput | boolean
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutBusiness_amenitiesInput, institutionUpdateWithoutBusiness_amenitiesInput>, institutionUncheckedUpdateWithoutBusiness_amenitiesInput>
  }

  export type institutionCreateNestedOneWithoutPrice_rangesInput = {
    create?: XOR<institutionCreateWithoutPrice_rangesInput, institutionUncheckedCreateWithoutPrice_rangesInput>
    connectOrCreate?: institutionCreateOrConnectWithoutPrice_rangesInput
    connect?: institutionWhereUniqueInput
  }

  export type institutionUpdateOneRequiredWithoutPrice_rangesNestedInput = {
    create?: XOR<institutionCreateWithoutPrice_rangesInput, institutionUncheckedCreateWithoutPrice_rangesInput>
    connectOrCreate?: institutionCreateOrConnectWithoutPrice_rangesInput
    upsert?: institutionUpsertWithoutPrice_rangesInput
    connect?: institutionWhereUniqueInput
    update?: XOR<XOR<institutionUpdateToOneWithWhereWithoutPrice_rangesInput, institutionUpdateWithoutPrice_rangesInput>, institutionUncheckedUpdateWithoutPrice_rangesInput>
  }

  export type surveyQuestionsCreateNestedOneWithoutSurveyAnswersInput = {
    create?: XOR<surveyQuestionsCreateWithoutSurveyAnswersInput, surveyQuestionsUncheckedCreateWithoutSurveyAnswersInput>
    connectOrCreate?: surveyQuestionsCreateOrConnectWithoutSurveyAnswersInput
    connect?: surveyQuestionsWhereUniqueInput
  }

  export type surveyQuestionsUpdateOneRequiredWithoutSurveyAnswersNestedInput = {
    create?: XOR<surveyQuestionsCreateWithoutSurveyAnswersInput, surveyQuestionsUncheckedCreateWithoutSurveyAnswersInput>
    connectOrCreate?: surveyQuestionsCreateOrConnectWithoutSurveyAnswersInput
    upsert?: surveyQuestionsUpsertWithoutSurveyAnswersInput
    connect?: surveyQuestionsWhereUniqueInput
    update?: XOR<XOR<surveyQuestionsUpdateToOneWithWhereWithoutSurveyAnswersInput, surveyQuestionsUpdateWithoutSurveyAnswersInput>, surveyQuestionsUncheckedUpdateWithoutSurveyAnswersInput>
  }

  export type surveyAnswersCreateNestedManyWithoutSurveyQuestionsInput = {
    create?: XOR<surveyAnswersCreateWithoutSurveyQuestionsInput, surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput> | surveyAnswersCreateWithoutSurveyQuestionsInput[] | surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput[]
    connectOrCreate?: surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput | surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput[]
    createMany?: surveyAnswersCreateManySurveyQuestionsInputEnvelope
    connect?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
  }

  export type service_groupCreateNestedOneWithoutSurveyQuestionsInput = {
    create?: XOR<service_groupCreateWithoutSurveyQuestionsInput, service_groupUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: service_groupCreateOrConnectWithoutSurveyQuestionsInput
    connect?: service_groupWhereUniqueInput
  }

  export type surveyAnswersUncheckedCreateNestedManyWithoutSurveyQuestionsInput = {
    create?: XOR<surveyAnswersCreateWithoutSurveyQuestionsInput, surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput> | surveyAnswersCreateWithoutSurveyQuestionsInput[] | surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput[]
    connectOrCreate?: surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput | surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput[]
    createMany?: surveyAnswersCreateManySurveyQuestionsInputEnvelope
    connect?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
  }

  export type surveyAnswersUpdateManyWithoutSurveyQuestionsNestedInput = {
    create?: XOR<surveyAnswersCreateWithoutSurveyQuestionsInput, surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput> | surveyAnswersCreateWithoutSurveyQuestionsInput[] | surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput[]
    connectOrCreate?: surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput | surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput[]
    upsert?: surveyAnswersUpsertWithWhereUniqueWithoutSurveyQuestionsInput | surveyAnswersUpsertWithWhereUniqueWithoutSurveyQuestionsInput[]
    createMany?: surveyAnswersCreateManySurveyQuestionsInputEnvelope
    set?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    disconnect?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    delete?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    connect?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    update?: surveyAnswersUpdateWithWhereUniqueWithoutSurveyQuestionsInput | surveyAnswersUpdateWithWhereUniqueWithoutSurveyQuestionsInput[]
    updateMany?: surveyAnswersUpdateManyWithWhereWithoutSurveyQuestionsInput | surveyAnswersUpdateManyWithWhereWithoutSurveyQuestionsInput[]
    deleteMany?: surveyAnswersScalarWhereInput | surveyAnswersScalarWhereInput[]
  }

  export type service_groupUpdateOneRequiredWithoutSurveyQuestionsNestedInput = {
    create?: XOR<service_groupCreateWithoutSurveyQuestionsInput, service_groupUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: service_groupCreateOrConnectWithoutSurveyQuestionsInput
    upsert?: service_groupUpsertWithoutSurveyQuestionsInput
    connect?: service_groupWhereUniqueInput
    update?: XOR<XOR<service_groupUpdateToOneWithWhereWithoutSurveyQuestionsInput, service_groupUpdateWithoutSurveyQuestionsInput>, service_groupUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type surveyAnswersUncheckedUpdateManyWithoutSurveyQuestionsNestedInput = {
    create?: XOR<surveyAnswersCreateWithoutSurveyQuestionsInput, surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput> | surveyAnswersCreateWithoutSurveyQuestionsInput[] | surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput[]
    connectOrCreate?: surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput | surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput[]
    upsert?: surveyAnswersUpsertWithWhereUniqueWithoutSurveyQuestionsInput | surveyAnswersUpsertWithWhereUniqueWithoutSurveyQuestionsInput[]
    createMany?: surveyAnswersCreateManySurveyQuestionsInputEnvelope
    set?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    disconnect?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    delete?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    connect?: surveyAnswersWhereUniqueInput | surveyAnswersWhereUniqueInput[]
    update?: surveyAnswersUpdateWithWhereUniqueWithoutSurveyQuestionsInput | surveyAnswersUpdateWithWhereUniqueWithoutSurveyQuestionsInput[]
    updateMany?: surveyAnswersUpdateManyWithWhereWithoutSurveyQuestionsInput | surveyAnswersUpdateManyWithWhereWithoutSurveyQuestionsInput[]
    deleteMany?: surveyAnswersScalarWhereInput | surveyAnswersScalarWhereInput[]
  }

  export type service_groupCreateNestedOneWithoutServiceReviewInput = {
    create?: XOR<service_groupCreateWithoutServiceReviewInput, service_groupUncheckedCreateWithoutServiceReviewInput>
    connectOrCreate?: service_groupCreateOrConnectWithoutServiceReviewInput
    connect?: service_groupWhereUniqueInput
  }

  export type users_profileCreateNestedOneWithoutServiceReviewInput = {
    create?: XOR<users_profileCreateWithoutServiceReviewInput, users_profileUncheckedCreateWithoutServiceReviewInput>
    connectOrCreate?: users_profileCreateOrConnectWithoutServiceReviewInput
    connect?: users_profileWhereUniqueInput
  }

  export type service_groupUpdateOneWithoutServiceReviewNestedInput = {
    create?: XOR<service_groupCreateWithoutServiceReviewInput, service_groupUncheckedCreateWithoutServiceReviewInput>
    connectOrCreate?: service_groupCreateOrConnectWithoutServiceReviewInput
    upsert?: service_groupUpsertWithoutServiceReviewInput
    disconnect?: service_groupWhereInput | boolean
    delete?: service_groupWhereInput | boolean
    connect?: service_groupWhereUniqueInput
    update?: XOR<XOR<service_groupUpdateToOneWithWhereWithoutServiceReviewInput, service_groupUpdateWithoutServiceReviewInput>, service_groupUncheckedUpdateWithoutServiceReviewInput>
  }

  export type users_profileUpdateOneWithoutServiceReviewNestedInput = {
    create?: XOR<users_profileCreateWithoutServiceReviewInput, users_profileUncheckedCreateWithoutServiceReviewInput>
    connectOrCreate?: users_profileCreateOrConnectWithoutServiceReviewInput
    upsert?: users_profileUpsertWithoutServiceReviewInput
    disconnect?: users_profileWhereInput | boolean
    delete?: users_profileWhereInput | boolean
    connect?: users_profileWhereUniqueInput
    update?: XOR<XOR<users_profileUpdateToOneWithWhereWithoutServiceReviewInput, users_profileUpdateWithoutServiceReviewInput>, users_profileUncheckedUpdateWithoutServiceReviewInput>
  }

  export type categoriesCreateNestedOneWithoutCategory_search_termsInput = {
    create?: XOR<categoriesCreateWithoutCategory_search_termsInput, categoriesUncheckedCreateWithoutCategory_search_termsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutCategory_search_termsInput
    connect?: categoriesWhereUniqueInput
  }

  export type categoriesUpdateOneRequiredWithoutCategory_search_termsNestedInput = {
    create?: XOR<categoriesCreateWithoutCategory_search_termsInput, categoriesUncheckedCreateWithoutCategory_search_termsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutCategory_search_termsInput
    upsert?: categoriesUpsertWithoutCategory_search_termsInput
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutCategory_search_termsInput, categoriesUpdateWithoutCategory_search_termsInput>, categoriesUncheckedUpdateWithoutCategory_search_termsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumapp_releases_app_nameFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_app_name | Enumapp_releases_app_nameFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_app_name[]
    notIn?: $Enums.app_releases_app_name[]
    not?: NestedEnumapp_releases_app_nameFilter<$PrismaModel> | $Enums.app_releases_app_name
  }

  export type NestedEnumapp_releases_platformFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_platform | Enumapp_releases_platformFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_platform[]
    notIn?: $Enums.app_releases_platform[]
    not?: NestedEnumapp_releases_platformFilter<$PrismaModel> | $Enums.app_releases_platform
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumapp_releases_app_nameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_app_name | Enumapp_releases_app_nameFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_app_name[]
    notIn?: $Enums.app_releases_app_name[]
    not?: NestedEnumapp_releases_app_nameWithAggregatesFilter<$PrismaModel> | $Enums.app_releases_app_name
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapp_releases_app_nameFilter<$PrismaModel>
    _max?: NestedEnumapp_releases_app_nameFilter<$PrismaModel>
  }

  export type NestedEnumapp_releases_platformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.app_releases_platform | Enumapp_releases_platformFieldRefInput<$PrismaModel>
    in?: $Enums.app_releases_platform[]
    notIn?: $Enums.app_releases_platform[]
    not?: NestedEnumapp_releases_platformWithAggregatesFilter<$PrismaModel> | $Enums.app_releases_platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumapp_releases_platformFilter<$PrismaModel>
    _max?: NestedEnumapp_releases_platformFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumaudit_trail_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_trail_status | Enumaudit_trail_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.audit_trail_status[] | null
    notIn?: $Enums.audit_trail_status[] | null
    not?: NestedEnumaudit_trail_statusNullableFilter<$PrismaModel> | $Enums.audit_trail_status | null
  }

  export type NestedEnumaudit_trail_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.audit_trail_status | Enumaudit_trail_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.audit_trail_status[] | null
    notIn?: $Enums.audit_trail_status[] | null
    not?: NestedEnumaudit_trail_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.audit_trail_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumaudit_trail_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumaudit_trail_statusNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_payment_status | Enuminstitution_invoices_payment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_payment_status[]
    notIn?: $Enums.institution_invoices_payment_status[]
    not?: NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel> | $Enums.institution_invoices_payment_status
  }

  export type NestedEnuminstitution_invoices_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_status | Enuminstitution_invoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_status[]
    notIn?: $Enums.institution_invoices_status[]
    not?: NestedEnuminstitution_invoices_statusFilter<$PrismaModel> | $Enums.institution_invoices_status
  }

  export type NestedEnuminstitution_invoices_payment_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_payment_status | Enuminstitution_invoices_payment_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_payment_status[]
    notIn?: $Enums.institution_invoices_payment_status[]
    not?: NestedEnuminstitution_invoices_payment_statusWithAggregatesFilter<$PrismaModel> | $Enums.institution_invoices_payment_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel>
    _max?: NestedEnuminstitution_invoices_payment_statusFilter<$PrismaModel>
  }

  export type NestedEnuminstitution_invoices_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.institution_invoices_status | Enuminstitution_invoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.institution_invoices_status[]
    notIn?: $Enums.institution_invoices_status[]
    not?: NestedEnuminstitution_invoices_statusWithAggregatesFilter<$PrismaModel> | $Enums.institution_invoices_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminstitution_invoices_statusFilter<$PrismaModel>
    _max?: NestedEnuminstitution_invoices_statusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumqms_queue_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.qms_queue_status | Enumqms_queue_statusFieldRefInput<$PrismaModel>
    in?: $Enums.qms_queue_status[]
    notIn?: $Enums.qms_queue_status[]
    not?: NestedEnumqms_queue_statusFilter<$PrismaModel> | $Enums.qms_queue_status
  }

  export type NestedEnumqms_queue_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.qms_queue_status | Enumqms_queue_statusFieldRefInput<$PrismaModel>
    in?: $Enums.qms_queue_status[]
    notIn?: $Enums.qms_queue_status[]
    not?: NestedEnumqms_queue_statusWithAggregatesFilter<$PrismaModel> | $Enums.qms_queue_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumqms_queue_statusFilter<$PrismaModel>
    _max?: NestedEnumqms_queue_statusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.rating_qr_code_sessions_status | Enumrating_qr_code_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.rating_qr_code_sessions_status[]
    notIn?: $Enums.rating_qr_code_sessions_status[]
    not?: NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel> | $Enums.rating_qr_code_sessions_status
  }

  export type NestedEnumrating_qr_code_sessions_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rating_qr_code_sessions_status | Enumrating_qr_code_sessions_statusFieldRefInput<$PrismaModel>
    in?: $Enums.rating_qr_code_sessions_status[]
    notIn?: $Enums.rating_qr_code_sessions_status[]
    not?: NestedEnumrating_qr_code_sessions_statusWithAggregatesFilter<$PrismaModel> | $Enums.rating_qr_code_sessions_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel>
    _max?: NestedEnumrating_qr_code_sessions_statusFilter<$PrismaModel>
  }

  export type userCreateWithoutAppointments_appointments_creator_idTouserInput = {
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_user_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_created_byTouser?: tagsCreateNestedManyWithoutUser_tags_created_byTouserInput
    tags_tags_updated_byTouser?: tagsCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userUncheckedCreateWithoutAppointments_appointments_creator_idTouserInput = {
    id?: number
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_user_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_created_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_created_byTouserInput
    tags_tags_updated_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userCreateOrConnectWithoutAppointments_appointments_creator_idTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAppointments_appointments_creator_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_creator_idTouserInput>
  }

  export type institutionCreateWithoutAppointmentsInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutAppointmentsInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutAppointmentsInput, institutionUncheckedCreateWithoutAppointmentsInput>
  }

  export type qms_operatorCreateWithoutAppointmentsInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutQms_operatorInput
    institution?: institutionCreateNestedOneWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorCreateOrConnectWithoutAppointmentsInput = {
    where: qms_operatorWhereUniqueInput
    create: XOR<qms_operatorCreateWithoutAppointmentsInput, qms_operatorUncheckedCreateWithoutAppointmentsInput>
  }

  export type serviceCreateWithoutAppointmentsInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    qms_counter?: qms_counterCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueCreateNestedManyWithoutServiceInput
    rating?: ratingCreateNestedManyWithoutServiceInput
    service_group?: service_groupCreateNestedOneWithoutServiceInput
    institution?: institutionCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    qms_counter?: qms_counterUncheckedCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueUncheckedCreateNestedManyWithoutServiceInput
    rating?: ratingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutAppointmentsInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutAppointmentsInput, serviceUncheckedCreateWithoutAppointmentsInput>
  }

  export type userCreateWithoutAppointments_appointments_user_idTouserInput = {
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    tags_tags_created_byTouser?: tagsCreateNestedManyWithoutUser_tags_created_byTouserInput
    tags_tags_updated_byTouser?: tagsCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userUncheckedCreateWithoutAppointments_appointments_user_idTouserInput = {
    id?: number
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    tags_tags_created_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_created_byTouserInput
    tags_tags_updated_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userCreateOrConnectWithoutAppointments_appointments_user_idTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAppointments_appointments_user_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_user_idTouserInput>
  }

  export type userUpsertWithoutAppointments_appointments_creator_idTouserInput = {
    update: XOR<userUpdateWithoutAppointments_appointments_creator_idTouserInput, userUncheckedUpdateWithoutAppointments_appointments_creator_idTouserInput>
    create: XOR<userCreateWithoutAppointments_appointments_creator_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_creator_idTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAppointments_appointments_creator_idTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAppointments_appointments_creator_idTouserInput, userUncheckedUpdateWithoutAppointments_appointments_creator_idTouserInput>
  }

  export type userUpdateWithoutAppointments_appointments_creator_idTouserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_user_idTouser?: appointmentsUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUpdateManyWithoutUser_tags_created_byTouserNestedInput
    tags_tags_updated_byTouser?: tagsUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type userUncheckedUpdateWithoutAppointments_appointments_creator_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_user_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserNestedInput
    tags_tags_updated_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type institutionUpsertWithoutAppointmentsInput = {
    update: XOR<institutionUpdateWithoutAppointmentsInput, institutionUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<institutionCreateWithoutAppointmentsInput, institutionUncheckedCreateWithoutAppointmentsInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutAppointmentsInput, institutionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type institutionUpdateWithoutAppointmentsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type qms_operatorUpsertWithoutAppointmentsInput = {
    update: XOR<qms_operatorUpdateWithoutAppointmentsInput, qms_operatorUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<qms_operatorCreateWithoutAppointmentsInput, qms_operatorUncheckedCreateWithoutAppointmentsInput>
    where?: qms_operatorWhereInput
  }

  export type qms_operatorUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: qms_operatorWhereInput
    data: XOR<qms_operatorUpdateWithoutAppointmentsInput, qms_operatorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type qms_operatorUpdateWithoutAppointmentsInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput
    institution?: institutionUpdateOneWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type serviceUpsertWithoutAppointmentsInput = {
    update: XOR<serviceUpdateWithoutAppointmentsInput, serviceUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<serviceCreateWithoutAppointmentsInput, serviceUncheckedCreateWithoutAppointmentsInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutAppointmentsInput, serviceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type serviceUpdateWithoutAppointmentsInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_counter?: qms_counterUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUpdateManyWithoutServiceNestedInput
    rating?: ratingUpdateManyWithoutServiceNestedInput
    service_group?: service_groupUpdateOneWithoutServiceNestedInput
    institution?: institutionUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_counter?: qms_counterUncheckedUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type userUpsertWithoutAppointments_appointments_user_idTouserInput = {
    update: XOR<userUpdateWithoutAppointments_appointments_user_idTouserInput, userUncheckedUpdateWithoutAppointments_appointments_user_idTouserInput>
    create: XOR<userCreateWithoutAppointments_appointments_user_idTouserInput, userUncheckedCreateWithoutAppointments_appointments_user_idTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAppointments_appointments_user_idTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAppointments_appointments_user_idTouserInput, userUncheckedUpdateWithoutAppointments_appointments_user_idTouserInput>
  }

  export type userUpdateWithoutAppointments_appointments_user_idTouserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUpdateManyWithoutUser_tags_created_byTouserNestedInput
    tags_tags_updated_byTouser?: tagsUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type userUncheckedUpdateWithoutAppointments_appointments_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserNestedInput
    tags_tags_updated_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type institutionCreateWithoutAppsInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutAppsInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutAppsInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutAppsInput, institutionUncheckedCreateWithoutAppsInput>
  }

  export type institutionUpsertWithoutAppsInput = {
    update: XOR<institutionUpdateWithoutAppsInput, institutionUncheckedUpdateWithoutAppsInput>
    create: XOR<institutionCreateWithoutAppsInput, institutionUncheckedCreateWithoutAppsInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutAppsInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutAppsInput, institutionUncheckedUpdateWithoutAppsInput>
  }

  export type institutionUpdateWithoutAppsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutAppsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type sectorsCreateWithoutCategoriesInput = {
    name?: string | null
    description?: string | null
  }

  export type sectorsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    name?: string | null
    description?: string | null
  }

  export type sectorsCreateOrConnectWithoutCategoriesInput = {
    where: sectorsWhereUniqueInput
    create: XOR<sectorsCreateWithoutCategoriesInput, sectorsUncheckedCreateWithoutCategoriesInput>
  }

  export type category_search_termsCreateWithoutCategoriesInput = {
    term: string
  }

  export type category_search_termsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    term: string
  }

  export type category_search_termsCreateOrConnectWithoutCategoriesInput = {
    where: category_search_termsWhereUniqueInput
    create: XOR<category_search_termsCreateWithoutCategoriesInput, category_search_termsUncheckedCreateWithoutCategoriesInput>
  }

  export type category_search_termsCreateManyCategoriesInputEnvelope = {
    data: category_search_termsCreateManyCategoriesInput | category_search_termsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type institutionCreateWithoutCategoriesInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutCategoriesInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutCategoriesInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutCategoriesInput, institutionUncheckedCreateWithoutCategoriesInput>
  }

  export type institutionCreateManyCategoriesInputEnvelope = {
    data: institutionCreateManyCategoriesInput | institutionCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type sectorsUpsertWithoutCategoriesInput = {
    update: XOR<sectorsUpdateWithoutCategoriesInput, sectorsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<sectorsCreateWithoutCategoriesInput, sectorsUncheckedCreateWithoutCategoriesInput>
    where?: sectorsWhereInput
  }

  export type sectorsUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: sectorsWhereInput
    data: XOR<sectorsUpdateWithoutCategoriesInput, sectorsUncheckedUpdateWithoutCategoriesInput>
  }

  export type sectorsUpdateWithoutCategoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sectorsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type category_search_termsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: category_search_termsWhereUniqueInput
    update: XOR<category_search_termsUpdateWithoutCategoriesInput, category_search_termsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<category_search_termsCreateWithoutCategoriesInput, category_search_termsUncheckedCreateWithoutCategoriesInput>
  }

  export type category_search_termsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: category_search_termsWhereUniqueInput
    data: XOR<category_search_termsUpdateWithoutCategoriesInput, category_search_termsUncheckedUpdateWithoutCategoriesInput>
  }

  export type category_search_termsUpdateManyWithWhereWithoutCategoriesInput = {
    where: category_search_termsScalarWhereInput
    data: XOR<category_search_termsUpdateManyMutationInput, category_search_termsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type category_search_termsScalarWhereInput = {
    AND?: category_search_termsScalarWhereInput | category_search_termsScalarWhereInput[]
    OR?: category_search_termsScalarWhereInput[]
    NOT?: category_search_termsScalarWhereInput | category_search_termsScalarWhereInput[]
    id?: IntFilter<"category_search_terms"> | number
    category_id?: IntFilter<"category_search_terms"> | number
    term?: StringFilter<"category_search_terms"> | string
  }

  export type institutionUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: institutionWhereUniqueInput
    update: XOR<institutionUpdateWithoutCategoriesInput, institutionUncheckedUpdateWithoutCategoriesInput>
    create: XOR<institutionCreateWithoutCategoriesInput, institutionUncheckedCreateWithoutCategoriesInput>
  }

  export type institutionUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: institutionWhereUniqueInput
    data: XOR<institutionUpdateWithoutCategoriesInput, institutionUncheckedUpdateWithoutCategoriesInput>
  }

  export type institutionUpdateManyWithWhereWithoutCategoriesInput = {
    where: institutionScalarWhereInput
    data: XOR<institutionUpdateManyMutationInput, institutionUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type institutionScalarWhereInput = {
    AND?: institutionScalarWhereInput | institutionScalarWhereInput[]
    OR?: institutionScalarWhereInput[]
    NOT?: institutionScalarWhereInput | institutionScalarWhereInput[]
    id?: IntFilter<"institution"> | number
    uuid?: StringNullableFilter<"institution"> | string | null
    name?: StringFilter<"institution"> | string
    search_term?: StringNullableFilter<"institution"> | string | null
    email?: StringNullableFilter<"institution"> | string | null
    address?: StringNullableFilter<"institution"> | string | null
    phone_number?: StringNullableFilter<"institution"> | string | null
    url?: StringNullableFilter<"institution"> | string | null
    status?: IntNullableFilter<"institution"> | number | null
    created_at?: DateTimeFilter<"institution"> | Date | string
    plan?: IntNullableFilter<"institution"> | number | null
    type?: IntNullableFilter<"institution"> | number | null
    level?: IntNullableFilter<"institution"> | number | null
    parent_id?: IntNullableFilter<"institution"> | number | null
    good_ratings?: IntNullableFilter<"institution"> | number | null
    bad_ratings?: IntNullableFilter<"institution"> | number | null
    excellent_ratings?: IntNullableFilter<"institution"> | number | null
    nps?: IntNullableFilter<"institution"> | number | null
    csat?: IntNullableFilter<"institution"> | number | null
    queue_autocreation?: IntNullableFilter<"institution"> | number | null
    queue_manual_creation?: IntNullableFilter<"institution"> | number | null
    working_hours?: StringNullableFilter<"institution"> | string | null
    qms_message?: StringNullableFilter<"institution"> | string | null
    priority_list?: StringNullableFilter<"institution"> | string | null
    logo?: StringNullableFilter<"institution"> | string | null
    app_name?: StringNullableFilter<"institution"> | string | null
    allowed_context?: IntNullableFilter<"institution"> | number | null
    host_name?: StringNullableFilter<"institution"> | string | null
    membership_type?: IntFilter<"institution"> | number
    category_id?: IntNullableFilter<"institution"> | number | null
    latest_membership_renew_time?: DateTimeNullableFilter<"institution"> | Date | string | null
    description?: StringNullableFilter<"institution"> | string | null
    latitude?: StringNullableFilter<"institution"> | string | null
    longitude?: StringNullableFilter<"institution"> | string | null
    button_one?: StringNullableFilter<"institution"> | string | null
    button_two?: StringNullableFilter<"institution"> | string | null
    amenities?: StringNullableFilter<"institution"> | string | null
  }

  export type institutionCreateWithoutDeviceInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutDeviceInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutDeviceInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutDeviceInput, institutionUncheckedCreateWithoutDeviceInput>
  }

  export type qms_customerCreateWithoutDeviceInput = {
    customer_uuid: string
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    qms_ticket?: qms_ticketCreateNestedManyWithoutQms_customerInput
  }

  export type qms_customerUncheckedCreateWithoutDeviceInput = {
    id?: number
    customer_uuid: string
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    qms_ticket?: qms_ticketUncheckedCreateNestedManyWithoutQms_customerInput
  }

  export type qms_customerCreateOrConnectWithoutDeviceInput = {
    where: qms_customerWhereUniqueInput
    create: XOR<qms_customerCreateWithoutDeviceInput, qms_customerUncheckedCreateWithoutDeviceInput>
  }

  export type qms_customerCreateManyDeviceInputEnvelope = {
    data: qms_customerCreateManyDeviceInput | qms_customerCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type ratingCreateWithoutDeviceInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    service: serviceCreateNestedOneWithoutRatingInput
    rating_assets?: rating_assetsCreateNestedManyWithoutRatingInput
    tip?: tipCreateNestedManyWithoutRatingInput
  }

  export type ratingUncheckedCreateWithoutDeviceInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    service_id: number
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    rating_assets?: rating_assetsUncheckedCreateNestedManyWithoutRatingInput
    tip?: tipUncheckedCreateNestedManyWithoutRatingInput
  }

  export type ratingCreateOrConnectWithoutDeviceInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutDeviceInput, ratingUncheckedCreateWithoutDeviceInput>
  }

  export type ratingCreateManyDeviceInputEnvelope = {
    data: ratingCreateManyDeviceInput | ratingCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type tipCreateWithoutDeviceInput = {
    collection_reference_id: string
    disbursement_reference_id: string
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    rating?: ratingCreateNestedOneWithoutTipInput
  }

  export type tipUncheckedCreateWithoutDeviceInput = {
    id?: number
    collection_reference_id: string
    disbursement_reference_id: string
    rating_id?: bigint | number | null
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tipCreateOrConnectWithoutDeviceInput = {
    where: tipWhereUniqueInput
    create: XOR<tipCreateWithoutDeviceInput, tipUncheckedCreateWithoutDeviceInput>
  }

  export type tipCreateManyDeviceInputEnvelope = {
    data: tipCreateManyDeviceInput | tipCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type institutionUpsertWithoutDeviceInput = {
    update: XOR<institutionUpdateWithoutDeviceInput, institutionUncheckedUpdateWithoutDeviceInput>
    create: XOR<institutionCreateWithoutDeviceInput, institutionUncheckedCreateWithoutDeviceInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutDeviceInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutDeviceInput, institutionUncheckedUpdateWithoutDeviceInput>
  }

  export type institutionUpdateWithoutDeviceInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type qms_customerUpsertWithWhereUniqueWithoutDeviceInput = {
    where: qms_customerWhereUniqueInput
    update: XOR<qms_customerUpdateWithoutDeviceInput, qms_customerUncheckedUpdateWithoutDeviceInput>
    create: XOR<qms_customerCreateWithoutDeviceInput, qms_customerUncheckedCreateWithoutDeviceInput>
  }

  export type qms_customerUpdateWithWhereUniqueWithoutDeviceInput = {
    where: qms_customerWhereUniqueInput
    data: XOR<qms_customerUpdateWithoutDeviceInput, qms_customerUncheckedUpdateWithoutDeviceInput>
  }

  export type qms_customerUpdateManyWithWhereWithoutDeviceInput = {
    where: qms_customerScalarWhereInput
    data: XOR<qms_customerUpdateManyMutationInput, qms_customerUncheckedUpdateManyWithoutDeviceInput>
  }

  export type qms_customerScalarWhereInput = {
    AND?: qms_customerScalarWhereInput | qms_customerScalarWhereInput[]
    OR?: qms_customerScalarWhereInput[]
    NOT?: qms_customerScalarWhereInput | qms_customerScalarWhereInput[]
    id?: IntFilter<"qms_customer"> | number
    customer_uuid?: StringFilter<"qms_customer"> | string
    device_id?: IntNullableFilter<"qms_customer"> | number | null
    name?: StringFilter<"qms_customer"> | string
    phone_number?: StringNullableFilter<"qms_customer"> | string | null
    email?: StringNullableFilter<"qms_customer"> | string | null
    has_priority_service?: BoolNullableFilter<"qms_customer"> | boolean | null
    created_at?: DateTimeFilter<"qms_customer"> | Date | string
    updated_at?: DateTimeFilter<"qms_customer"> | Date | string
  }

  export type ratingUpsertWithWhereUniqueWithoutDeviceInput = {
    where: ratingWhereUniqueInput
    update: XOR<ratingUpdateWithoutDeviceInput, ratingUncheckedUpdateWithoutDeviceInput>
    create: XOR<ratingCreateWithoutDeviceInput, ratingUncheckedCreateWithoutDeviceInput>
  }

  export type ratingUpdateWithWhereUniqueWithoutDeviceInput = {
    where: ratingWhereUniqueInput
    data: XOR<ratingUpdateWithoutDeviceInput, ratingUncheckedUpdateWithoutDeviceInput>
  }

  export type ratingUpdateManyWithWhereWithoutDeviceInput = {
    where: ratingScalarWhereInput
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyWithoutDeviceInput>
  }

  export type ratingScalarWhereInput = {
    AND?: ratingScalarWhereInput | ratingScalarWhereInput[]
    OR?: ratingScalarWhereInput[]
    NOT?: ratingScalarWhereInput | ratingScalarWhereInput[]
    id?: BigIntFilter<"rating"> | bigint | number
    state?: BoolFilter<"rating"> | boolean
    time?: DateTimeFilter<"rating"> | Date | string
    service_id?: IntFilter<"rating"> | number
    comment?: StringNullableFilter<"rating"> | string | null
    gender?: IntNullableFilter<"rating"> | number | null
    age_range?: IntNullableFilter<"rating"> | number | null
    location?: IntNullableFilter<"rating"> | number | null
    device_id?: IntNullableFilter<"rating"> | number | null
    nps_score?: IntNullableFilter<"rating"> | number | null
    ticket_id?: IntNullableFilter<"rating"> | number | null
    finger_print?: StringNullableFilter<"rating"> | string | null
  }

  export type tipUpsertWithWhereUniqueWithoutDeviceInput = {
    where: tipWhereUniqueInput
    update: XOR<tipUpdateWithoutDeviceInput, tipUncheckedUpdateWithoutDeviceInput>
    create: XOR<tipCreateWithoutDeviceInput, tipUncheckedCreateWithoutDeviceInput>
  }

  export type tipUpdateWithWhereUniqueWithoutDeviceInput = {
    where: tipWhereUniqueInput
    data: XOR<tipUpdateWithoutDeviceInput, tipUncheckedUpdateWithoutDeviceInput>
  }

  export type tipUpdateManyWithWhereWithoutDeviceInput = {
    where: tipScalarWhereInput
    data: XOR<tipUpdateManyMutationInput, tipUncheckedUpdateManyWithoutDeviceInput>
  }

  export type tipScalarWhereInput = {
    AND?: tipScalarWhereInput | tipScalarWhereInput[]
    OR?: tipScalarWhereInput[]
    NOT?: tipScalarWhereInput | tipScalarWhereInput[]
    id?: IntFilter<"tip"> | number
    collection_reference_id?: StringFilter<"tip"> | string
    disbursement_reference_id?: StringFilter<"tip"> | string
    device_id?: IntFilter<"tip"> | number
    rating_id?: BigIntNullableFilter<"tip"> | bigint | number | null
    payee?: StringFilter<"tip"> | string
    payer?: StringFilter<"tip"> | string
    amount?: IntFilter<"tip"> | number
    tip_amount?: IntFilter<"tip"> | number
    collection_status?: StringNullableFilter<"tip"> | string | null
    collection_status_details?: StringNullableFilter<"tip"> | string | null
    closed_at?: DateTimeNullableFilter<"tip"> | Date | string | null
    disbursed_at?: DateTimeNullableFilter<"tip"> | Date | string | null
    disbursement_status?: StringNullableFilter<"tip"> | string | null
    disbursement_status_details?: StringNullableFilter<"tip"> | string | null
    created_at?: DateTimeFilter<"tip"> | Date | string
    updated_at?: DateTimeFilter<"tip"> | Date | string
  }

  export type appointmentsCreateWithoutInstitutionInput = {
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
    user_appointments_creator_idTouser: userCreateNestedOneWithoutAppointments_appointments_creator_idTouserInput
    qms_operator?: qms_operatorCreateNestedOneWithoutAppointmentsInput
    service?: serviceCreateNestedOneWithoutAppointmentsInput
    user_appointments_user_idTouser?: userCreateNestedOneWithoutAppointments_appointments_user_idTouserInput
  }

  export type appointmentsUncheckedCreateWithoutInstitutionInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    service_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsCreateOrConnectWithoutInstitutionInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutInstitutionInput, appointmentsUncheckedCreateWithoutInstitutionInput>
  }

  export type appointmentsCreateManyInstitutionInputEnvelope = {
    data: appointmentsCreateManyInstitutionInput | appointmentsCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type appsCreateWithoutInstitutionInput = {
    name: string
    status?: number
    secret_key?: string | null
    access_key?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type appsUncheckedCreateWithoutInstitutionInput = {
    id?: number
    name: string
    status?: number
    secret_key?: string | null
    access_key?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type appsCreateOrConnectWithoutInstitutionInput = {
    where: appsWhereUniqueInput
    create: XOR<appsCreateWithoutInstitutionInput, appsUncheckedCreateWithoutInstitutionInput>
  }

  export type appsCreateManyInstitutionInputEnvelope = {
    data: appsCreateManyInstitutionInput | appsCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type business_amenitiesCreateWithoutInstitutionInput = {
    amenities?: amenitiesCreateNestedOneWithoutBusiness_amenitiesInput
  }

  export type business_amenitiesUncheckedCreateWithoutInstitutionInput = {
    id?: number
    amenitY_id?: number | null
  }

  export type business_amenitiesCreateOrConnectWithoutInstitutionInput = {
    where: business_amenitiesWhereUniqueInput
    create: XOR<business_amenitiesCreateWithoutInstitutionInput, business_amenitiesUncheckedCreateWithoutInstitutionInput>
  }

  export type business_amenitiesCreateManyInstitutionInputEnvelope = {
    data: business_amenitiesCreateManyInstitutionInput | business_amenitiesCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type deviceCreateWithoutInstitutionInput = {
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    qms_customer?: qms_customerCreateNestedManyWithoutDeviceInput
    rating?: ratingCreateNestedManyWithoutDeviceInput
    tip?: tipCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutInstitutionInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    qms_customer?: qms_customerUncheckedCreateNestedManyWithoutDeviceInput
    rating?: ratingUncheckedCreateNestedManyWithoutDeviceInput
    tip?: tipUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutInstitutionInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutInstitutionInput, deviceUncheckedCreateWithoutInstitutionInput>
  }

  export type deviceCreateManyInstitutionInputEnvelope = {
    data: deviceCreateManyInstitutionInput | deviceCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type imagesCreateWithoutInstitutionInput = {
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    reviews?: reviewsCreateNestedOneWithoutImagesInput
    users_profile?: users_profileCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutInstitutionInput = {
    id?: number
    user_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    review_id?: number | null
  }

  export type imagesCreateOrConnectWithoutInstitutionInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutInstitutionInput, imagesUncheckedCreateWithoutInstitutionInput>
  }

  export type imagesCreateManyInstitutionInputEnvelope = {
    data: imagesCreateManyInstitutionInput | imagesCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutInstitutionInput = {
    name: string
    sectors?: sectorsCreateNestedOneWithoutCategoriesInput
    category_search_terms?: category_search_termsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutInstitutionInput = {
    id?: number
    name: string
    sector_id?: number | null
    category_search_terms?: category_search_termsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutInstitutionInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutInstitutionInput, categoriesUncheckedCreateWithoutInstitutionInput>
  }

  export type popup_questionsCreateWithoutInstitutionInput = {
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersCreateNestedManyWithoutPopup_questionsInput
  }

  export type popup_questionsUncheckedCreateWithoutInstitutionInput = {
    id?: number
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersUncheckedCreateNestedManyWithoutPopup_questionsInput
  }

  export type popup_questionsCreateOrConnectWithoutInstitutionInput = {
    where: popup_questionsWhereUniqueInput
    create: XOR<popup_questionsCreateWithoutInstitutionInput, popup_questionsUncheckedCreateWithoutInstitutionInput>
  }

  export type popup_questionsCreateManyInstitutionInputEnvelope = {
    data: popup_questionsCreateManyInstitutionInput | popup_questionsCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type price_rangesCreateWithoutInstitutionInput = {
    max_value: number
    min_value: number
    label?: string | null
  }

  export type price_rangesUncheckedCreateWithoutInstitutionInput = {
    id?: number
    max_value: number
    min_value: number
    label?: string | null
  }

  export type price_rangesCreateOrConnectWithoutInstitutionInput = {
    where: price_rangesWhereUniqueInput
    create: XOR<price_rangesCreateWithoutInstitutionInput, price_rangesUncheckedCreateWithoutInstitutionInput>
  }

  export type price_rangesCreateManyInstitutionInputEnvelope = {
    data: price_rangesCreateManyInstitutionInput | price_rangesCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type qms_branch_operatorCreateWithoutInstitutionInput = {
    service_id: string
    linked_at?: Date | string
    status?: number
    qms_operator: qms_operatorCreateNestedOneWithoutQms_branch_operatorInput
  }

  export type qms_branch_operatorUncheckedCreateWithoutInstitutionInput = {
    id?: number
    operator_id: number
    service_id: string
    linked_at?: Date | string
    status?: number
  }

  export type qms_branch_operatorCreateOrConnectWithoutInstitutionInput = {
    where: qms_branch_operatorWhereUniqueInput
    create: XOR<qms_branch_operatorCreateWithoutInstitutionInput, qms_branch_operatorUncheckedCreateWithoutInstitutionInput>
  }

  export type qms_branch_operatorCreateManyInstitutionInputEnvelope = {
    data: qms_branch_operatorCreateManyInstitutionInput | qms_branch_operatorCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type qms_branch_transactionsCreateWithoutInstitutionInput = {
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_branch_transactionsInput
  }

  export type qms_branch_transactionsUncheckedCreateWithoutInstitutionInput = {
    id?: number
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_branch_transactionsInput
  }

  export type qms_branch_transactionsCreateOrConnectWithoutInstitutionInput = {
    where: qms_branch_transactionsWhereUniqueInput
    create: XOR<qms_branch_transactionsCreateWithoutInstitutionInput, qms_branch_transactionsUncheckedCreateWithoutInstitutionInput>
  }

  export type qms_branch_transactionsCreateManyInstitutionInputEnvelope = {
    data: qms_branch_transactionsCreateManyInstitutionInput | qms_branch_transactionsCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type qms_operatorCreateWithoutInstitutionInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateWithoutInstitutionInput = {
    id?: number
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorCreateOrConnectWithoutInstitutionInput = {
    where: qms_operatorWhereUniqueInput
    create: XOR<qms_operatorCreateWithoutInstitutionInput, qms_operatorUncheckedCreateWithoutInstitutionInput>
  }

  export type qms_operatorCreateManyInstitutionInputEnvelope = {
    data: qms_operatorCreateManyInstitutionInput | qms_operatorCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutInstitutionInput = {
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    images?: imagesCreateNestedManyWithoutReviewsInput
    users_profile: users_profileCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutInstitutionInput = {
    id?: number
    user_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    images?: imagesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutInstitutionInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutInstitutionInput, reviewsUncheckedCreateWithoutInstitutionInput>
  }

  export type reviewsCreateManyInstitutionInputEnvelope = {
    data: reviewsCreateManyInstitutionInput | reviewsCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type serviceCreateWithoutInstitutionInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueCreateNestedManyWithoutServiceInput
    rating?: ratingCreateNestedManyWithoutServiceInput
    service_group?: service_groupCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutInstitutionInput = {
    id?: number
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterUncheckedCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueUncheckedCreateNestedManyWithoutServiceInput
    rating?: ratingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutInstitutionInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutInstitutionInput, serviceUncheckedCreateWithoutInstitutionInput>
  }

  export type serviceCreateManyInstitutionInputEnvelope = {
    data: serviceCreateManyInstitutionInput | serviceCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type service_groupCreateWithoutInstitutionInput = {
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceCreateNestedManyWithoutService_groupInput
    serviceReview?: serviceReviewCreateNestedManyWithoutService_groupInput
    surveyQuestions?: surveyQuestionsCreateNestedManyWithoutService_groupInput
  }

  export type service_groupUncheckedCreateWithoutInstitutionInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceUncheckedCreateNestedManyWithoutService_groupInput
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutService_groupInput
    surveyQuestions?: surveyQuestionsUncheckedCreateNestedManyWithoutService_groupInput
  }

  export type service_groupCreateOrConnectWithoutInstitutionInput = {
    where: service_groupWhereUniqueInput
    create: XOR<service_groupCreateWithoutInstitutionInput, service_groupUncheckedCreateWithoutInstitutionInput>
  }

  export type service_groupCreateManyInstitutionInputEnvelope = {
    data: service_groupCreateManyInstitutionInput | service_groupCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type workingHourCreateWithoutInstitutionInput = {
    day_of_week: string
    open_time?: Date | string | null
    close_time?: Date | string | null
  }

  export type workingHourUncheckedCreateWithoutInstitutionInput = {
    id?: number
    day_of_week: string
    open_time?: Date | string | null
    close_time?: Date | string | null
  }

  export type workingHourCreateOrConnectWithoutInstitutionInput = {
    where: workingHourWhereUniqueInput
    create: XOR<workingHourCreateWithoutInstitutionInput, workingHourUncheckedCreateWithoutInstitutionInput>
  }

  export type workingHourCreateManyInstitutionInputEnvelope = {
    data: workingHourCreateManyInstitutionInput | workingHourCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutInstitutionInput, appointmentsUncheckedUpdateWithoutInstitutionInput>
    create: XOR<appointmentsCreateWithoutInstitutionInput, appointmentsUncheckedCreateWithoutInstitutionInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutInstitutionInput, appointmentsUncheckedUpdateWithoutInstitutionInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutInstitutionInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type appointmentsScalarWhereInput = {
    AND?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
    OR?: appointmentsScalarWhereInput[]
    NOT?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
    id?: IntFilter<"appointments"> | number
    name?: StringNullableFilter<"appointments"> | string | null
    email?: StringNullableFilter<"appointments"> | string | null
    phone?: StringFilter<"appointments"> | string
    registry_type?: IntFilter<"appointments"> | number
    institution_id?: IntNullableFilter<"appointments"> | number | null
    service_id?: IntNullableFilter<"appointments"> | number | null
    operator_id?: IntNullableFilter<"appointments"> | number | null
    user_id?: IntNullableFilter<"appointments"> | number | null
    reason?: StringFilter<"appointments"> | string
    date?: DateTimeFilter<"appointments"> | Date | string
    start_time?: DateTimeFilter<"appointments"> | Date | string
    end_time?: DateTimeFilter<"appointments"> | Date | string
    location?: StringFilter<"appointments"> | string
    additional_note?: StringFilter<"appointments"> | string
    creator_id?: IntFilter<"appointments"> | number
    recurring?: IntNullableFilter<"appointments"> | number | null
    notification_status?: IntNullableFilter<"appointments"> | number | null
    ticket_created?: IntNullableFilter<"appointments"> | number | null
    appointment_cancelled?: IntNullableFilter<"appointments"> | number | null
    created_at?: DateTimeNullableFilter<"appointments"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"appointments"> | string | null
  }

  export type appsUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: appsWhereUniqueInput
    update: XOR<appsUpdateWithoutInstitutionInput, appsUncheckedUpdateWithoutInstitutionInput>
    create: XOR<appsCreateWithoutInstitutionInput, appsUncheckedCreateWithoutInstitutionInput>
  }

  export type appsUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: appsWhereUniqueInput
    data: XOR<appsUpdateWithoutInstitutionInput, appsUncheckedUpdateWithoutInstitutionInput>
  }

  export type appsUpdateManyWithWhereWithoutInstitutionInput = {
    where: appsScalarWhereInput
    data: XOR<appsUpdateManyMutationInput, appsUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type appsScalarWhereInput = {
    AND?: appsScalarWhereInput | appsScalarWhereInput[]
    OR?: appsScalarWhereInput[]
    NOT?: appsScalarWhereInput | appsScalarWhereInput[]
    id?: IntFilter<"apps"> | number
    name?: StringFilter<"apps"> | string
    status?: IntFilter<"apps"> | number
    institution_id?: IntFilter<"apps"> | number
    secret_key?: StringNullableFilter<"apps"> | string | null
    access_key?: StringNullableFilter<"apps"> | string | null
    created_at?: DateTimeNullableFilter<"apps"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"apps"> | Date | string | null
  }

  export type business_amenitiesUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: business_amenitiesWhereUniqueInput
    update: XOR<business_amenitiesUpdateWithoutInstitutionInput, business_amenitiesUncheckedUpdateWithoutInstitutionInput>
    create: XOR<business_amenitiesCreateWithoutInstitutionInput, business_amenitiesUncheckedCreateWithoutInstitutionInput>
  }

  export type business_amenitiesUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: business_amenitiesWhereUniqueInput
    data: XOR<business_amenitiesUpdateWithoutInstitutionInput, business_amenitiesUncheckedUpdateWithoutInstitutionInput>
  }

  export type business_amenitiesUpdateManyWithWhereWithoutInstitutionInput = {
    where: business_amenitiesScalarWhereInput
    data: XOR<business_amenitiesUpdateManyMutationInput, business_amenitiesUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type business_amenitiesScalarWhereInput = {
    AND?: business_amenitiesScalarWhereInput | business_amenitiesScalarWhereInput[]
    OR?: business_amenitiesScalarWhereInput[]
    NOT?: business_amenitiesScalarWhereInput | business_amenitiesScalarWhereInput[]
    id?: IntFilter<"business_amenities"> | number
    institution_id?: IntNullableFilter<"business_amenities"> | number | null
    amenitY_id?: IntNullableFilter<"business_amenities"> | number | null
  }

  export type deviceUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: deviceWhereUniqueInput
    update: XOR<deviceUpdateWithoutInstitutionInput, deviceUncheckedUpdateWithoutInstitutionInput>
    create: XOR<deviceCreateWithoutInstitutionInput, deviceUncheckedCreateWithoutInstitutionInput>
  }

  export type deviceUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: deviceWhereUniqueInput
    data: XOR<deviceUpdateWithoutInstitutionInput, deviceUncheckedUpdateWithoutInstitutionInput>
  }

  export type deviceUpdateManyWithWhereWithoutInstitutionInput = {
    where: deviceScalarWhereInput
    data: XOR<deviceUpdateManyMutationInput, deviceUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type deviceScalarWhereInput = {
    AND?: deviceScalarWhereInput | deviceScalarWhereInput[]
    OR?: deviceScalarWhereInput[]
    NOT?: deviceScalarWhereInput | deviceScalarWhereInput[]
    id?: IntFilter<"device"> | number
    uuid?: StringNullableFilter<"device"> | string | null
    notification_token?: StringNullableFilter<"device"> | string | null
    affiliate_id?: IntNullableFilter<"device"> | number | null
    service_id?: StringNullableFilter<"device"> | string | null
    serial_number?: StringNullableFilter<"device"> | string | null
    status?: IntFilter<"device"> | number
    created_at?: DateTimeFilter<"device"> | Date | string
    device_type?: IntFilter<"device"> | number
    gender?: IntNullableFilter<"device"> | number | null
    age_range?: IntNullableFilter<"device"> | number | null
    language?: IntNullableFilter<"device"> | number | null
    notification_enabled?: BoolNullableFilter<"device"> | boolean | null
    apiKey?: StringNullableFilter<"device"> | string | null
    nonce?: IntNullableFilter<"device"> | number | null
    linkShortCode?: StringNullableFilter<"device"> | string | null
    linkShortCodeExp?: DateTimeNullableFilter<"device"> | Date | string | null
    phone_number?: StringNullableFilter<"device"> | string | null
    latest_hb?: DateTimeNullableFilter<"device"> | Date | string | null
    latest_hb_version?: StringNullableFilter<"device"> | string | null
    updated_at?: DateTimeFilter<"device"> | Date | string
  }

  export type imagesUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutInstitutionInput, imagesUncheckedUpdateWithoutInstitutionInput>
    create: XOR<imagesCreateWithoutInstitutionInput, imagesUncheckedCreateWithoutInstitutionInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutInstitutionInput, imagesUncheckedUpdateWithoutInstitutionInput>
  }

  export type imagesUpdateManyWithWhereWithoutInstitutionInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type imagesScalarWhereInput = {
    AND?: imagesScalarWhereInput | imagesScalarWhereInput[]
    OR?: imagesScalarWhereInput[]
    NOT?: imagesScalarWhereInput | imagesScalarWhereInput[]
    id?: IntFilter<"images"> | number
    institution_id?: IntNullableFilter<"images"> | number | null
    user_id?: IntNullableFilter<"images"> | number | null
    type?: StringNullableFilter<"images"> | string | null
    image_url?: StringNullableFilter<"images"> | string | null
    caption?: StringNullableFilter<"images"> | string | null
    uploaded_at?: DateTimeFilter<"images"> | Date | string
    review_id?: IntNullableFilter<"images"> | number | null
  }

  export type categoriesUpsertWithoutInstitutionInput = {
    update: XOR<categoriesUpdateWithoutInstitutionInput, categoriesUncheckedUpdateWithoutInstitutionInput>
    create: XOR<categoriesCreateWithoutInstitutionInput, categoriesUncheckedCreateWithoutInstitutionInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutInstitutionInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutInstitutionInput, categoriesUncheckedUpdateWithoutInstitutionInput>
  }

  export type categoriesUpdateWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    sectors?: sectorsUpdateOneWithoutCategoriesNestedInput
    category_search_terms?: category_search_termsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_search_terms?: category_search_termsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type popup_questionsUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: popup_questionsWhereUniqueInput
    update: XOR<popup_questionsUpdateWithoutInstitutionInput, popup_questionsUncheckedUpdateWithoutInstitutionInput>
    create: XOR<popup_questionsCreateWithoutInstitutionInput, popup_questionsUncheckedCreateWithoutInstitutionInput>
  }

  export type popup_questionsUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: popup_questionsWhereUniqueInput
    data: XOR<popup_questionsUpdateWithoutInstitutionInput, popup_questionsUncheckedUpdateWithoutInstitutionInput>
  }

  export type popup_questionsUpdateManyWithWhereWithoutInstitutionInput = {
    where: popup_questionsScalarWhereInput
    data: XOR<popup_questionsUpdateManyMutationInput, popup_questionsUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type popup_questionsScalarWhereInput = {
    AND?: popup_questionsScalarWhereInput | popup_questionsScalarWhereInput[]
    OR?: popup_questionsScalarWhereInput[]
    NOT?: popup_questionsScalarWhereInput | popup_questionsScalarWhereInput[]
    id?: IntFilter<"popup_questions"> | number
    name_en?: StringFilter<"popup_questions"> | string
    name_fr?: StringNullableFilter<"popup_questions"> | string | null
    name_rw?: StringNullableFilter<"popup_questions"> | string | null
    name_sw?: StringNullableFilter<"popup_questions"> | string | null
    service_id?: StringFilter<"popup_questions"> | string
    description_en?: StringFilter<"popup_questions"> | string
    description_fr?: StringNullableFilter<"popup_questions"> | string | null
    description_rw?: StringNullableFilter<"popup_questions"> | string | null
    description_sw?: StringNullableFilter<"popup_questions"> | string | null
    applies_to_bad?: BoolFilter<"popup_questions"> | boolean
    applies_to_good?: BoolFilter<"popup_questions"> | boolean
    applies_to_excellent?: BoolFilter<"popup_questions"> | boolean
    institution_id?: IntFilter<"popup_questions"> | number
    status?: BoolNullableFilter<"popup_questions"> | boolean | null
    type?: IntNullableFilter<"popup_questions"> | number | null
    created_at?: DateTimeFilter<"popup_questions"> | Date | string
    updated_at?: DateTimeFilter<"popup_questions"> | Date | string
  }

  export type price_rangesUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: price_rangesWhereUniqueInput
    update: XOR<price_rangesUpdateWithoutInstitutionInput, price_rangesUncheckedUpdateWithoutInstitutionInput>
    create: XOR<price_rangesCreateWithoutInstitutionInput, price_rangesUncheckedCreateWithoutInstitutionInput>
  }

  export type price_rangesUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: price_rangesWhereUniqueInput
    data: XOR<price_rangesUpdateWithoutInstitutionInput, price_rangesUncheckedUpdateWithoutInstitutionInput>
  }

  export type price_rangesUpdateManyWithWhereWithoutInstitutionInput = {
    where: price_rangesScalarWhereInput
    data: XOR<price_rangesUpdateManyMutationInput, price_rangesUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type price_rangesScalarWhereInput = {
    AND?: price_rangesScalarWhereInput | price_rangesScalarWhereInput[]
    OR?: price_rangesScalarWhereInput[]
    NOT?: price_rangesScalarWhereInput | price_rangesScalarWhereInput[]
    id?: IntFilter<"price_ranges"> | number
    max_value?: IntFilter<"price_ranges"> | number
    min_value?: IntFilter<"price_ranges"> | number
    institution_id?: IntFilter<"price_ranges"> | number
    label?: StringNullableFilter<"price_ranges"> | string | null
  }

  export type qms_branch_operatorUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: qms_branch_operatorWhereUniqueInput
    update: XOR<qms_branch_operatorUpdateWithoutInstitutionInput, qms_branch_operatorUncheckedUpdateWithoutInstitutionInput>
    create: XOR<qms_branch_operatorCreateWithoutInstitutionInput, qms_branch_operatorUncheckedCreateWithoutInstitutionInput>
  }

  export type qms_branch_operatorUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: qms_branch_operatorWhereUniqueInput
    data: XOR<qms_branch_operatorUpdateWithoutInstitutionInput, qms_branch_operatorUncheckedUpdateWithoutInstitutionInput>
  }

  export type qms_branch_operatorUpdateManyWithWhereWithoutInstitutionInput = {
    where: qms_branch_operatorScalarWhereInput
    data: XOR<qms_branch_operatorUpdateManyMutationInput, qms_branch_operatorUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type qms_branch_operatorScalarWhereInput = {
    AND?: qms_branch_operatorScalarWhereInput | qms_branch_operatorScalarWhereInput[]
    OR?: qms_branch_operatorScalarWhereInput[]
    NOT?: qms_branch_operatorScalarWhereInput | qms_branch_operatorScalarWhereInput[]
    id?: IntFilter<"qms_branch_operator"> | number
    operator_id?: IntFilter<"qms_branch_operator"> | number
    institution_id?: IntFilter<"qms_branch_operator"> | number
    service_id?: StringFilter<"qms_branch_operator"> | string
    linked_at?: DateTimeFilter<"qms_branch_operator"> | Date | string
    status?: IntFilter<"qms_branch_operator"> | number
  }

  export type qms_branch_transactionsUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: qms_branch_transactionsWhereUniqueInput
    update: XOR<qms_branch_transactionsUpdateWithoutInstitutionInput, qms_branch_transactionsUncheckedUpdateWithoutInstitutionInput>
    create: XOR<qms_branch_transactionsCreateWithoutInstitutionInput, qms_branch_transactionsUncheckedCreateWithoutInstitutionInput>
  }

  export type qms_branch_transactionsUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: qms_branch_transactionsWhereUniqueInput
    data: XOR<qms_branch_transactionsUpdateWithoutInstitutionInput, qms_branch_transactionsUncheckedUpdateWithoutInstitutionInput>
  }

  export type qms_branch_transactionsUpdateManyWithWhereWithoutInstitutionInput = {
    where: qms_branch_transactionsScalarWhereInput
    data: XOR<qms_branch_transactionsUpdateManyMutationInput, qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type qms_branch_transactionsScalarWhereInput = {
    AND?: qms_branch_transactionsScalarWhereInput | qms_branch_transactionsScalarWhereInput[]
    OR?: qms_branch_transactionsScalarWhereInput[]
    NOT?: qms_branch_transactionsScalarWhereInput | qms_branch_transactionsScalarWhereInput[]
    id?: IntFilter<"qms_branch_transactions"> | number
    affiliate_id?: IntFilter<"qms_branch_transactions"> | number
    date?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    note?: StringNullableFilter<"qms_branch_transactions"> | string | null
    created_at?: DateTimeFilter<"qms_branch_transactions"> | Date | string
    last_updated?: DateTimeFilter<"qms_branch_transactions"> | Date | string
  }

  export type qms_operatorUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: qms_operatorWhereUniqueInput
    update: XOR<qms_operatorUpdateWithoutInstitutionInput, qms_operatorUncheckedUpdateWithoutInstitutionInput>
    create: XOR<qms_operatorCreateWithoutInstitutionInput, qms_operatorUncheckedCreateWithoutInstitutionInput>
  }

  export type qms_operatorUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: qms_operatorWhereUniqueInput
    data: XOR<qms_operatorUpdateWithoutInstitutionInput, qms_operatorUncheckedUpdateWithoutInstitutionInput>
  }

  export type qms_operatorUpdateManyWithWhereWithoutInstitutionInput = {
    where: qms_operatorScalarWhereInput
    data: XOR<qms_operatorUpdateManyMutationInput, qms_operatorUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type qms_operatorScalarWhereInput = {
    AND?: qms_operatorScalarWhereInput | qms_operatorScalarWhereInput[]
    OR?: qms_operatorScalarWhereInput[]
    NOT?: qms_operatorScalarWhereInput | qms_operatorScalarWhereInput[]
    id?: IntFilter<"qms_operator"> | number
    operator_uuid?: StringFilter<"qms_operator"> | string
    institution_id?: IntNullableFilter<"qms_operator"> | number | null
    name?: StringFilter<"qms_operator"> | string
    username?: StringFilter<"qms_operator"> | string
    password_hash?: StringNullableFilter<"qms_operator"> | string | null
    is_active?: BoolFilter<"qms_operator"> | boolean
    created_at?: DateTimeFilter<"qms_operator"> | Date | string
    updated_at?: DateTimeFilter<"qms_operator"> | Date | string
    email_address?: StringFilter<"qms_operator"> | string
    phone_number?: StringNullableFilter<"qms_operator"> | string | null
    terminal?: BoolNullableFilter<"qms_operator"> | boolean | null
  }

  export type reviewsUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutInstitutionInput, reviewsUncheckedUpdateWithoutInstitutionInput>
    create: XOR<reviewsCreateWithoutInstitutionInput, reviewsUncheckedCreateWithoutInstitutionInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutInstitutionInput, reviewsUncheckedUpdateWithoutInstitutionInput>
  }

  export type reviewsUpdateManyWithWhereWithoutInstitutionInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type reviewsScalarWhereInput = {
    AND?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    OR?: reviewsScalarWhereInput[]
    NOT?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    id?: IntFilter<"reviews"> | number
    user_id?: IntFilter<"reviews"> | number
    institution_id?: IntFilter<"reviews"> | number
    rating?: IntFilter<"reviews"> | number
    review?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeFilter<"reviews"> | Date | string
    is_approved?: BoolNullableFilter<"reviews"> | boolean | null
  }

  export type serviceUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: serviceWhereUniqueInput
    update: XOR<serviceUpdateWithoutInstitutionInput, serviceUncheckedUpdateWithoutInstitutionInput>
    create: XOR<serviceCreateWithoutInstitutionInput, serviceUncheckedCreateWithoutInstitutionInput>
  }

  export type serviceUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: serviceWhereUniqueInput
    data: XOR<serviceUpdateWithoutInstitutionInput, serviceUncheckedUpdateWithoutInstitutionInput>
  }

  export type serviceUpdateManyWithWhereWithoutInstitutionInput = {
    where: serviceScalarWhereInput
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type serviceScalarWhereInput = {
    AND?: serviceScalarWhereInput | serviceScalarWhereInput[]
    OR?: serviceScalarWhereInput[]
    NOT?: serviceScalarWhereInput | serviceScalarWhereInput[]
    id?: IntFilter<"service"> | number
    institution_id?: IntNullableFilter<"service"> | number | null
    status?: IntNullableFilter<"service"> | number | null
    created_at?: DateTimeFilter<"service"> | Date | string
    bad_rating_threshold?: IntNullableFilter<"service"> | number | null
    group?: IntNullableFilter<"service"> | number | null
    good_ratings?: IntNullableFilter<"service"> | number | null
    bad_ratings?: IntNullableFilter<"service"> | number | null
    excellent_ratings?: IntNullableFilter<"service"> | number | null
    nps?: IntNullableFilter<"service"> | number | null
    csat?: IntNullableFilter<"service"> | number | null
    mean_service_time?: IntNullableFilter<"service"> | number | null
    avg_service_time?: FloatNullableFilter<"service"> | number | null
    uuid?: StringNullableFilter<"service"> | string | null
    inter_arrival_time?: FloatNullableFilter<"service"> | number | null
    estimated_time?: FloatNullableFilter<"service"> | number | null
  }

  export type service_groupUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: service_groupWhereUniqueInput
    update: XOR<service_groupUpdateWithoutInstitutionInput, service_groupUncheckedUpdateWithoutInstitutionInput>
    create: XOR<service_groupCreateWithoutInstitutionInput, service_groupUncheckedCreateWithoutInstitutionInput>
  }

  export type service_groupUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: service_groupWhereUniqueInput
    data: XOR<service_groupUpdateWithoutInstitutionInput, service_groupUncheckedUpdateWithoutInstitutionInput>
  }

  export type service_groupUpdateManyWithWhereWithoutInstitutionInput = {
    where: service_groupScalarWhereInput
    data: XOR<service_groupUpdateManyMutationInput, service_groupUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type service_groupScalarWhereInput = {
    AND?: service_groupScalarWhereInput | service_groupScalarWhereInput[]
    OR?: service_groupScalarWhereInput[]
    NOT?: service_groupScalarWhereInput | service_groupScalarWhereInput[]
    id?: IntFilter<"service_group"> | number
    name?: StringFilter<"service_group"> | string
    name_rw?: StringNullableFilter<"service_group"> | string | null
    name_fr?: StringNullableFilter<"service_group"> | string | null
    name_sw?: StringNullableFilter<"service_group"> | string | null
    search_term?: StringNullableFilter<"service_group"> | string | null
    institution_id?: IntFilter<"service_group"> | number
    created_at?: DateTimeFilter<"service_group"> | Date | string
    updated_at?: DateTimeFilter<"service_group"> | Date | string
    uuid?: StringNullableFilter<"service_group"> | string | null
    status?: IntNullableFilter<"service_group"> | number | null
    good_ratings?: IntNullableFilter<"service_group"> | number | null
    bad_ratings?: IntNullableFilter<"service_group"> | number | null
    excellent_ratings?: IntNullableFilter<"service_group"> | number | null
    nps?: IntNullableFilter<"service_group"> | number | null
    csat?: IntNullableFilter<"service_group"> | number | null
    mean_service_time?: IntNullableFilter<"service_group"> | number | null
    ticket_prefix?: StringNullableFilter<"service_group"> | string | null
    bad_rating_threshold?: IntNullableFilter<"service_group"> | number | null
  }

  export type workingHourUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: workingHourWhereUniqueInput
    update: XOR<workingHourUpdateWithoutInstitutionInput, workingHourUncheckedUpdateWithoutInstitutionInput>
    create: XOR<workingHourCreateWithoutInstitutionInput, workingHourUncheckedCreateWithoutInstitutionInput>
  }

  export type workingHourUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: workingHourWhereUniqueInput
    data: XOR<workingHourUpdateWithoutInstitutionInput, workingHourUncheckedUpdateWithoutInstitutionInput>
  }

  export type workingHourUpdateManyWithWhereWithoutInstitutionInput = {
    where: workingHourScalarWhereInput
    data: XOR<workingHourUpdateManyMutationInput, workingHourUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type workingHourScalarWhereInput = {
    AND?: workingHourScalarWhereInput | workingHourScalarWhereInput[]
    OR?: workingHourScalarWhereInput[]
    NOT?: workingHourScalarWhereInput | workingHourScalarWhereInput[]
    id?: IntFilter<"workingHour"> | number
    institution_id?: IntFilter<"workingHour"> | number
    day_of_week?: StringFilter<"workingHour"> | string
    open_time?: DateTimeNullableFilter<"workingHour"> | Date | string | null
    close_time?: DateTimeNullableFilter<"workingHour"> | Date | string | null
  }

  export type qms_ticketCreateWithoutOptionInput = {
    ticket_uuid: string
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    qms_customer: qms_customerCreateNestedOneWithoutQms_ticketInput
    qms_queue: qms_queueCreateNestedOneWithoutQms_ticketInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketUncheckedCreateWithoutOptionInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketCreateOrConnectWithoutOptionInput = {
    where: qms_ticketWhereUniqueInput
    create: XOR<qms_ticketCreateWithoutOptionInput, qms_ticketUncheckedCreateWithoutOptionInput>
  }

  export type qms_ticketCreateManyOptionInputEnvelope = {
    data: qms_ticketCreateManyOptionInput | qms_ticketCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type qms_ticketUpsertWithWhereUniqueWithoutOptionInput = {
    where: qms_ticketWhereUniqueInput
    update: XOR<qms_ticketUpdateWithoutOptionInput, qms_ticketUncheckedUpdateWithoutOptionInput>
    create: XOR<qms_ticketCreateWithoutOptionInput, qms_ticketUncheckedCreateWithoutOptionInput>
  }

  export type qms_ticketUpdateWithWhereUniqueWithoutOptionInput = {
    where: qms_ticketWhereUniqueInput
    data: XOR<qms_ticketUpdateWithoutOptionInput, qms_ticketUncheckedUpdateWithoutOptionInput>
  }

  export type qms_ticketUpdateManyWithWhereWithoutOptionInput = {
    where: qms_ticketScalarWhereInput
    data: XOR<qms_ticketUpdateManyMutationInput, qms_ticketUncheckedUpdateManyWithoutOptionInput>
  }

  export type qms_ticketScalarWhereInput = {
    AND?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
    OR?: qms_ticketScalarWhereInput[]
    NOT?: qms_ticketScalarWhereInput | qms_ticketScalarWhereInput[]
    id?: IntFilter<"qms_ticket"> | number
    ticket_uuid?: StringFilter<"qms_ticket"> | string
    queue_id?: IntFilter<"qms_ticket"> | number
    customer_id?: IntFilter<"qms_ticket"> | number
    ticket_number?: StringFilter<"qms_ticket"> | string
    full_ticket_number?: StringNullableFilter<"qms_ticket"> | string | null
    pin?: IntFilter<"qms_ticket"> | number
    status?: IntNullableFilter<"qms_ticket"> | number | null
    service_time?: FloatNullableFilter<"qms_ticket"> | number | null
    estimated_waiting_time?: IntNullableFilter<"qms_ticket"> | number | null
    created_at?: DateTimeFilter<"qms_ticket"> | Date | string
    waiting_ended_on?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    skipped_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    cancelled_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    on_hold_from?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    skips_count?: IntNullableFilter<"qms_ticket"> | number | null
    prioritized?: BoolNullableFilter<"qms_ticket"> | boolean | null
    reason_id?: IntNullableFilter<"qms_ticket"> | number | null
    prioritized_at?: DateTimeNullableFilter<"qms_ticket"> | Date | string | null
    is_next?: BoolNullableFilter<"qms_ticket"> | boolean | null
    prev_ticket_id?: IntNullableFilter<"qms_ticket"> | number | null
    rating_notification_sent?: IntFilter<"qms_ticket"> | number
    source?: IntFilter<"qms_ticket"> | number
  }

  export type institutionCreateWithoutPopup_questionsInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutPopup_questionsInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutPopup_questionsInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutPopup_questionsInput, institutionUncheckedCreateWithoutPopup_questionsInput>
  }

  export type popup_questions_possible_answersCreateWithoutPopup_questionsInput = {
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
    popup_questions_answers?: popup_questions_answersCreateNestedManyWithoutPopup_questions_possible_answersInput
  }

  export type popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput = {
    id?: number
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
    popup_questions_answers?: popup_questions_answersUncheckedCreateNestedManyWithoutPopup_questions_possible_answersInput
  }

  export type popup_questions_possible_answersCreateOrConnectWithoutPopup_questionsInput = {
    where: popup_questions_possible_answersWhereUniqueInput
    create: XOR<popup_questions_possible_answersCreateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput>
  }

  export type popup_questions_possible_answersCreateManyPopup_questionsInputEnvelope = {
    data: popup_questions_possible_answersCreateManyPopup_questionsInput | popup_questions_possible_answersCreateManyPopup_questionsInput[]
    skipDuplicates?: boolean
  }

  export type institutionUpsertWithoutPopup_questionsInput = {
    update: XOR<institutionUpdateWithoutPopup_questionsInput, institutionUncheckedUpdateWithoutPopup_questionsInput>
    create: XOR<institutionCreateWithoutPopup_questionsInput, institutionUncheckedCreateWithoutPopup_questionsInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutPopup_questionsInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutPopup_questionsInput, institutionUncheckedUpdateWithoutPopup_questionsInput>
  }

  export type institutionUpdateWithoutPopup_questionsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutPopup_questionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type popup_questions_possible_answersUpsertWithWhereUniqueWithoutPopup_questionsInput = {
    where: popup_questions_possible_answersWhereUniqueInput
    update: XOR<popup_questions_possible_answersUpdateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedUpdateWithoutPopup_questionsInput>
    create: XOR<popup_questions_possible_answersCreateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questionsInput>
  }

  export type popup_questions_possible_answersUpdateWithWhereUniqueWithoutPopup_questionsInput = {
    where: popup_questions_possible_answersWhereUniqueInput
    data: XOR<popup_questions_possible_answersUpdateWithoutPopup_questionsInput, popup_questions_possible_answersUncheckedUpdateWithoutPopup_questionsInput>
  }

  export type popup_questions_possible_answersUpdateManyWithWhereWithoutPopup_questionsInput = {
    where: popup_questions_possible_answersScalarWhereInput
    data: XOR<popup_questions_possible_answersUpdateManyMutationInput, popup_questions_possible_answersUncheckedUpdateManyWithoutPopup_questionsInput>
  }

  export type popup_questions_possible_answersScalarWhereInput = {
    AND?: popup_questions_possible_answersScalarWhereInput | popup_questions_possible_answersScalarWhereInput[]
    OR?: popup_questions_possible_answersScalarWhereInput[]
    NOT?: popup_questions_possible_answersScalarWhereInput | popup_questions_possible_answersScalarWhereInput[]
    id?: IntFilter<"popup_questions_possible_answers"> | number
    popup_question_id?: IntFilter<"popup_questions_possible_answers"> | number
    answer_en?: StringFilter<"popup_questions_possible_answers"> | string
    answer_fr?: StringFilter<"popup_questions_possible_answers"> | string
    answer_rw?: StringFilter<"popup_questions_possible_answers"> | string
    answer_sw?: StringFilter<"popup_questions_possible_answers"> | string
    created_at?: DateTimeFilter<"popup_questions_possible_answers"> | Date | string
    updated_at?: DateTimeFilter<"popup_questions_possible_answers"> | Date | string
    priority?: IntNullableFilter<"popup_questions_possible_answers"> | number | null
  }

  export type popup_questions_possible_answersCreateWithoutPopup_questions_answersInput = {
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
    popup_questions: popup_questionsCreateNestedOneWithoutPopup_questions_possible_answersInput
  }

  export type popup_questions_possible_answersUncheckedCreateWithoutPopup_questions_answersInput = {
    id?: number
    popup_question_id: number
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
  }

  export type popup_questions_possible_answersCreateOrConnectWithoutPopup_questions_answersInput = {
    where: popup_questions_possible_answersWhereUniqueInput
    create: XOR<popup_questions_possible_answersCreateWithoutPopup_questions_answersInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questions_answersInput>
  }

  export type popup_questions_possible_answersUpsertWithoutPopup_questions_answersInput = {
    update: XOR<popup_questions_possible_answersUpdateWithoutPopup_questions_answersInput, popup_questions_possible_answersUncheckedUpdateWithoutPopup_questions_answersInput>
    create: XOR<popup_questions_possible_answersCreateWithoutPopup_questions_answersInput, popup_questions_possible_answersUncheckedCreateWithoutPopup_questions_answersInput>
    where?: popup_questions_possible_answersWhereInput
  }

  export type popup_questions_possible_answersUpdateToOneWithWhereWithoutPopup_questions_answersInput = {
    where?: popup_questions_possible_answersWhereInput
    data: XOR<popup_questions_possible_answersUpdateWithoutPopup_questions_answersInput, popup_questions_possible_answersUncheckedUpdateWithoutPopup_questions_answersInput>
  }

  export type popup_questions_possible_answersUpdateWithoutPopup_questions_answersInput = {
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    popup_questions?: popup_questionsUpdateOneRequiredWithoutPopup_questions_possible_answersNestedInput
  }

  export type popup_questions_possible_answersUncheckedUpdateWithoutPopup_questions_answersInput = {
    id?: IntFieldUpdateOperationsInput | number
    popup_question_id?: IntFieldUpdateOperationsInput | number
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type popup_questions_answersCreateWithoutPopup_questions_possible_answersInput = {
    device_id: number
    rating_id?: number | null
    ticket_id?: number | null
    answered_at?: Date | string
  }

  export type popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput = {
    id?: number
    device_id: number
    rating_id?: number | null
    ticket_id?: number | null
    answered_at?: Date | string
  }

  export type popup_questions_answersCreateOrConnectWithoutPopup_questions_possible_answersInput = {
    where: popup_questions_answersWhereUniqueInput
    create: XOR<popup_questions_answersCreateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questions_answersCreateManyPopup_questions_possible_answersInputEnvelope = {
    data: popup_questions_answersCreateManyPopup_questions_possible_answersInput | popup_questions_answersCreateManyPopup_questions_possible_answersInput[]
    skipDuplicates?: boolean
  }

  export type popup_questionsCreateWithoutPopup_questions_possible_answersInput = {
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    institution: institutionCreateNestedOneWithoutPopup_questionsInput
  }

  export type popup_questionsUncheckedCreateWithoutPopup_questions_possible_answersInput = {
    id?: number
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    institution_id: number
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type popup_questionsCreateOrConnectWithoutPopup_questions_possible_answersInput = {
    where: popup_questionsWhereUniqueInput
    create: XOR<popup_questionsCreateWithoutPopup_questions_possible_answersInput, popup_questionsUncheckedCreateWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questions_answersUpsertWithWhereUniqueWithoutPopup_questions_possible_answersInput = {
    where: popup_questions_answersWhereUniqueInput
    update: XOR<popup_questions_answersUpdateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedUpdateWithoutPopup_questions_possible_answersInput>
    create: XOR<popup_questions_answersCreateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedCreateWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questions_answersUpdateWithWhereUniqueWithoutPopup_questions_possible_answersInput = {
    where: popup_questions_answersWhereUniqueInput
    data: XOR<popup_questions_answersUpdateWithoutPopup_questions_possible_answersInput, popup_questions_answersUncheckedUpdateWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questions_answersUpdateManyWithWhereWithoutPopup_questions_possible_answersInput = {
    where: popup_questions_answersScalarWhereInput
    data: XOR<popup_questions_answersUpdateManyMutationInput, popup_questions_answersUncheckedUpdateManyWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questions_answersScalarWhereInput = {
    AND?: popup_questions_answersScalarWhereInput | popup_questions_answersScalarWhereInput[]
    OR?: popup_questions_answersScalarWhereInput[]
    NOT?: popup_questions_answersScalarWhereInput | popup_questions_answersScalarWhereInput[]
    id?: IntFilter<"popup_questions_answers"> | number
    device_id?: IntFilter<"popup_questions_answers"> | number
    rating_id?: IntNullableFilter<"popup_questions_answers"> | number | null
    ticket_id?: IntNullableFilter<"popup_questions_answers"> | number | null
    answer_id?: IntFilter<"popup_questions_answers"> | number
    answered_at?: DateTimeFilter<"popup_questions_answers"> | Date | string
  }

  export type popup_questionsUpsertWithoutPopup_questions_possible_answersInput = {
    update: XOR<popup_questionsUpdateWithoutPopup_questions_possible_answersInput, popup_questionsUncheckedUpdateWithoutPopup_questions_possible_answersInput>
    create: XOR<popup_questionsCreateWithoutPopup_questions_possible_answersInput, popup_questionsUncheckedCreateWithoutPopup_questions_possible_answersInput>
    where?: popup_questionsWhereInput
  }

  export type popup_questionsUpdateToOneWithWhereWithoutPopup_questions_possible_answersInput = {
    where?: popup_questionsWhereInput
    data: XOR<popup_questionsUpdateWithoutPopup_questions_possible_answersInput, popup_questionsUncheckedUpdateWithoutPopup_questions_possible_answersInput>
  }

  export type popup_questionsUpdateWithoutPopup_questions_possible_answersInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneRequiredWithoutPopup_questionsNestedInput
  }

  export type popup_questionsUncheckedUpdateWithoutPopup_questions_possible_answersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    institution_id?: IntFieldUpdateOperationsInput | number
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionCreateWithoutQms_branch_operatorInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutQms_branch_operatorInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutQms_branch_operatorInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutQms_branch_operatorInput, institutionUncheckedCreateWithoutQms_branch_operatorInput>
  }

  export type qms_operatorCreateWithoutQms_branch_operatorInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutQms_operatorInput
    institution?: institutionCreateNestedOneWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateWithoutQms_branch_operatorInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorCreateOrConnectWithoutQms_branch_operatorInput = {
    where: qms_operatorWhereUniqueInput
    create: XOR<qms_operatorCreateWithoutQms_branch_operatorInput, qms_operatorUncheckedCreateWithoutQms_branch_operatorInput>
  }

  export type institutionUpsertWithoutQms_branch_operatorInput = {
    update: XOR<institutionUpdateWithoutQms_branch_operatorInput, institutionUncheckedUpdateWithoutQms_branch_operatorInput>
    create: XOR<institutionCreateWithoutQms_branch_operatorInput, institutionUncheckedCreateWithoutQms_branch_operatorInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutQms_branch_operatorInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutQms_branch_operatorInput, institutionUncheckedUpdateWithoutQms_branch_operatorInput>
  }

  export type institutionUpdateWithoutQms_branch_operatorInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutQms_branch_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type qms_operatorUpsertWithoutQms_branch_operatorInput = {
    update: XOR<qms_operatorUpdateWithoutQms_branch_operatorInput, qms_operatorUncheckedUpdateWithoutQms_branch_operatorInput>
    create: XOR<qms_operatorCreateWithoutQms_branch_operatorInput, qms_operatorUncheckedCreateWithoutQms_branch_operatorInput>
    where?: qms_operatorWhereInput
  }

  export type qms_operatorUpdateToOneWithWhereWithoutQms_branch_operatorInput = {
    where?: qms_operatorWhereInput
    data: XOR<qms_operatorUpdateWithoutQms_branch_operatorInput, qms_operatorUncheckedUpdateWithoutQms_branch_operatorInput>
  }

  export type qms_operatorUpdateWithoutQms_branch_operatorInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutQms_operatorNestedInput
    institution?: institutionUpdateOneWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateWithoutQms_branch_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type institutionCreateWithoutQms_branch_transactionsInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutQms_branch_transactionsInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutQms_branch_transactionsInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutQms_branch_transactionsInput, institutionUncheckedCreateWithoutQms_branch_transactionsInput>
  }

  export type qms_operator_transactionsCreateWithoutQms_branch_transactionsInput = {
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
    qms_operator: qms_operatorCreateNestedOneWithoutQms_operator_transactionsInput
  }

  export type qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput = {
    id?: number
    operator_id: number
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_operator_transactionsCreateOrConnectWithoutQms_branch_transactionsInput = {
    where: qms_operator_transactionsWhereUniqueInput
    create: XOR<qms_operator_transactionsCreateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput>
  }

  export type qms_operator_transactionsCreateManyQms_branch_transactionsInputEnvelope = {
    data: qms_operator_transactionsCreateManyQms_branch_transactionsInput | qms_operator_transactionsCreateManyQms_branch_transactionsInput[]
    skipDuplicates?: boolean
  }

  export type institutionUpsertWithoutQms_branch_transactionsInput = {
    update: XOR<institutionUpdateWithoutQms_branch_transactionsInput, institutionUncheckedUpdateWithoutQms_branch_transactionsInput>
    create: XOR<institutionCreateWithoutQms_branch_transactionsInput, institutionUncheckedCreateWithoutQms_branch_transactionsInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutQms_branch_transactionsInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutQms_branch_transactionsInput, institutionUncheckedUpdateWithoutQms_branch_transactionsInput>
  }

  export type institutionUpdateWithoutQms_branch_transactionsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutQms_branch_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_branch_transactionsInput = {
    where: qms_operator_transactionsWhereUniqueInput
    update: XOR<qms_operator_transactionsUpdateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedUpdateWithoutQms_branch_transactionsInput>
    create: XOR<qms_operator_transactionsCreateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedCreateWithoutQms_branch_transactionsInput>
  }

  export type qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_branch_transactionsInput = {
    where: qms_operator_transactionsWhereUniqueInput
    data: XOR<qms_operator_transactionsUpdateWithoutQms_branch_transactionsInput, qms_operator_transactionsUncheckedUpdateWithoutQms_branch_transactionsInput>
  }

  export type qms_operator_transactionsUpdateManyWithWhereWithoutQms_branch_transactionsInput = {
    where: qms_operator_transactionsScalarWhereInput
    data: XOR<qms_operator_transactionsUpdateManyMutationInput, qms_operator_transactionsUncheckedUpdateManyWithoutQms_branch_transactionsInput>
  }

  export type qms_operator_transactionsScalarWhereInput = {
    AND?: qms_operator_transactionsScalarWhereInput | qms_operator_transactionsScalarWhereInput[]
    OR?: qms_operator_transactionsScalarWhereInput[]
    NOT?: qms_operator_transactionsScalarWhereInput | qms_operator_transactionsScalarWhereInput[]
    id?: IntFilter<"qms_operator_transactions"> | number
    branch_transaction_id?: IntFilter<"qms_operator_transactions"> | number
    operator_id?: IntFilter<"qms_operator_transactions"> | number
    transaction?: IntFilter<"qms_operator_transactions"> | number
    created_at?: DateTimeFilter<"qms_operator_transactions"> | Date | string
    last_updated?: DateTimeFilter<"qms_operator_transactions"> | Date | string
  }

  export type serviceCreateWithoutQms_counterInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueCreateNestedManyWithoutServiceInput
    rating?: ratingCreateNestedManyWithoutServiceInput
    service_group?: service_groupCreateNestedOneWithoutServiceInput
    institution?: institutionCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutQms_counterInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueUncheckedCreateNestedManyWithoutServiceInput
    rating?: ratingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutQms_counterInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutQms_counterInput, serviceUncheckedCreateWithoutQms_counterInput>
  }

  export type serviceUpsertWithoutQms_counterInput = {
    update: XOR<serviceUpdateWithoutQms_counterInput, serviceUncheckedUpdateWithoutQms_counterInput>
    create: XOR<serviceCreateWithoutQms_counterInput, serviceUncheckedCreateWithoutQms_counterInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutQms_counterInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutQms_counterInput, serviceUncheckedUpdateWithoutQms_counterInput>
  }

  export type serviceUpdateWithoutQms_counterInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUpdateManyWithoutServiceNestedInput
    rating?: ratingUpdateManyWithoutServiceNestedInput
    service_group?: service_groupUpdateOneWithoutServiceNestedInput
    institution?: institutionUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutQms_counterInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUncheckedUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type deviceCreateWithoutQms_customerInput = {
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    institution?: institutionCreateNestedOneWithoutDeviceInput
    rating?: ratingCreateNestedManyWithoutDeviceInput
    tip?: tipCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutQms_customerInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    affiliate_id?: number | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    rating?: ratingUncheckedCreateNestedManyWithoutDeviceInput
    tip?: tipUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutQms_customerInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutQms_customerInput, deviceUncheckedCreateWithoutQms_customerInput>
  }

  export type qms_ticketCreateWithoutQms_customerInput = {
    ticket_uuid: string
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    option?: optionCreateNestedOneWithoutQms_ticketInput
    qms_queue: qms_queueCreateNestedOneWithoutQms_ticketInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketUncheckedCreateWithoutQms_customerInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketCreateOrConnectWithoutQms_customerInput = {
    where: qms_ticketWhereUniqueInput
    create: XOR<qms_ticketCreateWithoutQms_customerInput, qms_ticketUncheckedCreateWithoutQms_customerInput>
  }

  export type qms_ticketCreateManyQms_customerInputEnvelope = {
    data: qms_ticketCreateManyQms_customerInput | qms_ticketCreateManyQms_customerInput[]
    skipDuplicates?: boolean
  }

  export type deviceUpsertWithoutQms_customerInput = {
    update: XOR<deviceUpdateWithoutQms_customerInput, deviceUncheckedUpdateWithoutQms_customerInput>
    create: XOR<deviceCreateWithoutQms_customerInput, deviceUncheckedCreateWithoutQms_customerInput>
    where?: deviceWhereInput
  }

  export type deviceUpdateToOneWithWhereWithoutQms_customerInput = {
    where?: deviceWhereInput
    data: XOR<deviceUpdateWithoutQms_customerInput, deviceUncheckedUpdateWithoutQms_customerInput>
  }

  export type deviceUpdateWithoutQms_customerInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutDeviceNestedInput
    rating?: ratingUpdateManyWithoutDeviceNestedInput
    tip?: tipUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutQms_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: ratingUncheckedUpdateManyWithoutDeviceNestedInput
    tip?: tipUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type qms_ticketUpsertWithWhereUniqueWithoutQms_customerInput = {
    where: qms_ticketWhereUniqueInput
    update: XOR<qms_ticketUpdateWithoutQms_customerInput, qms_ticketUncheckedUpdateWithoutQms_customerInput>
    create: XOR<qms_ticketCreateWithoutQms_customerInput, qms_ticketUncheckedCreateWithoutQms_customerInput>
  }

  export type qms_ticketUpdateWithWhereUniqueWithoutQms_customerInput = {
    where: qms_ticketWhereUniqueInput
    data: XOR<qms_ticketUpdateWithoutQms_customerInput, qms_ticketUncheckedUpdateWithoutQms_customerInput>
  }

  export type qms_ticketUpdateManyWithWhereWithoutQms_customerInput = {
    where: qms_ticketScalarWhereInput
    data: XOR<qms_ticketUpdateManyMutationInput, qms_ticketUncheckedUpdateManyWithoutQms_customerInput>
  }

  export type appointmentsCreateWithoutQms_operatorInput = {
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
    user_appointments_creator_idTouser: userCreateNestedOneWithoutAppointments_appointments_creator_idTouserInput
    institution?: institutionCreateNestedOneWithoutAppointmentsInput
    service?: serviceCreateNestedOneWithoutAppointmentsInput
    user_appointments_user_idTouser?: userCreateNestedOneWithoutAppointments_appointments_user_idTouserInput
  }

  export type appointmentsUncheckedCreateWithoutQms_operatorInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsCreateOrConnectWithoutQms_operatorInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutQms_operatorInput, appointmentsUncheckedCreateWithoutQms_operatorInput>
  }

  export type appointmentsCreateManyQms_operatorInputEnvelope = {
    data: appointmentsCreateManyQms_operatorInput | appointmentsCreateManyQms_operatorInput[]
    skipDuplicates?: boolean
  }

  export type qms_branch_operatorCreateWithoutQms_operatorInput = {
    service_id: string
    linked_at?: Date | string
    status?: number
    institution: institutionCreateNestedOneWithoutQms_branch_operatorInput
  }

  export type qms_branch_operatorUncheckedCreateWithoutQms_operatorInput = {
    id?: number
    institution_id: number
    service_id: string
    linked_at?: Date | string
    status?: number
  }

  export type qms_branch_operatorCreateOrConnectWithoutQms_operatorInput = {
    where: qms_branch_operatorWhereUniqueInput
    create: XOR<qms_branch_operatorCreateWithoutQms_operatorInput, qms_branch_operatorUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_branch_operatorCreateManyQms_operatorInputEnvelope = {
    data: qms_branch_operatorCreateManyQms_operatorInput | qms_branch_operatorCreateManyQms_operatorInput[]
    skipDuplicates?: boolean
  }

  export type institutionCreateWithoutQms_operatorInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutQms_operatorInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutQms_operatorInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutQms_operatorInput, institutionUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_operator_transactionsCreateWithoutQms_operatorInput = {
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
    qms_branch_transactions: qms_branch_transactionsCreateNestedOneWithoutQms_operator_transactionsInput
  }

  export type qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput = {
    id?: number
    branch_transaction_id: number
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_operator_transactionsCreateOrConnectWithoutQms_operatorInput = {
    where: qms_operator_transactionsWhereUniqueInput
    create: XOR<qms_operator_transactionsCreateWithoutQms_operatorInput, qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_operator_transactionsCreateManyQms_operatorInputEnvelope = {
    data: qms_operator_transactionsCreateManyQms_operatorInput | qms_operator_transactionsCreateManyQms_operatorInput[]
    skipDuplicates?: boolean
  }

  export type qms_queue_operator_lnkCreateWithoutQms_operatorInput = {
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
    qms_queue: qms_queueCreateNestedOneWithoutQms_queue_operator_lnkInput
  }

  export type qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput = {
    id?: number
    queue_id: number
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
  }

  export type qms_queue_operator_lnkCreateOrConnectWithoutQms_operatorInput = {
    where: qms_queue_operator_lnkWhereUniqueInput
    create: XOR<qms_queue_operator_lnkCreateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_queue_operator_lnkCreateManyQms_operatorInputEnvelope = {
    data: qms_queue_operator_lnkCreateManyQms_operatorInput | qms_queue_operator_lnkCreateManyQms_operatorInput[]
    skipDuplicates?: boolean
  }

  export type qms_ticket_assignmentCreateWithoutQms_operatorInput = {
    queue_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
    qms_ticket: qms_ticketCreateNestedOneWithoutQms_ticket_assignmentInput
  }

  export type qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput = {
    id?: number
    ticket_id: number
    queue_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
  }

  export type qms_ticket_assignmentCreateOrConnectWithoutQms_operatorInput = {
    where: qms_ticket_assignmentWhereUniqueInput
    create: XOR<qms_ticket_assignmentCreateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_ticket_assignmentCreateManyQms_operatorInputEnvelope = {
    data: qms_ticket_assignmentCreateManyQms_operatorInput | qms_ticket_assignmentCreateManyQms_operatorInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutQms_operatorInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutQms_operatorInput, appointmentsUncheckedUpdateWithoutQms_operatorInput>
    create: XOR<appointmentsCreateWithoutQms_operatorInput, appointmentsUncheckedCreateWithoutQms_operatorInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutQms_operatorInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutQms_operatorInput, appointmentsUncheckedUpdateWithoutQms_operatorInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutQms_operatorInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutQms_operatorInput>
  }

  export type qms_branch_operatorUpsertWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_branch_operatorWhereUniqueInput
    update: XOR<qms_branch_operatorUpdateWithoutQms_operatorInput, qms_branch_operatorUncheckedUpdateWithoutQms_operatorInput>
    create: XOR<qms_branch_operatorCreateWithoutQms_operatorInput, qms_branch_operatorUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_branch_operatorUpdateWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_branch_operatorWhereUniqueInput
    data: XOR<qms_branch_operatorUpdateWithoutQms_operatorInput, qms_branch_operatorUncheckedUpdateWithoutQms_operatorInput>
  }

  export type qms_branch_operatorUpdateManyWithWhereWithoutQms_operatorInput = {
    where: qms_branch_operatorScalarWhereInput
    data: XOR<qms_branch_operatorUpdateManyMutationInput, qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorInput>
  }

  export type institutionUpsertWithoutQms_operatorInput = {
    update: XOR<institutionUpdateWithoutQms_operatorInput, institutionUncheckedUpdateWithoutQms_operatorInput>
    create: XOR<institutionCreateWithoutQms_operatorInput, institutionUncheckedCreateWithoutQms_operatorInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutQms_operatorInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutQms_operatorInput, institutionUncheckedUpdateWithoutQms_operatorInput>
  }

  export type institutionUpdateWithoutQms_operatorInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type qms_operator_transactionsUpsertWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_operator_transactionsWhereUniqueInput
    update: XOR<qms_operator_transactionsUpdateWithoutQms_operatorInput, qms_operator_transactionsUncheckedUpdateWithoutQms_operatorInput>
    create: XOR<qms_operator_transactionsCreateWithoutQms_operatorInput, qms_operator_transactionsUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_operator_transactionsUpdateWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_operator_transactionsWhereUniqueInput
    data: XOR<qms_operator_transactionsUpdateWithoutQms_operatorInput, qms_operator_transactionsUncheckedUpdateWithoutQms_operatorInput>
  }

  export type qms_operator_transactionsUpdateManyWithWhereWithoutQms_operatorInput = {
    where: qms_operator_transactionsScalarWhereInput
    data: XOR<qms_operator_transactionsUpdateManyMutationInput, qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorInput>
  }

  export type qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_queue_operator_lnkWhereUniqueInput
    update: XOR<qms_queue_operator_lnkUpdateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedUpdateWithoutQms_operatorInput>
    create: XOR<qms_queue_operator_lnkCreateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_queue_operator_lnkWhereUniqueInput
    data: XOR<qms_queue_operator_lnkUpdateWithoutQms_operatorInput, qms_queue_operator_lnkUncheckedUpdateWithoutQms_operatorInput>
  }

  export type qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_operatorInput = {
    where: qms_queue_operator_lnkScalarWhereInput
    data: XOR<qms_queue_operator_lnkUpdateManyMutationInput, qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorInput>
  }

  export type qms_queue_operator_lnkScalarWhereInput = {
    AND?: qms_queue_operator_lnkScalarWhereInput | qms_queue_operator_lnkScalarWhereInput[]
    OR?: qms_queue_operator_lnkScalarWhereInput[]
    NOT?: qms_queue_operator_lnkScalarWhereInput | qms_queue_operator_lnkScalarWhereInput[]
    id?: IntFilter<"qms_queue_operator_lnk"> | number
    queue_id?: IntFilter<"qms_queue_operator_lnk"> | number
    operator_id?: IntFilter<"qms_queue_operator_lnk"> | number
    operator_uuid?: StringNullableFilter<"qms_queue_operator_lnk"> | string | null
    counter_id?: IntNullableFilter<"qms_queue_operator_lnk"> | number | null
    first_login?: DateTimeNullableFilter<"qms_queue_operator_lnk"> | Date | string | null
    last_logout?: DateTimeNullableFilter<"qms_queue_operator_lnk"> | Date | string | null
    api_key?: StringNullableFilter<"qms_queue_operator_lnk"> | string | null
  }

  export type qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_ticket_assignmentWhereUniqueInput
    update: XOR<qms_ticket_assignmentUpdateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedUpdateWithoutQms_operatorInput>
    create: XOR<qms_ticket_assignmentCreateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedCreateWithoutQms_operatorInput>
  }

  export type qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_operatorInput = {
    where: qms_ticket_assignmentWhereUniqueInput
    data: XOR<qms_ticket_assignmentUpdateWithoutQms_operatorInput, qms_ticket_assignmentUncheckedUpdateWithoutQms_operatorInput>
  }

  export type qms_ticket_assignmentUpdateManyWithWhereWithoutQms_operatorInput = {
    where: qms_ticket_assignmentScalarWhereInput
    data: XOR<qms_ticket_assignmentUpdateManyMutationInput, qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorInput>
  }

  export type qms_ticket_assignmentScalarWhereInput = {
    AND?: qms_ticket_assignmentScalarWhereInput | qms_ticket_assignmentScalarWhereInput[]
    OR?: qms_ticket_assignmentScalarWhereInput[]
    NOT?: qms_ticket_assignmentScalarWhereInput | qms_ticket_assignmentScalarWhereInput[]
    id?: IntFilter<"qms_ticket_assignment"> | number
    ticket_id?: IntFilter<"qms_ticket_assignment"> | number
    queue_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    operator_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    counter_id?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    status?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    started_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    assigned_at?: DateTimeNullableFilter<"qms_ticket_assignment"> | Date | string | null
    state?: IntNullableFilter<"qms_ticket_assignment"> | number | null
    comment?: StringNullableFilter<"qms_ticket_assignment"> | string | null
  }

  export type qms_branch_transactionsCreateWithoutQms_operator_transactionsInput = {
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
    institution: institutionCreateNestedOneWithoutQms_branch_transactionsInput
  }

  export type qms_branch_transactionsUncheckedCreateWithoutQms_operator_transactionsInput = {
    id?: number
    affiliate_id: number
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_branch_transactionsCreateOrConnectWithoutQms_operator_transactionsInput = {
    where: qms_branch_transactionsWhereUniqueInput
    create: XOR<qms_branch_transactionsCreateWithoutQms_operator_transactionsInput, qms_branch_transactionsUncheckedCreateWithoutQms_operator_transactionsInput>
  }

  export type qms_operatorCreateWithoutQms_operator_transactionsInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutQms_operatorInput
    institution?: institutionCreateNestedOneWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateWithoutQms_operator_transactionsInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorCreateOrConnectWithoutQms_operator_transactionsInput = {
    where: qms_operatorWhereUniqueInput
    create: XOR<qms_operatorCreateWithoutQms_operator_transactionsInput, qms_operatorUncheckedCreateWithoutQms_operator_transactionsInput>
  }

  export type qms_branch_transactionsUpsertWithoutQms_operator_transactionsInput = {
    update: XOR<qms_branch_transactionsUpdateWithoutQms_operator_transactionsInput, qms_branch_transactionsUncheckedUpdateWithoutQms_operator_transactionsInput>
    create: XOR<qms_branch_transactionsCreateWithoutQms_operator_transactionsInput, qms_branch_transactionsUncheckedCreateWithoutQms_operator_transactionsInput>
    where?: qms_branch_transactionsWhereInput
  }

  export type qms_branch_transactionsUpdateToOneWithWhereWithoutQms_operator_transactionsInput = {
    where?: qms_branch_transactionsWhereInput
    data: XOR<qms_branch_transactionsUpdateWithoutQms_operator_transactionsInput, qms_branch_transactionsUncheckedUpdateWithoutQms_operator_transactionsInput>
  }

  export type qms_branch_transactionsUpdateWithoutQms_operator_transactionsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneRequiredWithoutQms_branch_transactionsNestedInput
  }

  export type qms_branch_transactionsUncheckedUpdateWithoutQms_operator_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operatorUpsertWithoutQms_operator_transactionsInput = {
    update: XOR<qms_operatorUpdateWithoutQms_operator_transactionsInput, qms_operatorUncheckedUpdateWithoutQms_operator_transactionsInput>
    create: XOR<qms_operatorCreateWithoutQms_operator_transactionsInput, qms_operatorUncheckedCreateWithoutQms_operator_transactionsInput>
    where?: qms_operatorWhereInput
  }

  export type qms_operatorUpdateToOneWithWhereWithoutQms_operator_transactionsInput = {
    where?: qms_operatorWhereInput
    data: XOR<qms_operatorUpdateWithoutQms_operator_transactionsInput, qms_operatorUncheckedUpdateWithoutQms_operator_transactionsInput>
  }

  export type qms_operatorUpdateWithoutQms_operator_transactionsInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput
    institution?: institutionUpdateOneWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateWithoutQms_operator_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type serviceCreateWithoutQms_queueInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterCreateNestedManyWithoutServiceInput
    rating?: ratingCreateNestedManyWithoutServiceInput
    service_group?: service_groupCreateNestedOneWithoutServiceInput
    institution?: institutionCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutQms_queueInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterUncheckedCreateNestedManyWithoutServiceInput
    rating?: ratingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutQms_queueInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutQms_queueInput, serviceUncheckedCreateWithoutQms_queueInput>
  }

  export type qms_queue_operator_lnkCreateWithoutQms_queueInput = {
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
    qms_operator: qms_operatorCreateNestedOneWithoutQms_queue_operator_lnkInput
  }

  export type qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput = {
    id?: number
    operator_id: number
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
  }

  export type qms_queue_operator_lnkCreateOrConnectWithoutQms_queueInput = {
    where: qms_queue_operator_lnkWhereUniqueInput
    create: XOR<qms_queue_operator_lnkCreateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput>
  }

  export type qms_queue_operator_lnkCreateManyQms_queueInputEnvelope = {
    data: qms_queue_operator_lnkCreateManyQms_queueInput | qms_queue_operator_lnkCreateManyQms_queueInput[]
    skipDuplicates?: boolean
  }

  export type qms_ticketCreateWithoutQms_queueInput = {
    ticket_uuid: string
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    option?: optionCreateNestedOneWithoutQms_ticketInput
    qms_customer: qms_customerCreateNestedOneWithoutQms_ticketInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketUncheckedCreateWithoutQms_queueInput = {
    id?: number
    ticket_uuid: string
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_ticketInput
  }

  export type qms_ticketCreateOrConnectWithoutQms_queueInput = {
    where: qms_ticketWhereUniqueInput
    create: XOR<qms_ticketCreateWithoutQms_queueInput, qms_ticketUncheckedCreateWithoutQms_queueInput>
  }

  export type qms_ticketCreateManyQms_queueInputEnvelope = {
    data: qms_ticketCreateManyQms_queueInput | qms_ticketCreateManyQms_queueInput[]
    skipDuplicates?: boolean
  }

  export type serviceUpsertWithoutQms_queueInput = {
    update: XOR<serviceUpdateWithoutQms_queueInput, serviceUncheckedUpdateWithoutQms_queueInput>
    create: XOR<serviceCreateWithoutQms_queueInput, serviceUncheckedCreateWithoutQms_queueInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutQms_queueInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutQms_queueInput, serviceUncheckedUpdateWithoutQms_queueInput>
  }

  export type serviceUpdateWithoutQms_queueInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUpdateManyWithoutServiceNestedInput
    rating?: ratingUpdateManyWithoutServiceNestedInput
    service_group?: service_groupUpdateOneWithoutServiceNestedInput
    institution?: institutionUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutQms_queueInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUncheckedUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type qms_queue_operator_lnkUpsertWithWhereUniqueWithoutQms_queueInput = {
    where: qms_queue_operator_lnkWhereUniqueInput
    update: XOR<qms_queue_operator_lnkUpdateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedUpdateWithoutQms_queueInput>
    create: XOR<qms_queue_operator_lnkCreateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedCreateWithoutQms_queueInput>
  }

  export type qms_queue_operator_lnkUpdateWithWhereUniqueWithoutQms_queueInput = {
    where: qms_queue_operator_lnkWhereUniqueInput
    data: XOR<qms_queue_operator_lnkUpdateWithoutQms_queueInput, qms_queue_operator_lnkUncheckedUpdateWithoutQms_queueInput>
  }

  export type qms_queue_operator_lnkUpdateManyWithWhereWithoutQms_queueInput = {
    where: qms_queue_operator_lnkScalarWhereInput
    data: XOR<qms_queue_operator_lnkUpdateManyMutationInput, qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_queueInput>
  }

  export type qms_ticketUpsertWithWhereUniqueWithoutQms_queueInput = {
    where: qms_ticketWhereUniqueInput
    update: XOR<qms_ticketUpdateWithoutQms_queueInput, qms_ticketUncheckedUpdateWithoutQms_queueInput>
    create: XOR<qms_ticketCreateWithoutQms_queueInput, qms_ticketUncheckedCreateWithoutQms_queueInput>
  }

  export type qms_ticketUpdateWithWhereUniqueWithoutQms_queueInput = {
    where: qms_ticketWhereUniqueInput
    data: XOR<qms_ticketUpdateWithoutQms_queueInput, qms_ticketUncheckedUpdateWithoutQms_queueInput>
  }

  export type qms_ticketUpdateManyWithWhereWithoutQms_queueInput = {
    where: qms_ticketScalarWhereInput
    data: XOR<qms_ticketUpdateManyMutationInput, qms_ticketUncheckedUpdateManyWithoutQms_queueInput>
  }

  export type qms_queueCreateWithoutQms_queue_operator_lnkInput = {
    queue_uuid: string
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    service: serviceCreateNestedOneWithoutQms_queueInput
    qms_ticket?: qms_ticketCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueUncheckedCreateWithoutQms_queue_operator_lnkInput = {
    id?: number
    queue_uuid: string
    service_id: number
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    qms_ticket?: qms_ticketUncheckedCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueCreateOrConnectWithoutQms_queue_operator_lnkInput = {
    where: qms_queueWhereUniqueInput
    create: XOR<qms_queueCreateWithoutQms_queue_operator_lnkInput, qms_queueUncheckedCreateWithoutQms_queue_operator_lnkInput>
  }

  export type qms_operatorCreateWithoutQms_queue_operator_lnkInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutQms_operatorInput
    institution?: institutionCreateNestedOneWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateWithoutQms_queue_operator_lnkInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorCreateOrConnectWithoutQms_queue_operator_lnkInput = {
    where: qms_operatorWhereUniqueInput
    create: XOR<qms_operatorCreateWithoutQms_queue_operator_lnkInput, qms_operatorUncheckedCreateWithoutQms_queue_operator_lnkInput>
  }

  export type qms_queueUpsertWithoutQms_queue_operator_lnkInput = {
    update: XOR<qms_queueUpdateWithoutQms_queue_operator_lnkInput, qms_queueUncheckedUpdateWithoutQms_queue_operator_lnkInput>
    create: XOR<qms_queueCreateWithoutQms_queue_operator_lnkInput, qms_queueUncheckedCreateWithoutQms_queue_operator_lnkInput>
    where?: qms_queueWhereInput
  }

  export type qms_queueUpdateToOneWithWhereWithoutQms_queue_operator_lnkInput = {
    where?: qms_queueWhereInput
    data: XOR<qms_queueUpdateWithoutQms_queue_operator_lnkInput, qms_queueUncheckedUpdateWithoutQms_queue_operator_lnkInput>
  }

  export type qms_queueUpdateWithoutQms_queue_operator_lnkInput = {
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    service?: serviceUpdateOneRequiredWithoutQms_queueNestedInput
    qms_ticket?: qms_ticketUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_queueUncheckedUpdateWithoutQms_queue_operator_lnkInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_uuid?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_ticket?: qms_ticketUncheckedUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_operatorUpsertWithoutQms_queue_operator_lnkInput = {
    update: XOR<qms_operatorUpdateWithoutQms_queue_operator_lnkInput, qms_operatorUncheckedUpdateWithoutQms_queue_operator_lnkInput>
    create: XOR<qms_operatorCreateWithoutQms_queue_operator_lnkInput, qms_operatorUncheckedCreateWithoutQms_queue_operator_lnkInput>
    where?: qms_operatorWhereInput
  }

  export type qms_operatorUpdateToOneWithWhereWithoutQms_queue_operator_lnkInput = {
    where?: qms_operatorWhereInput
    data: XOR<qms_operatorUpdateWithoutQms_queue_operator_lnkInput, qms_operatorUncheckedUpdateWithoutQms_queue_operator_lnkInput>
  }

  export type qms_operatorUpdateWithoutQms_queue_operator_lnkInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput
    institution?: institutionUpdateOneWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateWithoutQms_queue_operator_lnkInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type optionCreateWithoutQms_ticketInput = {
    name?: string | null
    description?: string | null
    type?: number | null
    parent_id?: number | null
    created_at?: Date | string
  }

  export type optionUncheckedCreateWithoutQms_ticketInput = {
    id?: number
    name?: string | null
    description?: string | null
    type?: number | null
    parent_id?: number | null
    created_at?: Date | string
  }

  export type optionCreateOrConnectWithoutQms_ticketInput = {
    where: optionWhereUniqueInput
    create: XOR<optionCreateWithoutQms_ticketInput, optionUncheckedCreateWithoutQms_ticketInput>
  }

  export type qms_customerCreateWithoutQms_ticketInput = {
    customer_uuid: string
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    device?: deviceCreateNestedOneWithoutQms_customerInput
  }

  export type qms_customerUncheckedCreateWithoutQms_ticketInput = {
    id?: number
    customer_uuid: string
    device_id?: number | null
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_customerCreateOrConnectWithoutQms_ticketInput = {
    where: qms_customerWhereUniqueInput
    create: XOR<qms_customerCreateWithoutQms_ticketInput, qms_customerUncheckedCreateWithoutQms_ticketInput>
  }

  export type qms_queueCreateWithoutQms_ticketInput = {
    queue_uuid: string
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    service: serviceCreateNestedOneWithoutQms_queueInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueUncheckedCreateWithoutQms_ticketInput = {
    id?: number
    queue_uuid: string
    service_id: number
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueCreateOrConnectWithoutQms_ticketInput = {
    where: qms_queueWhereUniqueInput
    create: XOR<qms_queueCreateWithoutQms_ticketInput, qms_queueUncheckedCreateWithoutQms_ticketInput>
  }

  export type qms_ticket_assignmentCreateWithoutQms_ticketInput = {
    queue_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
    qms_operator?: qms_operatorCreateNestedOneWithoutQms_ticket_assignmentInput
  }

  export type qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput = {
    id?: number
    queue_id?: number | null
    operator_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
  }

  export type qms_ticket_assignmentCreateOrConnectWithoutQms_ticketInput = {
    where: qms_ticket_assignmentWhereUniqueInput
    create: XOR<qms_ticket_assignmentCreateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput>
  }

  export type qms_ticket_assignmentCreateManyQms_ticketInputEnvelope = {
    data: qms_ticket_assignmentCreateManyQms_ticketInput | qms_ticket_assignmentCreateManyQms_ticketInput[]
    skipDuplicates?: boolean
  }

  export type optionUpsertWithoutQms_ticketInput = {
    update: XOR<optionUpdateWithoutQms_ticketInput, optionUncheckedUpdateWithoutQms_ticketInput>
    create: XOR<optionCreateWithoutQms_ticketInput, optionUncheckedCreateWithoutQms_ticketInput>
    where?: optionWhereInput
  }

  export type optionUpdateToOneWithWhereWithoutQms_ticketInput = {
    where?: optionWhereInput
    data: XOR<optionUpdateWithoutQms_ticketInput, optionUncheckedUpdateWithoutQms_ticketInput>
  }

  export type optionUpdateWithoutQms_ticketInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type optionUncheckedUpdateWithoutQms_ticketInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_customerUpsertWithoutQms_ticketInput = {
    update: XOR<qms_customerUpdateWithoutQms_ticketInput, qms_customerUncheckedUpdateWithoutQms_ticketInput>
    create: XOR<qms_customerCreateWithoutQms_ticketInput, qms_customerUncheckedCreateWithoutQms_ticketInput>
    where?: qms_customerWhereInput
  }

  export type qms_customerUpdateToOneWithWhereWithoutQms_ticketInput = {
    where?: qms_customerWhereInput
    data: XOR<qms_customerUpdateWithoutQms_ticketInput, qms_customerUncheckedUpdateWithoutQms_ticketInput>
  }

  export type qms_customerUpdateWithoutQms_ticketInput = {
    customer_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: deviceUpdateOneWithoutQms_customerNestedInput
  }

  export type qms_customerUncheckedUpdateWithoutQms_ticketInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_uuid?: StringFieldUpdateOperationsInput | string
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_queueUpsertWithoutQms_ticketInput = {
    update: XOR<qms_queueUpdateWithoutQms_ticketInput, qms_queueUncheckedUpdateWithoutQms_ticketInput>
    create: XOR<qms_queueCreateWithoutQms_ticketInput, qms_queueUncheckedCreateWithoutQms_ticketInput>
    where?: qms_queueWhereInput
  }

  export type qms_queueUpdateToOneWithWhereWithoutQms_ticketInput = {
    where?: qms_queueWhereInput
    data: XOR<qms_queueUpdateWithoutQms_ticketInput, qms_queueUncheckedUpdateWithoutQms_ticketInput>
  }

  export type qms_queueUpdateWithoutQms_ticketInput = {
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    service?: serviceUpdateOneRequiredWithoutQms_queueNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_queueUncheckedUpdateWithoutQms_ticketInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_uuid?: StringFieldUpdateOperationsInput | string
    service_id?: IntFieldUpdateOperationsInput | number
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_ticket_assignmentUpsertWithWhereUniqueWithoutQms_ticketInput = {
    where: qms_ticket_assignmentWhereUniqueInput
    update: XOR<qms_ticket_assignmentUpdateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedUpdateWithoutQms_ticketInput>
    create: XOR<qms_ticket_assignmentCreateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedCreateWithoutQms_ticketInput>
  }

  export type qms_ticket_assignmentUpdateWithWhereUniqueWithoutQms_ticketInput = {
    where: qms_ticket_assignmentWhereUniqueInput
    data: XOR<qms_ticket_assignmentUpdateWithoutQms_ticketInput, qms_ticket_assignmentUncheckedUpdateWithoutQms_ticketInput>
  }

  export type qms_ticket_assignmentUpdateManyWithWhereWithoutQms_ticketInput = {
    where: qms_ticket_assignmentScalarWhereInput
    data: XOR<qms_ticket_assignmentUpdateManyMutationInput, qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketInput>
  }

  export type qms_ticketCreateWithoutQms_ticket_assignmentInput = {
    ticket_uuid: string
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
    option?: optionCreateNestedOneWithoutQms_ticketInput
    qms_customer: qms_customerCreateNestedOneWithoutQms_ticketInput
    qms_queue: qms_queueCreateNestedOneWithoutQms_ticketInput
  }

  export type qms_ticketUncheckedCreateWithoutQms_ticket_assignmentInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
  }

  export type qms_ticketCreateOrConnectWithoutQms_ticket_assignmentInput = {
    where: qms_ticketWhereUniqueInput
    create: XOR<qms_ticketCreateWithoutQms_ticket_assignmentInput, qms_ticketUncheckedCreateWithoutQms_ticket_assignmentInput>
  }

  export type qms_operatorCreateWithoutQms_ticket_assignmentInput = {
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutQms_operatorInput
    institution?: institutionCreateNestedOneWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorUncheckedCreateWithoutQms_ticket_assignmentInput = {
    id?: number
    operator_uuid: string
    institution_id?: number | null
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedCreateNestedManyWithoutQms_operatorInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_operatorInput
  }

  export type qms_operatorCreateOrConnectWithoutQms_ticket_assignmentInput = {
    where: qms_operatorWhereUniqueInput
    create: XOR<qms_operatorCreateWithoutQms_ticket_assignmentInput, qms_operatorUncheckedCreateWithoutQms_ticket_assignmentInput>
  }

  export type qms_ticketUpsertWithoutQms_ticket_assignmentInput = {
    update: XOR<qms_ticketUpdateWithoutQms_ticket_assignmentInput, qms_ticketUncheckedUpdateWithoutQms_ticket_assignmentInput>
    create: XOR<qms_ticketCreateWithoutQms_ticket_assignmentInput, qms_ticketUncheckedCreateWithoutQms_ticket_assignmentInput>
    where?: qms_ticketWhereInput
  }

  export type qms_ticketUpdateToOneWithWhereWithoutQms_ticket_assignmentInput = {
    where?: qms_ticketWhereInput
    data: XOR<qms_ticketUpdateWithoutQms_ticket_assignmentInput, qms_ticketUncheckedUpdateWithoutQms_ticket_assignmentInput>
  }

  export type qms_ticketUpdateWithoutQms_ticket_assignmentInput = {
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    option?: optionUpdateOneWithoutQms_ticketNestedInput
    qms_customer?: qms_customerUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_queue?: qms_queueUpdateOneRequiredWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateWithoutQms_ticket_assignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
  }

  export type qms_operatorUpsertWithoutQms_ticket_assignmentInput = {
    update: XOR<qms_operatorUpdateWithoutQms_ticket_assignmentInput, qms_operatorUncheckedUpdateWithoutQms_ticket_assignmentInput>
    create: XOR<qms_operatorCreateWithoutQms_ticket_assignmentInput, qms_operatorUncheckedCreateWithoutQms_ticket_assignmentInput>
    where?: qms_operatorWhereInput
  }

  export type qms_operatorUpdateToOneWithWhereWithoutQms_ticket_assignmentInput = {
    where?: qms_operatorWhereInput
    data: XOR<qms_operatorUpdateWithoutQms_ticket_assignmentInput, qms_operatorUncheckedUpdateWithoutQms_ticket_assignmentInput>
  }

  export type qms_operatorUpdateWithoutQms_ticket_assignmentInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput
    institution?: institutionUpdateOneWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateWithoutQms_ticket_assignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type serviceCreateWithoutRatingInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueCreateNestedManyWithoutServiceInput
    service_group?: service_groupCreateNestedOneWithoutServiceInput
    institution?: institutionCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutRatingInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterUncheckedCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutRatingInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutRatingInput, serviceUncheckedCreateWithoutRatingInput>
  }

  export type deviceCreateWithoutRatingInput = {
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    institution?: institutionCreateNestedOneWithoutDeviceInput
    qms_customer?: qms_customerCreateNestedManyWithoutDeviceInput
    tip?: tipCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutRatingInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    affiliate_id?: number | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    qms_customer?: qms_customerUncheckedCreateNestedManyWithoutDeviceInput
    tip?: tipUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutRatingInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutRatingInput, deviceUncheckedCreateWithoutRatingInput>
  }

  export type rating_assetsCreateWithoutRatingInput = {
    rating_assets_image?: string | null
    rating_assets_video?: string | null
  }

  export type rating_assetsUncheckedCreateWithoutRatingInput = {
    rating_assets_id?: number
    rating_assets_image?: string | null
    rating_assets_video?: string | null
  }

  export type rating_assetsCreateOrConnectWithoutRatingInput = {
    where: rating_assetsWhereUniqueInput
    create: XOR<rating_assetsCreateWithoutRatingInput, rating_assetsUncheckedCreateWithoutRatingInput>
  }

  export type rating_assetsCreateManyRatingInputEnvelope = {
    data: rating_assetsCreateManyRatingInput | rating_assetsCreateManyRatingInput[]
    skipDuplicates?: boolean
  }

  export type tipCreateWithoutRatingInput = {
    collection_reference_id: string
    disbursement_reference_id: string
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    device: deviceCreateNestedOneWithoutTipInput
  }

  export type tipUncheckedCreateWithoutRatingInput = {
    id?: number
    collection_reference_id: string
    disbursement_reference_id: string
    device_id: number
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tipCreateOrConnectWithoutRatingInput = {
    where: tipWhereUniqueInput
    create: XOR<tipCreateWithoutRatingInput, tipUncheckedCreateWithoutRatingInput>
  }

  export type tipCreateManyRatingInputEnvelope = {
    data: tipCreateManyRatingInput | tipCreateManyRatingInput[]
    skipDuplicates?: boolean
  }

  export type serviceUpsertWithoutRatingInput = {
    update: XOR<serviceUpdateWithoutRatingInput, serviceUncheckedUpdateWithoutRatingInput>
    create: XOR<serviceCreateWithoutRatingInput, serviceUncheckedCreateWithoutRatingInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutRatingInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutRatingInput, serviceUncheckedUpdateWithoutRatingInput>
  }

  export type serviceUpdateWithoutRatingInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUpdateManyWithoutServiceNestedInput
    service_group?: service_groupUpdateOneWithoutServiceNestedInput
    institution?: institutionUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUncheckedUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUncheckedUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type deviceUpsertWithoutRatingInput = {
    update: XOR<deviceUpdateWithoutRatingInput, deviceUncheckedUpdateWithoutRatingInput>
    create: XOR<deviceCreateWithoutRatingInput, deviceUncheckedCreateWithoutRatingInput>
    where?: deviceWhereInput
  }

  export type deviceUpdateToOneWithWhereWithoutRatingInput = {
    where?: deviceWhereInput
    data: XOR<deviceUpdateWithoutRatingInput, deviceUncheckedUpdateWithoutRatingInput>
  }

  export type deviceUpdateWithoutRatingInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutDeviceNestedInput
    qms_customer?: qms_customerUpdateManyWithoutDeviceNestedInput
    tip?: tipUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_customer?: qms_customerUncheckedUpdateManyWithoutDeviceNestedInput
    tip?: tipUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type rating_assetsUpsertWithWhereUniqueWithoutRatingInput = {
    where: rating_assetsWhereUniqueInput
    update: XOR<rating_assetsUpdateWithoutRatingInput, rating_assetsUncheckedUpdateWithoutRatingInput>
    create: XOR<rating_assetsCreateWithoutRatingInput, rating_assetsUncheckedCreateWithoutRatingInput>
  }

  export type rating_assetsUpdateWithWhereUniqueWithoutRatingInput = {
    where: rating_assetsWhereUniqueInput
    data: XOR<rating_assetsUpdateWithoutRatingInput, rating_assetsUncheckedUpdateWithoutRatingInput>
  }

  export type rating_assetsUpdateManyWithWhereWithoutRatingInput = {
    where: rating_assetsScalarWhereInput
    data: XOR<rating_assetsUpdateManyMutationInput, rating_assetsUncheckedUpdateManyWithoutRatingInput>
  }

  export type rating_assetsScalarWhereInput = {
    AND?: rating_assetsScalarWhereInput | rating_assetsScalarWhereInput[]
    OR?: rating_assetsScalarWhereInput[]
    NOT?: rating_assetsScalarWhereInput | rating_assetsScalarWhereInput[]
    rating_assets_id?: IntFilter<"rating_assets"> | number
    rating_assets_image?: StringNullableFilter<"rating_assets"> | string | null
    rating_assets_video?: StringNullableFilter<"rating_assets"> | string | null
    rating_id?: BigIntNullableFilter<"rating_assets"> | bigint | number | null
  }

  export type tipUpsertWithWhereUniqueWithoutRatingInput = {
    where: tipWhereUniqueInput
    update: XOR<tipUpdateWithoutRatingInput, tipUncheckedUpdateWithoutRatingInput>
    create: XOR<tipCreateWithoutRatingInput, tipUncheckedCreateWithoutRatingInput>
  }

  export type tipUpdateWithWhereUniqueWithoutRatingInput = {
    where: tipWhereUniqueInput
    data: XOR<tipUpdateWithoutRatingInput, tipUncheckedUpdateWithoutRatingInput>
  }

  export type tipUpdateManyWithWhereWithoutRatingInput = {
    where: tipScalarWhereInput
    data: XOR<tipUpdateManyMutationInput, tipUncheckedUpdateManyWithoutRatingInput>
  }

  export type ratingCreateWithoutRating_assetsInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    service: serviceCreateNestedOneWithoutRatingInput
    device?: deviceCreateNestedOneWithoutRatingInput
    tip?: tipCreateNestedManyWithoutRatingInput
  }

  export type ratingUncheckedCreateWithoutRating_assetsInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    service_id: number
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    device_id?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    tip?: tipUncheckedCreateNestedManyWithoutRatingInput
  }

  export type ratingCreateOrConnectWithoutRating_assetsInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutRating_assetsInput, ratingUncheckedCreateWithoutRating_assetsInput>
  }

  export type ratingUpsertWithoutRating_assetsInput = {
    update: XOR<ratingUpdateWithoutRating_assetsInput, ratingUncheckedUpdateWithoutRating_assetsInput>
    create: XOR<ratingCreateWithoutRating_assetsInput, ratingUncheckedCreateWithoutRating_assetsInput>
    where?: ratingWhereInput
  }

  export type ratingUpdateToOneWithWhereWithoutRating_assetsInput = {
    where?: ratingWhereInput
    data: XOR<ratingUpdateWithoutRating_assetsInput, ratingUncheckedUpdateWithoutRating_assetsInput>
  }

  export type ratingUpdateWithoutRating_assetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateOneRequiredWithoutRatingNestedInput
    device?: deviceUpdateOneWithoutRatingNestedInput
    tip?: tipUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateWithoutRating_assetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    service_id?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    tip?: tipUncheckedUpdateManyWithoutRatingNestedInput
  }

  export type appointmentsCreateWithoutServiceInput = {
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
    user_appointments_creator_idTouser: userCreateNestedOneWithoutAppointments_appointments_creator_idTouserInput
    institution?: institutionCreateNestedOneWithoutAppointmentsInput
    qms_operator?: qms_operatorCreateNestedOneWithoutAppointmentsInput
    user_appointments_user_idTouser?: userCreateNestedOneWithoutAppointments_appointments_user_idTouserInput
  }

  export type appointmentsUncheckedCreateWithoutServiceInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsCreateOrConnectWithoutServiceInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutServiceInput, appointmentsUncheckedCreateWithoutServiceInput>
  }

  export type appointmentsCreateManyServiceInputEnvelope = {
    data: appointmentsCreateManyServiceInput | appointmentsCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type qms_counterCreateWithoutServiceInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_counterUncheckedCreateWithoutServiceInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_counterCreateOrConnectWithoutServiceInput = {
    where: qms_counterWhereUniqueInput
    create: XOR<qms_counterCreateWithoutServiceInput, qms_counterUncheckedCreateWithoutServiceInput>
  }

  export type qms_counterCreateManyServiceInputEnvelope = {
    data: qms_counterCreateManyServiceInput | qms_counterCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type qms_queueCreateWithoutServiceInput = {
    queue_uuid: string
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkCreateNestedManyWithoutQms_queueInput
    qms_ticket?: qms_ticketCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueUncheckedCreateWithoutServiceInput = {
    id?: number
    queue_uuid: string
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedCreateNestedManyWithoutQms_queueInput
    qms_ticket?: qms_ticketUncheckedCreateNestedManyWithoutQms_queueInput
  }

  export type qms_queueCreateOrConnectWithoutServiceInput = {
    where: qms_queueWhereUniqueInput
    create: XOR<qms_queueCreateWithoutServiceInput, qms_queueUncheckedCreateWithoutServiceInput>
  }

  export type qms_queueCreateManyServiceInputEnvelope = {
    data: qms_queueCreateManyServiceInput | qms_queueCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ratingCreateWithoutServiceInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    device?: deviceCreateNestedOneWithoutRatingInput
    rating_assets?: rating_assetsCreateNestedManyWithoutRatingInput
    tip?: tipCreateNestedManyWithoutRatingInput
  }

  export type ratingUncheckedCreateWithoutServiceInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    device_id?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    rating_assets?: rating_assetsUncheckedCreateNestedManyWithoutRatingInput
    tip?: tipUncheckedCreateNestedManyWithoutRatingInput
  }

  export type ratingCreateOrConnectWithoutServiceInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutServiceInput, ratingUncheckedCreateWithoutServiceInput>
  }

  export type ratingCreateManyServiceInputEnvelope = {
    data: ratingCreateManyServiceInput | ratingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type service_groupCreateWithoutServiceInput = {
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    serviceReview?: serviceReviewCreateNestedManyWithoutService_groupInput
    institution: institutionCreateNestedOneWithoutService_groupInput
    surveyQuestions?: surveyQuestionsCreateNestedManyWithoutService_groupInput
  }

  export type service_groupUncheckedCreateWithoutServiceInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    institution_id: number
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutService_groupInput
    surveyQuestions?: surveyQuestionsUncheckedCreateNestedManyWithoutService_groupInput
  }

  export type service_groupCreateOrConnectWithoutServiceInput = {
    where: service_groupWhereUniqueInput
    create: XOR<service_groupCreateWithoutServiceInput, service_groupUncheckedCreateWithoutServiceInput>
  }

  export type institutionCreateWithoutServiceInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutServiceInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutServiceInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutServiceInput, institutionUncheckedCreateWithoutServiceInput>
  }

  export type appointmentsUpsertWithWhereUniqueWithoutServiceInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutServiceInput, appointmentsUncheckedUpdateWithoutServiceInput>
    create: XOR<appointmentsCreateWithoutServiceInput, appointmentsUncheckedCreateWithoutServiceInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutServiceInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutServiceInput, appointmentsUncheckedUpdateWithoutServiceInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutServiceInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutServiceInput>
  }

  export type qms_counterUpsertWithWhereUniqueWithoutServiceInput = {
    where: qms_counterWhereUniqueInput
    update: XOR<qms_counterUpdateWithoutServiceInput, qms_counterUncheckedUpdateWithoutServiceInput>
    create: XOR<qms_counterCreateWithoutServiceInput, qms_counterUncheckedCreateWithoutServiceInput>
  }

  export type qms_counterUpdateWithWhereUniqueWithoutServiceInput = {
    where: qms_counterWhereUniqueInput
    data: XOR<qms_counterUpdateWithoutServiceInput, qms_counterUncheckedUpdateWithoutServiceInput>
  }

  export type qms_counterUpdateManyWithWhereWithoutServiceInput = {
    where: qms_counterScalarWhereInput
    data: XOR<qms_counterUpdateManyMutationInput, qms_counterUncheckedUpdateManyWithoutServiceInput>
  }

  export type qms_counterScalarWhereInput = {
    AND?: qms_counterScalarWhereInput | qms_counterScalarWhereInput[]
    OR?: qms_counterScalarWhereInput[]
    NOT?: qms_counterScalarWhereInput | qms_counterScalarWhereInput[]
    id?: IntFilter<"qms_counter"> | number
    name?: StringFilter<"qms_counter"> | string
    description?: StringNullableFilter<"qms_counter"> | string | null
    service_id?: IntNullableFilter<"qms_counter"> | number | null
    created_at?: DateTimeFilter<"qms_counter"> | Date | string
    updated_at?: DateTimeFilter<"qms_counter"> | Date | string
  }

  export type qms_queueUpsertWithWhereUniqueWithoutServiceInput = {
    where: qms_queueWhereUniqueInput
    update: XOR<qms_queueUpdateWithoutServiceInput, qms_queueUncheckedUpdateWithoutServiceInput>
    create: XOR<qms_queueCreateWithoutServiceInput, qms_queueUncheckedCreateWithoutServiceInput>
  }

  export type qms_queueUpdateWithWhereUniqueWithoutServiceInput = {
    where: qms_queueWhereUniqueInput
    data: XOR<qms_queueUpdateWithoutServiceInput, qms_queueUncheckedUpdateWithoutServiceInput>
  }

  export type qms_queueUpdateManyWithWhereWithoutServiceInput = {
    where: qms_queueScalarWhereInput
    data: XOR<qms_queueUpdateManyMutationInput, qms_queueUncheckedUpdateManyWithoutServiceInput>
  }

  export type qms_queueScalarWhereInput = {
    AND?: qms_queueScalarWhereInput | qms_queueScalarWhereInput[]
    OR?: qms_queueScalarWhereInput[]
    NOT?: qms_queueScalarWhereInput | qms_queueScalarWhereInput[]
    id?: IntFilter<"qms_queue"> | number
    queue_uuid?: StringFilter<"qms_queue"> | string
    service_id?: IntFilter<"qms_queue"> | number
    queue_date?: DateTimeFilter<"qms_queue"> | Date | string
    start_time?: DateTimeFilter<"qms_queue"> | Date | string
    end_time?: DateTimeFilter<"qms_queue"> | Date | string
    status?: Enumqms_queue_statusFilter<"qms_queue"> | $Enums.qms_queue_status
    avg_service_time?: FloatNullableFilter<"qms_queue"> | number | null
    created_at?: DateTimeFilter<"qms_queue"> | Date | string
    updated_at?: DateTimeFilter<"qms_queue"> | Date | string
    closure_notification?: IntFilter<"qms_queue"> | number
    inter_arrival_time?: FloatNullableFilter<"qms_queue"> | number | null
  }

  export type ratingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ratingWhereUniqueInput
    update: XOR<ratingUpdateWithoutServiceInput, ratingUncheckedUpdateWithoutServiceInput>
    create: XOR<ratingCreateWithoutServiceInput, ratingUncheckedCreateWithoutServiceInput>
  }

  export type ratingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ratingWhereUniqueInput
    data: XOR<ratingUpdateWithoutServiceInput, ratingUncheckedUpdateWithoutServiceInput>
  }

  export type ratingUpdateManyWithWhereWithoutServiceInput = {
    where: ratingScalarWhereInput
    data: XOR<ratingUpdateManyMutationInput, ratingUncheckedUpdateManyWithoutServiceInput>
  }

  export type service_groupUpsertWithoutServiceInput = {
    update: XOR<service_groupUpdateWithoutServiceInput, service_groupUncheckedUpdateWithoutServiceInput>
    create: XOR<service_groupCreateWithoutServiceInput, service_groupUncheckedCreateWithoutServiceInput>
    where?: service_groupWhereInput
  }

  export type service_groupUpdateToOneWithWhereWithoutServiceInput = {
    where?: service_groupWhereInput
    data: XOR<service_groupUpdateWithoutServiceInput, service_groupUncheckedUpdateWithoutServiceInput>
  }

  export type service_groupUpdateWithoutServiceInput = {
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    serviceReview?: serviceReviewUpdateManyWithoutService_groupNestedInput
    institution?: institutionUpdateOneRequiredWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUncheckedUpdateManyWithoutService_groupNestedInput
  }

  export type institutionUpsertWithoutServiceInput = {
    update: XOR<institutionUpdateWithoutServiceInput, institutionUncheckedUpdateWithoutServiceInput>
    create: XOR<institutionCreateWithoutServiceInput, institutionUncheckedCreateWithoutServiceInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutServiceInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutServiceInput, institutionUncheckedUpdateWithoutServiceInput>
  }

  export type institutionUpdateWithoutServiceInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type serviceCreateWithoutService_groupInput = {
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueCreateNestedManyWithoutServiceInput
    rating?: ratingCreateNestedManyWithoutServiceInput
    institution?: institutionCreateNestedOneWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutService_groupInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutServiceInput
    qms_counter?: qms_counterUncheckedCreateNestedManyWithoutServiceInput
    qms_queue?: qms_queueUncheckedCreateNestedManyWithoutServiceInput
    rating?: ratingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutService_groupInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutService_groupInput, serviceUncheckedCreateWithoutService_groupInput>
  }

  export type serviceCreateManyService_groupInputEnvelope = {
    data: serviceCreateManyService_groupInput | serviceCreateManyService_groupInput[]
    skipDuplicates?: boolean
  }

  export type serviceReviewCreateWithoutService_groupInput = {
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
    users_profile?: users_profileCreateNestedOneWithoutServiceReviewInput
  }

  export type serviceReviewUncheckedCreateWithoutService_groupInput = {
    id?: number
    user_id?: number | null
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
  }

  export type serviceReviewCreateOrConnectWithoutService_groupInput = {
    where: serviceReviewWhereUniqueInput
    create: XOR<serviceReviewCreateWithoutService_groupInput, serviceReviewUncheckedCreateWithoutService_groupInput>
  }

  export type serviceReviewCreateManyService_groupInputEnvelope = {
    data: serviceReviewCreateManyService_groupInput | serviceReviewCreateManyService_groupInput[]
    skipDuplicates?: boolean
  }

  export type institutionCreateWithoutService_groupInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutService_groupInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutService_groupInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutService_groupInput, institutionUncheckedCreateWithoutService_groupInput>
  }

  export type surveyQuestionsCreateWithoutService_groupInput = {
    question?: string | null
    choices?: string | null
    added_at?: Date | string
    surveyAnswers?: surveyAnswersCreateNestedManyWithoutSurveyQuestionsInput
  }

  export type surveyQuestionsUncheckedCreateWithoutService_groupInput = {
    id?: number
    question?: string | null
    choices?: string | null
    added_at?: Date | string
    surveyAnswers?: surveyAnswersUncheckedCreateNestedManyWithoutSurveyQuestionsInput
  }

  export type surveyQuestionsCreateOrConnectWithoutService_groupInput = {
    where: surveyQuestionsWhereUniqueInput
    create: XOR<surveyQuestionsCreateWithoutService_groupInput, surveyQuestionsUncheckedCreateWithoutService_groupInput>
  }

  export type surveyQuestionsCreateManyService_groupInputEnvelope = {
    data: surveyQuestionsCreateManyService_groupInput | surveyQuestionsCreateManyService_groupInput[]
    skipDuplicates?: boolean
  }

  export type serviceUpsertWithWhereUniqueWithoutService_groupInput = {
    where: serviceWhereUniqueInput
    update: XOR<serviceUpdateWithoutService_groupInput, serviceUncheckedUpdateWithoutService_groupInput>
    create: XOR<serviceCreateWithoutService_groupInput, serviceUncheckedCreateWithoutService_groupInput>
  }

  export type serviceUpdateWithWhereUniqueWithoutService_groupInput = {
    where: serviceWhereUniqueInput
    data: XOR<serviceUpdateWithoutService_groupInput, serviceUncheckedUpdateWithoutService_groupInput>
  }

  export type serviceUpdateManyWithWhereWithoutService_groupInput = {
    where: serviceScalarWhereInput
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyWithoutService_groupInput>
  }

  export type serviceReviewUpsertWithWhereUniqueWithoutService_groupInput = {
    where: serviceReviewWhereUniqueInput
    update: XOR<serviceReviewUpdateWithoutService_groupInput, serviceReviewUncheckedUpdateWithoutService_groupInput>
    create: XOR<serviceReviewCreateWithoutService_groupInput, serviceReviewUncheckedCreateWithoutService_groupInput>
  }

  export type serviceReviewUpdateWithWhereUniqueWithoutService_groupInput = {
    where: serviceReviewWhereUniqueInput
    data: XOR<serviceReviewUpdateWithoutService_groupInput, serviceReviewUncheckedUpdateWithoutService_groupInput>
  }

  export type serviceReviewUpdateManyWithWhereWithoutService_groupInput = {
    where: serviceReviewScalarWhereInput
    data: XOR<serviceReviewUpdateManyMutationInput, serviceReviewUncheckedUpdateManyWithoutService_groupInput>
  }

  export type serviceReviewScalarWhereInput = {
    AND?: serviceReviewScalarWhereInput | serviceReviewScalarWhereInput[]
    OR?: serviceReviewScalarWhereInput[]
    NOT?: serviceReviewScalarWhereInput | serviceReviewScalarWhereInput[]
    id?: IntFilter<"serviceReview"> | number
    user_id?: IntNullableFilter<"serviceReview"> | number | null
    service_id?: IntNullableFilter<"serviceReview"> | number | null
    rating?: IntNullableFilter<"serviceReview"> | number | null
    emoRating?: StringFilter<"serviceReview"> | string
    added_at?: DateTimeNullableFilter<"serviceReview"> | Date | string | null
  }

  export type institutionUpsertWithoutService_groupInput = {
    update: XOR<institutionUpdateWithoutService_groupInput, institutionUncheckedUpdateWithoutService_groupInput>
    create: XOR<institutionCreateWithoutService_groupInput, institutionUncheckedCreateWithoutService_groupInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutService_groupInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutService_groupInput, institutionUncheckedUpdateWithoutService_groupInput>
  }

  export type institutionUpdateWithoutService_groupInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type surveyQuestionsUpsertWithWhereUniqueWithoutService_groupInput = {
    where: surveyQuestionsWhereUniqueInput
    update: XOR<surveyQuestionsUpdateWithoutService_groupInput, surveyQuestionsUncheckedUpdateWithoutService_groupInput>
    create: XOR<surveyQuestionsCreateWithoutService_groupInput, surveyQuestionsUncheckedCreateWithoutService_groupInput>
  }

  export type surveyQuestionsUpdateWithWhereUniqueWithoutService_groupInput = {
    where: surveyQuestionsWhereUniqueInput
    data: XOR<surveyQuestionsUpdateWithoutService_groupInput, surveyQuestionsUncheckedUpdateWithoutService_groupInput>
  }

  export type surveyQuestionsUpdateManyWithWhereWithoutService_groupInput = {
    where: surveyQuestionsScalarWhereInput
    data: XOR<surveyQuestionsUpdateManyMutationInput, surveyQuestionsUncheckedUpdateManyWithoutService_groupInput>
  }

  export type surveyQuestionsScalarWhereInput = {
    AND?: surveyQuestionsScalarWhereInput | surveyQuestionsScalarWhereInput[]
    OR?: surveyQuestionsScalarWhereInput[]
    NOT?: surveyQuestionsScalarWhereInput | surveyQuestionsScalarWhereInput[]
    id?: IntFilter<"surveyQuestions"> | number
    service_id?: IntFilter<"surveyQuestions"> | number
    question?: StringNullableFilter<"surveyQuestions"> | string | null
    choices?: StringNullableFilter<"surveyQuestions"> | string | null
    added_at?: DateTimeFilter<"surveyQuestions"> | Date | string
  }

  export type userCreateWithoutTags_tags_created_byTouserInput = {
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    appointments_appointments_user_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_updated_byTouser?: tagsCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userUncheckedCreateWithoutTags_tags_created_byTouserInput = {
    id?: number
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    appointments_appointments_user_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_updated_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_updated_byTouserInput
  }

  export type userCreateOrConnectWithoutTags_tags_created_byTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTags_tags_created_byTouserInput, userUncheckedCreateWithoutTags_tags_created_byTouserInput>
  }

  export type userCreateWithoutTags_tags_updated_byTouserInput = {
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    appointments_appointments_user_idTouser?: appointmentsCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_created_byTouser?: tagsCreateNestedManyWithoutUser_tags_created_byTouserInput
  }

  export type userUncheckedCreateWithoutTags_tags_updated_byTouserInput = {
    id?: number
    name?: string | null
    title?: string | null
    phone_number?: string | null
    username: string
    auth_key: string
    password_hash: string
    password_reset_token?: string | null
    email?: string | null
    status?: boolean
    role?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verification_token?: string | null
    allowed_context?: number | null
    institution_id?: string | null
    last_received_hb_alert_at?: Date | string
    last_received_rating_notification_at?: Date | string
    language?: string | null
    notifications_enabled?: boolean | null
    last_login?: Date | string | null
    allow_auto_approved_changes?: boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_creator_idTouserInput
    appointments_appointments_user_idTouser?: appointmentsUncheckedCreateNestedManyWithoutUser_appointments_user_idTouserInput
    tags_tags_created_byTouser?: tagsUncheckedCreateNestedManyWithoutUser_tags_created_byTouserInput
  }

  export type userCreateOrConnectWithoutTags_tags_updated_byTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTags_tags_updated_byTouserInput, userUncheckedCreateWithoutTags_tags_updated_byTouserInput>
  }

  export type userUpsertWithoutTags_tags_created_byTouserInput = {
    update: XOR<userUpdateWithoutTags_tags_created_byTouserInput, userUncheckedUpdateWithoutTags_tags_created_byTouserInput>
    create: XOR<userCreateWithoutTags_tags_created_byTouserInput, userUncheckedCreateWithoutTags_tags_created_byTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTags_tags_created_byTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTags_tags_created_byTouserInput, userUncheckedUpdateWithoutTags_tags_created_byTouserInput>
  }

  export type userUpdateWithoutTags_tags_created_byTouserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    appointments_appointments_user_idTouser?: appointmentsUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_updated_byTouser?: tagsUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type userUncheckedUpdateWithoutTags_tags_created_byTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    appointments_appointments_user_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_updated_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserNestedInput
  }

  export type userUpsertWithoutTags_tags_updated_byTouserInput = {
    update: XOR<userUpdateWithoutTags_tags_updated_byTouserInput, userUncheckedUpdateWithoutTags_tags_updated_byTouserInput>
    create: XOR<userCreateWithoutTags_tags_updated_byTouserInput, userUncheckedCreateWithoutTags_tags_updated_byTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTags_tags_updated_byTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTags_tags_updated_byTouserInput, userUncheckedUpdateWithoutTags_tags_updated_byTouserInput>
  }

  export type userUpdateWithoutTags_tags_updated_byTouserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    appointments_appointments_user_idTouser?: appointmentsUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUpdateManyWithoutUser_tags_created_byTouserNestedInput
  }

  export type userUncheckedUpdateWithoutTags_tags_updated_byTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    auth_key?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    role?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_received_hb_alert_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_received_rating_notification_at?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allow_auto_approved_changes?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments_appointments_creator_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserNestedInput
    appointments_appointments_user_idTouser?: appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserNestedInput
    tags_tags_created_byTouser?: tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserNestedInput
  }

  export type deviceCreateWithoutTipInput = {
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    institution?: institutionCreateNestedOneWithoutDeviceInput
    qms_customer?: qms_customerCreateNestedManyWithoutDeviceInput
    rating?: ratingCreateNestedManyWithoutDeviceInput
  }

  export type deviceUncheckedCreateWithoutTipInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    affiliate_id?: number | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
    qms_customer?: qms_customerUncheckedCreateNestedManyWithoutDeviceInput
    rating?: ratingUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type deviceCreateOrConnectWithoutTipInput = {
    where: deviceWhereUniqueInput
    create: XOR<deviceCreateWithoutTipInput, deviceUncheckedCreateWithoutTipInput>
  }

  export type ratingCreateWithoutTipInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    service: serviceCreateNestedOneWithoutRatingInput
    device?: deviceCreateNestedOneWithoutRatingInput
    rating_assets?: rating_assetsCreateNestedManyWithoutRatingInput
  }

  export type ratingUncheckedCreateWithoutTipInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    service_id: number
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    device_id?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
    rating_assets?: rating_assetsUncheckedCreateNestedManyWithoutRatingInput
  }

  export type ratingCreateOrConnectWithoutTipInput = {
    where: ratingWhereUniqueInput
    create: XOR<ratingCreateWithoutTipInput, ratingUncheckedCreateWithoutTipInput>
  }

  export type deviceUpsertWithoutTipInput = {
    update: XOR<deviceUpdateWithoutTipInput, deviceUncheckedUpdateWithoutTipInput>
    create: XOR<deviceCreateWithoutTipInput, deviceUncheckedCreateWithoutTipInput>
    where?: deviceWhereInput
  }

  export type deviceUpdateToOneWithWhereWithoutTipInput = {
    where?: deviceWhereInput
    data: XOR<deviceUpdateWithoutTipInput, deviceUncheckedUpdateWithoutTipInput>
  }

  export type deviceUpdateWithoutTipInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutDeviceNestedInput
    qms_customer?: qms_customerUpdateManyWithoutDeviceNestedInput
    rating?: ratingUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutTipInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_customer?: qms_customerUncheckedUpdateManyWithoutDeviceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type ratingUpsertWithoutTipInput = {
    update: XOR<ratingUpdateWithoutTipInput, ratingUncheckedUpdateWithoutTipInput>
    create: XOR<ratingCreateWithoutTipInput, ratingUncheckedCreateWithoutTipInput>
    where?: ratingWhereInput
  }

  export type ratingUpdateToOneWithWhereWithoutTipInput = {
    where?: ratingWhereInput
    data: XOR<ratingUpdateWithoutTipInput, ratingUncheckedUpdateWithoutTipInput>
  }

  export type ratingUpdateWithoutTipInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateOneRequiredWithoutRatingNestedInput
    device?: deviceUpdateOneWithoutRatingNestedInput
    rating_assets?: rating_assetsUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateWithoutTipInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    service_id?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets?: rating_assetsUncheckedUpdateManyWithoutRatingNestedInput
  }

  export type appointmentsCreateWithoutUser_appointments_creator_idTouserInput = {
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
    institution?: institutionCreateNestedOneWithoutAppointmentsInput
    qms_operator?: qms_operatorCreateNestedOneWithoutAppointmentsInput
    service?: serviceCreateNestedOneWithoutAppointmentsInput
    user_appointments_user_idTouser?: userCreateNestedOneWithoutAppointments_appointments_user_idTouserInput
  }

  export type appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsCreateOrConnectWithoutUser_appointments_creator_idTouserInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput>
  }

  export type appointmentsCreateManyUser_appointments_creator_idTouserInputEnvelope = {
    data: appointmentsCreateManyUser_appointments_creator_idTouserInput | appointmentsCreateManyUser_appointments_creator_idTouserInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsCreateWithoutUser_appointments_user_idTouserInput = {
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
    user_appointments_creator_idTouser: userCreateNestedOneWithoutAppointments_appointments_creator_idTouserInput
    institution?: institutionCreateNestedOneWithoutAppointmentsInput
    qms_operator?: qms_operatorCreateNestedOneWithoutAppointmentsInput
    service?: serviceCreateNestedOneWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    operator_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsCreateOrConnectWithoutUser_appointments_user_idTouserInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput>
  }

  export type appointmentsCreateManyUser_appointments_user_idTouserInputEnvelope = {
    data: appointmentsCreateManyUser_appointments_user_idTouserInput | appointmentsCreateManyUser_appointments_user_idTouserInput[]
    skipDuplicates?: boolean
  }

  export type tagsCreateWithoutUser_tags_created_byTouserInput = {
    name: string
    services: string
    created_at?: Date | string | null
    status?: boolean | null
    user_tags_updated_byTouser?: userCreateNestedOneWithoutTags_tags_updated_byTouserInput
  }

  export type tagsUncheckedCreateWithoutUser_tags_created_byTouserInput = {
    id?: number
    name: string
    services: string
    created_at?: Date | string | null
    updated_by?: number | null
    status?: boolean | null
  }

  export type tagsCreateOrConnectWithoutUser_tags_created_byTouserInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutUser_tags_created_byTouserInput, tagsUncheckedCreateWithoutUser_tags_created_byTouserInput>
  }

  export type tagsCreateManyUser_tags_created_byTouserInputEnvelope = {
    data: tagsCreateManyUser_tags_created_byTouserInput | tagsCreateManyUser_tags_created_byTouserInput[]
    skipDuplicates?: boolean
  }

  export type tagsCreateWithoutUser_tags_updated_byTouserInput = {
    name: string
    services: string
    created_at?: Date | string | null
    status?: boolean | null
    user_tags_created_byTouser: userCreateNestedOneWithoutTags_tags_created_byTouserInput
  }

  export type tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput = {
    id?: number
    name: string
    services: string
    created_at?: Date | string | null
    created_by: number
    status?: boolean | null
  }

  export type tagsCreateOrConnectWithoutUser_tags_updated_byTouserInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutUser_tags_updated_byTouserInput, tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput>
  }

  export type tagsCreateManyUser_tags_updated_byTouserInputEnvelope = {
    data: tagsCreateManyUser_tags_updated_byTouserInput | tagsCreateManyUser_tags_updated_byTouserInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutUser_appointments_creator_idTouserInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedUpdateWithoutUser_appointments_creator_idTouserInput>
    create: XOR<appointmentsCreateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_creator_idTouserInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutUser_appointments_creator_idTouserInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutUser_appointments_creator_idTouserInput, appointmentsUncheckedUpdateWithoutUser_appointments_creator_idTouserInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutUser_appointments_creator_idTouserInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserInput>
  }

  export type appointmentsUpsertWithWhereUniqueWithoutUser_appointments_user_idTouserInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedUpdateWithoutUser_appointments_user_idTouserInput>
    create: XOR<appointmentsCreateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedCreateWithoutUser_appointments_user_idTouserInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutUser_appointments_user_idTouserInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutUser_appointments_user_idTouserInput, appointmentsUncheckedUpdateWithoutUser_appointments_user_idTouserInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutUser_appointments_user_idTouserInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserInput>
  }

  export type tagsUpsertWithWhereUniqueWithoutUser_tags_created_byTouserInput = {
    where: tagsWhereUniqueInput
    update: XOR<tagsUpdateWithoutUser_tags_created_byTouserInput, tagsUncheckedUpdateWithoutUser_tags_created_byTouserInput>
    create: XOR<tagsCreateWithoutUser_tags_created_byTouserInput, tagsUncheckedCreateWithoutUser_tags_created_byTouserInput>
  }

  export type tagsUpdateWithWhereUniqueWithoutUser_tags_created_byTouserInput = {
    where: tagsWhereUniqueInput
    data: XOR<tagsUpdateWithoutUser_tags_created_byTouserInput, tagsUncheckedUpdateWithoutUser_tags_created_byTouserInput>
  }

  export type tagsUpdateManyWithWhereWithoutUser_tags_created_byTouserInput = {
    where: tagsScalarWhereInput
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserInput>
  }

  export type tagsScalarWhereInput = {
    AND?: tagsScalarWhereInput | tagsScalarWhereInput[]
    OR?: tagsScalarWhereInput[]
    NOT?: tagsScalarWhereInput | tagsScalarWhereInput[]
    id?: IntFilter<"tags"> | number
    name?: StringFilter<"tags"> | string
    services?: StringFilter<"tags"> | string
    created_at?: DateTimeNullableFilter<"tags"> | Date | string | null
    created_by?: IntFilter<"tags"> | number
    updated_by?: IntNullableFilter<"tags"> | number | null
    status?: BoolNullableFilter<"tags"> | boolean | null
  }

  export type tagsUpsertWithWhereUniqueWithoutUser_tags_updated_byTouserInput = {
    where: tagsWhereUniqueInput
    update: XOR<tagsUpdateWithoutUser_tags_updated_byTouserInput, tagsUncheckedUpdateWithoutUser_tags_updated_byTouserInput>
    create: XOR<tagsCreateWithoutUser_tags_updated_byTouserInput, tagsUncheckedCreateWithoutUser_tags_updated_byTouserInput>
  }

  export type tagsUpdateWithWhereUniqueWithoutUser_tags_updated_byTouserInput = {
    where: tagsWhereUniqueInput
    data: XOR<tagsUpdateWithoutUser_tags_updated_byTouserInput, tagsUncheckedUpdateWithoutUser_tags_updated_byTouserInput>
  }

  export type tagsUpdateManyWithWhereWithoutUser_tags_updated_byTouserInput = {
    where: tagsScalarWhereInput
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserInput>
  }

  export type institutionCreateWithoutImagesInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutImagesInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutImagesInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutImagesInput, institutionUncheckedCreateWithoutImagesInput>
  }

  export type reviewsCreateWithoutImagesInput = {
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    institution: institutionCreateNestedOneWithoutReviewsInput
    users_profile: users_profileCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutImagesInput = {
    id?: number
    user_id: number
    institution_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
  }

  export type reviewsCreateOrConnectWithoutImagesInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutImagesInput, reviewsUncheckedCreateWithoutImagesInput>
  }

  export type users_profileCreateWithoutImagesInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    reviews?: reviewsCreateNestedManyWithoutUsers_profileInput
    serviceReview?: serviceReviewCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileUncheckedCreateWithoutImagesInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsers_profileInput
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileCreateOrConnectWithoutImagesInput = {
    where: users_profileWhereUniqueInput
    create: XOR<users_profileCreateWithoutImagesInput, users_profileUncheckedCreateWithoutImagesInput>
  }

  export type institutionUpsertWithoutImagesInput = {
    update: XOR<institutionUpdateWithoutImagesInput, institutionUncheckedUpdateWithoutImagesInput>
    create: XOR<institutionCreateWithoutImagesInput, institutionUncheckedCreateWithoutImagesInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutImagesInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutImagesInput, institutionUncheckedUpdateWithoutImagesInput>
  }

  export type institutionUpdateWithoutImagesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type reviewsUpsertWithoutImagesInput = {
    update: XOR<reviewsUpdateWithoutImagesInput, reviewsUncheckedUpdateWithoutImagesInput>
    create: XOR<reviewsCreateWithoutImagesInput, reviewsUncheckedCreateWithoutImagesInput>
    where?: reviewsWhereInput
  }

  export type reviewsUpdateToOneWithWhereWithoutImagesInput = {
    where?: reviewsWhereInput
    data: XOR<reviewsUpdateWithoutImagesInput, reviewsUncheckedUpdateWithoutImagesInput>
  }

  export type reviewsUpdateWithoutImagesInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    institution?: institutionUpdateOneRequiredWithoutReviewsNestedInput
    users_profile?: users_profileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type users_profileUpsertWithoutImagesInput = {
    update: XOR<users_profileUpdateWithoutImagesInput, users_profileUncheckedUpdateWithoutImagesInput>
    create: XOR<users_profileCreateWithoutImagesInput, users_profileUncheckedCreateWithoutImagesInput>
    where?: users_profileWhereInput
  }

  export type users_profileUpdateToOneWithWhereWithoutImagesInput = {
    where?: users_profileWhereInput
    data: XOR<users_profileUpdateWithoutImagesInput, users_profileUncheckedUpdateWithoutImagesInput>
  }

  export type users_profileUpdateWithoutImagesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: reviewsUpdateManyWithoutUsers_profileNestedInput
    serviceReview?: serviceReviewUpdateManyWithoutUsers_profileNestedInput
  }

  export type users_profileUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: reviewsUncheckedUpdateManyWithoutUsers_profileNestedInput
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutUsers_profileNestedInput
  }

  export type categoriesCreateWithoutSectorsInput = {
    name: string
    category_search_terms?: category_search_termsCreateNestedManyWithoutCategoriesInput
    institution?: institutionCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutSectorsInput = {
    id?: number
    name: string
    category_search_terms?: category_search_termsUncheckedCreateNestedManyWithoutCategoriesInput
    institution?: institutionUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutSectorsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutSectorsInput, categoriesUncheckedCreateWithoutSectorsInput>
  }

  export type categoriesCreateManySectorsInputEnvelope = {
    data: categoriesCreateManySectorsInput | categoriesCreateManySectorsInput[]
    skipDuplicates?: boolean
  }

  export type categoriesUpsertWithWhereUniqueWithoutSectorsInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutSectorsInput, categoriesUncheckedUpdateWithoutSectorsInput>
    create: XOR<categoriesCreateWithoutSectorsInput, categoriesUncheckedCreateWithoutSectorsInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutSectorsInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutSectorsInput, categoriesUncheckedUpdateWithoutSectorsInput>
  }

  export type categoriesUpdateManyWithWhereWithoutSectorsInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutSectorsInput>
  }

  export type categoriesScalarWhereInput = {
    AND?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    OR?: categoriesScalarWhereInput[]
    NOT?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    id?: IntFilter<"categories"> | number
    name?: StringFilter<"categories"> | string
    sector_id?: IntNullableFilter<"categories"> | number | null
  }

  export type imagesCreateWithoutUsers_profileInput = {
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    institution?: institutionCreateNestedOneWithoutImagesInput
    reviews?: reviewsCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutUsers_profileInput = {
    id?: number
    institution_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    review_id?: number | null
  }

  export type imagesCreateOrConnectWithoutUsers_profileInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutUsers_profileInput, imagesUncheckedCreateWithoutUsers_profileInput>
  }

  export type imagesCreateManyUsers_profileInputEnvelope = {
    data: imagesCreateManyUsers_profileInput | imagesCreateManyUsers_profileInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutUsers_profileInput = {
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    images?: imagesCreateNestedManyWithoutReviewsInput
    institution: institutionCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutUsers_profileInput = {
    id?: number
    institution_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
    images?: imagesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutUsers_profileInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutUsers_profileInput, reviewsUncheckedCreateWithoutUsers_profileInput>
  }

  export type reviewsCreateManyUsers_profileInputEnvelope = {
    data: reviewsCreateManyUsers_profileInput | reviewsCreateManyUsers_profileInput[]
    skipDuplicates?: boolean
  }

  export type serviceReviewCreateWithoutUsers_profileInput = {
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
    service_group?: service_groupCreateNestedOneWithoutServiceReviewInput
  }

  export type serviceReviewUncheckedCreateWithoutUsers_profileInput = {
    id?: number
    service_id?: number | null
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
  }

  export type serviceReviewCreateOrConnectWithoutUsers_profileInput = {
    where: serviceReviewWhereUniqueInput
    create: XOR<serviceReviewCreateWithoutUsers_profileInput, serviceReviewUncheckedCreateWithoutUsers_profileInput>
  }

  export type serviceReviewCreateManyUsers_profileInputEnvelope = {
    data: serviceReviewCreateManyUsers_profileInput | serviceReviewCreateManyUsers_profileInput[]
    skipDuplicates?: boolean
  }

  export type imagesUpsertWithWhereUniqueWithoutUsers_profileInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutUsers_profileInput, imagesUncheckedUpdateWithoutUsers_profileInput>
    create: XOR<imagesCreateWithoutUsers_profileInput, imagesUncheckedCreateWithoutUsers_profileInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutUsers_profileInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutUsers_profileInput, imagesUncheckedUpdateWithoutUsers_profileInput>
  }

  export type imagesUpdateManyWithWhereWithoutUsers_profileInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutUsers_profileInput>
  }

  export type reviewsUpsertWithWhereUniqueWithoutUsers_profileInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutUsers_profileInput, reviewsUncheckedUpdateWithoutUsers_profileInput>
    create: XOR<reviewsCreateWithoutUsers_profileInput, reviewsUncheckedCreateWithoutUsers_profileInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutUsers_profileInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutUsers_profileInput, reviewsUncheckedUpdateWithoutUsers_profileInput>
  }

  export type reviewsUpdateManyWithWhereWithoutUsers_profileInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutUsers_profileInput>
  }

  export type serviceReviewUpsertWithWhereUniqueWithoutUsers_profileInput = {
    where: serviceReviewWhereUniqueInput
    update: XOR<serviceReviewUpdateWithoutUsers_profileInput, serviceReviewUncheckedUpdateWithoutUsers_profileInput>
    create: XOR<serviceReviewCreateWithoutUsers_profileInput, serviceReviewUncheckedCreateWithoutUsers_profileInput>
  }

  export type serviceReviewUpdateWithWhereUniqueWithoutUsers_profileInput = {
    where: serviceReviewWhereUniqueInput
    data: XOR<serviceReviewUpdateWithoutUsers_profileInput, serviceReviewUncheckedUpdateWithoutUsers_profileInput>
  }

  export type serviceReviewUpdateManyWithWhereWithoutUsers_profileInput = {
    where: serviceReviewScalarWhereInput
    data: XOR<serviceReviewUpdateManyMutationInput, serviceReviewUncheckedUpdateManyWithoutUsers_profileInput>
  }

  export type imagesCreateWithoutReviewsInput = {
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    institution?: institutionCreateNestedOneWithoutImagesInput
    users_profile?: users_profileCreateNestedOneWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutReviewsInput = {
    id?: number
    institution_id?: number | null
    user_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
  }

  export type imagesCreateOrConnectWithoutReviewsInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutReviewsInput, imagesUncheckedCreateWithoutReviewsInput>
  }

  export type imagesCreateManyReviewsInputEnvelope = {
    data: imagesCreateManyReviewsInput | imagesCreateManyReviewsInput[]
    skipDuplicates?: boolean
  }

  export type institutionCreateWithoutReviewsInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutReviewsInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutReviewsInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutReviewsInput, institutionUncheckedCreateWithoutReviewsInput>
  }

  export type users_profileCreateWithoutReviewsInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    images?: imagesCreateNestedManyWithoutUsers_profileInput
    serviceReview?: serviceReviewCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileUncheckedCreateWithoutReviewsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    images?: imagesUncheckedCreateNestedManyWithoutUsers_profileInput
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileCreateOrConnectWithoutReviewsInput = {
    where: users_profileWhereUniqueInput
    create: XOR<users_profileCreateWithoutReviewsInput, users_profileUncheckedCreateWithoutReviewsInput>
  }

  export type imagesUpsertWithWhereUniqueWithoutReviewsInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutReviewsInput, imagesUncheckedUpdateWithoutReviewsInput>
    create: XOR<imagesCreateWithoutReviewsInput, imagesUncheckedCreateWithoutReviewsInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutReviewsInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutReviewsInput, imagesUncheckedUpdateWithoutReviewsInput>
  }

  export type imagesUpdateManyWithWhereWithoutReviewsInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutReviewsInput>
  }

  export type institutionUpsertWithoutReviewsInput = {
    update: XOR<institutionUpdateWithoutReviewsInput, institutionUncheckedUpdateWithoutReviewsInput>
    create: XOR<institutionCreateWithoutReviewsInput, institutionUncheckedCreateWithoutReviewsInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutReviewsInput, institutionUncheckedUpdateWithoutReviewsInput>
  }

  export type institutionUpdateWithoutReviewsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type users_profileUpsertWithoutReviewsInput = {
    update: XOR<users_profileUpdateWithoutReviewsInput, users_profileUncheckedUpdateWithoutReviewsInput>
    create: XOR<users_profileCreateWithoutReviewsInput, users_profileUncheckedCreateWithoutReviewsInput>
    where?: users_profileWhereInput
  }

  export type users_profileUpdateToOneWithWhereWithoutReviewsInput = {
    where?: users_profileWhereInput
    data: XOR<users_profileUpdateWithoutReviewsInput, users_profileUncheckedUpdateWithoutReviewsInput>
  }

  export type users_profileUpdateWithoutReviewsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    images?: imagesUpdateManyWithoutUsers_profileNestedInput
    serviceReview?: serviceReviewUpdateManyWithoutUsers_profileNestedInput
  }

  export type users_profileUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    images?: imagesUncheckedUpdateManyWithoutUsers_profileNestedInput
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutUsers_profileNestedInput
  }

  export type institutionCreateWithoutWorkingHourInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutWorkingHourInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutWorkingHourInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutWorkingHourInput, institutionUncheckedCreateWithoutWorkingHourInput>
  }

  export type institutionUpsertWithoutWorkingHourInput = {
    update: XOR<institutionUpdateWithoutWorkingHourInput, institutionUncheckedUpdateWithoutWorkingHourInput>
    create: XOR<institutionCreateWithoutWorkingHourInput, institutionUncheckedCreateWithoutWorkingHourInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutWorkingHourInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutWorkingHourInput, institutionUncheckedUpdateWithoutWorkingHourInput>
  }

  export type institutionUpdateWithoutWorkingHourInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutWorkingHourInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type business_amenitiesCreateWithoutAmenitiesInput = {
    institution?: institutionCreateNestedOneWithoutBusiness_amenitiesInput
  }

  export type business_amenitiesUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    institution_id?: number | null
  }

  export type business_amenitiesCreateOrConnectWithoutAmenitiesInput = {
    where: business_amenitiesWhereUniqueInput
    create: XOR<business_amenitiesCreateWithoutAmenitiesInput, business_amenitiesUncheckedCreateWithoutAmenitiesInput>
  }

  export type business_amenitiesCreateManyAmenitiesInputEnvelope = {
    data: business_amenitiesCreateManyAmenitiesInput | business_amenitiesCreateManyAmenitiesInput[]
    skipDuplicates?: boolean
  }

  export type business_amenitiesUpsertWithWhereUniqueWithoutAmenitiesInput = {
    where: business_amenitiesWhereUniqueInput
    update: XOR<business_amenitiesUpdateWithoutAmenitiesInput, business_amenitiesUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<business_amenitiesCreateWithoutAmenitiesInput, business_amenitiesUncheckedCreateWithoutAmenitiesInput>
  }

  export type business_amenitiesUpdateWithWhereUniqueWithoutAmenitiesInput = {
    where: business_amenitiesWhereUniqueInput
    data: XOR<business_amenitiesUpdateWithoutAmenitiesInput, business_amenitiesUncheckedUpdateWithoutAmenitiesInput>
  }

  export type business_amenitiesUpdateManyWithWhereWithoutAmenitiesInput = {
    where: business_amenitiesScalarWhereInput
    data: XOR<business_amenitiesUpdateManyMutationInput, business_amenitiesUncheckedUpdateManyWithoutAmenitiesInput>
  }

  export type amenitiesCreateWithoutBusiness_amenitiesInput = {
    name: string
    icon?: string | null
    added_at?: Date | string | null
  }

  export type amenitiesUncheckedCreateWithoutBusiness_amenitiesInput = {
    id?: number
    name: string
    icon?: string | null
    added_at?: Date | string | null
  }

  export type amenitiesCreateOrConnectWithoutBusiness_amenitiesInput = {
    where: amenitiesWhereUniqueInput
    create: XOR<amenitiesCreateWithoutBusiness_amenitiesInput, amenitiesUncheckedCreateWithoutBusiness_amenitiesInput>
  }

  export type institutionCreateWithoutBusiness_amenitiesInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutBusiness_amenitiesInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    price_ranges?: price_rangesUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutBusiness_amenitiesInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutBusiness_amenitiesInput, institutionUncheckedCreateWithoutBusiness_amenitiesInput>
  }

  export type amenitiesUpsertWithoutBusiness_amenitiesInput = {
    update: XOR<amenitiesUpdateWithoutBusiness_amenitiesInput, amenitiesUncheckedUpdateWithoutBusiness_amenitiesInput>
    create: XOR<amenitiesCreateWithoutBusiness_amenitiesInput, amenitiesUncheckedCreateWithoutBusiness_amenitiesInput>
    where?: amenitiesWhereInput
  }

  export type amenitiesUpdateToOneWithWhereWithoutBusiness_amenitiesInput = {
    where?: amenitiesWhereInput
    data: XOR<amenitiesUpdateWithoutBusiness_amenitiesInput, amenitiesUncheckedUpdateWithoutBusiness_amenitiesInput>
  }

  export type amenitiesUpdateWithoutBusiness_amenitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type amenitiesUncheckedUpdateWithoutBusiness_amenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type institutionUpsertWithoutBusiness_amenitiesInput = {
    update: XOR<institutionUpdateWithoutBusiness_amenitiesInput, institutionUncheckedUpdateWithoutBusiness_amenitiesInput>
    create: XOR<institutionCreateWithoutBusiness_amenitiesInput, institutionUncheckedCreateWithoutBusiness_amenitiesInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutBusiness_amenitiesInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutBusiness_amenitiesInput, institutionUncheckedUpdateWithoutBusiness_amenitiesInput>
  }

  export type institutionUpdateWithoutBusiness_amenitiesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutBusiness_amenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionCreateWithoutPrice_rangesInput = {
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsCreateNestedManyWithoutInstitutionInput
    apps?: appsCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesCreateNestedManyWithoutInstitutionInput
    device?: deviceCreateNestedManyWithoutInstitutionInput
    images?: imagesCreateNestedManyWithoutInstitutionInput
    categories?: categoriesCreateNestedOneWithoutInstitutionInput
    popup_questions?: popup_questionsCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsCreateNestedManyWithoutInstitutionInput
    service?: serviceCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourCreateNestedManyWithoutInstitutionInput
  }

  export type institutionUncheckedCreateWithoutPrice_rangesInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    category_id?: number | null
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutInstitutionInput
    apps?: appsUncheckedCreateNestedManyWithoutInstitutionInput
    business_amenities?: business_amenitiesUncheckedCreateNestedManyWithoutInstitutionInput
    device?: deviceUncheckedCreateNestedManyWithoutInstitutionInput
    images?: imagesUncheckedCreateNestedManyWithoutInstitutionInput
    popup_questions?: popup_questionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_operator?: qms_branch_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedCreateNestedManyWithoutInstitutionInput
    qms_operator?: qms_operatorUncheckedCreateNestedManyWithoutInstitutionInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutInstitutionInput
    service?: serviceUncheckedCreateNestedManyWithoutInstitutionInput
    service_group?: service_groupUncheckedCreateNestedManyWithoutInstitutionInput
    workingHour?: workingHourUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionCreateOrConnectWithoutPrice_rangesInput = {
    where: institutionWhereUniqueInput
    create: XOR<institutionCreateWithoutPrice_rangesInput, institutionUncheckedCreateWithoutPrice_rangesInput>
  }

  export type institutionUpsertWithoutPrice_rangesInput = {
    update: XOR<institutionUpdateWithoutPrice_rangesInput, institutionUncheckedUpdateWithoutPrice_rangesInput>
    create: XOR<institutionCreateWithoutPrice_rangesInput, institutionUncheckedCreateWithoutPrice_rangesInput>
    where?: institutionWhereInput
  }

  export type institutionUpdateToOneWithWhereWithoutPrice_rangesInput = {
    where?: institutionWhereInput
    data: XOR<institutionUpdateWithoutPrice_rangesInput, institutionUncheckedUpdateWithoutPrice_rangesInput>
  }

  export type institutionUpdateWithoutPrice_rangesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    categories?: categoriesUpdateOneWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutPrice_rangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type surveyQuestionsCreateWithoutSurveyAnswersInput = {
    question?: string | null
    choices?: string | null
    added_at?: Date | string
    service_group: service_groupCreateNestedOneWithoutSurveyQuestionsInput
  }

  export type surveyQuestionsUncheckedCreateWithoutSurveyAnswersInput = {
    id?: number
    service_id: number
    question?: string | null
    choices?: string | null
    added_at?: Date | string
  }

  export type surveyQuestionsCreateOrConnectWithoutSurveyAnswersInput = {
    where: surveyQuestionsWhereUniqueInput
    create: XOR<surveyQuestionsCreateWithoutSurveyAnswersInput, surveyQuestionsUncheckedCreateWithoutSurveyAnswersInput>
  }

  export type surveyQuestionsUpsertWithoutSurveyAnswersInput = {
    update: XOR<surveyQuestionsUpdateWithoutSurveyAnswersInput, surveyQuestionsUncheckedUpdateWithoutSurveyAnswersInput>
    create: XOR<surveyQuestionsCreateWithoutSurveyAnswersInput, surveyQuestionsUncheckedCreateWithoutSurveyAnswersInput>
    where?: surveyQuestionsWhereInput
  }

  export type surveyQuestionsUpdateToOneWithWhereWithoutSurveyAnswersInput = {
    where?: surveyQuestionsWhereInput
    data: XOR<surveyQuestionsUpdateWithoutSurveyAnswersInput, surveyQuestionsUncheckedUpdateWithoutSurveyAnswersInput>
  }

  export type surveyQuestionsUpdateWithoutSurveyAnswersInput = {
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service_group?: service_groupUpdateOneRequiredWithoutSurveyQuestionsNestedInput
  }

  export type surveyQuestionsUncheckedUpdateWithoutSurveyAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyAnswersCreateWithoutSurveyQuestionsInput = {
    user_id?: number | null
    answer?: string | null
    scale_rating?: number | null
    added_at?: Date | string
  }

  export type surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput = {
    id?: number
    user_id?: number | null
    answer?: string | null
    scale_rating?: number | null
    added_at?: Date | string
  }

  export type surveyAnswersCreateOrConnectWithoutSurveyQuestionsInput = {
    where: surveyAnswersWhereUniqueInput
    create: XOR<surveyAnswersCreateWithoutSurveyQuestionsInput, surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type surveyAnswersCreateManySurveyQuestionsInputEnvelope = {
    data: surveyAnswersCreateManySurveyQuestionsInput | surveyAnswersCreateManySurveyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type service_groupCreateWithoutSurveyQuestionsInput = {
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceCreateNestedManyWithoutService_groupInput
    serviceReview?: serviceReviewCreateNestedManyWithoutService_groupInput
    institution: institutionCreateNestedOneWithoutService_groupInput
  }

  export type service_groupUncheckedCreateWithoutSurveyQuestionsInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    institution_id: number
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceUncheckedCreateNestedManyWithoutService_groupInput
    serviceReview?: serviceReviewUncheckedCreateNestedManyWithoutService_groupInput
  }

  export type service_groupCreateOrConnectWithoutSurveyQuestionsInput = {
    where: service_groupWhereUniqueInput
    create: XOR<service_groupCreateWithoutSurveyQuestionsInput, service_groupUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type surveyAnswersUpsertWithWhereUniqueWithoutSurveyQuestionsInput = {
    where: surveyAnswersWhereUniqueInput
    update: XOR<surveyAnswersUpdateWithoutSurveyQuestionsInput, surveyAnswersUncheckedUpdateWithoutSurveyQuestionsInput>
    create: XOR<surveyAnswersCreateWithoutSurveyQuestionsInput, surveyAnswersUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type surveyAnswersUpdateWithWhereUniqueWithoutSurveyQuestionsInput = {
    where: surveyAnswersWhereUniqueInput
    data: XOR<surveyAnswersUpdateWithoutSurveyQuestionsInput, surveyAnswersUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type surveyAnswersUpdateManyWithWhereWithoutSurveyQuestionsInput = {
    where: surveyAnswersScalarWhereInput
    data: XOR<surveyAnswersUpdateManyMutationInput, surveyAnswersUncheckedUpdateManyWithoutSurveyQuestionsInput>
  }

  export type surveyAnswersScalarWhereInput = {
    AND?: surveyAnswersScalarWhereInput | surveyAnswersScalarWhereInput[]
    OR?: surveyAnswersScalarWhereInput[]
    NOT?: surveyAnswersScalarWhereInput | surveyAnswersScalarWhereInput[]
    id?: IntFilter<"surveyAnswers"> | number
    question_id?: IntFilter<"surveyAnswers"> | number
    user_id?: IntNullableFilter<"surveyAnswers"> | number | null
    answer?: StringNullableFilter<"surveyAnswers"> | string | null
    scale_rating?: IntNullableFilter<"surveyAnswers"> | number | null
    added_at?: DateTimeFilter<"surveyAnswers"> | Date | string
  }

  export type service_groupUpsertWithoutSurveyQuestionsInput = {
    update: XOR<service_groupUpdateWithoutSurveyQuestionsInput, service_groupUncheckedUpdateWithoutSurveyQuestionsInput>
    create: XOR<service_groupCreateWithoutSurveyQuestionsInput, service_groupUncheckedCreateWithoutSurveyQuestionsInput>
    where?: service_groupWhereInput
  }

  export type service_groupUpdateToOneWithWhereWithoutSurveyQuestionsInput = {
    where?: service_groupWhereInput
    data: XOR<service_groupUpdateWithoutSurveyQuestionsInput, service_groupUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type service_groupUpdateWithoutSurveyQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUpdateManyWithoutService_groupNestedInput
    serviceReview?: serviceReviewUpdateManyWithoutService_groupNestedInput
    institution?: institutionUpdateOneRequiredWithoutService_groupNestedInput
  }

  export type service_groupUncheckedUpdateWithoutSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUncheckedUpdateManyWithoutService_groupNestedInput
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupCreateWithoutServiceReviewInput = {
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceCreateNestedManyWithoutService_groupInput
    institution: institutionCreateNestedOneWithoutService_groupInput
    surveyQuestions?: surveyQuestionsCreateNestedManyWithoutService_groupInput
  }

  export type service_groupUncheckedCreateWithoutServiceReviewInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    institution_id: number
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
    service?: serviceUncheckedCreateNestedManyWithoutService_groupInput
    surveyQuestions?: surveyQuestionsUncheckedCreateNestedManyWithoutService_groupInput
  }

  export type service_groupCreateOrConnectWithoutServiceReviewInput = {
    where: service_groupWhereUniqueInput
    create: XOR<service_groupCreateWithoutServiceReviewInput, service_groupUncheckedCreateWithoutServiceReviewInput>
  }

  export type users_profileCreateWithoutServiceReviewInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    images?: imagesCreateNestedManyWithoutUsers_profileInput
    reviews?: reviewsCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileUncheckedCreateWithoutServiceReviewInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    phone_number?: string | null
    age_group?: string | null
    gender?: string | null
    address?: string | null
    added_at?: Date | string
    isVerified?: boolean | null
    verifyToken?: string | null
    images?: imagesUncheckedCreateNestedManyWithoutUsers_profileInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsers_profileInput
  }

  export type users_profileCreateOrConnectWithoutServiceReviewInput = {
    where: users_profileWhereUniqueInput
    create: XOR<users_profileCreateWithoutServiceReviewInput, users_profileUncheckedCreateWithoutServiceReviewInput>
  }

  export type service_groupUpsertWithoutServiceReviewInput = {
    update: XOR<service_groupUpdateWithoutServiceReviewInput, service_groupUncheckedUpdateWithoutServiceReviewInput>
    create: XOR<service_groupCreateWithoutServiceReviewInput, service_groupUncheckedCreateWithoutServiceReviewInput>
    where?: service_groupWhereInput
  }

  export type service_groupUpdateToOneWithWhereWithoutServiceReviewInput = {
    where?: service_groupWhereInput
    data: XOR<service_groupUpdateWithoutServiceReviewInput, service_groupUncheckedUpdateWithoutServiceReviewInput>
  }

  export type service_groupUpdateWithoutServiceReviewInput = {
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUpdateManyWithoutService_groupNestedInput
    institution?: institutionUpdateOneRequiredWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupUncheckedUpdateWithoutServiceReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUncheckedUpdateManyWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUncheckedUpdateManyWithoutService_groupNestedInput
  }

  export type users_profileUpsertWithoutServiceReviewInput = {
    update: XOR<users_profileUpdateWithoutServiceReviewInput, users_profileUncheckedUpdateWithoutServiceReviewInput>
    create: XOR<users_profileCreateWithoutServiceReviewInput, users_profileUncheckedCreateWithoutServiceReviewInput>
    where?: users_profileWhereInput
  }

  export type users_profileUpdateToOneWithWhereWithoutServiceReviewInput = {
    where?: users_profileWhereInput
    data: XOR<users_profileUpdateWithoutServiceReviewInput, users_profileUncheckedUpdateWithoutServiceReviewInput>
  }

  export type users_profileUpdateWithoutServiceReviewInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    images?: imagesUpdateManyWithoutUsers_profileNestedInput
    reviews?: reviewsUpdateManyWithoutUsers_profileNestedInput
  }

  export type users_profileUncheckedUpdateWithoutServiceReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    age_group?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    images?: imagesUncheckedUpdateManyWithoutUsers_profileNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsers_profileNestedInput
  }

  export type categoriesCreateWithoutCategory_search_termsInput = {
    name: string
    sectors?: sectorsCreateNestedOneWithoutCategoriesInput
    institution?: institutionCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutCategory_search_termsInput = {
    id?: number
    name: string
    sector_id?: number | null
    institution?: institutionUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutCategory_search_termsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutCategory_search_termsInput, categoriesUncheckedCreateWithoutCategory_search_termsInput>
  }

  export type categoriesUpsertWithoutCategory_search_termsInput = {
    update: XOR<categoriesUpdateWithoutCategory_search_termsInput, categoriesUncheckedUpdateWithoutCategory_search_termsInput>
    create: XOR<categoriesCreateWithoutCategory_search_termsInput, categoriesUncheckedCreateWithoutCategory_search_termsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutCategory_search_termsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutCategory_search_termsInput, categoriesUncheckedUpdateWithoutCategory_search_termsInput>
  }

  export type categoriesUpdateWithoutCategory_search_termsInput = {
    name?: StringFieldUpdateOperationsInput | string
    sectors?: sectorsUpdateOneWithoutCategoriesNestedInput
    institution?: institutionUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutCategory_search_termsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    institution?: institutionUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type category_search_termsCreateManyCategoriesInput = {
    id?: number
    term: string
  }

  export type institutionCreateManyCategoriesInput = {
    id?: number
    uuid?: string | null
    name: string
    search_term?: string | null
    email?: string | null
    address?: string | null
    phone_number?: string | null
    url?: string | null
    status?: number | null
    created_at?: Date | string
    plan?: number | null
    type?: number | null
    level?: number | null
    parent_id?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    queue_autocreation?: number | null
    queue_manual_creation?: number | null
    working_hours?: string | null
    qms_message?: string | null
    priority_list?: string | null
    logo?: string | null
    app_name?: string | null
    allowed_context?: number | null
    host_name?: string | null
    membership_type?: number
    latest_membership_renew_time?: Date | string | null
    description?: string | null
    latitude?: string | null
    longitude?: string | null
    button_one?: string | null
    button_two?: string | null
    amenities?: string | null
  }

  export type category_search_termsUpdateWithoutCategoriesInput = {
    term?: StringFieldUpdateOperationsInput | string
  }

  export type category_search_termsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
  }

  export type category_search_termsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    term?: StringFieldUpdateOperationsInput | string
  }

  export type institutionUpdateWithoutCategoriesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutInstitutionNestedInput
    apps?: appsUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUpdateManyWithoutInstitutionNestedInput
    device?: deviceUpdateManyWithoutInstitutionNestedInput
    images?: imagesUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUpdateManyWithoutInstitutionNestedInput
    service?: serviceUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutInstitutionNestedInput
    apps?: appsUncheckedUpdateManyWithoutInstitutionNestedInput
    business_amenities?: business_amenitiesUncheckedUpdateManyWithoutInstitutionNestedInput
    device?: deviceUncheckedUpdateManyWithoutInstitutionNestedInput
    images?: imagesUncheckedUpdateManyWithoutInstitutionNestedInput
    popup_questions?: popup_questionsUncheckedUpdateManyWithoutInstitutionNestedInput
    price_ranges?: price_rangesUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_branch_transactions?: qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionNestedInput
    qms_operator?: qms_operatorUncheckedUpdateManyWithoutInstitutionNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutInstitutionNestedInput
    service?: serviceUncheckedUpdateManyWithoutInstitutionNestedInput
    service_group?: service_groupUncheckedUpdateManyWithoutInstitutionNestedInput
    workingHour?: workingHourUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    queue_autocreation?: NullableIntFieldUpdateOperationsInput | number | null
    queue_manual_creation?: NullableIntFieldUpdateOperationsInput | number | null
    working_hours?: NullableStringFieldUpdateOperationsInput | string | null
    qms_message?: NullableStringFieldUpdateOperationsInput | string | null
    priority_list?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    app_name?: NullableStringFieldUpdateOperationsInput | string | null
    allowed_context?: NullableIntFieldUpdateOperationsInput | number | null
    host_name?: NullableStringFieldUpdateOperationsInput | string | null
    membership_type?: IntFieldUpdateOperationsInput | number
    latest_membership_renew_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    button_one?: NullableStringFieldUpdateOperationsInput | string | null
    button_two?: NullableStringFieldUpdateOperationsInput | string | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_customerCreateManyDeviceInput = {
    id?: number
    customer_uuid: string
    name: string
    phone_number?: string | null
    email?: string | null
    has_priority_service?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ratingCreateManyDeviceInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    service_id: number
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
  }

  export type tipCreateManyDeviceInput = {
    id?: number
    collection_reference_id: string
    disbursement_reference_id: string
    rating_id?: bigint | number | null
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_customerUpdateWithoutDeviceInput = {
    customer_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_ticket?: qms_ticketUpdateManyWithoutQms_customerNestedInput
  }

  export type qms_customerUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_ticket?: qms_ticketUncheckedUpdateManyWithoutQms_customerNestedInput
  }

  export type qms_customerUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    has_priority_service?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingUpdateWithoutDeviceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    service?: serviceUpdateOneRequiredWithoutRatingNestedInput
    rating_assets?: rating_assetsUpdateManyWithoutRatingNestedInput
    tip?: tipUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateWithoutDeviceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    service_id?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets?: rating_assetsUncheckedUpdateManyWithoutRatingNestedInput
    tip?: tipUncheckedUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateManyWithoutDeviceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    service_id?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipUpdateWithoutDeviceInput = {
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: ratingUpdateOneWithoutTipNestedInput
  }

  export type tipUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    rating_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tipUncheckedUpdateManyWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    rating_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsCreateManyInstitutionInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    service_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appsCreateManyInstitutionInput = {
    id?: number
    name: string
    status?: number
    secret_key?: string | null
    access_key?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type business_amenitiesCreateManyInstitutionInput = {
    id?: number
    amenitY_id?: number | null
  }

  export type deviceCreateManyInstitutionInput = {
    id?: number
    uuid?: string | null
    notification_token?: string | null
    service_id?: string | null
    serial_number?: string | null
    status?: number
    created_at?: Date | string
    device_type?: number
    gender?: number | null
    age_range?: number | null
    language?: number | null
    notification_enabled?: boolean | null
    apiKey?: string | null
    nonce?: number | null
    linkShortCode?: string | null
    linkShortCodeExp?: Date | string | null
    phone_number?: string | null
    latest_hb?: Date | string | null
    latest_hb_version?: string | null
    updated_at?: Date | string
  }

  export type imagesCreateManyInstitutionInput = {
    id?: number
    user_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    review_id?: number | null
  }

  export type popup_questionsCreateManyInstitutionInput = {
    id?: number
    name_en: string
    name_fr?: string | null
    name_rw?: string | null
    name_sw?: string | null
    service_id: string
    description_en: string
    description_fr?: string | null
    description_rw?: string | null
    description_sw?: string | null
    applies_to_bad?: boolean
    applies_to_good?: boolean
    applies_to_excellent?: boolean
    status?: boolean | null
    type?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type price_rangesCreateManyInstitutionInput = {
    id?: number
    max_value: number
    min_value: number
    label?: string | null
  }

  export type qms_branch_operatorCreateManyInstitutionInput = {
    id?: number
    operator_id: number
    service_id: string
    linked_at?: Date | string
    status?: number
  }

  export type qms_branch_transactionsCreateManyInstitutionInput = {
    id?: number
    date: Date | string
    note?: string | null
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_operatorCreateManyInstitutionInput = {
    id?: number
    operator_uuid: string
    name: string
    username: string
    password_hash?: string | null
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email_address: string
    phone_number?: string | null
    terminal?: boolean | null
  }

  export type reviewsCreateManyInstitutionInput = {
    id?: number
    user_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
  }

  export type serviceCreateManyInstitutionInput = {
    id?: number
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    group?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
  }

  export type service_groupCreateManyInstitutionInput = {
    id?: number
    name: string
    name_rw?: string | null
    name_fr?: string | null
    name_sw?: string | null
    search_term?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    uuid?: string | null
    status?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    ticket_prefix?: string | null
    bad_rating_threshold?: number | null
  }

  export type workingHourCreateManyInstitutionInput = {
    id?: number
    day_of_week: string
    open_time?: Date | string | null
    close_time?: Date | string | null
  }

  export type appointmentsUpdateWithoutInstitutionInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments_creator_idTouser?: userUpdateOneRequiredWithoutAppointments_appointments_creator_idTouserNestedInput
    qms_operator?: qms_operatorUpdateOneWithoutAppointmentsNestedInput
    service?: serviceUpdateOneWithoutAppointmentsNestedInput
    user_appointments_user_idTouser?: userUpdateOneWithoutAppointments_appointments_user_idTouserNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appsUpdateWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appsUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appsUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    access_key?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type business_amenitiesUpdateWithoutInstitutionInput = {
    amenities?: amenitiesUpdateOneWithoutBusiness_amenitiesNestedInput
  }

  export type business_amenitiesUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenitY_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type business_amenitiesUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    amenitY_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type deviceUpdateWithoutInstitutionInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_customer?: qms_customerUpdateManyWithoutDeviceNestedInput
    rating?: ratingUpdateManyWithoutDeviceNestedInput
    tip?: tipUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_customer?: qms_customerUncheckedUpdateManyWithoutDeviceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutDeviceNestedInput
    tip?: tipUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type deviceUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    notification_token?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    serial_number?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_type?: IntFieldUpdateOperationsInput | number
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableIntFieldUpdateOperationsInput | number | null
    notification_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    nonce?: NullableIntFieldUpdateOperationsInput | number | null
    linkShortCode?: NullableStringFieldUpdateOperationsInput | string | null
    linkShortCodeExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    latest_hb?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latest_hb_version?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUpdateWithoutInstitutionInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: reviewsUpdateOneWithoutImagesNestedInput
    users_profile?: users_profileUpdateOneWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    review_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type imagesUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    review_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type popup_questionsUpdateWithoutInstitutionInput = {
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersUpdateManyWithoutPopup_questionsNestedInput
  }

  export type popup_questionsUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    popup_questions_possible_answers?: popup_questions_possible_answersUncheckedUpdateManyWithoutPopup_questionsNestedInput
  }

  export type popup_questionsUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_en?: StringFieldUpdateOperationsInput | string
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_fr?: NullableStringFieldUpdateOperationsInput | string | null
    description_rw?: NullableStringFieldUpdateOperationsInput | string | null
    description_sw?: NullableStringFieldUpdateOperationsInput | string | null
    applies_to_bad?: BoolFieldUpdateOperationsInput | boolean
    applies_to_good?: BoolFieldUpdateOperationsInput | boolean
    applies_to_excellent?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type price_rangesUpdateWithoutInstitutionInput = {
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_rangesUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_rangesUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    max_value?: IntFieldUpdateOperationsInput | number
    min_value?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_branch_operatorUpdateWithoutInstitutionInput = {
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    qms_operator?: qms_operatorUpdateOneRequiredWithoutQms_branch_operatorNestedInput
  }

  export type qms_branch_operatorUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_branch_operatorUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_branch_transactionsUpdateWithoutInstitutionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_branch_transactionsNestedInput
  }

  export type qms_branch_transactionsUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_branch_transactionsNestedInput
  }

  export type qms_branch_transactionsUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operatorUpdateWithoutInstitutionInput = {
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_branch_operator?: qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_operator_transactions?: qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorNestedInput
  }

  export type qms_operatorUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type reviewsUpdateWithoutInstitutionInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: imagesUpdateManyWithoutReviewsNestedInput
    users_profile?: users_profileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: imagesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type serviceUpdateWithoutInstitutionInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUpdateManyWithoutServiceNestedInput
    rating?: ratingUpdateManyWithoutServiceNestedInput
    service_group?: service_groupUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUncheckedUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUncheckedUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    group?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type service_groupUpdateWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUpdateManyWithoutService_groupNestedInput
    serviceReview?: serviceReviewUpdateManyWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    service?: serviceUncheckedUpdateManyWithoutService_groupNestedInput
    serviceReview?: serviceReviewUncheckedUpdateManyWithoutService_groupNestedInput
    surveyQuestions?: surveyQuestionsUncheckedUpdateManyWithoutService_groupNestedInput
  }

  export type service_groupUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_rw?: NullableStringFieldUpdateOperationsInput | string | null
    name_fr?: NullableStringFieldUpdateOperationsInput | string | null
    name_sw?: NullableStringFieldUpdateOperationsInput | string | null
    search_term?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type workingHourUpdateWithoutInstitutionInput = {
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workingHourUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workingHourUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day_of_week?: StringFieldUpdateOperationsInput | string
    open_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    close_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qms_ticketCreateManyOptionInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
  }

  export type qms_ticketUpdateWithoutOptionInput = {
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    qms_customer?: qms_customerUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_queue?: qms_queueUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateManyWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
  }

  export type popup_questions_possible_answersCreateManyPopup_questionsInput = {
    id?: number
    answer_en: string
    answer_fr: string
    answer_rw: string
    answer_sw: string
    created_at?: Date | string
    updated_at?: Date | string
    priority?: number | null
  }

  export type popup_questions_possible_answersUpdateWithoutPopup_questionsInput = {
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    popup_questions_answers?: popup_questions_answersUpdateManyWithoutPopup_questions_possible_answersNestedInput
  }

  export type popup_questions_possible_answersUncheckedUpdateWithoutPopup_questionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    popup_questions_answers?: popup_questions_answersUncheckedUpdateManyWithoutPopup_questions_possible_answersNestedInput
  }

  export type popup_questions_possible_answersUncheckedUpdateManyWithoutPopup_questionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer_en?: StringFieldUpdateOperationsInput | string
    answer_fr?: StringFieldUpdateOperationsInput | string
    answer_rw?: StringFieldUpdateOperationsInput | string
    answer_sw?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type popup_questions_answersCreateManyPopup_questions_possible_answersInput = {
    id?: number
    device_id: number
    rating_id?: number | null
    ticket_id?: number | null
    answered_at?: Date | string
  }

  export type popup_questions_answersUpdateWithoutPopup_questions_possible_answersInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questions_answersUncheckedUpdateWithoutPopup_questions_possible_answersInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type popup_questions_answersUncheckedUpdateManyWithoutPopup_questions_possible_answersInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
    rating_id?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    answered_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operator_transactionsCreateManyQms_branch_transactionsInput = {
    id?: number
    operator_id: number
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_operator_transactionsUpdateWithoutQms_branch_transactionsInput = {
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_operator?: qms_operatorUpdateOneRequiredWithoutQms_operator_transactionsNestedInput
  }

  export type qms_operator_transactionsUncheckedUpdateWithoutQms_branch_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operator_transactionsUncheckedUpdateManyWithoutQms_branch_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_ticketCreateManyQms_customerInput = {
    id?: number
    ticket_uuid: string
    queue_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
  }

  export type qms_ticketUpdateWithoutQms_customerInput = {
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    option?: optionUpdateOneWithoutQms_ticketNestedInput
    qms_queue?: qms_queueUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateWithoutQms_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateManyWithoutQms_customerInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    queue_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
  }

  export type appointmentsCreateManyQms_operatorInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type qms_branch_operatorCreateManyQms_operatorInput = {
    id?: number
    institution_id: number
    service_id: string
    linked_at?: Date | string
    status?: number
  }

  export type qms_operator_transactionsCreateManyQms_operatorInput = {
    id?: number
    branch_transaction_id: number
    transaction: number
    created_at?: Date | string
    last_updated?: Date | string
  }

  export type qms_queue_operator_lnkCreateManyQms_operatorInput = {
    id?: number
    queue_id: number
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
  }

  export type qms_ticket_assignmentCreateManyQms_operatorInput = {
    id?: number
    ticket_id: number
    queue_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
  }

  export type appointmentsUpdateWithoutQms_operatorInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments_creator_idTouser?: userUpdateOneRequiredWithoutAppointments_appointments_creator_idTouserNestedInput
    institution?: institutionUpdateOneWithoutAppointmentsNestedInput
    service?: serviceUpdateOneWithoutAppointmentsNestedInput
    user_appointments_user_idTouser?: userUpdateOneWithoutAppointments_appointments_user_idTouserNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUncheckedUpdateManyWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_branch_operatorUpdateWithoutQms_operatorInput = {
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    institution?: institutionUpdateOneRequiredWithoutQms_branch_operatorNestedInput
  }

  export type qms_branch_operatorUncheckedUpdateWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_branch_operatorUncheckedUpdateManyWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    service_id?: StringFieldUpdateOperationsInput | string
    linked_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type qms_operator_transactionsUpdateWithoutQms_operatorInput = {
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
    qms_branch_transactions?: qms_branch_transactionsUpdateOneRequiredWithoutQms_operator_transactionsNestedInput
  }

  export type qms_operator_transactionsUncheckedUpdateWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch_transaction_id?: IntFieldUpdateOperationsInput | number
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_operator_transactionsUncheckedUpdateManyWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch_transaction_id?: IntFieldUpdateOperationsInput | number
    transaction?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_queue_operator_lnkUpdateWithoutQms_operatorInput = {
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
    qms_queue?: qms_queueUpdateOneRequiredWithoutQms_queue_operator_lnkNestedInput
  }

  export type qms_queue_operator_lnkUncheckedUpdateWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticket_assignmentUpdateWithoutQms_operatorInput = {
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    qms_ticket?: qms_ticketUpdateOneRequiredWithoutQms_ticket_assignmentNestedInput
  }

  export type qms_ticket_assignmentUncheckedUpdateWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticket_assignmentUncheckedUpdateManyWithoutQms_operatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_queue_operator_lnkCreateManyQms_queueInput = {
    id?: number
    operator_id: number
    operator_uuid?: string | null
    counter_id?: number | null
    first_login?: Date | string | null
    last_logout?: Date | string | null
    api_key?: string | null
  }

  export type qms_ticketCreateManyQms_queueInput = {
    id?: number
    ticket_uuid: string
    customer_id: number
    ticket_number: string
    full_ticket_number?: string | null
    pin: number
    status?: number | null
    service_time?: number | null
    estimated_waiting_time?: number | null
    created_at?: Date | string
    waiting_ended_on?: Date | string | null
    skipped_at?: Date | string | null
    cancelled_at?: Date | string | null
    on_hold_from?: Date | string | null
    skips_count?: number | null
    prioritized?: boolean | null
    reason_id?: number | null
    prioritized_at?: Date | string | null
    is_next?: boolean | null
    prev_ticket_id?: number | null
    rating_notification_sent?: number
    source?: number
  }

  export type qms_queue_operator_lnkUpdateWithoutQms_queueInput = {
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
    qms_operator?: qms_operatorUpdateOneRequiredWithoutQms_queue_operator_lnkNestedInput
  }

  export type qms_queue_operator_lnkUncheckedUpdateWithoutQms_queueInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_queueInput = {
    id?: IntFieldUpdateOperationsInput | number
    operator_id?: IntFieldUpdateOperationsInput | number
    operator_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_logout?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    api_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticketUpdateWithoutQms_queueInput = {
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    option?: optionUpdateOneWithoutQms_ticketNestedInput
    qms_customer?: qms_customerUpdateOneRequiredWithoutQms_ticketNestedInput
    qms_ticket_assignment?: qms_ticket_assignmentUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateWithoutQms_queueInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
    qms_ticket_assignment?: qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketNestedInput
  }

  export type qms_ticketUncheckedUpdateManyWithoutQms_queueInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_uuid?: StringFieldUpdateOperationsInput | string
    customer_id?: IntFieldUpdateOperationsInput | number
    ticket_number?: StringFieldUpdateOperationsInput | string
    full_ticket_number?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_waiting_time?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    waiting_ended_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    on_hold_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skips_count?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason_id?: NullableIntFieldUpdateOperationsInput | number | null
    prioritized_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_next?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prev_ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating_notification_sent?: IntFieldUpdateOperationsInput | number
    source?: IntFieldUpdateOperationsInput | number
  }

  export type qms_ticket_assignmentCreateManyQms_ticketInput = {
    id?: number
    queue_id?: number | null
    operator_id?: number | null
    counter_id?: number | null
    status?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    assigned_at?: Date | string | null
    state?: number | null
    comment?: string | null
  }

  export type qms_ticket_assignmentUpdateWithoutQms_ticketInput = {
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    qms_operator?: qms_operatorUpdateOneWithoutQms_ticket_assignmentNestedInput
  }

  export type qms_ticket_assignmentUncheckedUpdateWithoutQms_ticketInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_ticket_assignmentUncheckedUpdateManyWithoutQms_ticketInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    counter_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_assetsCreateManyRatingInput = {
    rating_assets_id?: number
    rating_assets_image?: string | null
    rating_assets_video?: string | null
  }

  export type tipCreateManyRatingInput = {
    id?: number
    collection_reference_id: string
    disbursement_reference_id: string
    device_id: number
    payee: string
    payer: string
    amount: number
    tip_amount: number
    collection_status?: string | null
    collection_status_details?: string | null
    closed_at?: Date | string | null
    disbursed_at?: Date | string | null
    disbursement_status?: string | null
    disbursement_status_details?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type rating_assetsUpdateWithoutRatingInput = {
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_assetsUncheckedUpdateWithoutRatingInput = {
    rating_assets_id?: IntFieldUpdateOperationsInput | number
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rating_assetsUncheckedUpdateManyWithoutRatingInput = {
    rating_assets_id?: IntFieldUpdateOperationsInput | number
    rating_assets_image?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets_video?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipUpdateWithoutRatingInput = {
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: deviceUpdateOneRequiredWithoutTipNestedInput
  }

  export type tipUncheckedUpdateWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    device_id?: IntFieldUpdateOperationsInput | number
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tipUncheckedUpdateManyWithoutRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    collection_reference_id?: StringFieldUpdateOperationsInput | string
    disbursement_reference_id?: StringFieldUpdateOperationsInput | string
    device_id?: IntFieldUpdateOperationsInput | number
    payee?: StringFieldUpdateOperationsInput | string
    payer?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    tip_amount?: IntFieldUpdateOperationsInput | number
    collection_status?: NullableStringFieldUpdateOperationsInput | string | null
    collection_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disbursement_status?: NullableStringFieldUpdateOperationsInput | string | null
    disbursement_status_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsCreateManyServiceInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type qms_counterCreateManyServiceInput = {
    id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type qms_queueCreateManyServiceInput = {
    id?: number
    queue_uuid: string
    queue_date: Date | string
    start_time: Date | string
    end_time: Date | string
    status: $Enums.qms_queue_status
    avg_service_time?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    closure_notification?: number
    inter_arrival_time?: number | null
  }

  export type ratingCreateManyServiceInput = {
    id?: bigint | number
    state: boolean
    time?: Date | string
    comment?: string | null
    gender?: number | null
    age_range?: number | null
    location?: number | null
    device_id?: number | null
    nps_score?: number | null
    ticket_id?: number | null
    finger_print?: string | null
  }

  export type appointmentsUpdateWithoutServiceInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments_creator_idTouser?: userUpdateOneRequiredWithoutAppointments_appointments_creator_idTouserNestedInput
    institution?: institutionUpdateOneWithoutAppointmentsNestedInput
    qms_operator?: qms_operatorUpdateOneWithoutAppointmentsNestedInput
    user_appointments_user_idTouser?: userUpdateOneWithoutAppointments_appointments_user_idTouserNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qms_counterUpdateWithoutServiceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_counterUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_counterUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type qms_queueUpdateWithoutServiceInput = {
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUpdateManyWithoutQms_queueNestedInput
    qms_ticket?: qms_ticketUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_queueUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    qms_queue_operator_lnk?: qms_queue_operator_lnkUncheckedUpdateManyWithoutQms_queueNestedInput
    qms_ticket?: qms_ticketUncheckedUpdateManyWithoutQms_queueNestedInput
  }

  export type qms_queueUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    queue_uuid?: StringFieldUpdateOperationsInput | string
    queue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumqms_queue_statusFieldUpdateOperationsInput | $Enums.qms_queue_status
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    closure_notification?: IntFieldUpdateOperationsInput | number
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ratingUpdateWithoutServiceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    device?: deviceUpdateOneWithoutRatingNestedInput
    rating_assets?: rating_assetsUpdateManyWithoutRatingNestedInput
    tip?: tipUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateWithoutServiceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
    rating_assets?: rating_assetsUncheckedUpdateManyWithoutRatingNestedInput
    tip?: tipUncheckedUpdateManyWithoutRatingNestedInput
  }

  export type ratingUncheckedUpdateManyWithoutServiceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: BoolFieldUpdateOperationsInput | boolean
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    age_range?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableIntFieldUpdateOperationsInput | number | null
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    nps_score?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_id?: NullableIntFieldUpdateOperationsInput | number | null
    finger_print?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceCreateManyService_groupInput = {
    id?: number
    institution_id?: number | null
    status?: number | null
    created_at?: Date | string
    bad_rating_threshold?: number | null
    good_ratings?: number | null
    bad_ratings?: number | null
    excellent_ratings?: number | null
    nps?: number | null
    csat?: number | null
    mean_service_time?: number | null
    avg_service_time?: number | null
    uuid?: string | null
    inter_arrival_time?: number | null
    estimated_time?: number | null
  }

  export type serviceReviewCreateManyService_groupInput = {
    id?: number
    user_id?: number | null
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
  }

  export type surveyQuestionsCreateManyService_groupInput = {
    id?: number
    question?: string | null
    choices?: string | null
    added_at?: Date | string
  }

  export type serviceUpdateWithoutService_groupInput = {
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUpdateManyWithoutServiceNestedInput
    rating?: ratingUpdateManyWithoutServiceNestedInput
    institution?: institutionUpdateOneWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
    appointments?: appointmentsUncheckedUpdateManyWithoutServiceNestedInput
    qms_counter?: qms_counterUncheckedUpdateManyWithoutServiceNestedInput
    qms_queue?: qms_queueUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ratingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateManyWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bad_rating_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    good_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    bad_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    excellent_ratings?: NullableIntFieldUpdateOperationsInput | number | null
    nps?: NullableIntFieldUpdateOperationsInput | number | null
    csat?: NullableIntFieldUpdateOperationsInput | number | null
    mean_service_time?: NullableIntFieldUpdateOperationsInput | number | null
    avg_service_time?: NullableFloatFieldUpdateOperationsInput | number | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    inter_arrival_time?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_time?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type serviceReviewUpdateWithoutService_groupInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users_profile?: users_profileUpdateOneWithoutServiceReviewNestedInput
  }

  export type serviceReviewUncheckedUpdateWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceReviewUncheckedUpdateManyWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveyQuestionsUpdateWithoutService_groupInput = {
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: surveyAnswersUpdateManyWithoutSurveyQuestionsNestedInput
  }

  export type surveyQuestionsUncheckedUpdateWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: surveyAnswersUncheckedUpdateManyWithoutSurveyQuestionsNestedInput
  }

  export type surveyQuestionsUncheckedUpdateManyWithoutService_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: NullableStringFieldUpdateOperationsInput | string | null
    choices?: NullableStringFieldUpdateOperationsInput | string | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsCreateManyUser_appointments_creator_idTouserInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    operator_id?: number | null
    user_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type appointmentsCreateManyUser_appointments_user_idTouserInput = {
    id?: number
    name?: string | null
    email?: string | null
    phone: string
    registry_type: number
    institution_id?: number | null
    service_id?: number | null
    operator_id?: number | null
    reason: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    location: string
    additional_note: string
    creator_id: number
    recurring?: number | null
    notification_status?: number | null
    ticket_created?: number | null
    appointment_cancelled?: number | null
    created_at?: Date | string | null
    cancellation_reason?: string | null
  }

  export type tagsCreateManyUser_tags_created_byTouserInput = {
    id?: number
    name: string
    services: string
    created_at?: Date | string | null
    updated_by?: number | null
    status?: boolean | null
  }

  export type tagsCreateManyUser_tags_updated_byTouserInput = {
    id?: number
    name: string
    services: string
    created_at?: Date | string | null
    created_by: number
    status?: boolean | null
  }

  export type appointmentsUpdateWithoutUser_appointments_creator_idTouserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: institutionUpdateOneWithoutAppointmentsNestedInput
    qms_operator?: qms_operatorUpdateOneWithoutAppointmentsNestedInput
    service?: serviceUpdateOneWithoutAppointmentsNestedInput
    user_appointments_user_idTouser?: userUpdateOneWithoutAppointments_appointments_user_idTouserNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutUser_appointments_creator_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUncheckedUpdateManyWithoutUser_appointments_creator_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUpdateWithoutUser_appointments_user_idTouserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    user_appointments_creator_idTouser?: userUpdateOneRequiredWithoutAppointments_appointments_creator_idTouserNestedInput
    institution?: institutionUpdateOneWithoutAppointmentsNestedInput
    qms_operator?: qms_operatorUpdateOneWithoutAppointmentsNestedInput
    service?: serviceUpdateOneWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutUser_appointments_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsUncheckedUpdateManyWithoutUser_appointments_user_idTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    registry_type?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    operator_id?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    additional_note?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    recurring?: NullableIntFieldUpdateOperationsInput | number | null
    notification_status?: NullableIntFieldUpdateOperationsInput | number | null
    ticket_created?: NullableIntFieldUpdateOperationsInput | number | null
    appointment_cancelled?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tagsUpdateWithoutUser_tags_created_byTouserInput = {
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_tags_updated_byTouser?: userUpdateOneWithoutTags_tags_updated_byTouserNestedInput
  }

  export type tagsUncheckedUpdateWithoutUser_tags_created_byTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tagsUncheckedUpdateManyWithoutUser_tags_created_byTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tagsUpdateWithoutUser_tags_updated_byTouserInput = {
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_tags_created_byTouser?: userUpdateOneRequiredWithoutTags_tags_created_byTouserNestedInput
  }

  export type tagsUncheckedUpdateWithoutUser_tags_updated_byTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tagsUncheckedUpdateManyWithoutUser_tags_updated_byTouserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type categoriesCreateManySectorsInput = {
    id?: number
    name: string
  }

  export type categoriesUpdateWithoutSectorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_search_terms?: category_search_termsUpdateManyWithoutCategoriesNestedInput
    institution?: institutionUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutSectorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_search_terms?: category_search_termsUncheckedUpdateManyWithoutCategoriesNestedInput
    institution?: institutionUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutSectorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type imagesCreateManyUsers_profileInput = {
    id?: number
    institution_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
    review_id?: number | null
  }

  export type reviewsCreateManyUsers_profileInput = {
    id?: number
    institution_id: number
    rating: number
    review?: string | null
    created_at?: Date | string
    is_approved?: boolean | null
  }

  export type serviceReviewCreateManyUsers_profileInput = {
    id?: number
    service_id?: number | null
    rating?: number | null
    emoRating: string
    added_at?: Date | string | null
  }

  export type imagesUpdateWithoutUsers_profileInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutImagesNestedInput
    reviews?: reviewsUpdateOneWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutUsers_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    review_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type imagesUncheckedUpdateManyWithoutUsers_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    review_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reviewsUpdateWithoutUsers_profileInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: imagesUpdateManyWithoutReviewsNestedInput
    institution?: institutionUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutUsers_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: imagesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateManyWithoutUsers_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type serviceReviewUpdateWithoutUsers_profileInput = {
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_group?: service_groupUpdateOneWithoutServiceReviewNestedInput
  }

  export type serviceReviewUncheckedUpdateWithoutUsers_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceReviewUncheckedUpdateManyWithoutUsers_profileInput = {
    id?: IntFieldUpdateOperationsInput | number
    service_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    emoRating?: StringFieldUpdateOperationsInput | string
    added_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type imagesCreateManyReviewsInput = {
    id?: number
    institution_id?: number | null
    user_id?: number | null
    type?: string | null
    image_url?: string | null
    caption?: string | null
    uploaded_at?: Date | string
  }

  export type imagesUpdateWithoutReviewsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: institutionUpdateOneWithoutImagesNestedInput
    users_profile?: users_profileUpdateOneWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imagesUncheckedUpdateManyWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type business_amenitiesCreateManyAmenitiesInput = {
    id?: number
    institution_id?: number | null
  }

  export type business_amenitiesUpdateWithoutAmenitiesInput = {
    institution?: institutionUpdateOneWithoutBusiness_amenitiesNestedInput
  }

  export type business_amenitiesUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type business_amenitiesUncheckedUpdateManyWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type surveyAnswersCreateManySurveyQuestionsInput = {
    id?: number
    user_id?: number | null
    answer?: string | null
    scale_rating?: number | null
    added_at?: Date | string
  }

  export type surveyAnswersUpdateWithoutSurveyQuestionsInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyAnswersUncheckedUpdateWithoutSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveyAnswersUncheckedUpdateManyWithoutSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    scale_rating?: NullableIntFieldUpdateOperationsInput | number | null
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}